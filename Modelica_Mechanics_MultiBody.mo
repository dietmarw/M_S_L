within ;
package Modelica_Mechanics_MultiBody
  "Library to model 3-dimensional mechanical systems"
  extends Modelica_Icons.Package;

import SI = Modelica_SIunits;
import Cv = Modelica_SIunits.Conversions;
import C = Modelica_Constants;

package UsersGuide "User's Guide of MultiBody Library"
  extends Modelica_Icons.Information;

  package Tutorial "Tutorial"
    extends Modelica_Icons.Information;

    class OverView "Overview of MultiBody library"
      extends Modelica_Icons.Information;

      annotation (Documentation(info="<HTML>
<p>
Library <b>MultiBody</b> is a <b>free</b> Modelica package providing
3-dimensional mechanical components to model in a convenient way
<b>mechanical systems</b>, such as robots, mechanisms, vehicles.
A basic feature is that all components have <b>animation</b> information
with appropriate default sizes and colors. A typical screenshot of the
animation of a double pendulum is shown in the figure below, together
with its schematic.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/DoublePendulumSmall.png\">

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/DoublePendulumDiagramSmall.png\" ALT=\"double pendulum (diagram layer)\">
</p>

<p>
Note, that all components - the coordinate system of the world frame,
the gravity acceleration vector, the revolute joints and the
bodies - are visualized in the animation.<br>
This library replaces the long available ModelicaAdditions.MultiBody
library, since it is much more easier to use and more powerful.
The main features of the library are:
</p>
<ul>
<li>About <b>60 main components</b>, i.e., joint, force, part,
    body, sensor and visualizer components that are ready to use
    and have useful default animation properties. One-dimensional
    force laws can be defined with components of the Modelica.Mechanics.Rotational
    and of the Modelica.Mechanics.Translational library and can be
    connected via available flange connectors to MultiBody
    components.
<li>About <b>75 functions</b> to operate in a convenient way on
    orientation objects, e.g., to transform vector quantities between
    frames, or compute the orientation object of a planar rotation.
    The basic idea is to hide the actual definition of an <b>orientation</b>
    by providing essentially an <b>Orientation</b> type together with
    <b>functions</b> operating on instances of this type. Orientation
    objects based on a 3x3 transformation matrix and on quaternions
    are provided. As a side effect, the equations in all other
    components are simpler and easier to understand.</li>
<li> <b>A World model</b> has to be present in every model on top
     level. Here the gravity field is defined (currently: no gravity,
     uniform gravity, point gravity), the visualization of the
     world coordinate system and default settings for animation.
     If a world model is not present, it is automatically provided
     together with a warning message.
<li><b>Built-in animation properties</b> of all components, such as
    joints, forces, bodies, sensors. This allows an easy visual
    check of the constructed model. Animation of every component
    can be switched off via a parameter. The animation of a complete
    system can be switched off via one parameter in the <b>world</b>
    model. If animation is switched off, all equations related
    to animation are removed from the generated code. This is especially
    important for real-time simulation.</li>
<li><b>Automatic handling of kinematic loops</b>.
    Components can be connected together in a nearly arbitrary fashion.
    It does not matter whether components are flipped. This does not
    influence the efficiency. If kinematic loop structures occur,
    this is automatically handled in an efficient way by a new
    technique to transform a certain class of overdetermined sets of
    differential algebraic equations symbolically to a system where
    the number of equations and unknowns are the same (the user need
    <b>not</b> cut loops with special cut-joints to construct a
    tree-structure). </li>
<li><b>Automatic state selection from joints and bodies</b>.
    Most joints and all bodies have potential states. A Modelica
    translator will use the generalized coordinates
    of joints as states if possible. If this is not possible,
    states are selected from body coordinates. As a consequence,
    strange joints with 6 degrees of freedom are not necessary
    to define a body moving freely in space. An advanced user
    may select states manually from the <b>Advanced</b> menu of the
    corresponding components or use a Modelica parameter modification
    to set the \"stateSelect\" attribute directly. </li>
<li> <b>Analytic solution of kinematic loops</b>. The non-linear
    equations occurring in kinematic loops are solved <b>analytically</b>
    for a large class of mechanisms, such as a 4 bar mechanism,
    a slider-crank mechanism or a MacPherson suspension. This is performed
    by constructing such loops with assembly joints JointXXX,
    available in the Modelica.Mechanics.MultiBody.Joints package. Assembly joints consist
    of 3 joints that have together 6 degrees of freedom, i.e., no
    constraints.They do not have potential states. When the motion
    of the two frame connectors are provided, a non-linear system of
    equation is solved analytically to compute the motion of the 3 joints.
    Analytic loop handling is especially important for real-time simulation.</li>
<li> <b>Line force components may have mass</b>.
     Masses of line force components are located on the line on which
     the force is acting. They approximate the mass properties of
     a real physical device by one or two point masses. For example,
     a spring has often significant mass that has to be taken into
     account. If masses are set to zero, the additional code to handle
     these point masses is removed. If the masses are taken into
     account, the calculation overhead is small (the reason is that
     the occurring kinematic loops are analytically solved).</li>
<li> <b>Force components may be connected directly together</b>, e.g.,
     3-dimensional springs in series connection. Usually,
     multi-body programs have the restriction that force components
     can only be connected between two bodies. Such restrictions are
     not present in the Modelica multi-body library, since it is
     a fully object-oriented, equation based library. Usually, if
     force components are connected directly together, non-linear
     systems of equations occur. The advantage is often, that this
     may avoid stiff systems that would occur if a small mass has
     to be put in between the two force elements.</li>
<li><b>Initialization definition is available via menus</b>.
    Initialization of states in joints and bodies can be
    performed in the parameter menu, <b>without</b> typing Modelica
    statements. For non-standard initialization, the usual
    Modelica commands can be used.</li>
<li><b>Multi-body specific error messages</b>. Annotations
    and assert statements have been introduced that provide
    in many cases warning or error messages that are related
    to the library components (and not to specific equations
    as it is usual in Modelica libraries). This requires
    appropriate tool support, as it is.</li>
<li><b>Inverse models</b> of mechanical systems can be easily
    defined by using motion generators, e.g.,
    Modelica.Mechanics.Rotational.Position. Also, non-standard
    inverse models can be generated, e.g., when elasticity is present
    it might be necessary to differentiate equations several times.</li>
</ul>
</html>"));
    end OverView;

    class FirstExample "A first example"
      extends Modelica_Icons.Information;

      annotation (Documentation(info="<HTML>
<p>
As a first example it shall be demonstrated how to build up, simulate
and animate a <b>simple pendulum</b>.
</p>
<p>
A simple pendulum consisting of a <b>body</b> and a <b>revolute</b> joint
with <b>linear damping</b> in the joint, is first build-up as
Modelica composition diagram, resulting in:
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/FirstExample/PenulumSchematic1.png\"
ALT=\"Modelica composition diagram of simple pendulum\">
</p>

<p>
In the following figure the location of the used
model components is shown. Drag these components in the diagram layer
and connect them according to the figure:
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/FirstExample/PenulumSchematic2.png\">
</p>

<p>
Every model that uses model components from the MultiBody library
must have an instance of the Modelica.Mechanics.MultiBody.World model on highest level.
The reason is that in the world object the gravity field is defined
(uniform gravity or point gravity), as well as the default sizes of
animation shapes and this information is reported to all used
components. If the World object is missing, a warning message is
printed and an instance of the World object with default settings is
automatically utilized (this feature is defined with annotations).
</p>
<p>
In a second step the parameters of the dragged components need to be
defined. Some parameters are vectors that have to be defined with respect
to a local coordinate system of the corresponding component. The easiest
way to perform this is to define a <b>reference configuration</b> of your
multi-body model: In this configuration, the relative coordinates of
all joints are zero. This means that all coordinate systems on all
components are parallel to each other. Therefore, this just means
that all vectors are resolved in the world frame in this configuration.
</p>
<p>
The reference configuration for the simple pendulum shall be defined
in the following way: The y-axis of the world frame is directed
upwards, i.e., the opposite direction of the gravity acceleration.
The x-axis of the world frame is orthogonal to it. The revolute joint
is placed in the origin of the world frame. The rotation axis of the revolute
joint is directed along the z-axis of the world frame. The body is
placed on the x-axis of the world frame (i.e., the rotation angle of the
revolute joint is zero, when the body is on the x-axis).
In the following figures the definition of this reference configuration
is shown in the parameter menus of the revolute joint and the body:
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/FirstExample/ActuatedRevolute.png\">

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/FirstExample/Body.png\">
</p>

<p>
Translate and simulate the model.
Automatically, all defined components are visualized in
an animation using default absolute or relative sizes
of the components. For example, a body is visualized as
a sphere and as a cylinder. The default size of the sphere is defined
as parameter in the world object. You may change this size
in the \"Animation\" parameter menu of the body (see parameter menu
above). The default size of the cylinder is defined relatively
to the size of the sphere (half of the sphere size).
With default settings, the following animation is defined:
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/FirstExample/Pendulum.png\">
</p>

<p>
The world coordinate system is visualized as coordinate system
with axes labels. The direction of the gravity acceleration
vector is shown as green arrow. The red cylinder represents
the rotation axis of the revolute joint and the light blue
shapes represent the body. The center of mass of the body is
in the middle of the light blue sphere.
</p>
</html>"));
    end FirstExample;

    package LoopStructures "Loop structures"
      extends Modelica_Icons.Information;

      class Introduction "Introduction"
        extends Modelica_Icons.Information;

        annotation (DocumentationClass=true, Documentation(info="<HTML>
<p>
In principal, now special action is needed, if
loop structures occur (contrary to the ModelicaAdditions.MultiBody library).
An example is presented in the figure below. It is available as
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar1\">
MultiBody.Examples.Loops.Fourbar1</a>
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/Fourbar1a.png\">
</p>

<p>
This mechanism consists of 6 revolute joints, 1 prismatic joint and forms a
kinematical loop.
It has has one degree of freedom. In the next figure the default animation
is shown. Note, that the axes of the revolute joints are represented by the
red cylinders and that the axis of the prismatic joint is represented by the
red box on the lower right side.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/Fourbar1b.png\" width=\"205\" height=\"107\">
</p>

<p>
Whenever loop structures occur, non-linear algebraic
equations are present on \"position level\". It is then usually not possible by
structural analysis to select states during translation (which is possible for
non-loop structures). In the example above, Dymola detects a non-linear
algebraic loop of 57 equations and reduces this to a system of 7 coupled
algebraic equations. Note, that this is performed without using any
\"cut-joints\" as it is usually done in multi-body programs, but by just
appropriate symbolic equation manipulation. Via the dynamic dummy derivative
method the generalized coordinates on position and velocity level from one of
the 7 joints are dynamically selected as states during simulation. Whenever,
these two states are no longer appropriate, states from one of the other
joints are selected during simulation.
</p>
<p>
The efficiency of loop structures can usually be
enhanced, if states are statically fixed at translation time. For this
mechanism, the generalized coordinates of joint j1 (i.e., the
rotation angle of the revolute joint and its derivative) can always be used as
states. This can be stated by setting parameter \"enforceStates = <b>true</b>\"
in the \"Advanced\" menu of the desired joint. This flag sets the attribute
stateSelect of the generalized coordinates of the corresponding joint to
\"StateSelect.always\". When setting this flag to <b>true</b> for joint j1 in
the four bar mechanism, Dymola detects a non-linear algebraic loop of 40
equations and reduces this to a system of 5 coupled non-linear algebraic
equations.
</p>
<p>
In many mechanisms it is possible to solve the non-linear algebraic
equations analytically. For a certain class of systems this can
be performed also with the MultiBody library. This technique
is described in section
\"<a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling\">Analytic loop handling</a>\".
</p>
</HTML>"));
      end Introduction;

      class PlanarLoops "Planar loops"
        extends Modelica_Icons.Information;

        annotation (Documentation(info="<HTML>
<p>
In the figure below, the model of a V6 engine is
shown that has a simple combustion model. It is available as
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6\">
MultiBody.Examples.Loops.EngineV6</a>.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/EngineV6_1.png\">
</p>

<p>
The Modelica schematic of one cylinder
is given in the figure below. Connecting 6 instances of this
cylinder appropriately together results in the engine schematic displayed
above.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/EngineV6_2.png\">
</p>

<p>
In the next figure the animation of the engine is
shown. Every cylinder consists essentially of 1 prismatic and 2 revolute
joints that form a planar loop, since the axes of the two revolute joints are
parallel to each other and the axis of the prismatic joint is orthogonal to
the revolute joint axes. All 6 cylinders together form a coupled set of 6
loops that have together 1 degree of freedom.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/EngineV6_3.png\" width=\"303\" height=\"136\">
</p>

<p>
All planar loops, and especially the engine, result in
a DAE (= Differential-Algebraic Equation system)
that does not have a unique solution. The reason is that, e.g., the cut
forces in direction of the axes of the revolute joints cannot be uniquely
computed. Any value fulfills the DAE equations. This is a structural property
that is determined by the symbolic algorithms. Since they detect that the DAE is
structurally singular, a further processing is not possible. Without
additional information it is also impossible that the symbolic algorithms
could be enhanced because if the axes of rotations of the revolute joints are
only slightly changed such that they are no longer parallel to each other, the
planar loop can no longer move and has 0 degrees of freedom. Algorithms based
on pure structural information cannot distinguish these two cases.
</p>
<p>
The usual remedy is to remove superfluous constraints,
e.g., along the axis of rotation of <b>one</b> revolute joint. Since this is
not easy for an inexperienced modeler, the special joint:
<a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.RevolutePlanarLoopConstraint\">
RevolutePlanarLoopConstraint</a> is provided that removes these constraints.
Exactly one revolute joint in a every planar loop must be replaced by this
joint type. In the engine example, this special joint is used for
the revolute joint B2 in the cylinder model above. The icon of the joint is
slightly different to other revolute joints to visualize this case.
</p>
<p>
If a modeler is not aware of the problems with planar
loops and models them without special consideration, a Modelica
translator displays an error
message and points out that a planar loop may be the reason and suggests to
use the RevolutePlanarLoopConstraint joint.
This error message is due to an annotation in
the Frame connector.
</p>
<pre>
  <b>connector</b> Frame
     ...
     <b>flow</b> SI.Force f[3] <b>annotation</b>(unassignedMessage=\"..\");
  <b>end</b> Frame;
</pre>
<p>
If no assignment can be found for some
forces in a connector, the \"unassignedMessage\" is displayed. In most cases the
reason for this is a planar loop or two joints that constrain the same motion.
Both cases are discussed in the error message.
</p>
<p>
Note, that the non-linear algebraic equations occurring
in planar loops can be solved analytically in most cases and therefore it is
highly recommended to use the techniques discussed in section
\"<a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling\">Analytic loop handling</a>\"
for such systems.
</p>
</HTML>"));
      end PlanarLoops;

      class AnalyticLoopHandling "Analytic loop handling"
        extends Modelica_Icons.Information;

        annotation (Documentation(info="<HTML>
<p>
It is well known that the non-linear
algebraic equations of most mechanical loops in technical devices can be
solved analytically. It is, however, difficult to perform this fully
automatically and therefore none of the commercial, general purpose multi-body
programs, such as MSC ADAMS, LMS DADS, SIMPACK, have this feature.
These programs solve loop structures with pure numerical methods. Multi-body
programs that are designed for real-time simulation of the dynamics of
specific vehicles, such as ve-DYNA, usually contain manual implementations
of a particular multi-body system (the vehicle) where the occurring loops are
either analytically solved, if this is possible, or are treated by table
look-up where the tables are constructed in a pre-processing phase. Without
these features the required real-time capability would be difficult to
achieve.
</p>
<p>
In a series of papers and dissertations
Prof. Hiller and his group in Duisburg, Germany,
have developed systematic methods to handle mechanical
loops analytically. The \"characteristic pair of joints\" method
basically cuts a loop at two joints and uses geometric
invariants to reduce the number of algebraic
equations, often down to one equation that can be solved analytically. Also
several multi-body codes have been developed that are based on this method,
e.g., MOBILE. Besides the very desired feature to solve non-linear
algebraic equations analytically, i.e., efficiently and in a robust way, there
are several drawbacks: It is difficult to apply this method automatically.
Even if this would be possible in a good way, there is always the problem that
it cannot be guaranteed that the statically selected states lead to no
singularity during simulation. Therefore, the \"characteristic pair of joints\"
method is usually manually applied which requires know-how and experience.
</p>
<p>
In the MultiBody library the \"characteristic pair of
joints\" method is supported in a restricted form such that it can be applied
also by non-specialists. The idea is to provide aggregations of joints in package
<a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies\">
MultiBody.Joints.Assemblies</a>.
as one object that either have <b>6</b> degrees of freedom or
<b>3</b> degrees of freedom (for usage in planar loops).
</p>
<p>
As an example, a variant of the four bar mechanism is given in
the figure below.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/FourbarAnalytic1.png\">
</p>

<p>
Here, the mechanism is modeled with one revolute
joint, two spherical joints and one prismatic joint.
In the figure below, the two spherical joints
and the prismatic joint are collected together in an assembly object
called \"jointSSP\" from
<a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies.JointSSP\">
MultiBody.Joints.Assemblies.JointSSP</a>.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/FourbarAnalytic2.png\">
</p>

<p>
The JointSSP joint aggregation has a frame at the
left side of the left spherical joint (frame_a) and a frame at the right side
of the prismatic joint (frame_b). JointSSP, as all other objects from the
Joints.Assemblies package, has the property, that the <b>generalized
coordinates, and all other frames
defined in the assembly, can be calculated given the movement of frame_a and
of frame_b</b>. This is performed by <b>analytically</b> solving non-linear
systems of equations (details are given in section xxx). From a
structural point of view, the equations in an assembly object are written in
the form
</p>
<p align=\"left\">
  <b>q</b> = <b>
  f</b><sub>1</sub>(<b>r</b><sup>a</sup>, <b>R</b><sup>a</sup>, <b>r</b><sup>b</sup>,
  <b>R</b><sup>b</sup>)
</p>
<p>
where <b>r</b><sup>a</sup>, <b>R</b><sup>a</sup>,<b>
r</b><sup>b</sup>, <b>R</b><sup>b</sup> are the variables defining the
position and orientation of the frame_a and frame_b connector,
<b>q</b> are the generalized positional coordinates inside the
assembly, e.g., the angle of a revolute joint. Given angle
<span style=\"font-family:Symbol\">j</span> of revolute joint j1 from the four
bar mechanism, frame_a and frame_b of the assembly object can be computed by a
forward recursion
</p>
<p align=\"left\">
(<b>r</b><sup>a</sup>,
<b>R</b><sup>a</sup>, <b>r</b><sup>b</sup>, <b>R</b><sup>b</sup>) = <b>f</b>(<span style=\"font-family:Symbol\">j)</span>
</p>
<p>
Since this is a structural property, the
symbolic algorithms can automatically select <span style=\"font-family:Symbol\">
j</span> and its derivative as states and then all positional variables can be
computed in a forwards sequence. It is now understandable that a Modelica
translator can
transform the equations of the four bar mechanism to a recursive sequence of
statements that has no non-linear algebraic loops anymore(remember,
the previous \"straightforward\" solution with 6 revolute joints and 1
prismatic joint has a nonlinear system of equations of order 5).
</p>
<p>
The aggregated joint
objects consist of a combination of either a revolute or prismatic joint and
of a rod that has either two spherical joints at its two ends or a spherical
and a universal joint, respectively. For all combinations, analytic solutions
can be determined. For planar loops, combinations of 1, 2 or 3 revolute joints
with parallel axes and of 2 or 1 prismatic joint with axes that are orthogonal
to the revolute joints can be treated analytically. The currently supported
combinations are listed in the table below.
The missing combinations (such as JointSUP
or Joint RPP) will be added in one of the next releases.
</p>
<div align=\"left\">
    <table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">
      <tr>
        <td colspan=\"2\"> <b>3-dimensional Loops:</b></td>
      </tr>
      <tr>
        <td valign=\"top\">JointSSR</td>
        <td valign=\"top\">Spherical - Spherical - Revolute</td>
      </tr>
      <tr>
        <td valign=\"top\">JointSSP</td>
        <td valign=\"top\">Spherical - Spherical - Prismatic</td>
      </tr>
      <tr>
        <td valign=\"top\">JointUSR</td>
        <td valign=\"top\">Universal - Spherical - Revolute</td>
      </tr>
      <tr>
        <td valign=\"top\">JointUSP</td>
        <td valign=\"top\">Universal - Spherical - Prismatic</td>
      </tr>
      <tr>
        <td valign=\"top\">JointUPS</td>
        <td valign=\"top\">Universal - Prismatic - Spherical</td>
      </tr>
      <tr>
        <td colspan=\"2\"><b>Planar Loops:</b></td>
      </tr>
      <tr>
        <td valign=\"top\">JointRRR</td>
        <td valign=\"top\">Revolute - Revolute - Revolute</td>
      </tr>
      <tr>
        <td valign=\"top\">JointRRP</td>
        <td valign=\"top\">Revolute - Revolute - Prismatic</td>
      </tr>
</table>
</div>
<p>
On first view this seems to be quite restrictive. However, mechanical devices are usually built up with rods connected by spherical joints on each end,
and additionally with revolute and prismatic joints.
Therefore, the combinations of the above table occur frequently.
The universal joint is usually not present in actual devices but is used
(a) if two JointXXX components can be connected such that a revolute
and a universal joint together form a spherical joint
and (b) if the orientation of the connecting rod between two
spherical joints is needed, e.g., since a body shall be attached.
In this case one of the spherical joints might be replaced by a
universal joint. This approximation is fine as long as the mass
and inertia of the rod is not significant.
</p>
<p>
Let us discuss item (a) in more detail: The
MacPherson suspension in the next figure
is from the Modelica VehicleDynamics library.

<p>
The JointSSP joint aggregation has a frame at the
left side of the left spherical joint (frame_a) and a frame at the right side
of the prismatic joint (frame_b). JointSSP, as all other objects from the
Joints.Assemblies package, has the property, that the <b>generalized
coordinates, and all other frames
defined in the assembly, can be calculated given the movement of frame_a and
of frame_b</b>. This is performed by <b>analytically</b> solving non-linear
systems of equations (details are given in section xxx). From a
structural point of view, the equations in an assembly object are written in
the form
</p>
<p align=\"left\">
  <b>q</b> = <b>
  f</b><sub>1</sub>(<b>r</b><sup>a</sup>, <b>R</b><sup>a</sup>, <b>r</b><sup>b</sup>,
  <b>R</b><sup>b</sup>)
</p>
<p>
where <b>r</b><sup>a</sup>, <b>R</b><sup>a</sup>,<b>
r</b><sup>b</sup>, <b>R</b><sup>b</sup> are the variables defining the
position and orientation of the frame_a and frame_b connector,
<b>q</b> are the generalized positional coordinates inside the
assembly, e.g., the angle of a revolute joint. Given angle
<span style=\"font-family:Symbol\">j</span> of revolute joint j1 from the four
bar mechanism, frame_a and frame_b of the assembly object can be computed by a
forward recursion
</p>
<p align=\"left\">
(<b>r</b><sup>a</sup>,
<b>R</b><sup>a</sup>, <b>r</b><sup>b</sup>, <b>R</b><sup>b</sup>) = <b>f</b>(<span style=\"font-family:Symbol\">j)</span>
</p>
<p>
Since this is a structural property, the
symbolic algorithms can automatically select <span style=\"font-family:Symbol\">
j</span> and its derivative as states and then all positional variables can be
computed in a forwards sequence. It is now understandable that a Modelica
translator can
transform the equations of the four bar mechanism to a recursive sequence of
statements that has no non-linear algebraic loops anymore(remember,
the previous \"straightforward\" solution with 6 revolute joints and 1
prismatic joint has a nonlinear system of equations of order 5).
</p>
<p>
The aggregated joint
objects consist of a combination of either a revolute or prismatic joint and
of a rod that has either two spherical joints at its two ends or a spherical
and a universal joint, respectively. For all combinations, analytic solutions
can be determined. For planar loops, combinations of 1, 2 or 3 revolute joints
with parallel axes and of 2 or 1 prismatic joint with axes that are orthogonal
to the revolute joints can be treated analytically. The currently supported
combinations are listed in the table below.
The missing combinations (such as JointSUP
or Joint RPP) will be added in one of the next releases.
</p>
<div align=\"left\">
    <table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">
      <tr>
        <td colspan=\"2\"> <b>3-dimensional Loops:</b></td>
      </tr>
      <tr>
        <td valign=\"top\">JointSSR</td>
        <td valign=\"top\">Spherical - Spherical - Revolute</td>
      </tr>
      <tr>
        <td valign=\"top\">JointSSP</td>
        <td valign=\"top\">Spherical - Spherical - Prismatic</td>
      </tr>
      <tr>
        <td valign=\"top\">JointUSR</td>
        <td valign=\"top\">Universal - Spherical - Revolute</td>
      </tr>
      <tr>
        <td valign=\"top\">JointUSP</td>
        <td valign=\"top\">Universal - Spherical - Prismatic</td>
      </tr>
      <tr>
        <td valign=\"top\">JointUPS</td>
        <td valign=\"top\">Universal - Prismatic - Spherical</td>
      </tr>
      <tr>
        <td colspan=\"2\"><b>Planar Loops:</b></td>
      </tr>
      <tr>
        <td valign=\"top\">JointRRR</td>
        <td valign=\"top\">Revolute - Revolute - Revolute</td>
      </tr>
      <tr>
        <td valign=\"top\">JointRRP</td>
        <td valign=\"top\">Revolute - Revolute - Prismatic</td>
      </tr>
</table>
</div>
<p>
On first view this seems to be quite restrictive. However, mechanical devices are usually built up with rods connected by spherical joints on each end,
and additionally with revolute and prismatic joints.
Therefore, the combinations of the above table occur frequently.
The universal joint is usually not present in actual devices but is used
(a) if two JointXXX components can be connected such that a revolute
and a universal joint together form a spherical joint
and (b) if the orientation of the connecting rod between two
spherical joints is needed, e.g., since a body shall be attached.
In this case one of the spherical joints might be replaced by a
universal joint. This approximation is fine as long as the mass
and inertia of the rod is not significant.
</p>
<p>
Let us discuss item (a) in more detail: The
MacPherson suspension in the next figure
is from the Modelica VehicleDynamics library.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/MacPherson1.png\">
</p>

<p>
It has three frame
connectors. The lower left one (frame_C) is fixed in the vehicle chassis. The
upper left one (frame_S) is driven by the steering mechanism, i.e., the
movement of both frames are given. The frame connector on the right (frame_U)
drives the wheel. The three frames are connected by a mechanism consisting
essentially of two rods with spherical joints on both ends. These are built up
by a jointUPS and a jointSSR assembly.
As can be seen, the universal joint from the jointUPS
assembly is connected to the revolute joint of the jointSSR assembly.
Therefore, we have 3 revolute joints connected together at one point and if
the axes of rotations are chosen appropriately, this describes a spherical
joint. In other words, the two connected assemblies define the desired two
rods with spherical joints on each ends.
</p>
<p>
The movement of the chassis, frame_C, is computed
somewhere else. When the generalized coordinates of revolute joint
\"innerJoint\" (lower left part in figure) are used as states, then frame_a and
frame_b of the jointUPS joint can be calculated. After the non-linear loop
with jointUPS is (analytically) solved, all frames on this assembly are
known, especially,
the one connected to frame_b of the jointSSR assembly. Since frame_b of
jointSSR is connected to frame_S which is computed from the steering
mechanism, again the two required frame movements of the jointSSR assembly are
calculated, meaning in turn that also all other frames on the jointSSR
assembly can be computed, especially, the one connected to frame_U that drives
the wheel. From this analysis it is clear that a tool is able to solve these
coupled loops analytically.
</p>
<p>
Another example is the model of the V6 engine,
see next figure for an animation view and the original definition
of one cylinder with elementary joints.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/EngineV6_3.png\" width=\"303\" height=\"136\">

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/EngineV6_2.png\">
</p>

<p>
It is sufficient to rewrite the basic cylinder model
by replacing the joints with a JointRRP object that has two
revolute and one prismatic joint, see next figure.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/EngineV6_4.png\">
</p>

<p>
Since 6
cylinders are connected together, 6 coupled loops with 6 JointRRP objects are
present. This model is available as
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6_analytic\">
MultiBody.Examples.Loops.EngineV6_analytic</a>.
</p>
<p>
The composition diagram of the connected 6 cylinders is
shown in the next figure
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/EngineV6_1.png\">
</p>
<p>
It can be seen that the revolute joint
of the crank shaft (joint \"bearing\" in left part of figure) might be
selected as degree of freedom. Then the 4 connector frames of all cylinders
can be computed. As a result the computations of the cylinders are decoupled
from each other. Within one cylinder
the position of frame_a and frame_b of the jointRRP assembly
can be computed and therefore the generalized coordinates of the two revolute
and the prismatic joint in the jointRRP object can be determined. From this
analysis it is not surprising that a Modelica translator
is able to transform the DAE
equations into a sequential evaluation without any non-linear loop.
Compare this nice result with the model using only elementary joints
that leads to a DAE with 6 algebraic loops and 5 non-linear equations per
loop. Additionally, a linear system of equations of order 43 is present.
The simulation time is about 5 times faster with the analytic loop handling.
</p>
</html>"));
      end AnalyticLoopHandling;
      annotation (Documentation(info="<HTML>
<p>
The MultiBody library has the feature that all components
can be connected together in a nearly arbitrary fashion.
Therefore, kinematic loop structures pose in principal
no problems. In this section several examples are given,
the special treatment of planar loops is discussed and it is explained
how a kinematic loop structure can be modeled such that the
occurring non-linear algebraic equation systems are solved
analytically. There are the following sub-chapters:
</p>
<ol>
<li><a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.Introduction\">Introduction</a>
</li>
<li><a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.PlanarLoops\">Planar loops</a>.
</li>
<li><a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling\">Analytic loop handling</a>.
</li>
</ol>
</HTML>"));
    end LoopStructures;

    class ConnectionOfLineForces "Connection of LineForces"
      extends Modelica_Icons.Information;
      annotation (Documentation(info="<html>
<p>
Line force elements, such as a
<a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.Spring\">Spring</a>,
are usually connected between two parts. In fact, this is the only possibility
in most multi-body programs. In an equation based system like Modelica, more
general connections are possible. In particular
<b>3-dimensional line force</b> elements can be connected together
in <b>series</b> without having a body with mass at the
connection point. This is advantageous since stiff systems can be avoided, say, due to
a stiff spring and a small mass at the connection point.
For an example, see model
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.ThreeSprings\">ThreeSprings</a>:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/ThreeSprings.png\">
</p>

<p>
Here, three springs are connected together at one point, without having a body
at the connection point of the springs. There is one difficulty: In such a situation
the orientation object at the connection point is undefined, because
the springs do not transmit torques. Translation will therefore fail, if three springs
and a body are connected together in this way. To handle such a case, all line force
elements have flags \"fixedRotationAtFrame_a\" and \"fixedRotationAtFrame_b\" in their
\"Advanced\" parameter menu. For example, if \"fixedRotationAtFrame_b = <b>true</b>\",
the orientation object at frame_b is explicitly set to a null rotation, i.e.,
</p>

<blockquote><pre>
frame_b.R = Modelica.Mechanics.MultiBody.Frames.nullRotation();
</pre></blockquote>

<p>
This means that the coordinate system in the connection point of the three springs
is always parallel to the world frame. When this option is selected, the corresponding
frame in the line force icon is marked with a red circle and with the text \"R=0\".
This is shown in the next figure, where this option is selected for spring3.frame_b:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/ThreeSpringsDiagramLayer.png\">
</p>

<p>
Note, if this flag is not set to <b>true</b>, a translation error will occur.
Due to the usage of overdetermined connectors in the MultiBody library, the error
message will be something like: .
</p>

<blockquote><p>
\"The overdetermined connectors &lt;...&gt; are connected but do not have any root defined\"
</p></blockquote>

<p>
The two flags \"fixedRotationAtFrame_a\" and \"fixedRotationAtFrame_b must be very carefully
set, because a wrong definition can lead to a model that simulates, but the simulation
result is wrong. This is the case, whenever the movement of the resulting system depends
on the orientation object that was arbitrarily set in parallel to the world frame.
A typical example is shown in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/UsersGuide/ThreeSprings2DiagramLayer.png\">
</p>

<p>
Here, spring3.frame_b.R is defined to be in parallel to the world frame.
However, this is then also the orientation of fixedTranslation.frame_a, and this
in turn means that the left part of the fixedTranslation object is always in parallel
to the world frame. Since this is not correct, this model
will result in a <b>wrong simulation result</b>
This system is mathematically not well-defined and does not have a solution.
The only way to model such a system is by providing a mass and an inertia tensor
to fixedTranslation. Then, the flags are not needed, because the \"connection\"
point of the springs is a body where the absolution position vector and the
orientation matrix of the body-fixed coordinate system are used as states.
</p>

</html>"));
    end ConnectionOfLineForces;

    annotation (DocumentationClass=true, Documentation(info="<HTML>
<p>
This tutorial provides an introduction into the
MultiBody library.
</p>
<ol>
<li><a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.OverView\">Overview of
MultiBody library</a> summarizes the most important aspects.
</li>
<li><a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.FirstExample\">A first example</a>
  describes in detail all the steps to build a simple pendulum model.
</li>
<li><a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures\">Loop structures</a>
  explains how to model kinematic loops, especially by analytically
  solving non-linear equations.
</li>
<li><a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces\">ConnectionOfLineForces</a>
  explains how to connect line force components directly together.
</li>
</ol>
</HTML>"));
  end Tutorial;

  class Upgrade "Upgrade from Former Versions"
    extends Modelica_Icons.Information;

    annotation (Documentation(info="<HTML>
<p>
If different versions of the MultiBody library are not
compatible to each other, corresponding conversion scripts are
provided. As a result, models build with an older version
of the MultiBody library are automatically converted to the
new version when the model is loaded. The user is prompted
whether automatic conversion shall take place or not.
Problems are not to be expected. Still one should first make
a copy of such a model as backup before the conversion
is performed.
</p>
<p>
<b>Upgrade from ModelicaAdditions.MultiBody</b>
</p>
<p>
There is now also a conversion script from the \"old\"
<b>ModelicaAdditions.MultiBody</b> library to the
\"new\" Modelica.Mechanics.MultiBody library. This script is also
automatically invoked. Since the differences between the \"old\" and the
\"new\" MultiBody library are so large, not everything is
converted and it might be that some pieces have to
be adapted manually. Still, this script is useful, since
many class names, parameters and modifiers are
automatically converted.
</p>
<p>
Components from the following sublibraries
are automatically converted
to the Modelica.Mechanics.MultiBody library:
</p>
<ul>
<li> ModelicaAdditions.MultiBody.Parts</li>
<li> ModelicaAdditions.MultiBody.Joints</li>
<li> ModelicaAdditions.MultiBody.Forces</li>
<li> Part of ModelicaAdditions.MultiBody.Interfaces</li>
</ul>
<p>
Models using the ModelicaAdditions.MultiBody library
that are programmed with <b>equations</b> are only partly converted:
The Frame connectors will be converted to the \"new\"
Frame connectors of the MultiBody library, but the equations
that reference variables of the Frame connectors will
<b>not</b> be converted. For a manual conversion, the following
table might be helpful showing how the <b>variables</b> of the
\"old\" and the \"new\" <b>Frame connectors</b> are
related to each other (resolve2 and angularVelocity2 are
functions from library Modelica.Mechanics.MultiBody.Frames):
</p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>ModelicaAdditions.MultiBody.<br>
           Interfaces.Frame_a</b></th>
    <th><b>MultiBody.Interfaces.Frame_a</b></th></tr>
<tr>
  <td valign=\"top\">frame_a.<b>r0</b></td>
  <td valign=\"top\">= frame_a.r_0 (is converted)</td>
</tr>
<tr>
  <td valign=\"top\">frame_a.<b>S</b></td>
  <td valign=\"top\">= transpose(frame_a.R)</td>
</tr>
<tr>
  <td valign=\"top\">frame_a.<b>v</b></td>
  <td valign=\"top\">= resolve2(frame_a.R, <b>der</b>(frame_a.r_0))</td>
</tr>
<tr>
  <td valign=\"top\">frame_a.<b>w</b></td>
  <td valign=\"top\">= angularVelocity2(frame_a.R)</td>
</tr>
<tr>
  <td valign=\"top\">frame_a.<b>a</b></td>
  <td valign=\"top\">= resolve2(frame_a.R, <b>der</b>(v_0)); v_0 = der(r_0)</td>
</tr>
<tr>
  <td valign=\"top\">frame_a.<b>z</b></td>
  <td valign=\"top\">= <b>der</b>(w);  w = angulaVelocity2(frame_a.R)</td>
</tr>
<tr>
  <td valign=\"top\">frame_a.<b>f</b></td>
  <td valign=\"top\">= frame_a.f (no conversion needed)</td>
</tr>
<tr>
  <td valign=\"top\">frame_a.<b>t</b></td>
  <td valign=\"top\">= frame_a.t (no conversion needed)</td>
</tr>
</table>
<p>
<b>Upgrade from MultiBody 0.99 (and earlier) to 1.0 (and later)</b>
<p>
The conversion from MultiBody 0.99 to 1.0 does not work in some rare
cases, where own components are implemented using functions of the
MultiBody.Frames package. In this case, the conversion has to be
performed manually. The changes in 1.0 with regards to 0.99 are:
</p>
<p>
The definition of the Modelica.Mechanics.MultiBody.Frames.Orientation object has changed.
In 0.99 this was just an alias type for a transformation matrix
(now Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.Orientation).
In 1.0 the orientation object is a record holding the
transformation matrix from frame 1 to frame 2 and the angular
velocity of the transformation matrix resolved in frame 2.
The reason is that this allows to compute the angular velocity
in many cases by standard recursive formulas and not by
differentiation of the transformation matrix. This is usually
much more efficient. As a consequence, the following
calls in 0.99 should be changed:
</p>
<pre>
   Frames.angularVelocity1(T,der(T)) -> Frames.angularVelocity1(T)
   Frames.angularVelocity2(T,der(T)) -> Frames.angularVelocity2(T)
   Frames.from_T(T)                  -> Frames.from_T2(T,der(T))
</pre>
</html>"));
  end Upgrade;

  class Literature "Literature"
    extends Modelica_Icons.References;

    annotation (Documentation(info="<html>
<ul>
<li>Technical details of this library are described in the
20 page paper:
<dl>
<dt>Otter M., Elmqvist H., and Mattsson S.E.:</dt>
<dd> <b>The New Modelica MultiBody Library</b>.
     Modelica 2003 Conference, Link&ouml;ping, Sweden,
     pp. 311-330, Nov. 3-4, 2003.
     Download from:
     <a href=\"https://www.modelica.org/events/Conference2003/papers/h37_Otter_multibody.pdf\">https://www.modelica.org/events/Conference2003/papers/h37_Otter_multibody.pdf</a>
     </dd>
</dl>
</li>
<li>The method how to describe drive trains with 1-dimensional mechanics
and to mount them on 3-dimensional components without neglecting
dynamical effects is described in:
<dl>
<dt>Schweiger C., and Otter M.:</dt>
<dd> <b>Modelling 3-dim. Mechanical Effects of 1-dim. Powertrains</b>.
     Modelica 2003 Conference, Link&ouml;ping, Sweden,
     pp. 149-158, Nov. 3-4, 2003.
     Download from:
<a href=\"https://www.modelica.org/events/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf\">https://www.modelica.org/events/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf</a>
     </dd>
</dl>
</li>
<li> The method to solve a certain class of kinematic loops
     analytically is based on:
<dl>
<dt>Woernle C.:</dt>
<dd><b>Ein systematisches Verfahren zur Aufstellung der geometrischen
    Schliessbedingungen in kinematischen Schleifen mit Anwendung
    bei der R&uuml;ckw&auml;rtstransformation f&uuml;r
    Industrieroboter.</b><br>
    Fortschritt-Berichte VDI, Reihe 18, Nr. 59, Duesseldorf: VDI-Verlag 1988,
    ISBN 3-18-145918-6.<br>&nbsp;</dd>
<dt>Hiller M., and Woernle C.:</dt>
<dd><b>A Systematic Approach for Solving the Inverse Kinematic
    Problem of Robot Manipulators</b>.<br>
    Proceedings 7th World Congress Th. Mach. Mech., Sevilla 1987. </dd>
</dl>
</li>
</ul>
</html>"));
  end Literature;

  class Contact "Contact"
    extends Modelica_Icons.Contact;

    annotation (Documentation(info="<html>
<dl>
<dt><b>Library Officer:</b>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
    Institut f&uuml;r Robotik und Mechatronik<br>
    Abteilung f&uuml;r Entwurfsorientierte Regelungstechnik<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    Germany<br>
    email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
</dl>
<p><b>Acknowledgements:</b></p>
<ul>
<li> The central idea to handle a certain class of overdetermined, consistent
     set of differential algebraic equations (i.e., there are more equations than
     unknowns) with symbolic transformation algorithms was developed together
     with Hilding Elmqvist and Sven Erik Mattsson from Dassault Syst&egrave;mes AB, Lund, Sweden.
     The MultiBody library is heavily relying on this feature which is a
     prerequisite for a truly \"object-oriented\" multi-body systems library,
     where components can be connected together in any meaningful way.</li>
<li> The Examples.Loops.EngineV6 demo of a six cylinder V6 engine with
     6 planar loops and 1 degree of freedom is from Hilding Elmqvist and
     Sven Erik Mattsson.</li>
<li> Modelica.Mechanics.MultiBody.Forces.LineForceWithMass is based on model
     \"RelativeDistance\" from the Modelica VehicleDynamics library of
     Johan Andreasson from Royal Institute of Technology, Stockholm, Sweden.</li>
<li> The 1-dim. components (Parts.Rotor1D, Parts.BevelGear1D, Mounting1D) and
     Joints.GearConstraints are from Christian Schweiger.</li>
<li> The design of this library is based on work carried out
     in the EU RealSim project (Real-time Simulation for Design of
     Multi-physics Systems) funded by the European Commission within
     the Information Societies Technology (IST) programme under
     contract number IST 1999-11979.
     </li>
</ul>
</html>"));
  end Contact;

  annotation (DocumentationClass=true, Documentation(info="<HTML>
<p>
Library <b>MultiBody</b> is a <b>free</b> Modelica package providing
3-dimensional mechanical components to model in a convenient way
<b>mechanical systems</b>, such as robots, mechanisms, vehicles.
This package contains the User's Guide for the MultiBody library.
</p>
<ol>
<li> <a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial\">Tutorial</a>
gives an introduction into the most important aspects of the library.
</li>
<li> <a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Upgrade\">Upgrade</a> describes
  how to upgrade from former versions, especially from the \"old\"
  ModelicaAdditions.MultiBody library.
</li>
<li> <a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Literature\">Literature</a> provides
  references that have been used to design and implement this library.
</li>
<li> <a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Contact\">Contact</a> provides
  information about the author of the library as well as
  acknowledgments.
</li>
</ol>
</HTML>"));
end UsersGuide;

model World
    "World coordinate system + gravity field + default animation definition"

  import Modelica_Mechanics_MultiBody.Types.GravityTypes;
  import Modelica_Mechanics_MultiBody.Types;

    Interfaces.Frame_b frame_b
      "Coordinate system fixed in the origin of the world frame"
                               annotation (Placement(transformation(extent={{84,
            -16},{116,16}}, rotation=0)));

  parameter Boolean enableAnimation=true
      "= true, if animation of all components is enabled";
  parameter Boolean animateWorld=true
      "= true, if world coordinate system shall be visualized"
                                                             annotation(Dialog(enable=enableAnimation));
  parameter Boolean animateGravity=true
      "= true, if gravity field shall be visualized (acceleration vector or field center)"
                                                                                          annotation(Dialog(enable=enableAnimation));
  parameter Types.AxisLabel label1="x" "Label of horizontal axis in icon";
  parameter Types.AxisLabel label2="y" "Label of vertical axis in icon";
  parameter Types.GravityTypes gravityType=GravityTypes.UniformGravity
      "Type of gravity field"                                                                                                   annotation (Evaluate=true);
    parameter Modelica_SIunits.Acceleration g=9.81
      "Constant gravity acceleration" annotation (Dialog(enable=gravityType ==
            Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity));
  parameter Types.Axis n={0,-1,0}
      "Direction of gravity resolved in world frame (gravity = g*n/length(n))"
    annotation (Evaluate=true, Dialog(enable=gravityType == Modelica.Mechanics.
          MultiBody.Types.GravityTypes.UniformGravity));
  parameter Real mue(
    unit="m3/s2",
    min=0) = 3.986e14
      "Gravity field constant (default = field constant of earth)"
    annotation (Dialog(enable=gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.PointGravity));
  parameter Boolean driveTrainMechanics3D=true
      "= true, if 3-dim. mechanical effects of Parts.Mounting1D/Rotor1D/BevelGear1D shall be taken into account";

    parameter Modelica_SIunits.Distance axisLength=nominalLength/2
      "Length of world axes arrows" annotation (Dialog(
        tab="Animation",
        group="if animateWorld = true",
        enable=enableAnimation and animateWorld));
    parameter Modelica_SIunits.Distance axisDiameter=axisLength/
        defaultFrameDiameterFraction "Diameter of world axes arrows"
      annotation (Dialog(
        tab="Animation",
        group="if animateWorld = true",
        enable=enableAnimation and animateWorld));
  parameter Boolean axisShowLabels=true "= true, if labels shall be shown"
    annotation (Dialog(tab="Animation", group="if animateWorld = true", enable=enableAnimation and animateWorld));
  input Types.Color axisColor_x=Types.Defaults.FrameColor "Color of x-arrow"
    annotation (Dialog(colorSelector=true,tab="Animation", group="if animateWorld = true", enable=enableAnimation and animateWorld));
  input Types.Color axisColor_y=axisColor_x
    annotation (Dialog(colorSelector=true,tab="Animation", group="if animateWorld = true", enable=enableAnimation and animateWorld));
  input Types.Color axisColor_z=axisColor_x "Color of z-arrow"
    annotation (Dialog(colorSelector=true,tab="Animation", group="if animateWorld = true", enable=enableAnimation and animateWorld));

    parameter Modelica_SIunits.Position gravityArrowTail[3]={0,0,0}
      "Position vector from origin of world frame to arrow tail, resolved in world frame"
      annotation (Dialog(
        tab="Animation",
        group="if animateGravity = true and gravityType = UniformGravity",
        enable=enableAnimation and animateGravity and gravityType ==
            GravityTypes.UniformGravity));
    parameter Modelica_SIunits.Length gravityArrowLength=axisLength/2
      "Length of gravity arrow" annotation (Dialog(
        tab="Animation",
        group="if animateGravity = true and gravityType = UniformGravity",
        enable=enableAnimation and animateGravity and gravityType ==
            GravityTypes.UniformGravity));
    parameter Modelica_SIunits.Diameter gravityArrowDiameter=gravityArrowLength
        /defaultWidthFraction "Diameter of gravity arrow" annotation (Dialog(
        tab="Animation",
        group="if animateGravity = true and gravityType = UniformGravity",
        enable=enableAnimation and animateGravity and gravityType ==
            GravityTypes.UniformGravity));
  input Types.Color gravityArrowColor={0,230,0} "Color of gravity arrow"
    annotation (Dialog(colorSelector=true, tab="Animation", group=
          "if animateGravity = true and gravityType = UniformGravity",
          enable=enableAnimation and animateGravity and gravityType == GravityTypes.UniformGravity));
    parameter Modelica_SIunits.Diameter gravitySphereDiameter=12742000
      "Diameter of sphere representing gravity center (default = mean diameter of earth)"
      annotation (Dialog(
        tab="Animation",
        group="if animateGravity = true and gravityType = PointGravity",
        enable=enableAnimation and animateGravity and gravityType ==
            GravityTypes.PointGravity));
  input Types.Color gravitySphereColor={0,230,0} "Color of gravity sphere"
    annotation (Dialog(colorSelector=true, tab="Animation", group=
          "if animateGravity = true and gravityType = PointGravity",
          enable=enableAnimation and animateGravity and gravityType == GravityTypes.PointGravity));

    parameter Modelica_SIunits.Length nominalLength=1
      "\"Nominal\" length of multi-body system"
      annotation (Dialog(tab="Defaults"));
    parameter Modelica_SIunits.Length defaultAxisLength=nominalLength/5
      "Default for length of a frame axis (but not world frame)"
      annotation (Dialog(tab="Defaults"));
    parameter Modelica_SIunits.Length defaultJointLength=nominalLength/10
      "Default for the fixed length of a shape representing a joint"
      annotation (Dialog(tab="Defaults"));
    parameter Modelica_SIunits.Length defaultJointWidth=nominalLength/20
      "Default for the fixed width of a shape representing a joint"
      annotation (Dialog(tab="Defaults"));
    parameter Modelica_SIunits.Length defaultForceLength=nominalLength/10
      "Default for the fixed length of a shape representing a force (e.g., damper)"
      annotation (Dialog(tab="Defaults"));
    parameter Modelica_SIunits.Length defaultForceWidth=nominalLength/20
      "Default for the fixed width of a shape representing a force (e.g., spring, bushing)"
      annotation (Dialog(tab="Defaults"));
    parameter Modelica_SIunits.Length defaultBodyDiameter=nominalLength/9
      "Default for diameter of sphere representing the center of mass of a body"
      annotation (Dialog(tab="Defaults"));
  parameter Real defaultWidthFraction=20
      "Default for shape width as a fraction of shape length (e.g., for Parts.FixedTranslation)"
    annotation (Dialog(tab="Defaults"));
    parameter Modelica_SIunits.Length defaultArrowDiameter=nominalLength/40
      "Default for arrow diameter (e.g., of forces, torques, sensors)"
      annotation (Dialog(tab="Defaults"));
  parameter Real defaultFrameDiameterFraction=40
      "Default for arrow diameter of a coordinate system as a fraction of axis length"
    annotation (Dialog(tab="Defaults"));
  parameter Real defaultSpecularCoefficient(min=0) = 0.7
      "Default reflection of ambient light (= 0: light is completely absorbed)"
    annotation (Dialog(tab="Defaults"));
  parameter Real defaultN_to_m(unit="N/m", min=0) = 1000
      "Default scaling of force arrows (length = force/defaultN_to_m)"
    annotation (Dialog(tab="Defaults"));
  parameter Real defaultNm_to_m(unit="N.m/m", min=0) = 1000
      "Default scaling of torque arrows (length = torque/defaultNm_to_m)"
    annotation (Dialog(tab="Defaults"));

  replaceable function gravityAcceleration =
       Modelica_Mechanics_MultiBody.Forces.Internal.standardGravityAcceleration
        (
        gravityType=gravityType,
        g=g*Modelica_Math.Vectors.normalizeWithAssert(n),
        mue=mue) constrainedby
      Modelica_Mechanics_MultiBody.Interfaces.partialGravityAcceleration
      "Function to compute the gravity acceleration, resolved in world frame"
       annotation(choicesAllMatching=true,Dialog(enable=gravityType==
                   Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity),
    Documentation(info="<html>
<p>Replaceable function to define the gravity field.
   Default is function
   <a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.Internal.standardGravityAcceleration\">standardGravityAcceleration</a>
   that provides some simple gravity fields (no gravity, constant parallel gravity field,
   point gravity field).
   By redeclaring this function, any type of gravity field can be defined, see example
     <a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.UserDefinedGravityField\">Examples.Elementary.UserDefinedGravityField</a>.
</p>
</html>"));

  /* The World object can only use the Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape model, but no
     other models in package Modelica.Mechanics.MultiBody.Visualizers, since the other models access
     data of the "outer Modelica.Mechanics.MultiBody.World world" object, i.e., there are
     mutually dependent classes. For this reason, the higher level visualization
     objects cannot be used.
  */
  protected
  parameter Integer ndim=if enableAnimation and animateWorld then 1 else 0;
  parameter Integer ndim2=if enableAnimation and animateWorld and
      axisShowLabels then 1 else 0;

  // Parameters to define axes
    parameter Modelica_SIunits.Length headLength=min(axisLength, axisDiameter*
        Types.Defaults.FrameHeadLengthFraction);
    parameter Modelica_SIunits.Length headWidth=axisDiameter*Types.Defaults.FrameHeadWidthFraction;
    parameter Modelica_SIunits.Length lineLength=max(0, axisLength - headLength);
    parameter Modelica_SIunits.Length lineWidth=axisDiameter;

  // Parameters to define axes labels
    parameter Modelica_SIunits.Length scaledLabel=Types.Defaults.FrameLabelHeightFraction
        *axisDiameter;
    parameter Modelica_SIunits.Length labelStart=1.05*axisLength;

  // x-axis
  Modelica_Mechanics_MultiBody.Visualizers.Advanced.Shape x_arrowLine(
      shapeType="cylinder",
      length=lineLength,
      width=lineWidth,
      height=lineWidth,
      lengthDirection={1,0,0},
      widthDirection={0,1,0},
      color=axisColor_x,
      specularCoefficient=0) if enableAnimation and animateWorld;
  Modelica_Mechanics_MultiBody.Visualizers.Advanced.Shape x_arrowHead(
      shapeType="cone",
      length=headLength,
      width=headWidth,
      height=headWidth,
      lengthDirection={1,0,0},
      widthDirection={0,1,0},
      color=axisColor_x,
      r={lineLength,0,0},
      specularCoefficient=0) if enableAnimation and animateWorld;
  Modelica_Mechanics_MultiBody.Visualizers.Internal.Lines x_label(
      lines=scaledLabel*{[0,0; 1,1],[0,1; 1,0]},
      diameter=axisDiameter,
      color=axisColor_x,
      r_lines={labelStart,0,0},
      n_x={1,0,0},
      n_y={0,1,0},
      specularCoefficient=0) if enableAnimation and animateWorld and
      axisShowLabels;

  // y-axis
  Modelica_Mechanics_MultiBody.Visualizers.Advanced.Shape y_arrowLine(
      shapeType="cylinder",
      length=lineLength,
      width=lineWidth,
      height=lineWidth,
      lengthDirection={0,1,0},
      widthDirection={1,0,0},
      color=axisColor_y,
      specularCoefficient=0) if enableAnimation and animateWorld;
  Modelica_Mechanics_MultiBody.Visualizers.Advanced.Shape y_arrowHead(
      shapeType="cone",
      length=headLength,
      width=headWidth,
      height=headWidth,
      lengthDirection={0,1,0},
      widthDirection={1,0,0},
      color=axisColor_y,
      r={0,lineLength,0},
      specularCoefficient=0) if enableAnimation and animateWorld;
  Modelica_Mechanics_MultiBody.Visualizers.Internal.Lines y_label(
      lines=scaledLabel*{[0,0; 1,1.5],[0,1.5; 0.5,0.75]},
      diameter=axisDiameter,
      color=axisColor_y,
      r_lines={0,labelStart,0},
      n_x={0,1,0},
      n_y={-1,0,0},
      specularCoefficient=0) if enableAnimation and animateWorld and
      axisShowLabels;

  // z-axis
  Modelica_Mechanics_MultiBody.Visualizers.Advanced.Shape z_arrowLine(
      shapeType="cylinder",
      length=lineLength,
      width=lineWidth,
      height=lineWidth,
      lengthDirection={0,0,1},
      widthDirection={0,1,0},
      color=axisColor_z,
      specularCoefficient=0) if enableAnimation and animateWorld;
  Modelica_Mechanics_MultiBody.Visualizers.Advanced.Shape z_arrowHead(
      shapeType="cone",
      length=headLength,
      width=headWidth,
      height=headWidth,
      lengthDirection={0,0,1},
      widthDirection={0,1,0},
      color=axisColor_z,
      r={0,0,lineLength},
      specularCoefficient=0) if enableAnimation and animateWorld;
  Modelica_Mechanics_MultiBody.Visualizers.Internal.Lines z_label(
      lines=scaledLabel*{[0,0; 1,0],[0,1; 1,1],[0,1; 1,0]},
      diameter=axisDiameter,
      color=axisColor_z,
      r_lines={0,0,labelStart},
      n_x={0,0,1},
      n_y={0,1,0},
      specularCoefficient=0) if enableAnimation and animateWorld and
      axisShowLabels;

  // Uniform gravity visualization
    parameter Modelica_SIunits.Length gravityHeadLength=min(gravityArrowLength,
        gravityArrowDiameter*Types.Defaults.ArrowHeadLengthFraction);
    parameter Modelica_SIunits.Length gravityHeadWidth=gravityArrowDiameter*
        Types.Defaults.ArrowHeadWidthFraction;
    parameter Modelica_SIunits.Length gravityLineLength=max(0,
        gravityArrowLength - gravityHeadLength);
  Modelica_Mechanics_MultiBody.Visualizers.Advanced.Shape gravityArrowLine(
      shapeType="cylinder",
      length=gravityLineLength,
      width=gravityArrowDiameter,
      height=gravityArrowDiameter,
      lengthDirection=n,
      widthDirection={0,1,0},
      color=gravityArrowColor,
      r_shape=gravityArrowTail,
      specularCoefficient=0) if enableAnimation and animateGravity and
      gravityType == GravityTypes.UniformGravity;
  Modelica_Mechanics_MultiBody.Visualizers.Advanced.Shape gravityArrowHead(
      shapeType="cone",
      length=gravityHeadLength,
      width=gravityHeadWidth,
      height=gravityHeadWidth,
      lengthDirection=n,
      widthDirection={0,1,0},
      color=gravityArrowColor,
      r_shape=gravityArrowTail + Modelica_Math.Vectors.normalize(n)*
          gravityLineLength,
      specularCoefficient=0) if enableAnimation and animateGravity and
      gravityType == GravityTypes.UniformGravity;

  // Point gravity visualization
  parameter Integer ndim_pointGravity=if enableAnimation and animateGravity
       and gravityType == GravityTypes.UniformGravity then 1 else 0;
  Modelica_Mechanics_MultiBody.Visualizers.Advanced.Shape gravitySphere(
      shapeType="sphere",
      r_shape={-gravitySphereDiameter/2,0,0},
      lengthDirection={1,0,0},
      length=gravitySphereDiameter,
      width=gravitySphereDiameter,
      height=gravitySphereDiameter,
      color=gravitySphereColor,
      specularCoefficient=0) if enableAnimation and animateGravity and
      gravityType == GravityTypes.PointGravity;

/*
  function gravityAcceleration = gravityAccelerationTypes (
      gravityType=gravityType,
      g=g*Modelica.Math.Vectors.normalize(
                                     n),
      mue=mue);
*/

equation
  Connections.root(frame_b.R);

  assert(Modelica_Math.Vectors.length(
                       n) > 1.e-10,
    "Parameter n of World object is wrong (length(n) > 0 required)");
  frame_b.r_0 = zeros(3);
  frame_b.R = Frames.nullRotation();
  annotation (
    defaultComponentName="world",
    defaultComponentPrefixes="inner",
    missingInnerMessage="No \"world\" component is defined. A default world
component with the default gravity field will be used
(g=9.81 in negative y-axis). If this is not desired,
drag Modelica.Mechanics.MultiBody.World into the top level of your model.",
    Icon(coordinateSystem(
        preserveAspectRatio=true,
        extent={{-100,-100},{100,100}}), graphics={
        Rectangle(
          extent={{-100,100},{100,-100}},
          lineColor={0,0,0},
          fillColor={255,255,255},
          fillPattern=FillPattern.Solid),
        Line(
          points={{-100,-118},{-100,61}},
          color={0,0,0},
          thickness=0.5),
        Polygon(
          points={{-100,100},{-120,60},{-80,60},{-100,100},{-100,100}},
          lineColor={0,0,0},
          fillColor={0,0,0},
          fillPattern=FillPattern.Solid),
        Line(
          points={{-119,-100},{59,-100}},
          color={0,0,0},
          thickness=0.5),
        Polygon(
          points={{99,-100},{59,-80},{59,-120},{99,-100}},
          lineColor={0,0,0},
          fillColor={0,0,0},
          fillPattern=FillPattern.Solid),
        Text(
          extent={{-150,145},{150,105}},
          textString="%name",
          lineColor={0,0,255}),
        Text(
          extent={{95,-113},{144,-162}},
          lineColor={0,0,0},
          textString="%label1"),
        Text(
          extent={{-170,127},{-119,77}},
          lineColor={0,0,0},
          textString="%label2"),
        Line(points={{-56,78},{-56,-26}}, color={0,0,255}),
        Polygon(
          points={{-68,-26},{-56,-66},{-44,-26},{-68,-26}},
          fillColor={0,0,255},
          fillPattern=FillPattern.Solid,
          lineColor={0,0,255}),
        Line(points={{2,78},{2,-26}}, color={0,0,255}),
        Polygon(
          points={{-10,-26},{2,-66},{14,-26},{-10,-26}},
          fillColor={0,0,255},
          fillPattern=FillPattern.Solid,
          lineColor={0,0,255}),
        Line(points={{66,80},{66,-26}}, color={0,0,255}),
        Polygon(
          points={{54,-26},{66,-66},{78,-26},{54,-26}},
          fillColor={0,0,255},
          fillPattern=FillPattern.Solid,
          lineColor={0,0,255})}),
    Documentation(info="<HTML>
<p>
Model <b>World</b> represents a global coordinate system fixed in
ground. This model serves several purposes:
<ul>
<li> It is used as <b>inertial system</b> in which
     the equations of all elements of the MultiBody library
     are defined.</li>
<li> It is the world frame of an <b>animation window</b> in which
     all elements of the MultiBody library are visualized.</li>
<li> It is used to define the <b>gravity field</b> in which a
     multi-body model is present. Default is a uniform gravity
     field where the gravity acceleration vector g is the
     same at every position. Additionally, a point gravity field or no
     gravity can be selected. Also, function gravityAcceleration can
     be redeclared to a user-defined function that computes the gravity
     acceleration, see example
     <a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.UserDefinedGravityField\">Examples.Elementary.UserDefinedGravityField</a>.
     </li>
<li> It is used to define <b>default settings</b> of animation properties
     (e.g., the diameter of a sphere representing by default
     the center of mass of a body, or the diameters of the cylinders
     representing a revolute joint).</li>
<li> It is used to define a <b>visual representation</b> of the
     world model (= 3 coordinate axes with labels) and of the defined
     gravity field.<br>
    <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/world.png\" ALT=\"MultiBody.World\">
</li>
</ul>
<p>
Since the gravity field function is required from all bodies with mass
and the default settings of animation properties are required
from nearly every component, exactly one instance of model World needs
to be present in every model on the top level. The basic declaration
needs to be:
</p>
<pre>
    <b>inner</b> Modelica.Mechanics.MultiBody.World world
</pre>
<p>
Note, it must be an <b>inner</b> declaration with instance name <b>world</b>
in order that this world object can be accessed from all objects in the
model. When dragging the \"World\" object from the package browser into
the diagram layer, this declaration is automatically generated
(this is defined via annotations in model World).
</p>
<p>
All vectors and tensors of a mechanical system are resolved in a
frame that is local to the corresponding component. Usually,
if all relative joint coordinates vanish, the local frames
of all components are parallel to each other, as well as to the
world frame (this holds as long as a Parts.FixedRotation,
component is <b>not</b> used). In this \"reference configuration\"
it is therefore
alternatively possible to resolve all vectors in the world
frame, since all frames are parallel to each other.
This is often very convenient. In order to give some visual
support in such a situation, in the icon of a World instance
two axes of the world frame are shown and the labels
of these axes can be set via parameters.
</p>
</html>"));
end World;

  package Examples
    "Examples that demonstrate the usage of the MultiBody library"
  extends Modelica_Icons.ExamplesPackage;

    package Elementary
      "Elementary examples to demonstrate various features of the MultiBody library"
    extends Modelica_Icons.ExamplesPackage;

      model DoublePendulum
        "Simple double pendulum with two revolute joints and two bodies"

        extends Modelica_Icons.Example;
        inner Modelica_Mechanics_MultiBody.World world annotation (Placement(
              transformation(extent={{-88,0},{-68,20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute revolute1(
          useAxisFlange=true,
          phi(fixed=true),
          w(fixed=true)) annotation (Placement(transformation(extent={{-48,0},{
                  -28,20}}, rotation=0)));
        Modelica_Mechanics_Rotational.Components.Damper damper(
                                                    d=0.1)
          annotation (Placement(transformation(extent={{-48,40},{-28,60}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.BodyBox boxBody1(r={0.5,0,0}, width=
              0.06) annotation (Placement(transformation(extent={{-10,0},{10,20}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute revolute2(phi(fixed=true),
            w(fixed=true)) annotation (Placement(transformation(extent={{32,0},
                  {52,20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.BodyBox boxBody2(r={0.5,0,0}, width=
              0.06) annotation (Placement(transformation(extent={{74,0},{94,20}},
                rotation=0)));
      equation

        connect(damper.flange_b, revolute1.axis) annotation (Line(points={{-28,50},{
                -24,50},{-24,28},{-38,28},{-38,20}}, color={0,0,0}));
        connect(revolute1.support, damper.flange_a) annotation (Line(points={{-44,20},
                {-44,28},{-58,28},{-58,50},{-48,50}}, color={0,0,0}));
        connect(revolute1.frame_b, boxBody1.frame_a)
          annotation (Line(
            points={{-28,10},{-10,10}},
            color={95,95,95},
            thickness=0.5));
        connect(revolute2.frame_b, boxBody2.frame_a)
          annotation (Line(
            points={{52,10},{74,10}},
            color={95,95,95},
            thickness=0.5));
        connect(boxBody1.frame_b, revolute2.frame_a)
          annotation (Line(
            points={{10,10},{32,10}},
            color={95,95,95},
            thickness=0.5));
        connect(world.frame_b, revolute1.frame_a)
          annotation (Line(
            points={{-68,10},{-48,10}},
            color={95,95,95},
            thickness=0.5));
        annotation (
          experiment(StopTime=3),
          Documentation(info="<html>
<p>
This example demonstrates that by using joint and body
elements animation is automatically available. Also the revolute
joints are animated. Note, that animation of every component
can be switched of by setting the first parameter <b>animation</b>
to <b>false</b> or by setting <b>enableAnimation</b> in the <b>world</b>
object to <b>false</b> to switch off animation of all components.
</p>

<table border=0 cellspacing=0 cellpadding=0><tr><td valign=\"top\">
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/DoublePendulum.png\"
ALT=\"model Examples.Elementary.DoublePendulum\">
</td></tr></table>

</HTML>"));
      end DoublePendulum;

      model DoublePendulumInitTip
        "Demonstrate how to initialize a double pendulum so that its tip starts at a predefined position"
        extends Modelica_Icons.Example;
        inner World world                              annotation (Placement(
              transformation(extent={{-100,0},{-80,20}},rotation=0)));
        Joints.Revolute revolute1(                             useAxisFlange=true)
                                                                       annotation (Placement(transformation(extent={{-60,0},
                  {-40,20}}, rotation=0)));
        Modelica_Mechanics_Rotational.Components.Damper damper(d=0.1)
          annotation (Placement(transformation(extent={{-60,40},{-40,60}},
                rotation=0)));
        Parts.BodyBox boxBody1(                             r={0.5,0,0}, width=0.06)
          annotation (Placement(transformation(extent={{-22,0},{-2,20}}, rotation=0)));
        Joints.Revolute revolute2                              annotation (Placement(transformation(extent={{20,0},{
                  40,20}}, rotation=0)));
        Parts.BodyBox boxBody2(                             r={0.5,0,0}, width=0.06)
          annotation (Placement(transformation(extent={{62,0},{82,20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.FreeMotionScalarInit freeMotionScalarInit(
          use_r=true,
          r_rel_a_1(start=0.7, fixed=true),
          r_rel_a_2(start=0.3, fixed=true),
          use_v=true,
          v_rel_a_1(fixed=true),
          v_rel_a_2(fixed=true))
          annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));
      equation
        connect(damper.flange_b,revolute1. axis) annotation (Line(points={{-40,50},{
                -36,50},{-36,28},{-50,28},{-50,20}}, color={0,0,0}));
        connect(revolute1.support,damper. flange_a) annotation (Line(points={{-56,20},
                {-56,28},{-70,28},{-70,50},{-60,50}}, color={0,0,0}));
        connect(revolute1.frame_b,boxBody1. frame_a)
          annotation (Line(
            points={{-40,10},{-22,10}},
            color={95,95,95},
            thickness=0.5));
        connect(revolute2.frame_b,boxBody2. frame_a)
          annotation (Line(
            points={{40,10},{62,10}},
            color={95,95,95},
            thickness=0.5));
        connect(boxBody1.frame_b,revolute2. frame_a)
          annotation (Line(
            points={{-2,10},{20,10}},
            color={95,95,95},
            thickness=0.5));
        connect(world.frame_b,revolute1. frame_a)
          annotation (Line(
            points={{-80,10},{-60,10}},
            color={95,95,95},
            thickness=0.5));
        connect(world.frame_b, freeMotionScalarInit.frame_a) annotation (Line(
            points={{-80,10},{-66,10},{-66,-30},{-20,-30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(freeMotionScalarInit.frame_b, boxBody2.frame_b) annotation (Line(
            points={{0,-30},{88,-30},{88,10},{82,10}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (
          experiment(StopTime=5),
          Documentation(info="<html>
<p>
This example demonstrates at hand of a double pendulum,
how no-standard initialization can be defined:
The absolute position of the pendulum tip, and its absolute speed
shall be initially defined. This can be performed with the
<a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.FreeMotionScalarInit\">Joints.FreeMotionScalarInit</a>
joint that allows to initialize individual elements of its relative vectors.
In this case, the x-, and y-coordinates of the relative position vector
(visualized by the yellow arrow in the figure below) and of its
derivative shall have a defined value at initial time.
The configuration of the double pendulum at the initial time is
shown below, where the tip position is required to have the coordinates
x=0.7, y=0.3.
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/DoublePendulumInitTip.png\">
</blockquote>

</html>"));
      end DoublePendulumInitTip;

      model ForceAndTorque "Demonstrate usage of ForceAndTorque element"
        extends Modelica_Icons.Example;
        inner World world(animateGravity=false) annotation (Placement(transformation(
                extent={{-90,30},{-70,50}}, rotation=0)));
        Parts.BodyCylinder body(r={1,0,0}) annotation (Placement(transformation(
                extent={{0,30},{20,50}}, rotation=0)));
        Parts.Fixed fixed1(r={0,-0.5,0}, width=0.03)
          annotation (Placement(transformation(extent={{-90,-10},{-70,10}}, rotation=
                  0)));
        Parts.FixedRotation fixedRotation(n={0,0,1}, angle=30)
          annotation (Placement(transformation(extent={{-8,-30},{12,-10}}, rotation=0)));
        Forces.ForceAndTorque forceAndTorque(Nm_to_m=120, N_to_m=1200,
          resolveInFrame=Types.ResolveInFrameAB.frame_resolve)
          annotation (Placement(transformation(extent={{60,50},{40,30}}, rotation=0)));
        Joints.Revolute revolute2(n={0,1,0},
          phi(fixed=true),
          w(fixed=true))        annotation (Placement(transformation(
              origin={-20,20},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        Modelica_Blocks.Sources.Constant torque[3](k={-100,100,0})
          annotation (Placement(transformation(
              origin={40,-10},
              extent={{10,-10},{-10,10}},
              rotation=270)));
        Joints.Revolute revolute1(phi(fixed=true), w(fixed=true))
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}}, rotation=
                  0)));
        Parts.Fixed fixed2(width=0.03, r={1.5,0.25,0})
          annotation (Placement(transformation(extent={{100,30},{80,50}}, rotation=0)));
        Modelica_Blocks.Sources.Constant force[3](k={0,1000,0})
          annotation (Placement(transformation(
              origin={80,-10},
              extent={{10,-10},{-10,10}},
              rotation=270)));
      equation
        connect(revolute2.frame_b, body.frame_a) annotation (Line(
            points={{-20,30},{-20,40},{0,40}},
            color={95,95,95},
            thickness=0.5));
        connect(forceAndTorque.frame_b, body.frame_b)
          annotation (Line(
            points={{40,40},{20,40}},
            color={95,95,95},
            thickness=0.5));
        connect(fixed1.frame_b, revolute1.frame_a)
          annotation (Line(
            points={{-70,0},{-60,0}},
            color={95,95,95},
            thickness=0.5));
        connect(revolute1.frame_b, revolute2.frame_a)
          annotation (Line(
            points={{-40,0},{-20,0},{-20,10}},
            color={95,95,95},
            thickness=0.5));
        connect(fixed2.frame_b, forceAndTorque.frame_a)
          annotation (Line(
            points={{80,40},{60,40}},
            color={95,95,95},
            thickness=0.5));
        connect(fixedRotation.frame_a, fixed1.frame_b) annotation (Line(
            points={{-8,-20},{-65,-20},{-65,0},{-70,0}},
            color={95,95,95},
            thickness=0.5));
        connect(forceAndTorque.frame_resolve, fixedRotation.frame_b) annotation (Line(
            points={{42,30},{42,30},{20,30},{20,-20},{12,-20}},
            color={95,95,95},
            pattern=LinePattern.Dot));
        connect(force.y, forceAndTorque.force) annotation (Line(
            points={{80,1},{80,10},{58,10},{58,28}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(torque.y, forceAndTorque.torque) annotation (Line(
            points={{40,1},{40,10},{50,10},{50,28}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (
          Documentation(info="<HTML>
<p>
In this example the usage of the general force element
\"<a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.ForceAndTorque\">ForceAndTorque</a>\"
is shown. A \"ForceAndTorque\" element is connected
between a body and a fixed point in the world system. The force and torque
is defined by the \"Constant\" block. The two vectors are resolved in the
coordinate system defined by the \"fixedRotation\" component that is
fixed in the world system:
</p>
<p>
The animation view at time = 0 is shown in the figure below.
The yellow line is directed from frame_a to frame_b of the
forceAndTorque component. The green arrow characterizes the
force acting at the body whereas the green double arrow characterizes
the torque acting at the body. The lengths of the two vectors
are proportional to the lengths of the force and torque vectors
(constant scaling factors are defined as parameters in the
forceAndTorque component):
</p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/ForceAndTorque.png\">
</html>"),       experiment(StopTime=1.01));
      end ForceAndTorque;

      model FreeBody "Free flying body attached by two springs to environment"
        extends Modelica_Icons.Example;
        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        inner Modelica_Mechanics_MultiBody.World world annotation (Placement(
              transformation(extent={{-60,20},{-40,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation bar2(r={0.8,0,0},
            animation=false) annotation (Placement(transformation(extent={{0,20},
                  {20,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Forces.Spring spring1(
          width=0.1,
          coilWidth=0.005,
          numberOfWindings=5,
          c=20,
          s_unstretched=0) annotation (Placement(transformation(
              origin={-20,6},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Parts.BodyShape body(
          m=1,
          I_11=1,
          I_22=1,
          I_33=1,
          r={0.4,0,0},
          r_CM={0.2,0,0},
          width=0.05,
          r_0(start={0.2,-0.5,0.1}, each fixed=true),
          v_0(each fixed=true),
          angles_fixed=true,
          w_0_fixed=true,
          angles_start={0.174532925199433,0.174532925199433,0.174532925199433})
          annotation (Placement(transformation(extent={{0,-40},{20,-20}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Forces.Spring spring2(
          c=20,
          s_unstretched=0,
          width=0.1,
          coilWidth=0.005,
          numberOfWindings=5) annotation (Placement(transformation(
              origin={40,6},
              extent={{-10,-10},{10,10}},
              rotation=270)));
      equation
        connect(bar2.frame_a, world.frame_b)
          annotation (Line(
            points={{0,30},{-40,30}},
            color={95,95,95},
            thickness=0.5));
        connect(spring1.frame_b, body.frame_a) annotation (Line(
            points={{-20,-4},{-20,-30},{0,-30}},
            color={95,95,95},
            thickness=0.5));
        connect(bar2.frame_b, spring2.frame_a)
          annotation (Line(
            points={{20,30},{40,30},{40,16}},
            color={95,95,95},
            thickness=0.5));
        connect(spring1.frame_a, world.frame_b) annotation (Line(
            points={{-20,16},{-20,30},{-40,30}},
            color={95,95,95},
            thickness=0.5));
        connect(body.frame_b, spring2.frame_b) annotation (Line(
            points={{20,-30},{40,-30},{40,-4}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (
          experiment(StopTime=10),
          Documentation(info="<html>
<p>
This example demonstrates:
</p>
<ul>
<li>The animation of spring and damper components</li>
<li>A body can be freely moving without any connection to a joint.
    In this case body coordinates are used automatically as
    states (whenever joints are present, it is first tried to
    use the generalized coordinates of the joints as states).</li>
<li>If a body is freely moving, the initial position and velocity of the body
    can be defined with the \"Initialization\" menu as shown with the
    body \"body1\" in the left part (click on \"Initialization\").</li>
</ul>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/FreeBody.png\"
ALT=\"model Examples.Elementary.FreeBody\">
</html>"));
      end FreeBody;

      model InitSpringConstant
        "Determine spring constant such that system is in steady state at given position"

        extends Modelica_Icons.Example;
        inner Modelica_Mechanics_MultiBody.World world(gravityType=Types.GravityTypes.UniformGravity)
          annotation (Placement(transformation(extent={{-80,0},{-60,20}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute rev(
          useAxisFlange=true,
          n={0,0,1},
          phi(fixed=true),
          w(fixed=true),
          a(fixed=true)) annotation (Placement(transformation(extent={{-40,0},{
                  -20,20}}, rotation=0)));
        Modelica_Mechanics_Rotational.Components.Damper damper(d=0.1) annotation (
            Placement(transformation(extent={{-40,40},{-20,60}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.BodyShape body(
          r={1,0,0},
          r_CM={0.5,0,0},
          m=1) annotation (Placement(transformation(extent={{0,0},{20,20}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.Fixed fixed(r={1,0.2,0}, width=0.02)
          annotation (Placement(transformation(
              origin={50,70},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Forces.Spring spring(s_unstretched=0.1, c(
              fixed=false, start=100)) annotation (Placement(transformation(
              origin={50,30},
              extent={{-10,-10},{10,10}},
              rotation=270)));

      equation
        connect(world.frame_b, rev.frame_a) annotation (Line(
            points={{-60,10},{-40,10}},
            color={95,95,95},
            thickness=0.5));
        connect(damper.flange_b, rev.axis) annotation (Line(points={{-20,50},{-16,50},
                {-16,26},{-30,26},{-30,20}}, color={0,0,0}));
        connect(rev.support, damper.flange_a) annotation (Line(points={{-36,20},{-36,
                26},{-48,26},{-48,50},{-40,50}}, color={0,0,0}));
        connect(rev.frame_b, body.frame_a) annotation (Line(
            points={{-20,10},{0,10}},
            color={95,95,95},
            thickness=0.5));
        connect(fixed.frame_b, spring.frame_a) annotation (Line(
            points={{50,60},{50,40}},
            color={95,95,95},
            thickness=0.5));
        connect(body.frame_b, spring.frame_b) annotation (Line(
            points={{20,10},{50,10},{50,20}},
            color={95,95,95},
            thickness=0.5));
        annotation (Documentation(info="<html>
<p>
This example demonstrates a non-standard type of initialization
by calculating a spring constant such
that a simple pendulum is at a defined position in steady state.
</p>
<p>
The goal is that the pendulum should be in steady state
when the rotation angle of the pendulum is zero. The spring
constant of the spring shall be calculated during initialization
such that this goal is reached.
</p>
<p>
The pendulum has one degree of freedom, i.e., two states.
Therefore, two additional equations have to be provided
for initialization. However, parameter \"c\" of the spring
component is defined with attribute \"fixed = <b>false</b>\", i.e.,
the value of this parameter is computed during initialization.
Therefore, there is one additional equation required during
initialization. The 3 initial equations are the rotational
angle of the revolute joint and its first and second
derivative. The latter ones are zero, in order to initialize
in steady state. By setting the start values of phi, w, a to zero and
their fixed attributes to true, the required
3 initial equations are defined.
</p>
<p>
After translation, this model is initialized in steady-state.
The spring constant is computed as c = 49.05 N/m.
An animation of this simulation is shown in the figure below.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/InitSpringConstant.png\"
ALT=\"model Examples.Elementary.InitSpringConstant\">
</html>"),       experiment(StopTime=1.01));
      end InitSpringConstant;

      model LineForceWithTwoMasses
        "Demonstrate line force with two point masses using a JointUPS and alternatively a LineForceWithTwoMasses component"
        extends Modelica_Icons.Example;
        parameter Modelica_SIunits.Mass m=1 "Mass of point masses";
        Modelica_SIunits.Force rod_f_diff[3]=rod1.frame_b.f - rod3.frame_b.f
          "Difference of cut-forces in rod1 and rod3";
        Modelica_SIunits.Force body_f_diff[3]=bodyBox1.frame_b.f - bodyBox2.frame_b.f
          "Difference of cut-forces in bodyBox1 and bodyBox2";

        inner Modelica_Mechanics_MultiBody.World world annotation (Placement(
              transformation(extent={{-80,60},{-60,80}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute revolute1(phi(fixed=true),
            w(fixed=true)) annotation (Placement(transformation(extent={{-20,60},
                  {0,80}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.BodyBox bodyBox1(r={0.7,0,0})
          annotation (Placement(transformation(extent={{20,60},{40,80}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation rod1(
          r={0,-0.9,0},
          width=0.01,
          animation=false) annotation (Placement(transformation(
              origin={-40,54},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Joints.Assemblies.JointUPS jointUPS(nAxis_ia=
              {0.7,1.2,0}, animation=true) annotation (Placement(transformation(
                extent={{0,50},{20,30}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.Body body1(
          r_CM=0.2*jointUPS.eAxis_ia,
          cylinderDiameter=0.05,
          animation=true,
          m=m,
          I_11=0,
          I_22=0,
          I_33=0) annotation (Placement(transformation(extent={{-14,14},{-34,34}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.Body body2(
          r_CM=-0.2*jointUPS.eAxis_ia,
          cylinderDiameter=0.05,
          animation=true,
          m=m,
          I_11=0,
          I_22=0,
          I_33=0) annotation (Placement(transformation(extent={{32,14},{52,34}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation rod2(
          r={0,0.3,0},
          width=0.01,
          animation=false) annotation (Placement(transformation(
              origin={-40,84},
              extent={{10,-10},{-10,10}},
              rotation=270)));
        Modelica_Mechanics_Translational.Components.Damper damper1(
                                                        d=3)
          annotation (Placement(transformation(extent={{0,24},{20,4}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute revolute2(phi(fixed=true),
            w(fixed=true)) annotation (Placement(transformation(extent={{-20,-40},
                  {0,-20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.BodyBox bodyBox2(r={0.7,0,0})
          annotation (Placement(transformation(extent={{20,-40},{40,-20}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation rod3(
          width=0.01,
          r={0,-0.9,0.3},
          animation=false) annotation (Placement(transformation(
              origin={-40,-46},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation rod4(
          width=0.01,
          r={0,0.3,0.3},
          animation=false) annotation (Placement(transformation(
              origin={-40,-16},
              extent={{10,-10},{-10,10}},
              rotation=270)));
        Modelica_Mechanics_Translational.Components.Damper damper2(
                                                        d=3)
          annotation (Placement(transformation(extent={{0,-76},{20,-96}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Forces.LineForceWithTwoMasses lineForceWithTwoMasses(
          L_a=0.2,
          L_b=0.2,
          cylinderLength_a=0.2,
          cylinderLength_b=1.2,
          massDiameterFaction=2.2,
          m_a=m,
          m_b=m) annotation (Placement(transformation(extent={{0,-50},{20,-70}},
                rotation=0)));
      equation
        connect(jointUPS.bearing, damper1.flange_a)
          annotation (Line(points={{6,30},{6,20},{0,20},{0,14}}, color={0,191,0}));
        connect(jointUPS.axis, damper1.flange_b)
          annotation (Line(points={{14,30},{14,20},{20,20},{20,14}}, color={0,191,0}));
        connect(jointUPS.frame_ib, body2.frame_a)
          annotation (Line(
            points={{18,30},{18,24},{32,24}},
            color={95,95,95},
            thickness=0.5));
        connect(world.frame_b, rod2.frame_a) annotation (Line(
            points={{-60,70},{-40,70},{-40,74}},
            color={95,95,95},
            thickness=0.5));
        connect(world.frame_b, rod1.frame_a) annotation (Line(
            points={{-60,70},{-40,70},{-40,64}},
            color={95,95,95},
            thickness=0.5));
        connect(rod2.frame_b, revolute1.frame_a) annotation (Line(
            points={{-40,94},{-40,98},{-28,98},{-28,70},{-20,70}},
            color={95,95,95},
            thickness=0.5));
        connect(revolute1.frame_b, bodyBox1.frame_a)
          annotation (Line(
            points={{0,70},{20,70}},
            color={95,95,95},
            thickness=0.5));
        connect(bodyBox1.frame_b, jointUPS.frame_b) annotation (Line(
            points={{40,70},{46,70},{46,40},{20,40}},
            color={95,95,95},
            thickness=0.5));
        connect(body1.frame_a, jointUPS.frame_ia)
          annotation (Line(
            points={{-14,24},{2,24},{2,30}},
            color={95,95,95},
            thickness=0.5));
        connect(rod1.frame_b, jointUPS.frame_a) annotation (Line(
            points={{-40,44},{-40,40},{0,40}},
            color={95,95,95},
            thickness=0.5));
        connect(rod4.frame_b, revolute2.frame_a) annotation (Line(
            points={{-40,-6},{-40,-2},{-28,-2},{-28,-30},{-20,-30}},
            color={95,95,95},
            thickness=0.5));
        connect(revolute2.frame_b, bodyBox2.frame_a)
          annotation (Line(
            points={{0,-30},{20,-30}},
            color={95,95,95},
            thickness=0.5));
        connect(world.frame_b, rod4.frame_a) annotation (Line(
            points={{-60,70},{-52,70},{-52,-32},{-40,-32},{-40,-26}},
            color={95,95,95},
            thickness=0.5));
        connect(rod3.frame_a, rod4.frame_a)
          annotation (Line(
            points={{-40,-36},{-40,-26}},
            color={0,0,0},
            thickness=0.5));
        connect(lineForceWithTwoMasses.frame_a, rod3.frame_b) annotation (Line(
            points={{0,-60},{-40,-60},{-40,-56}},
            color={95,95,95},
            thickness=0.5));
        connect(lineForceWithTwoMasses.frame_b, bodyBox2.frame_b) annotation (Line(
            points={{20,-60},{54,-60},{54,-30},{40,-30}},
            color={95,95,95},
            thickness=0.5));
        connect(lineForceWithTwoMasses.flange_b, damper2.flange_b)
          annotation (Line(points={{16,-71},{20,-71},{20,-86}}, color={0,191,0}));
        connect(lineForceWithTwoMasses.flange_a, damper2.flange_a)
          annotation (Line(points={{4,-71},{0,-71},{0,-86}}, color={0,191,0}));
        annotation (
          experiment(StopTime=3),
          Documentation(info="<html>
<p>
It is demonstrated how to implement line force components
that shall have mass properties. Two alternative implementations
are given:
</p>
<ul>
<li> With <a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUPS\">JointUPS</a>:<br>
     Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUPS is an aggregation
     of a universal, a prismatic and a spherical joint that approximates
     a real force component, such as a hydraulic cylinder. At the two
     frames of the prismatic joint (frame_ia, frame_ib of jointUPS)
     two bodies are attached. The parameters are selected such that
     the center of masses of the two bodies are located on the line
     connecting frame_a and frame_b of the jointUPS component.
     Both bodies have the same mass and the inertia tensor is set to zero,
     i.e., the two bodies are treated as point masses.</li>
<li> With <a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.LineForceWithTwoMasses\">LineForceWithTwoMasses</a>:<br>
     Modelica.Mechanics.MultiBody.Forces.LineForceWithTwoMasses is a line force component
     with the built-in property that two point masses are located
     on the line on which the line force is acting.
     The parameters are selected in such a way that the same
     system as with the jointUPS component is described.</li>
</ul>
<p>
In both cases, a linear 1-dimensional translational damper from the
Modelica.Mechanics.Translational library is used as
line force between the two attachment points. Simulate
this system and plot the differences of the cut forces at both sides
of the line force component (\"rod_f_diff\" and \"body_f_diff\").
Both vectors should be zero
(depending on the chosen relative tolerance of the integration,
the difference is in the order of 1.e-10 ... 1.e-15).
</p>
<p>
Note, that the implementation with the LineForceWithTwoMasses
component is simpler and more convenient.
An animation of this simulation is shown in the figure below.
The system on the left side in the front is the animation with
the LineForceWithTwoMasses component whereas the system on the right
side in the back is the animation with the JointUPS component.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/LineForceWithTwoMasses2.png\">

</html>"));
      end LineForceWithTwoMasses;

      model Pendulum "Simple pendulum with one revolute joint and one body"
        extends Modelica_Icons.Example;
        inner Modelica_Mechanics_MultiBody.World world(gravityType=Types.GravityTypes.UniformGravity)
          annotation (Placement(transformation(extent={{-60,0},{-40,20}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute rev(
          n={0,0,1},
          useAxisFlange=true,
          phi(fixed=true),
          w(fixed=true)) annotation (Placement(transformation(extent={{-20,0},{
                  0,20}}, rotation=0)));
        Modelica_Mechanics_Rotational.Components.Damper damper(
                                                    d=0.1)
          annotation (Placement(transformation(extent={{-20,40},{0,60}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.Body body(m=1.0, r_CM={0.5,0,0})
          annotation (Placement(transformation(extent={{20,0},{40,20}},
                rotation=0)));
      equation
        connect(world.frame_b, rev.frame_a)
          annotation (Line(
            points={{-40,10},{-20,10}},
            color={95,95,95},
            thickness=0.5));
        connect(damper.flange_b, rev.axis) annotation (Line(points={{0,50},{4,50},{4,
                26},{-10,26},{-10,20}}, color={0,0,0}));
        connect(rev.support, damper.flange_a) annotation (Line(points={{-16,20},{-16,
                26},{-28,26},{-28,50},{-20,50}}, color={0,0,0}));
        connect(body.frame_a, rev.frame_b) annotation (Line(
            points={{20,10},{0,10}},
            color={95,95,95},
            thickness=0.5));
        annotation (
          experiment(StopTime=5),
          Documentation(info="<html>
<p>
This simple model demonstrates that by just dragging components
default animation is defined that shows the structure of the
assembled system.

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/Pendulum.png\"
ALT=\"model Examples.Elementary.Pendulum\">
</html>"));
      end Pendulum;

      model PendulumWithSpringDamper "Simple spring/damper/mass system"
        extends Modelica_Icons.Example;
        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        inner Modelica_Mechanics_MultiBody.World world(axisLength=0.6)
          annotation (Placement(transformation(extent={{-80,20},{-60,40}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.Body body1(
          m=1,
          animation=animation,
          I_11=1,
          I_22=1,
          I_33=1,
          r_CM={0,0,0},
          cylinderDiameter=0.05,
          sphereDiameter=0.2) annotation (Placement(transformation(
              origin={72,30},
              extent={{10,-10},{-10,10}},
              rotation=180)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation bar1(animation=
              animation, r={0.3,0,0}) annotation (Placement(transformation(
                extent={{-46,20},{-26,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Forces.Spring spring1(
          coilWidth=0.01,
          numberOfWindings=5,
          c=20,
          s_unstretched=0.2) annotation (Placement(transformation(extent={{0,-46},
                  {20,-26}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Forces.Damper damper1(
          d=1,
          length_a=0.1,
          diameter_a=0.08,
          animation=false) annotation (Placement(transformation(extent={{0,-20},
                  {20,0}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute revolute(phi(fixed=true),
            w(fixed=true)) annotation (Placement(transformation(extent={{-12,20},
                  {8,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Prismatic prismatic(
          boxWidth=0.04,
          boxColor={255,65,65},
          s(fixed=true, start=0.5),
          v(fixed=true)) annotation (Placement(transformation(extent={{20,20},{
                  40,40}}, rotation=0)));
      equation
        connect(world.frame_b, bar1.frame_a)
          annotation (Line(
            points={{-60,30},{-46,30}},
            color={95,95,95},
            thickness=0.5));
        connect(revolute.frame_a, bar1.frame_b)
          annotation (Line(
            points={{-12,30},{-26,30}},
            color={95,95,95},
            thickness=0.5));
        connect(prismatic.frame_a, revolute.frame_b)
          annotation (Line(
            points={{20,30},{8,30}},
            color={95,95,95},
            thickness=0.5));
        connect(damper1.frame_a, bar1.frame_b) annotation (Line(
            points={{0,-10},{-18,-10},{-18,30},{-26,30}},
            color={95,95,95},
            thickness=0.5));
        connect(damper1.frame_b, prismatic.frame_b) annotation (Line(
            points={{20,-10},{44,-10},{44,30},{40,30}},
            color={95,95,95},
            thickness=0.5));
        connect(spring1.frame_a, bar1.frame_b) annotation (Line(
            points={{0,-36},{-18,-36},{-18,30},{-26,30}},
            color={95,95,95},
            thickness=0.5));
        connect(spring1.frame_b, prismatic.frame_b) annotation (Line(
            points={{20,-36},{44,-36},{44,30},{40,30}},
            color={95,95,95},
            thickness=0.5));
        connect(body1.frame_a, prismatic.frame_b)
          annotation (Line(
            points={{62,30},{40,30}},
            color={95,95,95},
            thickness=0.5));
        annotation (
          experiment(StopTime=10),
          Documentation(info="<html>
<p>
A body is attached on a revolute and prismatic joint.
A 3-dim. spring and a 3-dim. damper are connected between the body
and a point fixed in the world frame:
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/PendulumWithSpringDamper.png\"
ALT=\"model Examples.Elementary.PendulumWithSpringDamper\">
</html>"));
      end PendulumWithSpringDamper;

      model PointGravity "Two point masses in a point gravity field"
        extends Modelica_Icons.Example;
        inner Modelica_Mechanics_MultiBody.World world(
          mue=1,
          gravitySphereDiameter=0.1,
          gravityType=Types.GravityTypes.PointGravity) annotation (Placement(
              transformation(extent={{-20,-20},{0,0}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.Body body1(
          m=1,
          sphereDiameter=0.1,
          I_11=0.1,
          I_22=0.1,
          I_33=0.1,
          r_0(start={0,0.6,0}, each fixed=true),
          v_0(start={1,0,0}, each fixed=true),
          angles_fixed=true,
          w_0_fixed=true,
          r_CM={0,0,0}) annotation (Placement(transformation(extent={{-20,20},{
                  0,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.Body body2(
          m=1,
          sphereDiameter=0.1,
          I_11=0.1,
          I_22=0.1,
          I_33=0.1,
          r_0(start={0.6,0.6,0}, each fixed=true),
          v_0(start={0.6,0,0}, each fixed=true),
          angles_fixed=true,
          w_0_fixed=true,
          r_CM={0,0,0}) annotation (Placement(transformation(extent={{20,20},{
                  40,40}}, rotation=0)));
        annotation (
          experiment(StopTime=5),
          Documentation(info="<HTML>
<p>
This model demonstrates a point gravity field. Two bodies
are placed in the gravity field. The initial positions and velocities of
these bodies are selected such that one body rotates on a circle and
the other body rotates on an ellipse around the center of the
point gravity field.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/PointGravity.png\"
ALT=\"model Examples.Elementary.PointGravity\">
</HTML>"));
      end PointGravity;

      model PointGravityWithPointMasses
        "Two point masses in a point gravity field (rotation of bodies is neglected)"
        extends Modelica_Icons.Example;
        inner Modelica_Mechanics_MultiBody.World world(
          mue=1,
          gravitySphereDiameter=0.1,
          gravityType=Types.GravityTypes.PointGravity) annotation (Placement(
              transformation(extent={{-80,-20},{-60,0}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.PointMass body1(
          m=1,
          sphereDiameter=0.1,
          r_0(start={0,0.6,0}, each fixed=true),
          v_0(start={1,0,0}, each fixed=true)) annotation (Placement(
              transformation(extent={{-20,20},{0,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.PointMass body2(
          m=1,
          sphereDiameter=0.1,
          r_0(start={0.6,0.6,0}, each fixed=true),
          v_0(start={0.6,0,0}, each fixed=true)) annotation (Placement(
              transformation(extent={{20,20},{40,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.PointMass body3(
          m=1,
          sphereDiameter=0.1,
          r_0(start={0,0.8,0}, each fixed=true),
          v_0(start={0.6,0,0}, each fixed=true)) annotation (Placement(
              transformation(extent={{-20,60},{0,80}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.PointMass body4(
          m=1,
          sphereDiameter=0.1,
          r_0(start={0.3,0.8,0}, each fixed=true),
          v_0(start={0.6,0,0}, each fixed=true)) annotation (Placement(
              transformation(extent={{20,60},{40,80}}, rotation=0)));
        Forces.Spring spring(showMass=false, c=10,
          fixedRotationAtFrame_b=true,
          fixedRotationAtFrame_a=true)             annotation (Placement(
              transformation(extent={{0,60},{20,80}}, rotation=0)));
      equation

        connect(spring.frame_a, body3.frame_a) annotation (Line(
            points={{0,70},{-10,70}},
            color={95,95,95},
            thickness=0.5));
        connect(spring.frame_b, body4.frame_a) annotation (Line(
            points={{20,70},{30,70}},
            color={95,95,95},
            thickness=0.5));
        annotation (
          experiment(StopTime=2),
          Documentation(info="<HTML>
<p>
This model demonstrates the usage of model Parts.PointMass in a
point gravity field. The PointMass model has the feature that
that rotation is not taken into account and can therefore also not be
calculated. This example demonstrates two cases where this does not matter:
If a PointMass is not connected (body1, body2), the orientation object in
these point masses is set to a unit rotation.
If a PointMass is connected by a line force element, such as
the used Forces.LineForceWithMass component, then the orientation object
is set to a unit rotation within the line force element.
These are the two cases where the rotation is automatically set to
a default value, when the physical system does not provide the equations.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/PointGravityWithPointMasses.png\">
</HTML>"));
      end PointGravityWithPointMasses;

      model PointGravityWithPointMasses2
        "Rigidly connected point masses in a point gravity field"
        extends Modelica_Icons.Example;
        model PointMass = Modelica_Mechanics_MultiBody.Parts.PointMass (m=1,
              sphereColor={255,0,0})
          "Point mass used at all places of this example";

        PointMass pointMass1(r_0(start={3,0,0}, each fixed=true), v_0(start={0,0,-1},
              each fixed=true))   annotation (Placement(transformation(extent={{60,-10},{
                  80,10}}, rotation=0)));

        PointMass pointMass2 annotation (Placement(transformation(extent={{-60,-10},{
                  -40,10}}, rotation=0)));
        PointMass pointMass3(r_0(start={2,1,0}, each fixed=true), v_0(start={0,0,-1},
              each fixed=true))   annotation (Placement(transformation(extent={{60,20},{80,
                  40}}, rotation=0)));
        PointMass pointMass4 annotation (Placement(transformation(extent={{-50,-40},{
                  -30,-20}}, rotation=0)));
        PointMass pointMass5 annotation (Placement(transformation(extent={{0,80},{20,
                  100}}, rotation=0)));
        PointMass pointMass6 annotation (Placement(transformation(extent={{0,-100},{
                  20,-80}}, rotation=0)));

        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation(r={1,0,0})
          annotation (Placement(transformation(extent={{20,-10},{40,10}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation1(r={-1,0,0})
          annotation (Placement(transformation(extent={{0,-10},{-20,10}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation2(r={0,1,0})
          annotation (Placement(transformation(extent={{20,20},{40,40}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation3(r={0,-1,0})
          annotation (Placement(transformation(extent={{0,-40},{-20,-20}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation4(r={0,0,1})
          annotation (Placement(transformation(
              origin={10,60},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation5(r={0,0,-1})
          annotation (Placement(transformation(
              origin={10,-60},
              extent={{10,-10},{-10,10}},
              rotation=90)));

        inner World world(
          gravitySphereDiameter=0.1,
          gravityType=Types.GravityTypes.PointGravity,
          mue=5)
          annotation (Placement(transformation(extent={{-80,60},{-60,80}}, rotation=0)));
        Joints.FreeMotion freeMotion annotation (Placement(transformation(extent={{
                  -40,60},{-20,80}}, rotation=0)));

      model SystemWithStandardBodies
          "For comparison purposes, an equivalent model with Bodies instead of PointMasses"
        model PointMass = Modelica_Mechanics_MultiBody.Parts.Body (
              m=1,
              I_11=0,
              I_22=0,
              I_33=0)
            "Body used all places of the comparison model with zero inertia tensor";

        PointMass pointMass1(
            r_0(start={3,0,0}, each fixed=true),
            v_0(start={0,0,-1}, each fixed=true),
            angles_fixed=true,
            w_0_fixed=true,
            r_CM={0,0,0})    annotation (Placement(transformation(extent={{40,-20},{
                    60,0}}, rotation=0)));
        PointMass pointMass2(r_CM={0,0,0})
                             annotation (Placement(transformation(extent={{-60,-20},{
                    -80,0}}, rotation=0)));
        PointMass pointMass3(r_CM={0,0,0})
                             annotation (Placement(transformation(extent={{40,10},{60,
                    30}}, rotation=0)));
        PointMass pointMass4(r_CM={0,0,0})
                             annotation (Placement(transformation(extent={{-50,-50},{
                    -70,-30}}, rotation=0)));
        PointMass pointMass5(r_CM={0,0,0})
                             annotation (Placement(transformation(extent={{0,60},{20,
                    80}}, rotation=0)));
        PointMass pointMass6(r_CM={0,0,0})
                             annotation (Placement(transformation(extent={{2,-102},{
                    22,-82}}, rotation=0)));

        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation(r={1,0,0})
            annotation (Placement(transformation(extent={{0,-20},{20,0}},
                  rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation1(r={-1,0,0})
            annotation (Placement(transformation(extent={{-20,-20},{-40,0}},
                  rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation2(r={0,1,0})
            annotation (Placement(transformation(extent={{0,10},{20,30}},
                  rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation3(r={0,-1,0})
            annotation (Placement(transformation(extent={{-20,-50},{-40,-30}},
                  rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation4(r={0,0,1})
            annotation (Placement(transformation(
                origin={-10,50},
                extent={{-10,-10},{10,10}},
                rotation=90)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation5(r={0,0,-1})
            annotation (Placement(transformation(
                origin={-10,-70},
                extent={{10,-10},{-10,10}},
                rotation=90)));

      equation
        connect(fixedTranslation1.frame_a, fixedTranslation.frame_a)
                                                               annotation (Line(
              points={{-20,-10},{0,-10}},
              color={95,95,95},
              thickness=0.5));
        connect(fixedTranslation1.frame_a, fixedTranslation2.frame_a)
                                                                annotation (Line(
              points={{-20,-10},{-10,-10},{-10,20},{0,20}},
              color={95,95,95},
              thickness=0.5));
        connect(fixedTranslation3.frame_a, fixedTranslation.frame_a)
                                                               annotation (Line(
              points={{-20,-40},{-10,-40},{-10,-10},{0,-10}},
              color={95,95,95},
              thickness=0.5));
        connect(fixedTranslation1.frame_a, fixedTranslation4.frame_a)
                                                                annotation (Line(
              points={{-20,-10},{-10,-10},{-10,40}},
              color={95,95,95},
              thickness=0.5));
        connect(fixedTranslation5.frame_a, fixedTranslation.frame_a)
                                                               annotation (Line(
              points={{-10,-60},{-10,-10},{0,-10}},
              color={95,95,95},
              thickness=0.5));
        connect(fixedTranslation2.frame_b, pointMass3.frame_a)
                                                            annotation (Line(
              points={{20,20},{40,20}},
              color={95,95,95},
              thickness=0.5));
        connect(fixedTranslation3.frame_b, pointMass4.frame_a)
                                                            annotation (Line(
              points={{-40,-40},{-50,-40}},
              color={95,95,95},
              thickness=0.5));
        connect(pointMass5.frame_a, fixedTranslation4.frame_b)
                                                            annotation (Line(
              points={{0,70},{-10,70},{-10,60}},
              color={95,95,95},
              thickness=0.5));
        connect(fixedTranslation5.frame_b, pointMass6.frame_a)
                                                            annotation (Line(
              points={{-10,-80},{-10,-92},{2,-92}},
              color={95,95,95},
              thickness=0.5));
        connect(fixedTranslation.frame_b, pointMass1.frame_a)
                                                           annotation (Line(
              points={{20,-10},{40,-10}},
              color={95,95,95},
              thickness=0.5));
        connect(fixedTranslation1.frame_b, pointMass2.frame_a)
                                                            annotation (Line(
              points={{-40,-10},{-60,-10}},
              color={95,95,95},
              thickness=0.5));
        annotation (                       Documentation(info="<html>
<p>
In order to compare the results of the \"PointMass\" example where
6 point masses are rigidly connected together, in this comparison model,
an equivalent system is setup, with the only difference that the
point masses are replaced by Bodies with zero inertia.
</p>
</html>"));
      end SystemWithStandardBodies;

        SystemWithStandardBodies referenceSystem annotation (Placement(transformation(
                extent={{60,-60},{80,-40}}, rotation=0)));
      equation
        connect(fixedTranslation1.frame_a, fixedTranslation.frame_a)
                                                               annotation (Line(
            points={{0,0},{20,0}},
            color={95,95,95},
            thickness=0.5));
        connect(fixedTranslation1.frame_a, fixedTranslation2.frame_a)
                                                                annotation (Line(
            points={{0,0},{10,0},{10,30},{20,30}},
            color={95,95,95},
            thickness=0.5));
        connect(fixedTranslation3.frame_a, fixedTranslation.frame_a)
                                                               annotation (Line(
            points={{0,-30},{10,-30},{10,0},{20,0}},
            color={95,95,95},
            thickness=0.5));
        connect(fixedTranslation1.frame_a, fixedTranslation4.frame_a)
                                                                annotation (Line(
            points={{0,0},{10,0},{10,50}},
            color={95,95,95},
            thickness=0.5));
        connect(fixedTranslation5.frame_a, fixedTranslation.frame_a)
                                                               annotation (Line(
            points={{10,-50},{10,0},{20,0}},
            color={95,95,95},
            thickness=0.5));
        connect(fixedTranslation2.frame_b, pointMass3.frame_a)
                                                            annotation (Line(
            points={{40,30},{70,30}},
            color={95,95,95},
            thickness=0.5));
        connect(fixedTranslation3.frame_b, pointMass4.frame_a)
                                                            annotation (Line(
            points={{-20,-30},{-40,-30}},
            color={95,95,95},
            thickness=0.5));
        connect(pointMass5.frame_a, fixedTranslation4.frame_b)
                                                            annotation (Line(
            points={{10,90},{10,70}},
            color={95,95,95},
            thickness=0.5));
        connect(fixedTranslation5.frame_b, pointMass6.frame_a)
                                                            annotation (Line(
            points={{10,-70},{10,-90}},
            color={95,95,95},
            thickness=0.5));
        connect(fixedTranslation.frame_b, pointMass1.frame_a)
                                                           annotation (Line(
            points={{40,0},{70,0}},
            color={95,95,95},
            thickness=0.5));
        connect(fixedTranslation1.frame_b, pointMass2.frame_a)
                                                            annotation (Line(
            points={{-20,0},{-50,0}},
            color={95,95,95},
            thickness=0.5));
        connect(world.frame_b, freeMotion.frame_a) annotation (Line(
            points={{-60,70},{-40,70}},
            color={95,95,95},
            thickness=0.5));
        connect(freeMotion.frame_b, fixedTranslation1.frame_a) annotation (Line(
            points={{-20,70},{-10,70},{-10,20},{10,20},{10,0},{0,0}},
            color={95,95,95},
            thickness=0.5));
        annotation (    experiment(StopTime=3.0, Tolerance=1e-006),
          Documentation(info="<html>
<p>
This model demonstrates the usage of model Parts.PointMass in a
point gravity field. 6 point masses are connected rigidly together.
Translating such a model results in an error, because point masses do
not define an orientation object. The example demonstrates that in such
a case (when the orientation object is not defined by an object that
is connected to a point mass), a \"MultiBody.Joints.FreeMotion\" joint
has to be used, to define the the degrees of freedom of this structure.
</p>

<p>
In order to demonstrate that this approach is correct, in model
\"referenceSystem\", the same system is again provided, but this time
modeled with a generic body (Parts.Body) where the inertia tensor is
set to zero. In this case, no FreeMotion object is needed because every
body provides its absolute translational and rotational position and
velocity as potential states.
</p>

<p>
The two systems should move exactly in the same way. The system with the PointMasses
object visualizes the point masses in \"red\", whereas the \"referenceSystem\" shows
its bodies in \"blue\".

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/PointGravityWithPointMasses2.png\">
</html>"));
      end PointGravityWithPointMasses2;

      model SpringDamperSystem "Simple spring/damper/mass system"
        extends Modelica_Icons.Example;
        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        inner Modelica_Mechanics_MultiBody.World world annotation (Placement(
              transformation(extent={{-80,20},{-60,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.Body body1(
          m=1,
          animation=animation,
          r_CM={0,-0.2,0},
          cylinderDiameter=0.05,
          sphereDiameter=0.15,
          I_11=0.1,
          I_22=0.1,
          I_33=0.1,
          r_0(start={0.3,-0.2,0}, each fixed=true),
          v_0(each fixed=true),
          angles_fixed=true,
          w_0_fixed=true,
          w_0_start(each displayUnit="deg/s") = {0,0,0.03490658503988659})
          annotation (Placement(transformation(
              origin={-20,-50},
              extent={{-10,10},{10,-10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation bar1(animation=
              animation, r={0.3,0,0}) annotation (Placement(transformation(
                extent={{-46,20},{-26,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation bar2(animation=
              animation, r={0.6,0,0}) annotation (Placement(transformation(
                extent={{0,20},{20,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.Body body2(
          m=1,
          animation=animation,
          cylinderDiameter=0.05,
          sphereDiameter=0.15,
          r_CM={0,0,0}) annotation (Placement(transformation(
              origin={50,-50},
              extent={{-10,10},{10,-10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Joints.Prismatic p2(
          useAxisFlange=true,
          n={0,-1,0},
          animation=animation,
          boxWidth=0.05,
          stateSelect=StateSelect.always,
          v(fixed=true),
          s(fixed=true, start=0.1)) annotation (Placement(transformation(
              origin={50,-10},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Forces.Spring spring2(
          c=30,
          s_unstretched=0.1,
          coilWidth=0.01,
          width=0.1) annotation (Placement(transformation(
              origin={82,-10},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Forces.Spring spring1(
          s_unstretched=0.1,
          coilWidth=0.01,
          c=30,
          numberOfWindings=10,
          width=0.1) annotation (Placement(transformation(
              origin={-6,-10},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Forces.Damper damper1(d=2) annotation (
            Placement(transformation(
              origin={-30,-10},
              extent={{-10,-10},{10,10}},
              rotation=270)));
      equation
        connect(world.frame_b, bar1.frame_a)
          annotation (Line(
            points={{-60,30},{-46,30}},
            color={95,95,95},
            thickness=0.5));
        connect(bar1.frame_b, bar2.frame_a)
          annotation (Line(
            points={{-26,30},{0,30}},
            color={95,95,95},
            thickness=0.5));
        connect(bar2.frame_b, p2.frame_a)
          annotation (Line(
            points={{20,30},{50,30},{50,0}},
            color={95,95,95},
            thickness=0.5));
        connect(p2.frame_b, body2.frame_a)
          annotation (Line(
            points={{50,-20},{50,-40}},
            color={95,95,95},
            thickness=0.5));
        connect(bar2.frame_b, spring2.frame_a)
          annotation (Line(
            points={{20,30},{82,30},{82,0}},
            color={95,95,95},
            thickness=0.5));
        connect(body2.frame_a, spring2.frame_b) annotation (Line(
            points={{50,-40},{82,-40},{82,-20}},
            color={95,95,95},
            thickness=0.5));
        connect(damper1.frame_a, bar1.frame_b) annotation (Line(
            points={{-30,0},{-30,10},{-20,10},{-20,30},{-26,30}},
            color={95,95,95},
            thickness=0.5));
        connect(spring1.frame_a, bar1.frame_b) annotation (Line(
            points={{-6,0},{-6,10},{-20,10},{-20,30},{-26,30}},
            color={95,95,95},
            thickness=0.5));
        connect(damper1.frame_b, body1.frame_a) annotation (Line(
            points={{-30,-20},{-30,-28},{-20,-28},{-20,-40}},
            color={95,95,95},
            thickness=0.5));
        connect(spring1.frame_b, body1.frame_a) annotation (Line(
            points={{-6,-20},{-6,-28},{-20,-28},{-20,-40}},
            color={95,95,95},
            thickness=0.5));
        annotation (
          experiment(StopTime=10),
          Documentation(info="<html>
<p>
This example demonstrates:
</p>
<ul>
<li>The animation of spring and damper components</li>
<li>A body can be freely moving without any connection to a joint.
    In this case body coordinates are used automatically as
    states (whenever joints are present, it is first tried to
    use the generalized coordinates of the joints as states).</li>
<li>If a body is freely moving, the initial position and velocity of the body
    can be defined with the \"Initialization\" menu as shown with the
    body \"body1\" in the left part (click on \"Initialization\").</li>
</ul>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/SpringDamperSystem.png\"
ALT=\"model Examples.Elementary.SpringDamperSystem\">

</html>"));
      end SpringDamperSystem;

      model SpringMassSystem "Mass attached with a spring to the world frame"
        extends Modelica_Icons.Example;
        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        inner Modelica_Mechanics_MultiBody.World world annotation (Placement(
              transformation(extent={{-80,20},{-60,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Prismatic p1(
          useAxisFlange=true,
          n={0,-1,0},
          animation=animation,
          boxWidth=0.05,
          s(fixed=true, start=0.1),
          v(fixed=true)) annotation (Placement(transformation(
              origin={-20,-10},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica_Mechanics_Translational.Components.Spring spring1(
                                                        c=30, s_rel0=0.1)
          annotation (Placement(transformation(
              origin={10,-10},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Parts.Body body1(
          m=1,
          sphereDiameter=0.2,
          animation=animation,
          r_CM={0,0,0}) annotation (Placement(transformation(
              origin={-20,-50},
              extent={{-10,10},{10,-10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation bar1(animation=
              animation, r={0.3,0,0}) annotation (Placement(transformation(
                extent={{-46,20},{-26,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation bar2(animation=
              animation, r={0.3,0,0}) annotation (Placement(transformation(
                extent={{0,20},{20,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.Body body2(
          m=1,
          sphereDiameter=0.2,
          animation=animation,
          r_CM={0,0,0}) annotation (Placement(transformation(
              origin={50,-50},
              extent={{-10,10},{10,-10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Joints.Prismatic p2(
          useAxisFlange=true,
          n={0,-1,0},
          animation=animation,
          boxWidth=0.05,
          stateSelect=StateSelect.always,
          s(fixed=true, start=0.1),
          v(fixed=true)) annotation (Placement(transformation(
              origin={50,-10},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Forces.Spring spring2(
          c=30,
          s_unstretched=0.1,
          width=0.1) annotation (Placement(transformation(
              origin={90,-10},
              extent={{-10,-10},{10,10}},
              rotation=270)));
      equation
        connect(body1.frame_a, p1.frame_b)
          annotation (Line(
            points={{-20,-40},{-20,-35},{-20,-35},{-20,-30},{-20,-20},{-20,-20}},
            color={95,95,95},
            thickness=0.5));
        connect(world.frame_b, bar1.frame_a)
          annotation (Line(
            points={{-60,30},{-46,30}},
            color={95,95,95},
            thickness=0.5));
        connect(bar1.frame_b, p1.frame_a) annotation (Line(
            points={{-26,30},{-20,30},{-20,0}},
            color={95,95,95},
            thickness=0.5));
        connect(spring1.flange_b, p1.axis) annotation (Line(points={{10,-20},{10,-30},
                {-8,-30},{-8,-18},{-14,-18}}, color={0,191,0}));
        connect(bar1.frame_b, bar2.frame_a)
          annotation (Line(
            points={{-26,30},{0,30}},
            color={95,95,95},
            thickness=0.5));
        connect(bar2.frame_b, p2.frame_a)
          annotation (Line(
            points={{20,30},{50,30},{50,0}},
            color={95,95,95},
            thickness=0.5));
        connect(p2.frame_b, body2.frame_a)
          annotation (Line(
            points={{50,-20},{50,-40}},
            color={95,95,95},
            thickness=0.5));
        connect(bar2.frame_b, spring2.frame_a)
          annotation (Line(
            points={{20,30},{90,30},{90,0}},
            color={95,95,95},
            thickness=0.5));
        connect(body2.frame_a, spring2.frame_b) annotation (Line(
            points={{50,-40},{90,-40},{90,-20}},
            color={95,95,95},
            thickness=0.5));
        connect(spring1.flange_a, p1.support) annotation (Line(
            points={{10,0},{-8,0},{-8,-6},{-14,-6}},
            color={0,127,0},
            smooth=Smooth.None));
        annotation (
          experiment(StopTime=5),
          Documentation(info="<html>
<p>
This example shows the two different ways how force laws
can be utilized:
</p>
<ul>
<li>In the left system a body is attached via a prismatic
    joint to the world frame. The prismatic joint has two
    1-dimensional translational flanges (called \"support\" and \"axis\")
    that allows to connect elements from the Modelica.Mechanics.Translational
    library between the support and the axis connector. The effect is
    that the force generated by the 1-dimensional elements acts as driving
    force in the axis of the prismatic joint. In the example a simple
    spring is used.<br>
    The advantage of this approach is that the many elements from the
    Translational library can be easily used here and that this implementation
    is usually more efficient as when using 3-dimensional springs.</li>
<li>In the right system the same model is defined. The difference is
    that a 3-dimensional spring from the Modelica.Mechanics.MultiBody.Forces library is used.
    This has the advantage to get a nice animation of the force component.</li>
</ul>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/SpringMassSystem.png\"
ALT=\"model Examples.Elementary.SpringMassSystem\">
</html>"));
      end SpringMassSystem;

      model SpringWithMass "Point mass hanging on a spring"
        extends Modelica_Icons.Example;
        inner Modelica_Mechanics_MultiBody.World world(animateGravity=false)
          annotation (Placement(transformation(extent={{-40,40},{-20,60}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Forces.Spring spring(
          s_unstretched=0.2,
          m=0.5,
          c=40,
          width=0.1,
          massDiameter=0.07) annotation (Placement(transformation(
              origin={10,30},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Parts.Body body(
          r_0(start={0,-0.3,0}, each fixed=true),
          v_0(each fixed=true),
          angles_fixed=true,
          w_0_fixed=true,
          r_CM={0,0,0},
          m=1) annotation (Placement(transformation(
              origin={10,-10},
              extent={{-10,-10},{10,10}},
              rotation=270)));
      equation
        connect(world.frame_b, spring.frame_a)
          annotation (Line(
            points={{-20,50},{10,50},{10,40}},
            color={95,95,95},
            thickness=0.5));
        connect(body.frame_a, spring.frame_b)
          annotation (Line(
            points={{10,0},{10,10},{10,20}},
            color={95,95,95},
            thickness=0.5));
        annotation (experiment(StopTime=5), Documentation(info="<html>
<p>
This example shows that a force component may have a mass.
The 3-dimensional spring as used in this example, has an optional
point mass between the two points where the spring is attached.
In the animation, this point mass is represented by a small,
light blue, sphere.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/SpringWithMass.png\"
ALT=\"model Examples.Elementary.SpringWithMass\">
</html>"));
      end SpringWithMass;

      model ThreeSprings "3-dim. springs in series and parallel connection"
        extends Modelica_Icons.Example;
        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        inner Modelica_Mechanics_MultiBody.World world(animateWorld=animation)
          annotation (Placement(transformation(extent={{-60,20},{-40,40}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.Body body1(
          animation=animation,
          r_CM={0,-0.2,0},
          m=0.8,
          I_11=0.1,
          I_22=0.1,
          I_33=0.1,
          sphereDiameter=0.2,
          r_0(start={0.5,-0.3,0}, each fixed=true),
          v_0(each fixed=true),
          angles_fixed=true,
          w_0_fixed=true) annotation (Placement(transformation(
              origin={30,-70},
              extent={{-10,10},{10,-10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation bar1(animation=
              animation, r={0.3,0,0}) annotation (Placement(transformation(
                extent={{-20,20},{0,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Forces.Spring spring1(
          lineForce(r_rel_0(start={-0.2,-0.2,0.2})),
          s_unstretched=0.1,
          width=0.1,
          coilWidth=0.005,
          numberOfWindings=5,
          c=20,
          animation=animation) annotation (Placement(transformation(
              origin={30,10},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation bar2(animation=
              animation, r={0,0,0.3}) annotation (Placement(transformation(
              origin={-30,-10},
              extent={{10,-10},{-10,10}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Forces.Spring spring2(
          s_unstretched=0.1,
          width=0.1,
          coilWidth=0.005,
          numberOfWindings=5,
          c=40,
          animation=animation) annotation (Placement(transformation(
              origin={30,-38},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Forces.Spring spring3(
          s_unstretched=0.1,
          width=0.1,
          coilWidth=0.005,
          numberOfWindings=5,
          c=20,
          animation=animation,
          fixedRotationAtFrame_b=true) annotation (Placement(transformation(
                extent={{-20,-42},{0,-22}}, rotation=0)));
      equation
        connect(world.frame_b, bar1.frame_a)
          annotation (Line(
            points={{-40,30},{-20,30}},
            color={95,95,95},
            thickness=0.5));
        connect(world.frame_b, bar2.frame_a) annotation (Line(
            points={{-40,30},{-30,30},{-30,0}},
            color={95,95,95},
            thickness=0.5));
        connect(bar1.frame_b, spring1.frame_a)
          annotation (Line(
            points={{0,30},{30,30},{30,20}},
            color={95,95,95},
            thickness=0.5));
        connect(bar2.frame_b, spring3.frame_a) annotation (Line(
            points={{-30,-20},{-30,-32},{-20,-32}},
            color={95,95,95},
            thickness=0.5));
        connect(spring2.frame_b, body1.frame_a)
          annotation (Line(
            points={{30,-48},{30,-60},{30,-60}},
            color={0,0,0},
            thickness=0.5));
        connect(spring3.frame_b, spring1.frame_b)
          annotation (Line(
            points={{0,-32},{30,-14},{30,0}},
            color={95,95,95},
            thickness=0.5));
        connect(spring2.frame_a, spring1.frame_b)
          annotation (Line(
            points={{30,-28},{30,-21},{30,-21},{30,-14},{30,0},{30,0}},
            color={95,95,95},
            thickness=0.5));
        annotation (
          experiment(StopTime=10),
          Documentation(info="<html>
<p>
This example demonstrates that <b>3-dimensional line force</b> elements
(here: Modelica.Mechanics.MultiBody.Forces.Spring elements) can be connected together
in <b>series</b> without having a body with mass at the
connection point (as usually required by multi-body programs).
This is advantageous since stiff systems can be avoided, say, due to
a stiff spring and a small mass at the connection point.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/ThreeSprings.png\"
ALT=\"model Examples.Elementary.ThreeSprings\">

<p>
For a more thorough explanation, see
<a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces\">MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces</a>.
</p>
</html>"));
      end ThreeSprings;

      model RollingWheel
        "Single wheel rolling on ground starting from an initial speed"
         extends Modelica_Icons.Example;

        Modelica_Mechanics_MultiBody.Parts.RollingWheel wheel1(
          wheelRadius=0.3,
          wheelMass=2,
          wheel_I_axis=0.06,
          wheel_I_long=0.12,
          hollowFraction=0.6,
          x(start=0.2),
          y(start=0.2),
          der_angles(start={0,5,1}))
          annotation (Placement(transformation(extent={{-20,0},{0,20}})));
        inner Modelica_Mechanics_MultiBody.World world(label2="z", n={0,0,-1})
          annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
        Modelica_Mechanics_MultiBody.Visualizers.Ground ground(length=4)
          annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));
        annotation (
          experiment(StopTime=4),
          Documentation(info="<html>

</html>"));
      end RollingWheel;

      model RollingWheelSetDriving
        "Rolling wheel set that is driven by torques driving the wheels"
         extends Modelica_Icons.Example;

        Modelica_Mechanics_MultiBody.Visualizers.Ground ground(length=3,
            groundColor={0,255,0})
          annotation (Placement(transformation(extent={{-20,-60},{0,-40}})));
        inner Modelica_Mechanics_MultiBody.World world(label2="z", n={0,0,-1})
          annotation (Placement(transformation(extent={{-80,-60},{-60,-40}})));
        Modelica_Mechanics_MultiBody.Parts.RollingWheelSet wheelSet(
          wheelRadius=0.1,
          wheelMass=0.5,
          wheel_I_axis=0.01,
          wheel_I_long=0.02,
          wheelDistance=0.5,
          x(start=0.1, fixed=true),
          y(start=0.1, fixed=true),
          phi(fixed=true),
          theta1(fixed=true),
          theta2(fixed=true),
          der_theta1(fixed=true),
          der_theta2(fixed=true))
          annotation (Placement(transformation(extent={{-20,-20},{0,0}})));
        Modelica_Mechanics_MultiBody.Parts.Body body(
          m=0.01,
          r_CM={0,0,0},
          animation=false)
          annotation (Placement(transformation(extent={{40,56},{60,76}})));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation(
          r={0.2,0,0},
          animation=true,
          width=0.04)
          annotation (Placement(transformation(extent={{0,56},{20,76}})));
        Modelica_Blocks.Sources.Sine sine1(freqHz=1, amplitude=2)
          annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
        Modelica_Blocks.Sources.Sine sine2(
          freqHz=1,
          amplitude=2,
          phase=1.5707963267949)
          annotation (Placement(transformation(extent={{60,20},{40,40}})));
        Modelica_Mechanics_Rotational.Sources.Torque2 torque1
          annotation (Placement(transformation(extent={{-40,4},{-20,24}})));
        Modelica_Mechanics_Rotational.Sources.Torque2 torque2
          annotation (Placement(transformation(extent={{24,4},{4,24}})));
        Modelica_Mechanics_MultiBody.Visualizers.FixedShape shape(
          final lengthDirection={0,1,0},
          final widthDirection={1,0,0},
          final shapeType="pipe",
          final r_shape={0,-wheelSet.wheelWidth,0},
          final length=2*wheelSet.wheelWidth,
          final width=2*wheelSet.wheelRadius,
          final height=2*wheelSet.wheelRadius,
          final color={0,128,255},
          final extra=0.8) annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=0,
              origin={50,90})));
      equation
        connect(fixedTranslation.frame_a, wheelSet.frameMiddle) annotation (Line(
            points={{0,66},{-8,66},{-8,-6},{-10,-6},{-10,-10}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation.frame_b, body.frame_a) annotation (Line(
            points={{20,66},{40,66}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(wheelSet.axis1, torque1.flange_a) annotation (Line(
            points={{-20,0},{-40,0},{-40,14}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(torque1.flange_b, wheelSet.support) annotation (Line(
            points={{-20,14},{-10,14},{-10,-1.8}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(wheelSet.axis2, torque2.flange_a) annotation (Line(
            points={{0,0},{24,0},{24,14}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(wheelSet.support, torque2.flange_b) annotation (Line(
            points={{-10,-1.8},{-10,14},{4,14}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(sine1.y, torque1.tau) annotation (Line(
            points={{-59,30},{-30,30},{-30,18}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(sine2.y, torque2.tau) annotation (Line(
            points={{39,30},{14,30},{14,18}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shape.frame_a, fixedTranslation.frame_b) annotation (Line(
            points={{40,90},{28,90},{28,66},{20,66}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (    experiment(StopTime=3),
          Documentation(info="<html>

</html>"));
      end RollingWheelSetDriving;

      model RollingWheelSetPulling
        "Rolling wheel set that is pulled by a force"
         extends Modelica_Icons.Example;

        Modelica_Mechanics_MultiBody.Forces.WorldForce force(animation=false)
          annotation (Placement(transformation(extent={{-20,60},{0,80}})));
        Modelica_Mechanics_MultiBody.Visualizers.Ground ground(length=3)
          annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));
        inner Modelica_Mechanics_MultiBody.World world(label2="z", n={0,0,-1})
          annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
        Modelica_Mechanics_MultiBody.Parts.RollingWheelSet wheelSet(
          wheelRadius=0.1,
          wheelMass=0.5,
          wheel_I_axis=0.01,
          wheel_I_long=0.02,
          wheelDistance=0.5,
          x(start=0.1, fixed=true),
          y(start=0.1, fixed=true),
          phi(fixed=true),
          theta1(fixed=true),
          theta2(fixed=true),
          der_theta1(fixed=true),
          der_theta2(fixed=true))
          annotation (Placement(transformation(extent={{-20,0},{0,20}})));
        Modelica_Mechanics_MultiBody.Parts.Body body(
          m=0.01,
          r_CM={0,0,0},
          animation=false)
          annotation (Placement(transformation(extent={{42,20},{62,40}})));
        Modelica_Blocks.Sources.CombiTimeTable combiTimeTable(table=[0,1,0,0; 1,1,
              0,0; 2,0,2,0; 3,0,2,0])
          annotation (Placement(transformation(extent={{-80,70},{-60,90}})));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation(
          r={0.2,0,0},
          animation=true,
          width=0.04)
          annotation (Placement(transformation(extent={{0,20},{20,40}})));
        Modelica_Mechanics_MultiBody.Visualizers.FixedShape shape(
          final lengthDirection={0,1,0},
          final widthDirection={1,0,0},
          final shapeType="pipe",
          final r_shape={0,-wheelSet.wheelWidth,0},
          final length=2*wheelSet.wheelWidth,
          final width=2*wheelSet.wheelRadius,
          final height=2*wheelSet.wheelRadius,
          final color={0,128,255},
          final extra=0.8) annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=0,
              origin={52,54})));
      equation
        connect(combiTimeTable.y, force.force) annotation (Line(
            points={{-59,80},{-42,80},{-42,70},{-22,70}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(fixedTranslation.frame_a, wheelSet.frameMiddle) annotation (Line(
            points={{0,30},{-6,30},{-6,14},{-10,14},{-10,10}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation.frame_b, body.frame_a) annotation (Line(
            points={{20,30},{42,30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(force.frame_b, fixedTranslation.frame_b) annotation (Line(
            points={{0,70},{34,70},{34,30},{20,30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(shape.frame_a, fixedTranslation.frame_b) annotation (Line(
            points={{42,54},{34,54},{34,30},{20,30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (    experiment(StopTime=3),
          Documentation(info="<html>

</html>"));
      end RollingWheelSetPulling;

      model HeatLosses "Demonstrate the modeling of heat losses"
         extends Modelica_Icons.Example;
        inner World                              world annotation (Placement(
              transformation(extent={{-100,40},{-80,60}},rotation=0)));
        Parts.Body                              body1(
          m=1,
          r_CM={0,-0.2,0},
          cylinderDiameter=0.05,
          sphereDiameter=0.15,
          I_11=0.1,
          I_22=0.1,
          I_33=0.1,
          r_0(start={0.3,-0.2,0}, each fixed=true),
          v_0(each fixed=true),
          angles_fixed=true,
          w_0_fixed=true,
          w_0_start(each displayUnit="deg/s") = {0,0,0.034906585039887})
                    annotation (Placement(transformation(
              origin={-40,-30},
              extent={{-10,10},{10,-10}},
              rotation=270)));
        Parts.FixedTranslation                              bar1(                     r={0.3,0,0})
          annotation (Placement(transformation(extent={{-66,40},{-46,60}}, rotation=0)));
        Parts.FixedTranslation                              bar2(r={0.3,0,0})
          annotation (Placement(transformation(extent={{-20,40},{0,60}},rotation=0)));
        Forces.Spring                              spring1(
          s_unstretched=0.1,
          coilWidth=0.01,
          c=30,
          numberOfWindings=10,
          width=0.1) annotation (Placement(transformation(
              origin={-26,10},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Forces.Damper                              damper1(d=2, useHeatPort=true)
          annotation (Placement(transformation(
              origin={-50,10},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Forces.SpringDamperParallel springDamper(
          d=2,
          c=30,
          s_unstretched=0.1,
          width=0.1,
          coilWidth=0.01,
          numberOfWindings=10,
          useHeatPort=true)                       annotation (Placement(
              transformation(
              extent={{-10,-10},{10,10}},
              rotation=-90,
              origin={26,10})));
        Parts.Body                              body2(
          m=1,
          r_CM={0,-0.2,0},
          cylinderDiameter=0.05,
          sphereDiameter=0.15,
          I_11=0.1,
          I_22=0.1,
          I_33=0.1,
          v_0(each fixed=true),
          angles_fixed=true,
          w_0_fixed=true,
          w_0_start(each displayUnit="deg/s") = {0,0,0.034906585039887},
          r_0(start={0.6,-0.2,0}, each fixed=true))
                    annotation (Placement(transformation(
              origin={26,-30},
              extent={{-10,10},{10,-10}},
              rotation=270)));
        Parts.FixedTranslation                              bar3(r={0.3,0,0})
          annotation (Placement(transformation(extent={{34,40},{54,60}},rotation=0)));
        Forces.SpringDamperSeries springDamperSeries(
          d=2,
          c=30,
          s_unstretched=0.1,
          useHeatPort=true)                       annotation (Placement(
              transformation(
              extent={{-10,10},{10,-10}},
              rotation=-90,
              origin={80,10})));
        Parts.Body                              body3(
          m=1,
          r_CM={0,-0.2,0},
          cylinderDiameter=0.05,
          sphereDiameter=0.15,
          I_11=0.1,
          I_22=0.1,
          I_33=0.1,
          v_0(each fixed=true),
          angles_fixed=true,
          w_0_fixed=true,
          w_0_start(each displayUnit="deg/s") = {0,0,0.034906585039887},
          r_0(start={0.9,-0.2,0}, each fixed=true))
                    annotation (Placement(transformation(
              origin={80,-30},
              extent={{-10,10},{10,-10}},
              rotation=270)));
        Forces.Spring spring(
          s_unstretched=0.2,
          width=0.05,
          c=30)              annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=-90,
              origin={60,10})));
        Modelica_Blocks.Sources.Constant const(k=20)
          annotation (Placement(transformation(extent={{-8,-100},{12,-80}})));
        Modelica_Thermal_HeatTransfer.Components.Convection convection
          annotation (Placement(transformation(extent={{26,-52},{46,-72}})));
        Modelica_Thermal_HeatTransfer.Celsius.FixedTemperature TAmbient(T=25)
          "Ambient temperature"
          annotation (Placement(transformation(extent={{80,-72},{60,-52}})));
      equation

        connect(world.frame_b,bar1. frame_a)
          annotation (Line(
            points={{-80,50},{-66,50}},
            color={95,95,95},
            thickness=0.5));
        connect(bar1.frame_b,bar2. frame_a)
          annotation (Line(
            points={{-46,50},{-20,50}},
            color={95,95,95},
            thickness=0.5));
        connect(damper1.frame_a,bar1. frame_b) annotation (Line(
            points={{-50,20},{-50,30},{-40,30},{-40,50},{-46,50}},
            color={95,95,95},
            thickness=0.5));
        connect(spring1.frame_a,bar1. frame_b) annotation (Line(
            points={{-26,20},{-26,30},{-40,30},{-40,50},{-46,50}},
            color={95,95,95},
            thickness=0.5));
        connect(damper1.frame_b,body1. frame_a) annotation (Line(
            points={{-50,0},{-50,-8},{-40,-8},{-40,-20}},
            color={95,95,95},
            thickness=0.5));
        connect(spring1.frame_b,body1. frame_a) annotation (Line(
            points={{-26,0},{-26,-8},{-40,-8},{-40,-20}},
            color={95,95,95},
            thickness=0.5));
        connect(bar2.frame_b, springDamper.frame_a)  annotation (Line(
            points={{0,50},{26,50},{26,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(springDamper.frame_b, body2.frame_a)  annotation (Line(
            points={{26,0},{26,-5},{26,-5},{26,-10},{26,-20},{26,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bar3.frame_b, springDamperSeries.frame_a)
                                                     annotation (Line(
            points={{54,50},{80,50},{80,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(springDamperSeries.frame_b, body3.frame_a)
                                                      annotation (Line(
            points={{80,0},{80,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bar3.frame_a, bar2.frame_b) annotation (Line(
            points={{34,50},{0,50}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bar3.frame_b, spring.frame_a) annotation (Line(
            points={{54,50},{60,50},{60,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(spring.frame_b, body3.frame_a) annotation (Line(
            points={{60,0},{60,-12},{80,-12},{80,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(const.y,convection. Gc) annotation (Line(
            points={{13,-90},{36,-90},{36,-72}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(TAmbient.port,convection. fluid) annotation (Line(
            points={{60,-62},{46,-62}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(damper1.heatPort, convection.solid) annotation (Line(
            points={{-60,20},{-60,-62},{26,-62}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(springDamper.heatPort, convection.solid) annotation (Line(
            points={{16,20},{4,20},{4,-62},{26,-62}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(springDamperSeries.heatPort, convection.solid) annotation (Line(
            points={{90,20},{96,20},{96,-46},{4,-46},{4,-62},{26,-62}},
            color={191,0,0},
            smooth=Smooth.None));
        annotation (
          experiment(StopTime=3),
          Documentation(info="<html>
<p>
This model demonstrates how to model the dissipated power of a multi-body
force element by enabling the heatPort of all components and connecting these heatPorts via
a convection element to the environment. The total heat flow generated by the
elements of this multi-body system and transported to the environment
is present in variable convection.fluid.
</p>
</html>"));
      end HeatLosses;

      model UserDefinedGravityField
        "Demonstrate the modeling of a user-defined gravity field"
         extends Modelica_Icons.Example;
         parameter Modelica_SIunits.Conversions.NonSIunits.Angle_deg geodeticLatitude = 0
          "Geodetic latitude";
         parameter Modelica_SIunits.Position height = 20
          "Height of pendulum attachment point over WGS84 earth ellipsoid";
         Modelica_SIunits.Acceleration gravity[3]=body.g_0
          "Gravity acceleration at center of mass of body";
        inner Modelica_Mechanics_MultiBody.World world(
          gravityType=Types.GravityTypes.NoGravity,
          redeclare function gravityAcceleration =
              M_S_L.Mechanics.MultiBody.Examples.Elementary.Utilities.theoreticalNormalGravityWGS84
              (phi=geodeticLatitude),
          axisLength=10,
          nominalLength=10) annotation (Placement(transformation(extent={{-80,-20},
                  {-60,0}}, rotation=0)));
        Joints.Revolute rev(n={0,0,1},useAxisFlange=true,
          phi(fixed=true),
          w(fixed=true))             annotation (Placement(transformation(extent={{-14,20},
                  {6,40}},        rotation=0)));
        Modelica_Mechanics_Rotational.Components.Damper damper(d=0.1)
          annotation (Placement(transformation(extent={{-14,60},{6,80}},
                rotation=0)));
        Parts.Body body(r_CM={10,0,0},
          m=1000.0,
          sphereDiameter=1)
          annotation (Placement(transformation(extent={{26,20},{46,40}},rotation=0)));
        Parts.FixedTranslation fixedTranslation(r={0,height,0}, width=0.3)
                                                           annotation (Placement(
              transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-40,8})));
      equation
        connect(damper.flange_b,rev. axis) annotation (Line(points={{6,70},{10,70},{10,
                46},{-4,46},{-4,40}},   color={0,0,0}));
        connect(rev.support,damper. flange_a) annotation (Line(points={{-10,40},{-10,46},
                {-22,46},{-22,70},{-14,70}},     color={0,0,0}));
        connect(body.frame_a,rev. frame_b) annotation (Line(
            points={{26,30},{6,30}},
            color={95,95,95},
            thickness=0.5));
        connect(world.frame_b, fixedTranslation.frame_a) annotation (Line(
            points={{-60,-10},{-40,-10},{-40,-2}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation.frame_b, rev.frame_a) annotation (Line(
            points={{-40,18},{-40,30},{-14,30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (experiment(StopTime=10, Tolerance=1e-008),
          Documentation(info="<html>
<p>
This example demonstrates a user defined gravity field.
Function \"world.gravityAcceleration\" is redeclared to function
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.Utilities.theoreticalNormalGravityWGS84\">theoreticalNormalGravityWGS84</a>
that computes the theoretical gravity of the
<a href=\"http://earth-info.nga.mil/GandG/publications/tr8350.2/wgs84fin.pdf\">WGS84 ellipsoid earth model</a> at and close to
the earth ellipsoid surface. In the gravity field, a large, single pendulum is present. Via parameter \"geodeticLatitude\", the geodetic latitude on the earth can be defined, where the pendulum is present. The world frame is located at the WGS84 earth ellipsoid at this latitude. The result variable
\"gravity\" is the gravity vector at the center of mass of the pendulum mass.
Since the height of this mass is changing, the value of the gravity is also changing
(the difference is in the order of 0.00001).
</p>

<p>
The result of the simulation is slightly different at the equator (geodeticLatitude=0)
and at the poles (geodeticLatitude=90). For example, after 10 s of simulation time
the rotation angle of the pendulum, rev.phi, has the following values:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td><b><i>latitude [deg]</i></b></td>
    <td><b><i>rev.phi [rad]</i></b></td></tr>
<tr><td> = 0</td>
    <td>= -2.39 rad</td></tr>

<tr><td>= 90</td>
    <td>= -2.42 rad</td></tr>
</table>
</html>"));
      end UserDefinedGravityField;

      model Surfaces
        "Demonstrate the visualization of a sine surface, as well as a torus and a wheel constructed from a surface"
        extends Modelica_Icons.Example;
        parameter Real x_min=-1 "Minimum value of x";
        parameter Real x_max=+1 "Maximum value of x";
        parameter Real y_min=-1 "Minimum value of y";
        parameter Real y_max=+1 "Maximum value of y";
        parameter Real z_min=0 "Minimum value of z";
        parameter Real z_max=1 "Maximum value of z";
        Real wz = time;
        Modelica_Mechanics_MultiBody.Visualizers.Advanced.Surface surface(
          redeclare function surfaceCharacteristic =
              M_S_L.Mechanics.MultiBody.Examples.Elementary.Utilities.sineSurface
              (
              x_min=x_min,
              x_max=x_max,
              y_min=y_min,
              y_max=y_max,
              z_min=z_min,
              z_max=z_max,
              wz=wz),
          multiColoredSurface=false,
          nu=50,
          nv=50)
          annotation (Placement(transformation(extent={{-72,-52},{-52,-32}})));
        inner World world(axisLength=1, n={0,0,-1})
          annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
        Visualizers.Torus torus
          annotation (Placement(transformation(extent={{32,20},{52,40}})));
        Joints.Prismatic prismatic(useAxisFlange=true, animation=false,
          v(fixed=true))
          annotation (Placement(transformation(extent={{-38,20},{-18,40}})));
        Modelica_Mechanics_Translational.Sources.Position position
          annotation (Placement(transformation(extent={{-66,70},{-46,90}})));
        Modelica_Blocks.Sources.Sine sine(amplitude=2, freqHz=0.5)
          annotation (Placement(transformation(extent={{-98,70},{-78,90}})));
        Visualizers.Ground ground(          groundColor={215,215,215}, length=4)
          annotation (Placement(transformation(extent={{-72,-16},{-52,4}})));
        Parts.FixedTranslation fixedTranslation1(r={0,-1.3,torus.ro + torus.ri},
            animation=false)
          annotation (Placement(transformation(extent={{-4,20},{16,40}})));
        Parts.FixedTranslation fixedTranslation2(
            animation=false, r={0,-1.6,wheel.rTire})
          annotation (Placement(transformation(extent={{-4,50},{16,70}})));
        Visualizers.VoluminousWheel wheel
          annotation (Placement(transformation(extent={{32,50},{52,70}})));
        Visualizers.PipeWithScalarField pipeWithScalarField(
          rOuter=0.3,
          length=1,
          T_min=0,
          T_max=2,
          T=sin(Modelica_Constants.pi*pipeWithScalarField.xsi)*cos(
              Modelica_Constants.pi
              *time) .+ 1,
          n_colors=32)
          annotation (Placement(transformation(extent={{14,-30},{34,-10}})));
        Parts.FixedTranslation fixedTranslation3(
            animation=false, r={0,-2.2,0})
          annotation (Placement(transformation(extent={{-20,-30},{0,-10}})));
      equation
        connect(world.frame_b, prismatic.frame_a) annotation (Line(
            points={{-60,30},{-38,30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(position.flange, prismatic.axis) annotation (Line(
            points={{-46,80},{-24,80},{-24,36},{-20,36}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(sine.y, position.s_ref) annotation (Line(
            points={{-77,80},{-68,80}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(prismatic.frame_b, fixedTranslation1.frame_a)
                                                             annotation (Line(
            points={{-18,30},{-4,30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation1.frame_b, torus.frame_a)
                                                         annotation (Line(
            points={{16,30},{32,30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(prismatic.frame_b, fixedTranslation2.frame_a) annotation (Line(
            points={{-18,30},{-14,30},{-14,60},{-4,60}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation2.frame_b, wheel.frame_a) annotation (Line(
            points={{16,60},{32,60}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(world.frame_b, fixedTranslation3.frame_a) annotation (Line(
            points={{-60,30},{-46,30},{-46,-20},{-20,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation3.frame_b, pipeWithScalarField.frame_a) annotation (
            Line(
            points={{0,-20},{14,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (
          experiment(StopTime=5),
          Documentation(info="<html>
<p>
This example demonstrates the use of the
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface\">Surface</a>
visualizer that visualizes a moving, parameterized surface.
The \"sine-wave\" surface is a direct application of the surface model.
Furthermore, the \"torus\" surface is an instance of
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Torus\">Torus</a>,
the \"wheel\" surface is an instance of
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.VoluminousWheel\">VoluminousWheel</a>,
and the \"pipeWithScalarField surface is an instance of
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.PipeWithScalarField\">PipeWithScalarField</a>.
All latter visual shapes are constructed with the surface model.
The following image shows a screen-shot of this example model:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/Surfaces.png\">
</blockquote>

</html>"));
      end Surfaces;

      package Utilities
        "Utility models and functions used by MultiBody.Examples.Elementary"
        extends Modelica_Icons.UtilitiesPackage;
        function theoreticalNormalGravityWGS84
          "WGS84 normal gravity over earth ellipsoid in negative y-direction"
           extends
            Modelica_Mechanics_MultiBody.Interfaces.partialGravityAcceleration;
          input Modelica_SIunits.Conversions.NonSIunits.Angle_deg phi
            "Geodetic latitude" annotation(Dialog);
        protected
          constant Modelica_SIunits.Position a = 6378137.0
            "Semi-major axis of the earth ellipsoid";
          constant Modelica_SIunits.Position b = 6356752.3142
            "Semi-minor axis of the earth ellipsoid";
          constant Modelica_SIunits.AngularAcceleration g_e = 9.7803253359
            "Theoretical gravity acceleration at the equator";
          constant Modelica_SIunits.AngularAcceleration g_p = 9.8321849378
            "Theoretical gravity acceleration at the poles";
          constant Real k =   (b/a)*(g_p/g_e) - 1;

          constant Real e2 = (8.1819190842622e-2)^2
            "Square of the first ellipsoidal eccentricity";
          constant Real f = 1/298.257223563 "Ellipsoidal flattening";
          constant Modelica_SIunits.AngularVelocity w =   7292115e-11
            "Angular velocity of earth";
          constant Real GM(unit="m3/s2")=3986004.418e8
            "Earths Gravitational Constant";
          constant Real m(unit="1")=w^2*a^2*b/GM;
          Real sinphi2(unit="1");
          Modelica_SIunits.AngularAcceleration gn
            "Normal gravity at the earth ellipsoid";
          Modelica_SIunits.AngularAcceleration gh
            "Normal gravity at height h over the earth ellipsoid";
          Modelica_SIunits.Position h "Height over the WGS84 earth ellipsoid";
          Real ha(unit="1") "h/a";
        algorithm
          h := r[2];
          sinphi2 :=Modelica_Math.sin(Modelica_SIunits.Conversions.from_deg(phi))^2;
          gn := g_e*(1 + k*sinphi2)/sqrt(1 - e2*sinphi2);
          ha := h/a;
          gh := gn*(1 - ha*(2*(1+f+m-2*f*sinphi2)+3*ha));
          gravity :={0,-gh,0};
          annotation (Documentation(info="<html>
<p>
Function that computes the theoretical gravity of the
<a href=\"http://earth-info.nga.mil/GandG/publications/tr8350.2/wgs84fin.pdf\">WGS84 ellipsoid earth model</a> at and close to the earth ellipsoid surface, for the
given \"geodeticLatitude\" and the given \"height=r[2]\" over the
ellipsoid surface.
</p>

</html>"));
        end theoreticalNormalGravityWGS84;

        function sineSurface
          "Function defining the characteristic of a moving sine in three dimensions"
           extends
            Modelica_Mechanics_MultiBody.Interfaces.partialSurfaceCharacteristic;
           input Real x_min "Minimum value of x";
           input Real x_max "Maximum value of x";
           input Real y_min "Minimum value of y";
           input Real y_max "Maximum value of y";
           input Real z_min "Minimum value of z";
           input Real z_max "Maximum value of z";
           input Real wz "Factor for angular frequency";
        protected
           Real aux_y;
           Real A=(z_max-z_min)/2;
        algorithm
           for i in 1:nu loop
              aux_y := y_min + (y_max - y_min)*(i-1)/(nu-1);
              for j in 1:nv loop
                 X[i,j] := x_min + (x_max - x_min)*(j - 1)/(nv - 1);
                 Y[i,j] := aux_y;
                 Z[i,j] := A*sin(wz + 0.1*j + 0.1*i)+A;
              end for;
           end for;

           if multiColoredSurface then
              C := {{(Z[i,j]+1)*200,255,0} for j in 1:nv, i in 1:nu};
           end if;
        end sineSurface;
      end Utilities;
    annotation ( Documentation(info="<HTML>
<p>
This package contains elementary example models to demonstrate
the usage of the MultiBody library
</p>
<h4>Content</h4>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><b><i>Model</i></b></th><th><b><i>Description</i></b></th></tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.DoublePendulum\">DoublePendulum</a></td>
      <td valign=\"top\"> Simple double pendulum with two revolute joints and two bodies.<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/DoublePendulumSmall.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.ForceAndTorque\">ForceAndTorque</a></td>
      <td valign=\"top\"> Demonstrates usage of Forces.ForceAndTorque element.<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/ForceAndTorque_small.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.FreeBody\">FreeBody</a></td>
      <td valign=\"top\"> Free flying body attached by two springs to environment.<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/FreeBody_small.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.InitSpringConstant\">InitSpringConstant</a></td>
      <td valign=\"top\"> Determine spring constant such that system is in steady state
           at given position.<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/InitSpringConstant_small.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses\">LineForceWithTwoMasses</a></td>
      <td valign=\"top\"> Demonstrates a line force with two point masses using a
           Joints.Assemblies.JointUPS and alternatively a
           Forces.LineForceWithTwoMasses component.<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/LineForceWithTwoMasses_small.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.Pendulum\">Pendulum</a></td>
      <td valign=\"top\"> Simple pendulum with one revolute joint and one body. <br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/Pendulum_small.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.PendulumWithSpringDamper\">PendulumWithSpringDamper</a></td>
      <td valign=\"top\"> Simple spring/damper/mass system <br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/PendulumWithSpringDamper_small.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravity\">PointGravity</a></td>
      <td valign=\"top\"> Two bodies in a point gravity field <br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/PointGravity_small.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses\">PointGravityWithPointMasses</a></td>
      <td valign=\"top\"> Two point masses in a point gravity field (rotation of bodies is neglected) <br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/PointGravityWithPointMasses_small.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses2\">PointGravityWithPointMasses2</a></td>
      <td valign=\"top\"> Rigidly connected point masses in a point gravity field <br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/PointGravityWithPointMasses2_small.png\">
      </td>
  </tr>

  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheel\">RollingWheel</a></td>
      <td valign=\"top\"> Single wheel rolling on ground starting from an initial speed <br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/RollingWheel.png\">
      </td>
  </tr>

  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheelSetDriving\">RollingWheelSetDriving</a></td>
      <td valign=\"top\"> Rolling wheel set that is driven by torques driving the wheels <br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/RollingWheelSetDriving.png\">
      </td>
  </tr>

  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheelSetPulling\">RollingWheelSetPulling</a></td>
      <td valign=\"top\"> Rolling wheel set that is pulled by a force <br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/RollingWheelSetPulling.png\">
      </td>
  </tr>

  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.SpringDamperSystem\">SpringDamperSystem</a></td>
      <td valign=\"top\"> Spring/damper system with a prismatic joint and
           attached on free flying body <br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/SpringDamperSystem_small.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.SpringMassSystem\">SpringMassSystem</a></td>
      <td valign=\"top\"> Mass attached via a prismatic joint and a spring to the world frame <br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/SpringMassSystem_small.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.SpringWithMass\">SpringWithMass</a></td>
      <td valign=\"top\"> Point mass hanging on a spring <br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/SpringWithMass_small.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.ThreeSprings\">ThreeSprings</a></td>
      <td valign=\"top\"> 3-dimensional springs in series and parallel connection<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/ThreeSprings_small.png\">
      </td>
  </tr>

  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.HeatLosses\">HeatLosses</a></td>
      <td valign=\"top\"> Demonstrate the modeling of heat losses.  </td>
  </tr>

  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.UserDefinedGravityField\">UserDefinedGravityField </a></td>
      <td valign=\"top\"> Demonstrate the modeling of a user-defined gravity field.  </td>
  </tr>

  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.Surfaces\">Surfaces</a></td>
      <td valign=\"top\"> Demonstrate the visualization of a sine surface,
       as well as a torus and a wheel constructed from a surface <br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/Surfaces_small.png\">
      </td>
  </tr>

</table>
</HTML>"));
    end Elementary;

    package Loops "Examples with kinematic loops"
    extends Modelica_Icons.ExamplesPackage;

      model Engine1a "Model of one cylinder engine"
        extends Modelica_Icons.Example;
        Modelica_Mechanics_MultiBody.Parts.BodyCylinder Piston(diameter=0.1, r=
              {0,-0.1,0}) annotation (Placement(transformation(
              origin={90.5,66.5},
              extent={{-10.5,30.5},{10.5,-30.5}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Parts.BodyBox Rod(
          widthDirection={1,0,0},
          width=0.02,
          height=0.06,
          r={0,-0.2,0},
          color={0,0,200}) annotation (Placement(transformation(
              origin={90,5},
              extent={{10,-10},{-10,10}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Joints.Revolute B2(
          n={1,0,0},
          cylinderLength=0.02,
          cylinderDiameter=0.05) annotation (Placement(transformation(extent={{
                  80,22},{100,42}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute Bearing(
          useAxisFlange=true,
          n={1,0,0},
          cylinderLength=0.02,
          cylinderDiameter=0.05) annotation (Placement(transformation(extent={{
                  -10,-80},{10,-100}}, rotation=0)));
        inner Modelica_Mechanics_MultiBody.World world annotation (Placement(
              transformation(extent={{-50,-100},{-30,-80}}, rotation=0)));
        Modelica_Mechanics_Rotational.Components.Inertia Inertia(
          stateSelect=StateSelect.always,
          phi(fixed=true, start=0),
          w(fixed=true, start=10),
          J=1) annotation (Placement(transformation(extent={{-28,-120},{-8,-100}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.BodyBox Crank4(
          height=0.05,
          widthDirection={1,0,0},
          width=0.02,
          r={0,-0.1,0}) annotation (Placement(transformation(
              origin={115.5,-75},
              extent={{10,-10},{-10,10}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Parts.BodyCylinder Crank3(r={0.1,0,0},
            diameter=0.03) annotation (Placement(transformation(extent={{81.5,-71},
                  {101.5,-51}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.BodyCylinder Crank1(diameter=0.05, r=
             {0.1,0,0}) annotation (Placement(transformation(extent={{24,-100},
                  {44,-80}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.BodyBox Crank2(
          r={0,0.1,0},
          height=0.05,
          widthDirection={1,0,0},
          width=0.02) annotation (Placement(transformation(
              origin={70,-76},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        Joints.RevolutePlanarLoopConstraint B1(
          n={1,0,0},
          cylinderLength=0.02,
          cylinderDiameter=0.05) annotation (Placement(transformation(extent={{80,-30},
                  {100,-10}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation Mid(r={0.05,0,0})
          annotation (Placement(transformation(extent={{70,-53},{90,-33}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Prismatic Cylinder(
          boxWidth=0.02,
          n={0,-1,0},
          s(start=0.15)) annotation (Placement(transformation(
              origin={90,96},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation cylPosition(animation=
             false, r={0.15,0.45,0}) annotation (Placement(transformation(
                extent={{-0.5,100},{19.5,120}}, rotation=0)));
      equation
        connect(world.frame_b, Bearing.frame_a) annotation (Line(
            points={{-30,-90},{-10,-90}},
            color={95,95,95},
            thickness=0.5));
        connect(Crank2.frame_a, Crank1.frame_b) annotation (Line(
            points={{70,-86},{70,-90},{44,-90}},
            color={95,95,95},
            thickness=0.5));
        connect(Crank2.frame_b, Crank3.frame_a) annotation (Line(
            points={{70,-66},{70,-61},{81.5,-61}},
            color={95,95,95},
            thickness=0.5));
        connect(Bearing.frame_b, Crank1.frame_a) annotation (Line(
            points={{10,-90},{24,-90}},
            color={95,95,95},
            thickness=0.5));
        connect(cylPosition.frame_b, Cylinder.frame_a) annotation (Line(
            points={{19.5,110},{90,110},{90,106}},
            color={95,95,95},
            thickness=0.5));
        connect(world.frame_b, cylPosition.frame_a) annotation (Line(
            points={{-30,-90},{-20,-90},{-20,110},{-0.5,110}},
            color={95,95,95},
            thickness=0.5));
        connect(Crank3.frame_b, Crank4.frame_a) annotation (Line(
            points={{101.5,-61},{115,-61},{115,-65},{115.5,-65}},
            color={95,95,95},
            thickness=0.5));
        connect(B1.frame_a, Mid.frame_b) annotation (Line(
            points={{80,-20},{70,-20},{70,-32},{98,-32},{98,-43},{90,-43}},
            color={95,95,95},
            thickness=0.5));
        connect(B1.frame_b, Rod.frame_b) annotation (Line(
            points={{100,-20},{112,-20},{112,-9},{90,-9},{90,-5}},
            color={95,95,95},
            thickness=0.5));
        connect(Rod.frame_a, B2.frame_b) annotation (Line(
            points={{90,15},{90,21},{110,21},{110,32},{100,32}},
            color={95,95,95},
            thickness=0.5));
        connect(B2.frame_a, Piston.frame_b) annotation (Line(
            points={{80,32},{70,32},{70,46},{90.5,46},{90.5,56}},
            color={95,95,95},
            thickness=0.5));
        connect(Inertia.flange_b, Bearing.axis)
          annotation (Line(points={{-8,-110},{0,-110},{0,-100}}, color={0,0,0}));
        connect(Mid.frame_a, Crank2.frame_b) annotation (Line(
            points={{70,-43},{63,-43},{63,-61},{70,-61},{70,-66}},
            color={95,95,95},
            thickness=0.5));
        connect(Cylinder.frame_b, Piston.frame_a) annotation (Line(
            points={{90,86},{90,77},{90.5,77}},
            color={95,95,95},
            thickness=0.5));
        annotation (Diagram(coordinateSystem(extent={{-130.0,-130.0},{130.0,130.0}})),
          experiment(StopTime=5), Documentation(info="<html>
<p>
This is a model of the mechanical part of one cylinder of an engine.
The combustion is not modelled. The \"inertia\" component at the lower
left part is the output inertia of the engine driving the gearbox.
The angular velocity of the output inertia has a start value of 10 rad/s
in order to demonstrate the movement of the engine.
</p>
<p>
The engine is modeled solely by revolute and prismatic joints.
Since this results in a <b>planar</b> loop there is the well known
difficulty that the cut-forces perpendicular to the loop cannot be
uniquely computed, as well as the cut-torques within the plane.
This ambiguity is resolved by using the option <b>planarCutJoint</b>
in the <b>Advanced</b> menu of one revolute joint in every planar loop
(here: joint B1). This option sets the cut-force in direction of the
axis of rotation, as well as the cut-torques perpendicular to the axis
of rotation at this joint to zero and makes the problem mathematically
well-formed.
</p>
<p>
An animation of this example is shown in the figure below.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/Engine.png\" ALT=\"model Examples.Loops.Engine\">
</html>"));
      end Engine1a;

      model Engine1b
        "Model of one cylinder engine with gas force and preparation for assembly joint JointRRP"
        extends Modelica_Icons.Example;
        extends Utilities.Engine1bBase(Inertia(w(start=0)));
        Joints.RevolutePlanarLoopConstraint B2(
          n={1,0,0},
          cylinderLength=0.02,
          cylinderDiameter=0.05) annotation (Placement(transformation(extent={{40,20},
                  {60,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute B1(
          n={1,0,0},
          cylinderLength=0.02,
          cylinderDiameter=0.05) annotation (Placement(transformation(extent={{
                  40,-20},{60,0}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Prismatic Cylinder(
          useAxisFlange=true,
          boxWidth=0.02,
          n={0,-1,0}) annotation (Placement(transformation(
              origin={50,97},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Parts.FixedTranslation Rod1(r={0,0.2,0}, animation=false) annotation (
            Placement(transformation(
              origin={70,10},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        Parts.FixedTranslation Rod3(r={0,-0.1,0}, animation=false) annotation (
            Placement(transformation(
              origin={50,58},
              extent={{10,-10},{-10,10}},
              rotation=90)));
      equation
        connect(B1.frame_b, Rod1.frame_a) annotation (Line(
            points={{60,-10},{70,-10},{70,0}},
            color={95,95,95},
            thickness=0.5));
        connect(Rod1.frame_b, B2.frame_b) annotation (Line(
            points={{70,20},{70,30},{60,30}},
            color={95,95,95},
            thickness=0.5));
        connect(Cylinder.frame_b, Rod3.frame_a) annotation (Line(
            points={{50,87},{50,68}},
            color={95,95,95},
            thickness=0.5));
        connect(B2.frame_a, Rod3.frame_b) annotation (Line(
            points={{40,30},{30,30},{30,44},{50,44},{50,48}},
            color={95,95,95},
            thickness=0.5));
        connect(cylPosition.frame_b, Cylinder.frame_a) annotation (Line(
            points={{-20.5,110},{50,110},{50,107}},
            color={95,95,95},
            thickness=0.5));
        connect(gasForce.flange_a, Cylinder.support) annotation (Line(points={{119,
                107},{119,112},{70,112},{70,101},{56,101}}, color={0,127,0}));
        connect(Cylinder.axis, gasForce.flange_b) annotation (Line(points={{56,89},{
                71,89},{71,80},{119,80},{119,87}}, color={0,127,0}));
        connect(Piston.frame_a, Rod3.frame_a) annotation (Line(
            points={{120,63},{120,75},{50,75},{50,68}},
            color={95,95,95},
            thickness=0.5));
        connect(B1.frame_b, Rod2.frame_a) annotation (Line(
            points={{60,-10},{120,-10},{120,0}},
            color={95,95,95},
            thickness=0.5));
        connect(Mid.frame_b, B1.frame_a) annotation (Line(
            points={{50,-43},{57,-43},{57,-28},{30,-28},{30,-10},{40,-10}},
            color={95,95,95},
            thickness=0.5));
        annotation (
          experiment(StopTime=0.5),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-120},{150,120}}), graphics={Rectangle(
                extent={{3,117},{88,-23}},
                lineColor={255,0,0},
                lineThickness=0.5),Text(
                extent={{65,-30},{145,-39}},
                lineColor={255,0,0},
                lineThickness=0.5,
                textString="jointRRP in model"),Text(
                extent={{66,-34},{141,-52}},
                lineColor={255,0,0},
                lineThickness=0.5,
                textString="Loops.Engine1b_analytic")}),
          Documentation(info="<html>
<p>
This is a model of the mechanical part of one cylinder of an engine.
It is similar to
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Engine1a#diagram\">Loops.Engine1a</a>.
The difference is that a simple
model for the gas force in the cylinder is added and that the
model is restructured in such a way, that the central part of
the planar kinematic loop can be easily replaced by the
assembly joint \"Modelica.Mechanics.MultiBody.Joints.Assemblies.<b>JointRRP</b>\".
This exchange of the kinematic loop is shown in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b_analytic#diagram\">Loops.Engine1b_analytic</a>.
The advantage of using JointRRP is, that the
non-linear algebraic equation of this loop is solved analytically, and
not numerically as in this model (Engine1b).
</p>
<p>
An animation of this example is shown in the figure below.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/Engine.png\" ALT=\"model Examples.Loops.Engine\">
</html>"));
      end Engine1b;

      model Engine1b_analytic
        "Model of one cylinder engine with gas force and analytic loop handling"
        extends Modelica_Icons.Example;
        extends Utilities.Engine1bBase(Inertia(w(start=0)));
        Joints.Assemblies.JointRRP jointRRP(
          n_a={1,0,0},
          n_b={0,-1,0},
          animation=false,
          rRod1_ia={0,0.2,0},
          rRod2_ib={0,-0.1,0}) annotation (Placement(transformation(
              origin={30,54},
              extent={{-20,20},{20,-20}},
              rotation=90)));
      equation
        connect(Mid.frame_b, jointRRP.frame_a) annotation (Line(
            points={{50,-43},{58,-43},{58,-30},{30,-30},{30,34}},
            color={95,95,95},
            thickness=0.5));
        connect(jointRRP.frame_b, cylPosition.frame_b) annotation (Line(
            points={{30,74},{30,110},{-20.5,110}},
            color={95,95,95},
            thickness=0.5));
        connect(jointRRP.axis, gasForce.flange_b) annotation (Line(points={{46,74},{
                46,82},{119,82},{119,87}}, color={0,127,0}));
        connect(jointRRP.bearing, gasForce.flange_a) annotation (Line(points={{38,74},
                {38,114},{119,114},{119,107}}, color={0,127,0}));
        connect(jointRRP.frame_ib, Piston.frame_a) annotation (Line(
            points={{50,70},{120,70},{120,63}},
            color={95,95,95},
            thickness=0.5));
        connect(jointRRP.frame_ia, Rod2.frame_a) annotation (Line(
            points={{50,38},{80,38},{80,-10},{120,-10},{120,0}},
            color={95,95,95},
            thickness=0.5));
        annotation (experiment(StopTime=0.5), Documentation(info="<html>
<p>
This is the same model as
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b#diagram\">Loops.Engine1b</a>.
The only difference is that the central part of
the planar kinematic loop has been replaced by the
assembly joint \"Modelica.Mechanics.MultiBody.Joints.Assemblies.<b>JointRRP</b>\".
The advantage of using JointRRP is, that the
non-linear algebraic equation of this loop is solved analytically, and
not numerically as in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b#diagram\">Loops.Engine1b</a>.
</p>
<p>
An animation of this example is shown in the figure below.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/Engine.png\" ALT=\"model Examples.Loops.Engine\">
</html>"));
      end Engine1b_analytic;

      model EngineV6
        "V6 engine with 6 cylinders, 6 planar loops and 1 degree-of-freedom"

        extends Modelica_Icons.Example;
        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        output Modelica_SIunits.Conversions.NonSIunits.AngularVelocity_rpm
          engineSpeed_rpm=
               Modelica_SIunits.Conversions.to_rpm(load.w) "Engine speed";
        output Modelica_SIunits.Torque engineTorque = filter.u
          "Torque generated by engine";
        output Modelica_SIunits.Torque filteredEngineTorque = filter.y
          "Filtered torque generated by engine";

        Modelica_Mechanics_MultiBody.Joints.Revolute bearing(
          useAxisFlange=true,
          n={1,0,0},
          cylinderLength=0.02,
          cylinderDiameter=0.06,
          animation=animation) annotation (Placement(transformation(extent={{-90,
                  20},{-70,0}}, rotation=0)));
        inner Modelica_Mechanics_MultiBody.World world(animateWorld=false,
            animateGravity=false) annotation (Placement(transformation(extent={
                  {-120,20},{-100,40}}, rotation=0)));
        Utilities.Cylinder cylinder1(
          crankAngleOffset=Cv.from_deg(-30),
          cylinderInclination=Cv.from_deg(-30),
          animation=animation) annotation (Placement(transformation(extent={{-50,4},{
                  -30,34}}, rotation=0)));
        Utilities.Cylinder cylinder2(
          crankAngleOffset=Cv.from_deg(90),
          cylinderInclination=Cv.from_deg(30),
          animation=animation) annotation (Placement(transformation(extent={{-20,4},{
                  0,34}}, rotation=0)));
        Utilities.Cylinder cylinder3(
          cylinderInclination=Cv.from_deg(-30),
          animation=animation,
          crankAngleOffset=Cv.from_deg(210))
                               annotation (Placement(transformation(extent={{10,4},{
                  30,34}}, rotation=0)));
        Utilities.Cylinder cylinder4(
          cylinderInclination=Cv.from_deg(30),
          animation=animation,
          crankAngleOffset=Cv.from_deg(210))
                               annotation (Placement(transformation(extent={{39,4},{
                  59,34}}, rotation=0)));
        Utilities.Cylinder cylinder5(
          cylinderInclination=Cv.from_deg(-30),
          animation=animation,
          crankAngleOffset=Cv.from_deg(90))
                               annotation (Placement(transformation(extent={{70,4},{
                  90,34}}, rotation=0)));
        Utilities.Cylinder cylinder6(
          cylinderInclination=Cv.from_deg(30),
          animation=animation,
          crankAngleOffset=Cv.from_deg(-30))
                               annotation (Placement(transformation(extent={{100,4},{
                  120,34}}, rotation=0)));
        Modelica_Mechanics_Rotational.Components.Inertia load(
                                phi(
            start=0,
            fixed=true), w(
            start=10,
            fixed=true),
          stateSelect=StateSelect.always,
          J=1)                               annotation (Placement(transformation(
                extent={{-44,-30},{-24,-10}}, rotation=0)));
        Modelica_Mechanics_Rotational.Sources.QuadraticSpeedDependentTorque load2(
                                                       tau_nominal=-100, w_nominal=
              200,
          useSupport=false)
                   annotation (Placement(transformation(extent={{6,-30},{-14,-10}},
                rotation=0)));
        Modelica_Mechanics_Rotational.Sensors.TorqueSensor torqueSensor
          annotation (Placement(transformation(extent={{-72,-30},{-52,-10}},
                rotation=0)));
        Modelica_Blocks.Continuous.CriticalDamping filter(
          n=2,
          initType=Modelica_Blocks.Types.Init.SteadyState,
          f=5) annotation (Placement(transformation(extent={{-54,-60},{-34,-40}},
                rotation=0)));
      equation

        connect(bearing.frame_b, cylinder1.crank_a)
          annotation (Line(
            points={{-70,10},{-50,10}},
            color={95,95,95},
            thickness=0.5));
        connect(cylinder1.crank_b, cylinder2.crank_a)
          annotation (Line(
            points={{-30,10},{-20,10}},
            color={95,95,95},
            thickness=0.5));
        connect(cylinder2.crank_b, cylinder3.crank_a)
          annotation (Line(
            points={{0,10},{10,10}},
            color={95,95,95},
            thickness=0.5));
        connect(cylinder3.crank_b, cylinder4.crank_a)
          annotation (Line(
            points={{30,10},{39,10}},
            color={95,95,95},
            thickness=0.5));
        connect(cylinder4.crank_b, cylinder5.crank_a)
          annotation (Line(
            points={{59,10},{70,10}},
            color={95,95,95},
            thickness=0.5));
        connect(cylinder5.crank_b, cylinder6.crank_a)
          annotation (Line(
            points={{90,10},{100,10}},
            color={95,95,95},
            thickness=0.5));
        connect(cylinder5.cylinder_b, cylinder6.cylinder_a)
          annotation (Line(
            points={{90,32},{100,32}},
            color={95,95,95},
            thickness=0.5));
        connect(cylinder4.cylinder_b, cylinder5.cylinder_a)
          annotation (Line(
            points={{59,32},{70,32}},
            color={95,95,95},
            thickness=0.5));
        connect(cylinder4.cylinder_a, cylinder3.cylinder_b)
          annotation (Line(
            points={{39,32},{30,32}},
            color={95,95,95},
            thickness=0.5));
        connect(cylinder3.cylinder_a, cylinder2.cylinder_b)
          annotation (Line(
            points={{10,32},{0,32}},
            color={95,95,95},
            thickness=0.5));
        connect(cylinder2.cylinder_a, cylinder1.cylinder_b)
          annotation (Line(
            points={{-20,32},{-30,32}},
            color={95,95,95},
            thickness=0.5));
        connect(world.frame_b, cylinder1.cylinder_a) annotation (Line(
            points={{-100,30},{-59,30},{-59,32},{-50,32}},
            color={95,95,95},
            thickness=0.5));
        connect(world.frame_b, bearing.frame_a) annotation (Line(
            points={{-100,30},{-96,30},{-96,10},{-90,10}},
            color={95,95,95},
            thickness=0.5));
        connect(load2.flange, load.flange_b)
          annotation (Line(points={{-14,-20},{-24,-20}}, color={0,0,0}));
        connect(torqueSensor.flange_b, load.flange_a)
          annotation (Line(points={{-52,-20},{-44,-20}}, color={0,0,0}));
        connect(torqueSensor.tau,filter. u) annotation (Line(points={{-70,-31},{-70,
                -50},{-56,-50}}, color={0,0,127}));
        connect(torqueSensor.flange_a, bearing.axis) annotation (Line(points={{-72,
                -20},{-80,-20},{-80,0}}, color={0,0,0}));
        annotation (
          Documentation(info="<HTML>
<p>
This is a V6 engine with 6 cylinders. It is hierarchically built
up by using instances of one cylinder. For more details on the
modeling of one cylinder, see example
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b\">Engine1b</a>.
An animation of the engine is shown in the figure below.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/EngineV6.png\" ALT=\"model Examples.Loops.EngineV6\">

<p>
Simulate for 5 s, and plot the variables <b>engineSpeed_rpm</b>,
<b>engineTorque</b>, and <b>filteredEngineTorque</b>. Note, the result file has
a size of about 50 Mbyte (for 5000 output intervals).
</p>
</html>"),       experiment(StopTime=1.01));
      end EngineV6;

      model EngineV6_analytic
        "V6 engine with 6 cylinders, 6 planar loops, 1 degree-of-freedom and analytic handling of kinematic loops"

        extends Modelica_Icons.Example;
        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        output Modelica_SIunits.Conversions.NonSIunits.AngularVelocity_rpm
          engineSpeed_rpm=
               Modelica_SIunits.Conversions.to_rpm(load.w) "Engine speed";
        output Modelica_SIunits.Torque engineTorque = filter.u
          "Torque generated by engine";
        output Modelica_SIunits.Torque filteredEngineTorque = filter.y
          "Filtered torque generated by engine";

        inner Modelica_Mechanics_MultiBody.World world(animateWorld=false,
            animateGravity=false) annotation (Placement(transformation(extent={
                  {-80,-20},{-60,0}}, rotation=0)));
        Utilities.EngineV6_analytic engine(redeclare model Cylinder =
              M_S_L.Mechanics.MultiBody.Examples.Loops.Utilities.Cylinder_analytic_CAD)
          annotation (Placement(transformation(extent={{-40,0},{0,40}}, rotation=0)));
        Modelica_Mechanics_Rotational.Components.Inertia load(
                                                   phi(
            start=0,
            fixed=true), w(
            start=10,
            fixed=true),
          stateSelect=StateSelect.always,
          J=1)                               annotation (Placement(transformation(
                extent={{40,10},{60,30}}, rotation=0)));
        Modelica_Mechanics_Rotational.Sources.QuadraticSpeedDependentTorque load2(
                                                       tau_nominal=-100, w_nominal=
              200,
          useSupport=false)
                   annotation (Placement(transformation(extent={{90,10},{70,30}},
                rotation=0)));
        Modelica_Mechanics_Rotational.Sensors.TorqueSensor torqueSensor
          annotation (Placement(transformation(extent={{12,10},{32,30}},
                rotation=0)));
        Modelica_Blocks.Continuous.CriticalDamping filter(
          n=2,
          initType=Modelica_Blocks.Types.Init.SteadyState,
          f=5) annotation (Placement(transformation(extent={{30,-20},{50,0}},
                rotation=0)));
      equation

        connect(world.frame_b, engine.frame_a)
          annotation (Line(
            points={{-60,-10},{-20,-10},{-20,-0.2}},
            color={95,95,95},
            thickness=0.5));
        connect(load2.flange, load.flange_b)
          annotation (Line(points={{70,20},{60,20}}, color={0,0,0}));
        connect(torqueSensor.flange_a, engine.flange_b)
          annotation (Line(points={{12,20},{2,20}}, color={0,0,0}));
        connect(torqueSensor.flange_b, load.flange_a)
          annotation (Line(points={{32,20},{40,20}}, color={0,0,0}));
        connect(torqueSensor.tau, filter.u) annotation (Line(points={{14,9},{14,-10},
                {28,-10}}, color={0,0,127}));
        annotation (
          Documentation(info="<HTML>
<p>
This is a similar model as the example \"EngineV6\". However, the cylinders
have been built up with component Modelica.Mechanics.MultiBody.Joints.Assemblies.JointRRR that
solves the non-linear system of equations in an aggregation of 3 revolution
joints <b>analytically</b> and only one body is used that holds the total
mass of the crank shaft:
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/EngineV6_CAD_small.png\">

<p>
This model is about 20 times faster as the EngineV6 example and <b>no</b> linear or
non-linear system of equations occur. In contrast, the \"EngineV6\" example
leads to 6 systems of nonlinear equations (every system has dimension = 5, with
Evaluate=false and dimension=1 with Evaluate=true) and a linear system of equations
of about 40. This shows the power of the analytic loop handling.
</p>

<p>
Simulate for 5 s, and plot the variables <b>engineSpeed_rpm</b>,
<b>engineTorque</b>, and <b>filteredEngineTorque</b>. Note, the result file has
a size of about 50 Mbyte (for 5000 output intervals).
</p>
</html>"),       experiment(StopTime=1.01));
      end EngineV6_analytic;

      model Fourbar1
        "One kinematic loop with four bars (with only revolute joints; 5 non-linear equations)"
        extends Modelica_Icons.Example;

        output Modelica_SIunits.Angle j1_phi "angle of revolute joint j1";
        output Modelica_SIunits.Position j2_s "distance of prismatic joint j2";
        output Modelica_SIunits.AngularVelocity j1_w
          "axis speed of revolute joint j1";
        output Modelica_SIunits.Velocity j2_v
          "axis velocity of prismatic joint j2";

        inner Modelica_Mechanics_MultiBody.World world annotation (Placement(
              transformation(extent={{-100,-80},{-80,-60}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute j1(
          n={1,0,0},
          stateSelect=StateSelect.always,
          phi(fixed=true),
          w(displayUnit="deg/s",
            start=5.235987755982989,
            fixed=true)) annotation (Placement(transformation(extent={{-54,-40},
                  {-34,-20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Prismatic j2(
          n={1,0,0},
          s(start=-0.2),
          boxWidth=0.05) annotation (Placement(transformation(extent={{10,-80},
                  {30,-60}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.BodyCylinder b1(r={0,0.5,0.1},
            diameter=0.05) annotation (Placement(transformation(
              origin={-30,2},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Parts.BodyCylinder b2(r={0,0.2,0},
            diameter=0.05) annotation (Placement(transformation(
              origin={50,-50},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Parts.BodyCylinder b3(r={-1,0.3,0.1},
            diameter=0.05) annotation (Placement(transformation(extent={{38,20},
                  {18,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute rev(n={0,1,0}) annotation (
           Placement(transformation(
              origin={50,-22},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Joints.Revolute rev1 annotation (Placement(
              transformation(extent={{60,0},{80,20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute j3(n={1,0,0}) annotation (
            Placement(transformation(extent={{-60,40},{-40,60}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute j4(n={0,1,0}) annotation (
            Placement(transformation(extent={{-32,60},{-12,80}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute j5(n={0,0,1}) annotation (
            Placement(transformation(extent={{0,70},{20,90}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation b0(animation=false,
            r={1.2,0,0}) annotation (Placement(transformation(extent={{-40,-80},
                  {-20,-60}}, rotation=0)));
      equation
        connect(j2.frame_b, b2.frame_a) annotation (Line(
            points={{30,-70},{50,-70},{50,-60}},
            color={95,95,95},
            thickness=0.5));
        connect(j1.frame_b, b1.frame_a) annotation (Line(
            points={{-34,-30},{-30,-30},{-30,-8}},
            color={95,95,95},
            thickness=0.5));
        connect(rev.frame_a, b2.frame_b)
          annotation (Line(
            points={{50,-32},{50,-40}},
            color={95,95,95},
            thickness=0.5));
        connect(rev.frame_b, rev1.frame_a)
          annotation (Line(
            points={{50,-12},{50,10},{60,10}},
            color={95,95,95},
            thickness=0.5));
        connect(rev1.frame_b, b3.frame_a) annotation (Line(
            points={{80,10},{90,10},{90,30},{38,30}},
            color={95,95,95},
            thickness=0.5));
        connect(world.frame_b, j1.frame_a) annotation (Line(
            points={{-80,-70},{-66,-70},{-66,-30},{-54,-30}},
            color={95,95,95},
            thickness=0.5));
        connect(b1.frame_b, j3.frame_a) annotation (Line(
            points={{-30,12},{-30,28},{-72,28},{-72,50},{-60,50}},
            color={95,95,95},
            thickness=0.5));
        connect(j3.frame_b, j4.frame_a) annotation (Line(
            points={{-40,50},{-34,50},{-42,70},{-32,70}},
            color={95,95,95},
            thickness=0.5));
        connect(j4.frame_b, j5.frame_a)
          annotation (Line(
            points={{-12,70},{0,70},{0,80}},
            color={95,95,95},
            thickness=0.5));
        connect(j5.frame_b, b3.frame_b) annotation (Line(
            points={{20,80},{30,80},{30,54},{4,54},{4,30},{18,30}},
            color={95,95,95},
            thickness=0.5));
        connect(b0.frame_a, world.frame_b)
          annotation (Line(
            points={{-40,-70},{-80,-70}},
            color={95,95,95},
            thickness=0.5));
        connect(b0.frame_b, j2.frame_a)
          annotation (Line(
            points={{-20,-70},{10,-70}},
            color={95,95,95},
            thickness=0.5));
        j1_phi = j1.phi;
        j2_s = j2.s;
        j1_w = j1.w;
        j2_v = j2.v;
        annotation (
          experiment(StopTime=5),
          Documentation(info="<html>
<p>
This is a simple kinematic loop consisting of 6 revolute joints, 1 prismatic joint
and 4 bars that is often used as basic constructing unit in mechanisms.
This example demonstrates that usually no particular knowledge
of the user is needed to handle kinematic loops.
Just connect the joints and bodies together according
to the real system. In particular <b>no</b> cut-joints or a spanning tree has
to be determined. In this case, the initial condition of the angular velocity
of revolute joint j1 is set to 300 deg/s in order to drive this loop.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/Fourbar1.png\" ALT=\"model Examples.Loops.Fourbar1\">
</html>"));
      end Fourbar1;

      model Fourbar2
        "One kinematic loop with four bars (with UniversalSpherical joint; 1 non-linear equation)"
        extends Modelica_Icons.Example;

        output Modelica_SIunits.Angle j1_phi "angle of revolute joint j1";
        output Modelica_SIunits.Position j2_s "distance of prismatic joint j2";
        output Modelica_SIunits.AngularVelocity j1_w
          "axis speed of revolute joint j1";
        output Modelica_SIunits.Velocity j2_v
          "axis velocity of prismatic joint j2";

        inner Modelica_Mechanics_MultiBody.World world annotation (Placement(
              transformation(extent={{-80,-80},{-60,-60}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute j1(
          useAxisFlange=true,
          n={1,0,0},
          stateSelect=StateSelect.always,
          phi(fixed=true),
          w(displayUnit="deg/s",
            start=5.235987755982989,
            fixed=true)) annotation (Placement(transformation(extent={{-54,-40},
                  {-34,-20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Prismatic j2(
          n={1,0,0},
          boxWidth=0.05,
          s(fixed=true, start=-0.2)) annotation (Placement(transformation(
                extent={{12,-80},{32,-60}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.BodyCylinder b1(r={0,0.5,0.1},
            diameter=0.05) annotation (Placement(transformation(
              origin={-30,0},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Parts.BodyCylinder b2(r={0,0.2,0},
            diameter=0.05) annotation (Placement(transformation(
              origin={50,-50},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Joints.UniversalSpherical universalSpherical(
          n1_a={0,1,0},
          computeRodLength=true,
          rRod_ia={-1,0.3,0.1}) annotation (Placement(transformation(extent={{0,
                  18},{-20,38}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation b3(r={1.2,0,0},
            animation=false) annotation (Placement(transformation(extent={{-32,
                  -80},{-12,-60}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Visualizers.FixedFrame fixedFrame(color_x={
              0,0,255}) annotation (Placement(transformation(
              origin={-6,70},
              extent={{-10,-10},{10,10}},
              rotation=90)));
      equation
        j1_phi = j1.phi;
        j2_s = j2.s;
        j1_w = j1.w;
        j2_v = j2.v;
        connect(j2.frame_b, b2.frame_a) annotation (Line(
            points={{32,-70},{50,-70},{50,-60}},
            color={95,95,95},
            thickness=0.5));
        connect(j1.frame_b, b1.frame_a) annotation (Line(
            points={{-34,-30},{-30,-30},{-30,-10}},
            color={95,95,95},
            thickness=0.5));
        connect(j1.frame_a, world.frame_b) annotation (Line(
            points={{-54,-30},{-60,-30},{-60,-70}},
            color={95,95,95},
            thickness=0.5));
        connect(b1.frame_b, universalSpherical.frame_b) annotation (Line(
            points={{-30,10},{-30,28},{-20,28}},
            color={95,95,95},
            thickness=0.5));
        connect(universalSpherical.frame_a, b2.frame_b)
          annotation (Line(
            points={{0,28},{50,28},{50,-40}},
            color={95,95,95},
            thickness=0.5));
        connect(b3.frame_a, world.frame_b)
          annotation (Line(
            points={{-32,-70},{-60,-70}},
            color={95,95,95},
            thickness=0.5));
        connect(b3.frame_b, j2.frame_a)
          annotation (Line(
            points={{-12,-70},{12,-70}},
            color={95,95,95},
            thickness=0.5));
        connect(fixedFrame.frame_a, universalSpherical.frame_ia) annotation (Line(
            points={{-6,60},{-6,49},{-6,49},{-6,38}},
            color={95,95,95},
            thickness=0.5));
        annotation (
          experiment(StopTime=5),
          Documentation(info="<html>
<p>
This is a second version of the \"four-bar\" mechanism, see figure:
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/Fourbar2.png\" ALT=\"model Examples.Loops.Fourbar2\">

<p>
In this case
the three revolute joints on the left top-side and the two revolute
joints on the right top side have been replaced by the joint <b>UniversalSpherical</b>
that is a rod connecting a spherical and a universal joint. This joint is defined
by <b>1 constraint</b> stating that the distance between the two spherical joints is
constant. Using this joint in a kinematic loop reduces the sizes of
non-linear algebraic equations. For this loop, only one non-linear
algebraic system of equations of order 1 remains.
</p>
<p>
At the UniversalSpherical joint an additional frame_ia fixed to the rod
is present where components can be attached to the connecting rod. In this
example just a coordinate system is attached to visualize frame_ia (coordinate
system on the right in blue color).
</p>
<p>
Another feature is that the length of the connecting rod can be
automatically calculated during <b>initialization</b>. In order to do this,
another initialization condition has to be given. In this example, the
initial value of the distance of the prismatic joint j2 has been fixed
(via the \"Initialization\" menu) and the rod length of joint
\"UniversalSpherical\" is computed during initialization since parameter
<b>computeLength</b> = <b>true</b> is set in the joint parameter
menu. The main advantage is that during initialization no non-linear
system of equation is solved and therefore initialization always works.
To be precise, the following trivial non-linear equation is actually solved
for rodLength:
</p>
<pre>
   rodLength*rodLength = f(angle of revolute joint, distance of prismatic joint)
</pre>
</html>"));
      end Fourbar2;

      model Fourbar_analytic
        "One kinematic loop with four bars (with JointSSP joint; analytic solution of non-linear algebraic loop)"
        extends Modelica_Icons.Example;

        output Modelica_SIunits.Angle j1_phi "angle of revolute joint j1";
        output Modelica_SIunits.Position j2_s "distance of prismatic joint j2";
        output Modelica_SIunits.AngularVelocity j1_w
          "axis speed of revolute joint j1";
        output Modelica_SIunits.Velocity j2_v
          "axis velocity of prismatic joint j2";

        inner Modelica_Mechanics_MultiBody.World world(animateGravity=false)
          annotation (Placement(transformation(extent={{-80,-60},{-60,-40}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Revolute j1(
          useAxisFlange=true,
          n={1,0,0},
          stateSelect=StateSelect.always,
          phi(fixed=true),
          w(displayUnit="deg/s",
            start=5.235987755982989,
            fixed=true)) annotation (Placement(transformation(extent={{-54,-40},
                  {-34,-20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.BodyCylinder b1(r={0,0.5,0.1},
            diameter=0.05) annotation (Placement(transformation(
              origin={-30,-8},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation b3(r={1.2,0,0},
            animation=false) annotation (Placement(transformation(extent={{-32,
                  -60},{-12,-40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Assemblies.JointSSP jointSSP(
          rod1Length=sqrt({-1,0.3,0.1}*{-1,0.3,0.1}),
          n_b={1,0,0},
          s_offset=-0.2,
          rRod2_ib={0,0.2,0},
          rod1Color={0,128,255},
          rod2Color={0,128,255},
          checkTotalPower=true) annotation (Placement(transformation(extent={{-20,
                  0},{20,40}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.BodyCylinder b2(
          r={0,0.2,0},
          diameter=0.05,
          animation=false) annotation (Placement(transformation(
              origin={50,10},
              extent={{10,-10},{-10,10}},
              rotation=90)));
      equation
        j1_phi = j1.phi;
        j2_s = jointSSP.prismatic.distance;
        j1_w = j1.w;
        j2_v = der(jointSSP.prismatic.distance);
        connect(j1.frame_b, b1.frame_a) annotation (Line(
            points={{-34,-30},{-30,-30},{-30,-18}},
            color={95,95,95},
            thickness=0.5));
        connect(j1.frame_a, world.frame_b) annotation (Line(
            points={{-54,-30},{-60,-30},{-60,-50}},
            color={95,95,95},
            thickness=0.5));
        connect(b3.frame_a, world.frame_b)
          annotation (Line(
            points={{-32,-50},{-60,-50}},
            color={95,95,95},
            thickness=0.5));
        connect(b1.frame_b, jointSSP.frame_a) annotation (Line(
            points={{-30,2},{-30,20},{-20,20}},
            color={95,95,95},
            thickness=0.5));
        connect(b3.frame_b, jointSSP.frame_b) annotation (Line(
            points={{-12,-50},{30,-50},{30,20},{20,20}},
            color={95,95,95},
            thickness=0.5));
        connect(b2.frame_a, jointSSP.frame_ib) annotation (Line(
            points={{50,20},{50,48},{16,48},{16,40}},
            color={95,95,95},
            thickness=0.5));
        annotation (
          experiment(StopTime=5),
          Documentation(info="<html>
<p>
This is a third version of the \"four-bar\" mechanism, see figure:
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/Fourbar_analytic.png\" ALT=\"model Examples.Loops.Fourbar_analytic\">

<p>
In this case
the three revolute joints on the left top-side and the two revolute
joints on the right top side have been replaced by the assembly joint
<b>Joints.Assemblies.JointSSP</b>
which consists of two spherical joints and one prismatic joint.
Since JointSSP solves the non-linear constraint equation internally
analytically, no non-linear equation appears any more and a Modelica
translator can transform the system into state space
form without solving a system of equations. For more details, see
<a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling\">
MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling</a>.
</p>
</html>"));
      end Fourbar_analytic;

      model PlanarLoops_analytic
        "Mechanism with three planar kinematic loops and one degree-of-freedom with analytic loop handling (with JointRRR joints)"
        extends Modelica_Icons.Example;
        parameter Modelica_SIunits.Length rh[3]={0.5,0,0}
          "Position vector from 'lower left' revolute to 'lower right' revolute joint for all the 3 loops";
        parameter Modelica_SIunits.Length rv[3]={0,0.5,0}
          "Position vector from 'lower left' revolute to 'upper left' revolute joint in the first loop";

        parameter Modelica_SIunits.Length r1b[3]={0.1,0.5,0}
          "Position vector from 'lower right' revolute to 'upper right' revolute joint in the first loop";
        final parameter Modelica_SIunits.Length r1a[3]=r1b + rh - rv
          "Position vector from 'upper left' revolute to 'upper right' revolute joint in the first loop";

        parameter Modelica_SIunits.Length r2b[3]={0.1,0.6,0}
          "Position vector from 'lower right' revolute to 'upper right' revolute joint in the second loop";
        final parameter Modelica_SIunits.Length r2a[3]=r2b + rh - r1b
          "Position vector from 'upper left' revolute to 'upper right' revolute joint in the second loop";

        parameter Modelica_SIunits.Length r3b[3]={0,0.55,0}
          "Position vector from 'lower right' revolute to 'upper right' revolute joint in the third loop";
        final parameter Modelica_SIunits.Length r3a[3]=r3b + rh - r2b
          "Position vector from 'upper left' revolute to 'upper right' revolute joint in the third loop";

        inner Modelica_Mechanics_MultiBody.World world annotation (Placement(
              transformation(extent={{-94,-90},{-74,-70}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.Assemblies.JointRRR jointRRR1(
          rRod1_ia=r1a,
          rRod2_ib=r1b,
          checkTotalPower=true) annotation (Placement(transformation(
              origin={-20,0},
              extent={{-20,-20},{20,20}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Joints.Revolute rev(useAxisFlange=true, w(
              fixed=true)) annotation (Placement(transformation(
              origin={-56,-10},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation rod1(r=rv)
          annotation (Placement(transformation(
              origin={-56,30},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation rod2(r=rh)
          annotation (Placement(transformation(extent={{-50,-60},{-30,-40}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.Body body1(
          m=1,
          cylinderColor={155,155,155},
          r_CM=jointRRR1.rRod1_ia/2) annotation (Placement(transformation(
              origin={6,60},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        Modelica_Mechanics_Rotational.Sources.Position position(useSupport=true)
          annotation (Placement(transformation(extent={{-90,-20},{-70,0}}, rotation=0)));
        Modelica_Blocks.Sources.Sine sine(amplitude=0.7, freqHz=1)
          annotation (Placement(transformation(
              origin={-96,30},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Joints.Assemblies.JointRRR jointRRR2(
          rRod1_ia=r2a,
          rRod2_ib=r2b,
          checkTotalPower=true) annotation (Placement(transformation(
              origin={30,0},
              extent={{-20,-20},{20,20}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation rod3(r=rh)
          annotation (Placement(transformation(extent={{0,-60},{20,-40}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.Body body2(
          m=1,
          cylinderColor={155,155,155},
          r_CM=jointRRR2.rRod1_ia/2) annotation (Placement(transformation(
              origin={55,61},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Joints.Assemblies.JointRRR jointRRR3(
          rRod1_ia=r3a,
          rRod2_ib=r3b,
          checkTotalPower=true) annotation (Placement(transformation(
              origin={80,0},
              extent={{-20,-20},{20,20}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation rod4(r=rh)
          annotation (Placement(transformation(extent={{40,-60},{60,-40}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.Body body3(
          m=1,
          cylinderColor={155,155,155},
          r_CM=jointRRR3.rRod1_ia/2) annotation (Placement(transformation(
              origin={108,62},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        Parts.Mounting1D mounting1D
          annotation (Placement(transformation(extent={{-100,-50},{-80,-30}})));
      equation
        connect(world.frame_b, rev.frame_a) annotation (Line(
            points={{-74,-80},{-56,-80},{-56,-20}},
            color={95,95,95},
            thickness=0.5));
        connect(rod1.frame_a, rev.frame_b)
          annotation (Line(
            points={{-56,20},{-56,0}},
            color={0,0,0},
            thickness=0.5));
        connect(rod1.frame_b, jointRRR1.frame_a) annotation (Line(
            points={{-56,40},{-56,50},{-20,50},{-20,20}},
            color={95,95,95},
            thickness=0.5));
        connect(rod2.frame_a, world.frame_b)
          annotation (Line(
            points={{-50,-50},{-56,-50},{-56,-80},{-74,-80}},
            color={95,95,95},
            thickness=0.5));
        connect(rod2.frame_b, jointRRR1.frame_b) annotation (Line(
            points={{-30,-50},{-20,-50},{-20,-20}},
            color={95,95,95},
            thickness=0.5));
        connect(jointRRR1.frame_ia, body1.frame_a) annotation (Line(
            points={{0,16},{6,16},{6,50}},
            color={95,95,95},
            thickness=0.5));
        connect(rod3.frame_a, rod2.frame_b)
          annotation (Line(
            points={{0,-50},{-30,-50}},
            color={95,95,95},
            thickness=0.5));
        connect(rod3.frame_b, jointRRR2.frame_b) annotation (Line(
            points={{20,-50},{30,-50},{30,-20}},
            color={95,95,95},
            thickness=0.5));
        connect(jointRRR2.frame_ia, body2.frame_a) annotation (Line(
            points={{50,16},{55,16},{55,51}},
            color={95,95,95},
            thickness=0.5));
        connect(jointRRR1.frame_im, jointRRR2.frame_a) annotation (Line(
            points={{0,0},{12,0},{12,25},{30,25},{30,20}},
            color={95,95,95},
            thickness=0.5));
        connect(rod3.frame_b, rod4.frame_a)
          annotation (Line(
            points={{20,-50},{40,-50}},
            color={95,95,95},
            thickness=0.5));
        connect(rod4.frame_b, jointRRR3.frame_b) annotation (Line(
            points={{60,-50},{80,-50},{80,-20}},
            color={95,95,95},
            thickness=0.5));
        connect(jointRRR2.frame_im, jointRRR3.frame_a) annotation (Line(
            points={{50,0},{60,0},{60,26},{80,26},{80,20}},
            color={95,95,95},
            thickness=0.5));
        connect(jointRRR3.frame_ia, body3.frame_a) annotation (Line(
            points={{100,16},{108,16},{108,52}},
            color={95,95,95},
            thickness=0.5));
        connect(sine.y, position.phi_ref) annotation (Line(points={{-96,19},{-96,-10},
                {-92,-10}}, color={0,0,127}));
        connect(mounting1D.flange_b, position.support) annotation (Line(
            points={{-80,-40},{-80,-20}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(mounting1D.frame_a, world.frame_b) annotation (Line(
            points={{-90,-50},{-90,-57},{-70,-57},{-70,-80},{-74,-80}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(position.flange, rev.axis) annotation (Line(
            points={{-70,-10},{-66,-10}},
            color={0,0,0},
            smooth=Smooth.None));
        annotation (
          experiment(StopTime=5),
          Documentation(info="<html>
<p>
It is demonstrated how the Modelica.Mechanics.MultiBody.Joints.Assemblies.JointRRR joint can be
used to solve the non-linear equations of coupled planar loops analytically.
In the mechanism below no non-linear equation occurs any more from the tool
view, since these equations are solved analytically in the JointRRR joints.
For more details, see
<a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling\">
MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling</a>.
</p>

<p>
In the following figure the parameter vectors of this example are visualized in the
animation view.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/PlanarLoops2.png\" ALT=\"model Examples.Loops.PlanarLoops2\">
</html>"));
      end PlanarLoops_analytic;

      package Utilities "Utility models for Examples.Loops"
        extends Modelica_Icons.UtilitiesPackage;

        model Cylinder "Cylinder with rod and crank of a combustion engine"
          parameter Boolean animation=true
            "= true, if animation shall be enabled";
          parameter Modelica_SIunits.Length cylinderTopPosition=0.42
            "Length from crank shaft to end of cylinder.";
          parameter Modelica_SIunits.Length pistonLength=0.1
            "Length of cylinder";
          parameter Modelica_SIunits.Length rodLength=0.2 "Length of rod";
          parameter Modelica_SIunits.Length crankLength=0.2
            "Length of crank shaft in x direction";
          parameter Modelica_SIunits.Length crankPinOffset=0.1
            "Offset of crank pin from center axis";
          parameter Modelica_SIunits.Length crankPinLength=0.1
            "Offset of crank pin from center axis";
          parameter Modelica_SIunits.Angle cylinderInclination=0
            "Inclination of cylinder";
          parameter Modelica_SIunits.Angle crankAngleOffset=0
            "Offset for crank angle";
          parameter Modelica_SIunits.Length cylinderLength=cylinderTopPosition
               - (pistonLength + rodLength - crankPinOffset)
            "Maximum length of cylinder volume";

          Modelica_Mechanics_MultiBody.Parts.BodyCylinder Piston(
            diameter=0.1,
            r={0,pistonLength,0},
            color={180,180,180},
            animation=animation) annotation (Placement(transformation(
                origin={14.5,69.5},
                extent={{10.5,-30.5},{-10.5,30.5}},
                rotation=270)));
          Modelica_Mechanics_MultiBody.Parts.BodyBox Rod(
            widthDirection={1,0,0},
            height=0.06,
            color={0,0,200},
            width=0.02,
            r_shape={0,-0.02,0},
            r={0,rodLength,0},
            animation=animation) annotation (Placement(transformation(
                origin={14,8},
                extent={{-10,-10},{10,10}},
                rotation=90)));
          Modelica_Mechanics_MultiBody.Joints.Revolute B2(
            n={1,0,0},
            cylinderLength=0.02,
            animation=animation,
            cylinderDiameter=0.055) annotation (Placement(transformation(extent=
                   {{4,25},{24,45}}, rotation=0)));
          Modelica_Mechanics_MultiBody.Parts.BodyBox Crank4(
            height=0.05,
            widthDirection={1,0,0},
            width=0.02,
            r={0,-crankPinOffset,0},
            animation=animation) annotation (Placement(transformation(
                origin={40.5,-74},
                extent={{10,-10},{-10,10}},
                rotation=90)));
          Modelica_Mechanics_MultiBody.Parts.BodyCylinder Crank3(
            r_shape={-0.01,0,0},
            length=0.12,
            diameter=0.03,
            r={crankPinLength,0,0},
            color={180,180,180},
            animation=animation) annotation (Placement(transformation(extent={{
                    4.5,-60},{24.5,-40}}, rotation=0)));
          Modelica_Mechanics_MultiBody.Parts.BodyCylinder Crank1(
            diameter=0.05,
            r_shape={-0.01,0,0},
            length=0.12,
            r={crankLength - crankPinLength,0,0},
            color={180,180,180},
            animation=animation) annotation (Placement(transformation(extent={{
                    -50,-100},{-30,-80}}, rotation=0)));
          Modelica_Mechanics_MultiBody.Parts.BodyBox Crank2(
            height=0.05,
            widthDirection={1,0,0},
            width=0.02,
            r={0,crankPinOffset,0},
            animation=animation) annotation (Placement(transformation(
                origin={-10,-76},
                extent={{-10,-10},{10,10}},
                rotation=90)));
          Joints.RevolutePlanarLoopConstraint B1(
            n={1,0,0},
            cylinderLength=0.02,
            animation=animation,
            cylinderDiameter=0.055) annotation (Placement(transformation(extent={{4,
                    -27},{24,-7}}, rotation=0)));
          Modelica_Mechanics_MultiBody.Parts.FixedTranslation Mid(r={
                crankPinLength/2,0,0}, animation=false) annotation (Placement(
                transformation(extent={{-6,-46},{14,-26}}, rotation=0)));
          Modelica_Mechanics_MultiBody.Joints.Prismatic Cylinder(
            useAxisFlange=true,
            s(start=-0.3),
            n={0,-1,0},
            boxWidth=0.02) annotation (Placement(transformation(
                origin={14,99},
                extent={{-10,-10},{10,10}},
                rotation=270)));
          Modelica_Mechanics_MultiBody.Parts.FixedTranslation Mounting(r={
                crankLength,0,0}, animation=false) annotation (Placement(
                transformation(extent={{0,120},{20,140}}, rotation=0)));
          Modelica_Mechanics_MultiBody.Parts.FixedRotation CylinderInclination(
            r={crankLength - crankPinLength/2,0,0},
            n_y={0,cos(cylinderInclination),sin(cylinderInclination)},
            animation=false,
            rotationType=Types.RotationTypes.TwoAxesVectors) annotation (
              Placement(transformation(extent={{-60,30},{-40,50}}, rotation=0)));
          Modelica_Mechanics_MultiBody.Parts.FixedRotation CrankAngle1(
            n_y={0,cos(crankAngleOffset),sin(crankAngleOffset)},
            animation=false,
            rotationType=Types.RotationTypes.TwoAxesVectors) annotation (
              Placement(transformation(extent={{-90,-100},{-70,-80}}, rotation=
                    0)));
          Modelica_Mechanics_MultiBody.Parts.FixedRotation CrankAngle2(
            n_y={0,cos(-crankAngleOffset),sin(-crankAngleOffset)},
            animation=false,
            rotationType=Types.RotationTypes.TwoAxesVectors) annotation (
              Placement(transformation(extent={{60,-100},{80,-80}}, rotation=0)));
          Modelica_Mechanics_MultiBody.Parts.FixedTranslation CylinderTop(r={0,
                cylinderTopPosition,0}, animation=false) annotation (Placement(
                transformation(
                origin={-30,71},
                extent={{-10,-10},{10,10}},
                rotation=90)));
          GasForce gasForce(L=cylinderLength, d=0.1)
            annotation (Placement(transformation(
                origin={50,107},
                extent={{-10,-10},{10,10}},
                rotation=90)));
          Interfaces.Frame_a cylinder_a annotation (Placement(transformation(extent={
                    {-116,114},{-84,146}}, rotation=0)));
          Interfaces.Frame_a cylinder_b annotation (Placement(transformation(extent={
                    {84,114},{116,146}}, rotation=0)));
          Interfaces.Frame_a crank_a annotation (Placement(transformation(extent={{
                    -116,-106},{-84,-74}}, rotation=0)));
          Interfaces.Frame_a crank_b annotation (Placement(transformation(extent={{84,
                    -106},{116,-74}}, rotation=0)));
        equation
          connect(B1.frame_a, Mid.frame_b) annotation (Line(
              points={{4,-17},{-6,-17},{-6,-29},{22,-29},{22,-36},{14,-36}},
              color={95,95,95},
              thickness=0.5));
          connect(Rod.frame_a, B1.frame_b) annotation (Line(
              points={{14,-2},{14,-9},{30,-9},{30,-17},{24,-17}},
              color={95,95,95},
              thickness=0.5));
          connect(Cylinder.frame_b, Piston.frame_b) annotation (Line(
              points={{14,89},{14,80},{14.5,80}},
              color={95,95,95},
              thickness=0.5));
          connect(Crank1.frame_a, CrankAngle1.frame_b)
            annotation (Line(
              points={{-50,-90},{-70,-90}},
              color={95,95,95},
              thickness=0.5));
          connect(B2.frame_a, Piston.frame_a) annotation (Line(
              points={{4,35},{-6,35},{-6,49},{14.5,49},{14.5,59}},
              color={95,95,95},
              thickness=0.5));
          connect(Rod.frame_b, B2.frame_b) annotation (Line(
              points={{14,18},{14,23},{32,23},{32,35},{24,35}},
              color={95,95,95},
              thickness=0.5));
          connect(Crank4.frame_b, CrankAngle2.frame_a) annotation (Line(
              points={{40.5,-84},{40.5,-90},{60,-90}},
              color={95,95,95},
              thickness=0.5));
          connect(Cylinder.support, gasForce.flange_b) annotation (Line(points={{20,103},
                  {34,103},{34,117},{50,117}},      color={0,191,0}));
          connect(Cylinder.axis, gasForce.flange_a)
            annotation (Line(points={{20,91},{50,91},{50,97}}, color={0,191,0}));
          connect(CylinderInclination.frame_b, CylinderTop.frame_a)
            annotation (Line(points={{-40,40},{-30,40},{-30,61}}));
          connect(Crank1.frame_b, Crank2.frame_a) annotation (Line(
              points={{-30,-90},{-10,-90},{-10,-86}},
              color={95,95,95},
              thickness=0.5));
          connect(Crank3.frame_b, Crank4.frame_a) annotation (Line(
              points={{24.5,-50},{40.5,-50},{40.5,-64}},
              color={95,95,95},
              thickness=0.5));
          connect(Crank3.frame_a, Crank2.frame_b) annotation (Line(
              points={{4.5,-50},{-10,-50},{-10,-66}},
              color={95,95,95},
              thickness=0.5));
          connect(Crank2.frame_b, Mid.frame_a) annotation (Line(
              points={{-10,-66},{-10,-36},{-6,-36}},
              color={95,95,95},
              thickness=0.5));
          connect(CylinderTop.frame_b, Cylinder.frame_a) annotation (Line(
              points={{-30,81},{-30,120},{14,120},{14,109}},
              color={95,95,95},
              thickness=0.5));
          connect(CylinderInclination.frame_a, cylinder_a) annotation (Line(
              points={{-60,40},{-80,40},{-80,130},{-100,130}},
              color={95,95,95},
              thickness=0.5));
          connect(Mounting.frame_a, cylinder_a) annotation (Line(
              points={{0,130},{-100,130}},
              color={95,95,95},
              thickness=0.5));
          connect(Mounting.frame_b, cylinder_b) annotation (Line(
              points={{20,130},{100,130}},
              color={95,95,95},
              thickness=0.5));
          connect(CrankAngle1.frame_a, crank_a) annotation (Line(
              points={{-90,-90},{-100,-90}},
              color={95,95,95},
              thickness=0.5));
          connect(CrankAngle2.frame_b, crank_b) annotation (Line(
              points={{80,-90},{100,-90}},
              color={95,95,95},
              thickness=0.5));

          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-150},{100,150}}), graphics={
                Polygon(
                  points={{-60,-50},{-60,100},{60,100},{60,-52},{100,-52},{100,150},{
                      -100,150},{-100,-50},{-60,-50}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-58,89},{58,13}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.VerticalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-60,81},{60,75}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-60,67},{60,61}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-60,55},{60,49}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-60,11},{-42,23},{38,23},{56,11},{-60,11}},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255}),
                Ellipse(
                  extent={{-6,41},{2,33}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(extent={{-40,-129},{40,-49}}, lineColor={192,192,192}),
                Line(
                  points={{0,-90},{26,-58},{-2,37}},
                  color={0,0,0},
                  thickness=1),
                Text(
                  extent={{-150,-125},{150,-165}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(
                  points={{-100,-90},{100,-91}},
                  color={0,0,0},
                  thickness=0.5)}));
        end Cylinder;

        model GasForce "Simple gas force computation for combustion engine"

          extends Modelica_Mechanics_Translational.Interfaces.PartialCompliant;
          parameter Modelica_SIunits.Length L "Length of cylinder";
          parameter Modelica_SIunits.Diameter d "Diameter of cylinder";
          parameter Modelica_SIunits.Volume k0=0.01
            "Volume V = k0 + k1*(1-x), with x = 1 + s_rel/L";
          parameter Modelica_SIunits.Volume k1=1
            "Volume V = k0 + k1*(1-x), with x = 1 + s_rel/L";
          parameter Modelica_SIunits.HeatCapacity k=1
            "Gas constant (p*V = k*T)";
          constant Real pi=Modelica_Constants.pi;

          // Only for compatibility reasons
          Real x "Normalized position of cylinder";
          Real y "Normalized relative movement (= -s_rel/L)";
          Modelica_SIunits.Density dens;
          Modelica_SIunits.Conversions.NonSIunits.Pressure_bar press
            "cylinder pressure";
          Modelica_SIunits.Volume V;
          Modelica_SIunits.Temperature T;
          Modelica_SIunits.Velocity v_rel;
        protected
          constant Modelica_SIunits.Mass unitMass=1;
          Modelica_SIunits.Pressure p;
        equation
          y = -s_rel/L;
          x = 1 + s_rel/L;
          v_rel = der(s_rel);

          press = p/1e5;
          p = (if v_rel < 0 then (if x < 0.987 then 177.4132*x^4 - 287.2189*x^3 +
            151.8252*x^2 - 24.9973*x + 2.4 else 2836360*x^4 - 10569296*x^3 + 14761814
            *x^2 - 9158505*x + 2129670) else (if x > 0.93 then -3929704*x^4 +
            14748765*x^3 - 20747000*x^2 + 12964477*x - 3036495 else 145.930*x^4 -
            131.707*x^3 + 17.3438*x^2 + 17.9272*x + 2.4))*1e5;

          f = -1.0E5*press*pi*d^2/4;

          V = k0 + k1*(1 - x);
          dens = unitMass/V;
          (p/1e5)*V = k*T;
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-90,50},{90,-50}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-40,50},{-20,-50}},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255}),
                Rectangle(
                  extent={{-90,10},{-40,-10}},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255}),
                Polygon(
                  points={{60,2},{54,2},{0,2},{0,10},{-20,0},{0,-10},{0,-4},{60,-4},{
                      60,2}},
                  lineColor={255,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-100,120},{100,60}},
                  textString="%name",
                  lineColor={0,0,255})}),                         Diagram(
                coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                  extent={{-90,50},{90,-50}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-40,50},{-20,-50}},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255}),
                Rectangle(
                  extent={{-90,10},{-40,-10}},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255}),
                Polygon(
                  points={{60,2},{54,2},{0,2},{0,10},{-20,0},{0,-10},{0,-4},{60,-4},{
                      60,2}},
                  lineColor={255,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-100,120},{100,60}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end GasForce;

        model GasForce2 "Rough approximation of gas force in a cylinder"

          extends Modelica_Mechanics_Translational.Interfaces.PartialCompliant;
          parameter Modelica_SIunits.Length L "Length of cylinder";
          parameter Modelica_SIunits.Length d "diameter of cylinder";
          parameter Modelica_SIunits.Volume k0=0.01
            "Volume V = k0 + k1*(1-x), with x = 1 - s_rel/L";
          parameter Modelica_SIunits.Volume k1=1
            "Volume V = k0 + k1*(1-x), with x = 1 - s_rel/L";
          parameter Modelica_SIunits.HeatCapacity k=1
            "Gas constant (p*V = k*T)";

        /*
  parameter Real k0=0.01;
  parameter Real k1=1;
  parameter Real k=1;
*/
          constant Real pi=Modelica_Constants.pi;
          Real x "Normalized position of cylinder (= 1 - s_rel/L)";
          Modelica_SIunits.Density dens;
          Modelica_SIunits.AbsolutePressure press "Cylinder pressure";
          Modelica_SIunits.Volume V;
          Modelica_SIunits.Temperature T;
          Modelica_SIunits.Velocity v_rel;

        protected
          Modelica_SIunits.SpecificHeatCapacity R_air=Modelica_Constants.R  /0.0289651159;
        equation
          x = 1 - s_rel/L;
          v_rel = der(s_rel);

          press = 1.0E5*(if v_rel < 0 then (if x < 0.987 then 177.4132*x^4 - 287.2189*x^3 +
            151.8252*x^2 - 24.9973*x + 2.4 else 2836360*x^4 - 10569296*x^3 + 14761814
            *x^2 - 9158505*x + 2129670) else (if x > 0.93 then -3929704*x^4 +
            14748765*x^3 - 20747000*x^2 + 12964477*x - 3036495 else 145.930*x^4 -
            131.707*x^3 + 17.3438*x^2 + 17.9272*x + 2.4));

          f = -press*pi*d^2/4;

          V = k0 + k1*(1 - x);
          dens = press/(R_air*T);
          press*V = k*T;

          assert(s_rel >= -1.e-12, "flange_b.s - flange_a.s (= " + String(s_rel,
            significantDigits=14) + ") >= 0 required for GasForce component.\n" +
            "Most likely, the component has to be flipped.");
          assert(s_rel <= L + 1.e-12, " flange_b.s - flange_a.s (= " + String(s_rel,
            significantDigits=14) + ") <= L (= " + String(L, significantDigits=14) +
            ") required for GasForce component.\n" +
            "Most likely, parameter L is not correct.");
          annotation (Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-90,50},{90,-50}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-13,4},{-16,4},{-65,4},{-65,15},{-90,0},{-65,-15},{-65,-4},
                      {-13,-4},{-13,4}},
                  lineColor={255,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-135,44},{-99,19}},
                  lineColor={128,128,128},
                  textString="a"),
                Text(
                  extent={{97,40},{133,15}},
                  lineColor={128,128,128},
                  textString="b"),
                Polygon(
                  points={{12,4},{70,4},{65,4},{65,15},{90,0},{65,-15},{65,-4},{12,-4},
                      {12,4}},
                  lineColor={255,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,105},{150,65}},
                  textString="%name",
                  lineColor={0,0,255})}),                         Diagram(
                coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-90,50},{90,-50}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{12,5},{70,5},{65,5},{65,16},{90,1},{65,-14},{65,-3},{12,-3},
                      {12,5}},
                  lineColor={255,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-13,5},{-16,5},{-65,5},{-65,16},{-90,1},{-65,-14},{-65,-3},
                      {-13,-3},{-13,5}},
                  lineColor={255,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
The gas force in a cylinder is computed as function of the relative
distance of the two flanges. It is required that s_rel = flange_b.s - flange_a.s
is in the range
</p>
<pre>
    0 &le; s_rel &le; L
</pre>
<p>
where the parameter L is the length
of the cylinder. If this assumption is not fulfilled, an error occurs.
</p>
</html>"));
        end GasForce2;

        model CylinderBase
          "One cylinder with analytic handling of kinematic loop"
          parameter Boolean animation=true
            "= true, if animation shall be enabled";
          parameter Modelica_SIunits.Length cylinderTopPosition=0.42
            "Length from crank shaft to end of cylinder.";
          parameter Modelica_SIunits.Length crankLength=0.14
            "Length of crank shaft in x direction";
          parameter Modelica_SIunits.Length crankPinOffset=0.05
            "Offset of crank pin from center axis";
          parameter Modelica_SIunits.Length crankPinLength=0.1
            "Offset of crank pin from center axis";
          parameter Cv.NonSIunits.Angle_deg cylinderInclination=0
            "Inclination of cylinder";
          parameter Cv.NonSIunits.Angle_deg crankAngleOffset=0
            "Offset for crank angle";
          parameter Modelica_SIunits.Length pistonLength=0.1
            "Length of cylinder" annotation (Dialog(group="Piston"));
          parameter Modelica_SIunits.Length pistonCenterOfMass=pistonLength/2
            "Distance from frame_a to center of mass of piston"
            annotation (Dialog(group="Piston"));
          parameter Modelica_SIunits.Mass pistonMass(min=0) = 6
            "Mass of piston" annotation (Dialog(group="Piston"));
          parameter Modelica_SIunits.Inertia pistonInertia_11(min=0) = 0.0088
            "Inertia 11 of piston with respect to center of mass frame, parallel to frame_a"
            annotation (Dialog(group="Piston"));
          parameter Modelica_SIunits.Inertia pistonInertia_22(min=0) = 0.0076
            "Inertia 22 of piston with respect to center of mass frame, parallel to frame_a"
            annotation (Dialog(group="Piston"));
          parameter Modelica_SIunits.Inertia pistonInertia_33(min=0) = 0.0088
            "Inertia 33 of piston with respect to center of mass frame, parallel to frame_a"
            annotation (Dialog(group="Piston"));

          parameter Modelica_SIunits.Length rodLength=0.175 "Length of rod"
            annotation (Dialog(group="Rod"));
          parameter Modelica_SIunits.Length rodCenterOfMass=rodLength/2
            "Distance from frame_a to center of mass of piston"
            annotation (Dialog(group="Rod"));
          parameter Modelica_SIunits.Mass rodMass(min=0) = 1 "Mass of rod"
            annotation (Dialog(group="Rod"));
          parameter Modelica_SIunits.Inertia rodInertia_11(min=0) = 0.006
            "Inertia 11 of rod with respect to center of mass frame, parallel to frame_a"
            annotation (Dialog(group="Rod"));
          parameter Modelica_SIunits.Inertia rodInertia_22(min=0) = 0.0005
            "Inertia 22 of rod with respect to center of mass frame, parallel to frame_a"
            annotation (Dialog(group="Rod"));
          parameter Modelica_SIunits.Inertia rodInertia_33(min=0) = 0.006
            "Inertia 33 of rod with respect to center of mass frame, parallel to frame_a"
            annotation (Dialog(group="Rod"));
          final parameter Modelica_SIunits.Length cylinderLength=
              cylinderTopPosition - (pistonLength + rodLength - crankPinOffset)
            "Maximum length of cylinder volume";

          Modelica_Mechanics_MultiBody.Parts.FixedTranslation Mid(animation=
                false, r={crankLength - crankPinLength/2,crankPinOffset,0})
            annotation (Placement(transformation(extent={{-44,-30},{-24,-10}},
                  rotation=0)));
          Modelica_Mechanics_MultiBody.Parts.FixedTranslation Mounting(r={
                crankLength,0,0}, animation=false) annotation (Placement(
                transformation(extent={{-3,90},{17,110}}, rotation=0)));
          Modelica_Mechanics_MultiBody.Parts.FixedRotation CylinderInclination(
            r={crankLength - crankPinLength/2,0,0},
            animation=false,
            rotationType=Types.RotationTypes.RotationAxis,
            n={1,0,0},
            angle=cylinderInclination) annotation (Placement(transformation(
                  extent={{-44,30},{-24,50}}, rotation=0)));
          Modelica_Mechanics_MultiBody.Parts.FixedRotation CrankAngle(
            animation=false,
            rotationType=Types.RotationTypes.RotationAxis,
            n={1,0,0},
            angle=crankAngleOffset) annotation (Placement(transformation(extent=
                   {{-84,-80},{-64,-60}}, rotation=0)));
          Joints.Assemblies.JointRRP jointRRP(
            n_a={1,0,0},
            n_b={0,-1,0},
            rRod1_ia={0,rodLength,0},
            animation=false,
            rRod2_ib=-{0,pistonLength,0},
            s_offset=-cylinderTopPosition)
            annotation (Placement(transformation(
                origin={0,12},
                extent={{-20,20},{20,-20}},
                rotation=90)));
          Modelica_Mechanics_MultiBody.Parts.BodyShape Rod(
            animation=animation,
            r={0,rodLength,0},
            r_CM={0,rodLength/2,0},
            shapeType=
                "modelica://Modelica/Resources/Data/Shapes/Engine/rod.dxf",
            lengthDirection={1,0,0},
            widthDirection={0,0,-1},
            length=rodLength/1.75,
            width=rodLength/1.75,
            height=rodLength/1.75,
            color={155,155,155},
            extra=1,
            r_shape={0,0,0},
            animateSphere=false,
            m=rodMass,
            I_11=rodInertia_11,
            I_22=rodInertia_22,
            I_33=rodInertia_33) annotation (Placement(transformation(
                origin={49,9},
                extent={{-10,-10},{10,10}},
                rotation=90)));
          Modelica_Mechanics_MultiBody.Parts.BodyShape Piston(
            animation=animation,
            r={0,pistonLength,0},
            r_CM={0,pistonLength/2,0},
            shapeType=
                "modelica://Modelica/Resources/Data/Shapes/Engine/piston.dxf",
            length=0.08,
            width=0.08,
            height=0.08,
            extra=1,
            lengthDirection={1,0,0},
            widthDirection={0,0,-1},
            color={180,180,180},
            animateSphere=false,
            m=pistonMass,
            I_11=pistonInertia_11,
            I_22=pistonInertia_22,
            I_33=pistonInertia_33) annotation (Placement(transformation(
                origin={50,50},
                extent={{10,-10},{-10,10}},
                rotation=270)));
          GasForce gasForce(L=cylinderLength, d=0.1)
            annotation (Placement(transformation(
                origin={-1,70},
                extent={{-10,-10},{10,10}},
                rotation=180)));

          Modelica_Mechanics_MultiBody.Parts.FixedTranslation Crank(animation=
                false, r={crankLength,0,0}) annotation (Placement(
                transformation(extent={{-10,-110},{10,-90}}, rotation=0)));
          Interfaces.Frame_a cylinder_a annotation (Placement(transformation(extent={{-116,84},
                    {-84,116}},           rotation=0)));
          Interfaces.Frame_a cylinder_b annotation (Placement(transformation(extent={{84,84},
                    {116,116}},         rotation=0)));
          Interfaces.Frame_a crank_a annotation (Placement(transformation(extent={{-116,
                    -116},{-84,-84}},      rotation=0)));
          Interfaces.Frame_a crank_b annotation (Placement(transformation(extent={{84,-116},
                    {116,-84}},       rotation=0)));
        equation

          connect(jointRRP.frame_ia, Rod.frame_a) annotation (Line(
              points={{20,-4},{49,-4},{49,-1}},
              color={95,95,95},
              thickness=0.5));
          connect(Mid.frame_b, jointRRP.frame_a) annotation (Line(
              points={{-24,-20},{0,-20},{0,-8}},
              color={95,95,95},
              thickness=0.5));
          connect(gasForce.flange_a, jointRRP.axis)
            annotation (Line(points={{9,70},{16,70},{16,32}}, color={0,191,0}));
          connect(jointRRP.bearing, gasForce.flange_b) annotation (Line(points={{8,32},{
                  8,52},{-20,52},{-20,70},{-11,70}},  color={0,191,0}));
          connect(jointRRP.frame_ib, Piston.frame_b) annotation (Line(
              points={{20,28},{30,28},{30,70},{50,70},{50,60}},
              color={95,95,95},
              thickness=0.5));
          connect(jointRRP.frame_b, CylinderInclination.frame_b) annotation (Line(
              points={{0,32},{1,32},{1,40},{-24,40}},
              color={95,95,95},
              thickness=0.5));
          connect(CrankAngle.frame_b, Mid.frame_a) annotation (Line(
              points={{-64,-70},{-56,-70},{-56,-20},{-44,-20}},
              color={95,95,95},
              thickness=0.5));
          connect(cylinder_a, CylinderInclination.frame_a) annotation (Line(
              points={{-100,100},{-70,100},{-70,40},{-44,40}},
              color={95,95,95},
              thickness=0.5));
          connect(cylinder_a, Mounting.frame_a) annotation (Line(
              points={{-100,100},{-3,100}},
              color={95,95,95},
              thickness=0.5));
          connect(cylinder_b, Mounting.frame_b) annotation (Line(
              points={{100,100},{17,100}},
              color={95,95,95},
              thickness=0.5));
          connect(CrankAngle.frame_a, crank_a) annotation (Line(
              points={{-84,-70},{-89.5,-70},{-89.5,-100},{-100,-100}},
              color={95,95,95},
              thickness=0.5));
          connect(crank_a, Crank.frame_a) annotation (Line(
              points={{-100,-100},{-10,-100}},
              color={95,95,95},
              thickness=0.5));
          connect(Crank.frame_b, crank_b) annotation (Line(
              points={{10,-100},{100,-100}},
              color={95,95,95},
              thickness=0.5));
          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
                Polygon(
                  points={{-60,-61},{-60,64},{60,64},{60,-61},{100,-61},{100,114},{-100,
                      114},{-100,-61},{-60,-61}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-58,63},{58,-13}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.VerticalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-60,55},{60,49}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-60,41},{60,35}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-60,29},{60,23}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-57,-13},{-39,-1},{41,-1},{59,-13},{-57,-13}},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255}),
                Ellipse(
                  extent={{-6,15},{2,7}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(extent={{-41,-139},{39,-59}}, lineColor={192,192,192}),
                Line(
                  points={{-1,-99},{25,-67},{-2,10}},
                  color={0,0,0},
                  thickness=1),
                Text(
                  extent={{-156,178},{158,116}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(
                  points={{-100,-99},{100,-100}},
                  color={0,0,0},
                  thickness=0.5)}));
        end CylinderBase;

        model Cylinder_analytic_CAD
          "One cylinder with analytic handling of kinematic loop and CAD visualization"
          extends CylinderBase;
          Visualizers.FixedShape CrankShape(
            animation=animation,
            shapeType="modelica://Modelica/Resources/Data/Shapes/Engine/crank.dxf",
            lengthDirection={1,0,0},
            extra=1,
            widthDirection={0,1,0},
            length=crankPinOffset/0.5,
            width=crankPinOffset/0.5,
            height=crankPinOffset/0.5,
            r_shape={crankLength - crankPinLength/2 - 0.002,0,0})
            annotation (Placement(transformation(
                origin={-10,-70},
                extent={{10,10},{-10,-10}},
                rotation=180)));
        equation

          connect(CrankShape.frame_a, CrankAngle.frame_b)
            annotation (Line(
              points={{-20,-70},{-64,-70}},
              color={95,95,95},
              thickness=0.5));
        end Cylinder_analytic_CAD;

        model EngineV6_analytic "V6 engine with analytic loop handling"
          parameter Boolean animation=true
            "= true, if animation shall be enabled";
          replaceable model Cylinder = Cylinder_analytic_CAD constrainedby
            CylinderBase "Cylinder type"
               annotation (choices(choice(redeclare model Cylinder =
                  M_S_L.Mechanics.MultiBody.Examples.Loops.Utilities.Cylinder_analytic_CAD
                  "Analytic loop handling + CAD animation"),
                                                           choice(redeclare
                  model Cylinder =
                    M_S_L.Mechanics.MultiBody.Examples.Loops.Utilities.Cylinder_analytic
                  "Analytic loop handling + standard animation")));

          Cylinder cylinder1(
            crankAngleOffset=-30,
            cylinderInclination=-30,
            animation=animation) annotation (Placement(transformation(extent={{-90,
                    -10},{-70,10}}, rotation=0)));
          Cylinder cylinder2(
            crankAngleOffset=90,
            cylinderInclination=30,
            animation=animation) annotation (Placement(transformation(extent={{-60,
                    -10},{-40,10}}, rotation=0)));
          Cylinder cylinder3(
            cylinderInclination=-30,
            animation=animation,
            crankAngleOffset=210)
                                 annotation (Placement(transformation(extent={{-30,
                    -10},{-10,10}}, rotation=0)));
          Cylinder cylinder4(
            cylinderInclination=30,
            animation=animation,
            crankAngleOffset=210)
                                 annotation (Placement(transformation(extent={{0,-10},
                    {20,10}}, rotation=0)));
          Cylinder cylinder5(
            cylinderInclination=-30,
            animation=animation,
            crankAngleOffset=90) annotation (Placement(transformation(extent={{30,-10},
                    {50,10}}, rotation=0)));
          Cylinder cylinder6(
            cylinderInclination=30,
            animation=animation,
            crankAngleOffset=-30)
                                 annotation (Placement(transformation(extent={{60,-10},
                    {80,10}}, rotation=0)));
          Joints.Revolute bearing(useAxisFlange=true,
            n={1,0,0},
            cylinderLength=0.02,
            cylinderDiameter=0.06,
            animation=true) annotation (Placement(transformation(extent={{-90,-40},{
                    -70,-60}}, rotation=0)));
          Parts.BodyShape crank(
            animation=false,
            r={0,0,0},
            r_CM={6*0.1/2,0,0},
            I_22=1.e-5,
            I_33=1.e-5,
            m=6*30,
            I_11=0.1) annotation (Placement(transformation(extent={{-50,-60},{-30,-40}},
                  rotation=0)));
          Modelica_Mechanics_Rotational.Interfaces.Flange_b flange_b
            annotation (Placement(transformation(extent={{100,-10},{120,10}},
                  rotation=0)));
          Interfaces.Frame_a frame_a
            annotation (Placement(transformation(
                origin={0,-101},
                extent={{-16,-16},{16,16}},
                rotation=270)));
        equation
          connect(cylinder1.crank_b, cylinder2.crank_a)
            annotation (Line(
              points={{-70,-10},{-60,-10}},
              color={95,95,95},
              thickness=0.5));
          connect(cylinder2.cylinder_a, cylinder1.cylinder_b) annotation (Line(
              points={{-60,10},{-70,10}},
              color={95,95,95},
              thickness=0.5));
          connect(cylinder3.cylinder_a, cylinder2.cylinder_b) annotation (Line(
              points={{-30,10},{-40,10}},
              color={95,95,95},
              thickness=0.5));
          connect(cylinder3.crank_a, cylinder2.crank_b)
            annotation (Line(
              points={{-30,-10},{-40,-10}},
              color={95,95,95},
              thickness=0.5));
          connect(cylinder3.cylinder_b, cylinder4.cylinder_a) annotation (Line(
              points={{-10,10},{0,10}},
              color={95,95,95},
              thickness=0.5));
          connect(cylinder3.crank_b, cylinder4.crank_a)
            annotation (Line(
              points={{-10,-10},{0,-10}},
              color={95,95,95},
              thickness=0.5));
          connect(cylinder4.cylinder_b, cylinder5.cylinder_a) annotation (Line(
              points={{20,10},{30,10}},
              color={95,95,95},
              thickness=0.5));
          connect(cylinder4.crank_b, cylinder5.crank_a)
            annotation (Line(
              points={{20,-10},{30,-10}},
              color={95,95,95},
              thickness=0.5));
          connect(cylinder5.cylinder_b, cylinder6.cylinder_a) annotation (Line(
              points={{50,10},{60,10}},
              color={95,95,95},
              thickness=0.5));
          connect(cylinder5.crank_b, cylinder6.crank_a)
            annotation (Line(
              points={{50,-10},{60,-10}},
              color={95,95,95},
              thickness=0.5));
          connect(bearing.frame_b, crank.frame_a)
            annotation (Line(
              points={{-70,-50},{-50,-50}},
              color={95,95,95},
              thickness=0.5));
          connect(crank.frame_b, cylinder1.crank_a) annotation (Line(
              points={{-30,-50},{-24,-50},{-24,-26},{-94,-26},{-94,-10},{-90,-10}},
              color={95,95,95},
              thickness=0.5));
          connect(bearing.axis, flange_b) annotation (Line(points={{-80,-60},{-80,-66},
                  {90,-66},{90,0},{110,0}}, color={0,0,0}));
          connect(frame_a, bearing.frame_a) annotation (Line(
              points={{0,-101},{0,-81},{-98,-81},{-98,-50},{-90,-50}},
              color={95,95,95},
              thickness=0.5));
          connect(bearing.frame_a, cylinder1.cylinder_a) annotation (Line(
              points={{-90,-50},{-98,-50},{-98,10},{-90,10}},
              color={95,95,95},
              thickness=0.5));
          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,145},{150,105}},
                  lineColor={0,0,255},
                  textString="%name"),
                Bitmap(extent={{-97,75},{99,-39}}, fileName=
                      "modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/EngineV6_CAD.png")}));
        end EngineV6_analytic;

        partial model Engine1bBase
          "Model of one cylinder engine with gas force"

          Modelica_Mechanics_MultiBody.Parts.BodyCylinder Piston(diameter=0.1,
              r={0,-0.1,0}) annotation (Placement(transformation(
                origin={120,53},
                extent={{-10,30},{10,-30}},
                rotation=270)));
          Modelica_Mechanics_MultiBody.Parts.BodyBox Rod2(
            widthDirection={1,0,0},
            width=0.02,
            height=0.06,
            color={0,0,200},
            r={0,0.2,0}) annotation (Placement(transformation(
                origin={120,10},
                extent={{-10,-10},{10,10}},
                rotation=90)));
          Modelica_Mechanics_MultiBody.Joints.Revolute Bearing(
            useAxisFlange=true,
            n={1,0,0},
            cylinderLength=0.02,
            cylinderDiameter=0.05) annotation (Placement(transformation(extent=
                    {{-50,-80},{-30,-100}}, rotation=0)));
          inner Modelica_Mechanics_MultiBody.World world annotation (Placement(
                transformation(extent={{-90,-100},{-70,-80}}, rotation=0)));
          Modelica_Mechanics_Rotational.Components.Inertia Inertia(
            stateSelect=StateSelect.always,
            J=0.1,
            w(fixed=true),
            phi(
              fixed=true,
              start=0.001,
              displayUnit="rad"))              annotation (Placement(transformation(
                  extent={{-68,-120},{-48,-100}}, rotation=0)));
          Modelica_Mechanics_MultiBody.Parts.BodyBox Crank4(
            height=0.05,
            widthDirection={1,0,0},
            width=0.02,
            r={0,-0.1,0}) annotation (Placement(transformation(
                origin={75.5,-75},
                extent={{10,-10},{-10,10}},
                rotation=90)));
          Modelica_Mechanics_MultiBody.Parts.BodyCylinder Crank3(r={0.1,0,0},
              diameter=0.03) annotation (Placement(transformation(extent={{41.5,
                    -71},{61.5,-51}}, rotation=0)));
          Modelica_Mechanics_MultiBody.Parts.BodyCylinder Crank1(diameter=0.05,
              r={0.1,0,0}) annotation (Placement(transformation(extent={{-16,-100},
                    {4,-80}}, rotation=0)));
          Modelica_Mechanics_MultiBody.Parts.BodyBox Crank2(
            height=0.05,
            widthDirection={1,0,0},
            width=0.02,
            r={0,0.1,0}) annotation (Placement(transformation(
                origin={30,-76},
                extent={{-10,-10},{10,10}},
                rotation=90)));
          Modelica_Mechanics_MultiBody.Parts.FixedTranslation Mid(r={0.05,0,0})
            annotation (Placement(transformation(extent={{30,-53},{50,-33}},
                  rotation=0)));
          Modelica_Mechanics_MultiBody.Parts.FixedTranslation cylPosition(animation=
               false, r={0.15,0.55,0}) annotation (Placement(transformation(
                  extent={{-40.5,100},{-20.5,120}}, rotation=0)));
          Utilities.GasForce2 gasForce(        d=0.1, L=0.35)
            annotation (Placement(transformation(
                origin={119,97},
                extent={{10,-10},{-10,10}},
                rotation=90)));
        equation
          connect(world.frame_b, Bearing.frame_a)
            annotation (Line(
              points={{-70,-90},{-50,-90}},
              color={95,95,95},
              thickness=0.5));
          connect(Crank2.frame_a, Crank1.frame_b) annotation (Line(
              points={{30,-86},{30,-90},{4,-90}},
              color={95,95,95},
              thickness=0.5));
          connect(Crank2.frame_b, Crank3.frame_a) annotation (Line(
              points={{30,-66},{30,-61},{41.5,-61}},
              color={95,95,95},
              thickness=0.5));
          connect(Bearing.frame_b, Crank1.frame_a) annotation (Line(
              points={{-30,-90},{-16,-90}},
              color={95,95,95},
              thickness=0.5));
          connect(world.frame_b, cylPosition.frame_a) annotation (Line(
              points={{-70,-90},{-60,-90},{-60,110},{-40.5,110}},
              color={95,95,95},
              thickness=0.5));
          connect(Crank3.frame_b, Crank4.frame_a) annotation (Line(
              points={{61.5,-61},{75,-61},{75,-65},{75.5,-65}},
              color={95,95,95},
              thickness=0.5));
          connect(Inertia.flange_b, Bearing.axis) annotation (Line(
              points={{-48,-110},{-40,-110},{-40,-100}},
              color={0,0,0}));
          connect(Mid.frame_a, Crank2.frame_b) annotation (Line(
              points={{30,-43},{23,-43},{23,-61},{30,-61},{30,-66}},
              color={95,95,95},
              thickness=0.5));
          annotation (
            Documentation(info="<html>
<p>
This is a model of the mechanical part of one cylinder of an engine.
The combustion is not modelled. The \"inertia\" component at the lower
left part is the output inertia of the engine driving the gearbox.
The angular velocity of the output inertia has a start value of 10 rad/s
in order to demonstrate the movement of the engine.
</p>
<p>
The engine is modeled solely by revolute and prismatic joints.
Since this results in a <b>planar</b> loop there is the well known
difficulty that the cut-forces perpendicular to the loop cannot be
uniquely computed, as well as the cut-torques within the plane.
This ambiguity is resolved by using the option <b>planarCutJoint</b>
in the <b>Advanced</b> menu of one revolute joint in every planar loop
(here: joint B1). This option sets the cut-force in direction of the
axis of rotation, as well as the cut-torques perpendicular to the axis
of rotation at this joint to zero and makes the problem mathematically
well-formed.
</p>
<p>
An animation of this example is shown in the figure below.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/Engine.png\" ALT=\"model Examples.Loops.Engine\">
</html>"));
        end Engine1bBase;
      end Utilities;
    annotation ( Documentation(info="<html>
<p>
This package contains different examples to show how
mechanical systems with kinematic loops can be modeled.
</p>
<h4>Content</h4>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><b><i>Model</i></b></th><th><b><i>Description</i></b></th></tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Engine1a\">Engine1a</a><br>
             <a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b\">Engine1b</a><br>
             <a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b_analytic\">Engine1b_analytic</a></td>
      <td valign=\"top\"> Model of one cylinder engine (Engine1a: simple, without combustion; Engine1b: with combustion;
           Engine1b_analytic: same as Engine1b but analytic loop handling)<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/Engine.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6\">EngineV6</a><br>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6_analytic\">EngineV6_analytic</a></td>
      <td valign=\"top\"> V6 engine with 6 cylinders, 6 planar loops and 1 degree-of-freedom.
           Second version with analytic handling of kinematic loops and CAD data
           animation.<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/EngineV6_small.png\">
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/EngineV6_CAD_smaller.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar1\">Fourbar1</a></td>
      <td valign=\"top\"> One kinematic loop with four bars (with only revolute joints;
           5 non-linear equations)<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/Fourbar1_small.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar2\">Fourbar2</a></td>
      <td valign=\"top\"> One kinematic loop with four bars (with UniversalSpherical
           joint; 1 non-linear equation) <br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/Fourbar2_small.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar_analytic\">Fourbar_analytic</a></td>
      <td valign=\"top\"> One kinematic loop with four bars (with JointSSP joint;
           analytic solution of non-linear algebraic loop)  <br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/Fourbar_analytic_small.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Loops.PlanarLoops_analytic\">PlanarLoops_analytic</a></td>
      <td valign=\"top\"> Mechanism with three planar kinematic loops and one
           degree-of-freedom with analytic loop handling
           (with JointRRR joints) <br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Loops/PlanarLoops_small.png\">
      </td>
  </tr>
</table>
</html>"));
    end Loops;

    package Rotational3DEffects
      "Demonstrates the usage of 1-dim. rotational elements with all 3-dim. effects included"
      extends Modelica_Icons.ExamplesPackage;

      model GyroscopicEffects
        "Demonstrates that a cylindrical body can be replaced by Rotor1D model"
        extends Modelica_Icons.Example;

        inner World world(driveTrainMechanics3D=true) annotation (Placement(
              transformation(extent={{-100,20},{-80,40}}, rotation=0)));
        Joints.Spherical spherical1(
          angles_fixed=true,
          w_rel_a_fixed=true,
          z_rel_a_fixed=false) annotation (Placement(transformation(extent={{-70,20},
                  {-50,40}}, rotation=0)));
        Parts.BodyCylinder bodyCylinder1(r={0.25,0,0}, diameter=0.05) annotation (
            Placement(transformation(extent={{-44,20},{-24,40}}, rotation=0)));
        Parts.FixedRotation fixedRotation1(angle=45, n={0,1,0}) annotation (
            Placement(transformation(extent={{-16,20},{4,40}}, rotation=0)));
        Joints.Revolute revolute(
          n={1,0,0},
          a(fixed=false),
          phi(fixed=true),
          w(fixed=true, start=10)) annotation (Placement(transformation(extent={{14,
                  20},{34,40}}, rotation=0)));
        Parts.FixedTranslation fixedTranslation(r={-0.1,0,0}) annotation (Placement(
              transformation(extent={{42,20},{62,40}}, rotation=0)));
        Parts.BodyCylinder bodyCylinder2(diameter=0.1, r={0.2,0,0}) annotation (
            Placement(transformation(extent={{70,20},{90,40}}, rotation=0)));
        Parts.Fixed fixed annotation (Placement(transformation(extent={{-100,-40},{
                  -80,-20}}, rotation=0)));
        Joints.Spherical spherical2(
          angles_fixed=true,
          w_rel_a_fixed=true,
          z_rel_a_fixed=false) annotation (Placement(transformation(extent={{-70,-40},
                  {-50,-20}}, rotation=0)));
        Parts.BodyCylinder bodyCylinder3(
          r={0.25,0,0},
          diameter=0.05,
          color={0,128,0}) annotation (Placement(transformation(extent={{-44,-40},{
                  -24,-20}}, rotation=0)));
        Parts.FixedRotation fixedRotation2(n={0,1,0}, angle=45) annotation (
            Placement(transformation(extent={{-16,-40},{4,-20}}, rotation=0)));
        Parts.FixedTranslation fixedTranslation1(r={-0.1,0,0}) annotation (
            Placement(transformation(extent={{24,-40},{44,-20}}, rotation=0)));
        Parts.BodyCylinder bodyCylinder4(
          diameter=0.1,
          r={0.2,0,0},
          color={0,128,0}) annotation (Placement(transformation(extent={{56,-40},{
                  76,-20}}, rotation=0)));
        Parts.Rotor1D rotor1D(
          J=bodyCylinder4.I[1, 1],
          n={1,0,0},
          a(fixed=false),
          phi(fixed=true),
          w(fixed=true, start=10)) annotation (Placement(transformation(extent={{28,
                  -70},{48,-50}}, rotation=0)));
      equation
        connect(world.frame_b, spherical1.frame_a) annotation (Line(
            points={{-80,30},{-70,30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(spherical1.frame_b, bodyCylinder1.frame_a) annotation (Line(
            points={{-50,30},{-44,30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyCylinder1.frame_b, fixedRotation1.frame_a) annotation (Line(
            points={{-24,30},{-16,30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedRotation1.frame_b, revolute.frame_a) annotation (Line(
            points={{4,30},{14,30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(revolute.frame_b, fixedTranslation.frame_a) annotation (Line(
            points={{34,30},{42,30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation.frame_b, bodyCylinder2.frame_a) annotation (Line(
            points={{62,30},{70,30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(spherical2.frame_b, bodyCylinder3.frame_a) annotation (Line(
            points={{-50,-30},{-44,-30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyCylinder3.frame_b, fixedRotation2.frame_a) annotation (Line(
            points={{-24,-30},{-16,-30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixed.frame_b, spherical2.frame_a) annotation (Line(
            points={{-80,-30},{-70,-30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation1.frame_b, bodyCylinder4.frame_a) annotation (Line(
            points={{44,-30},{56,-30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedRotation2.frame_b, fixedTranslation1.frame_a) annotation (Line(
            points={{4,-30},{24,-30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(rotor1D.frame_a, fixedRotation2.frame_b) annotation (Line(
            points={{38,-70},{38,-76},{10,-76},{10,-30},{4,-30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (experiment(StopTime=5, Tolerance=1e-008), Documentation(info="<html>
<p>
This example consists of a body that is attached to the world system
with a spherical joint. On this body, a \"rotor\", i.e., a body with rotational
symmetry is present. Two kinds of models are shown:
</p>

<ul>
<li> In the upper part of the diagram layer, only multi-body components are used.</li>
<li> In the lower part of the diagram layer, the same model is implemented,
     but by a different modeling of the cylindrical body:
     The cylindrical body is included, but it is rigidly attached to its mount.
     This part takes into account the movement of the center of mass and of
     the inertia tensor of the cylindrical body. Note, since the cylindrical body
     has rotational symmetry, its center of mass and its inertia tensor is independent
     of the angle of the inertia and can therefore be rigidly attached to its mount.
     Additionally, with a \"MultiBody.Parts.Rotor1D\" model, a primarily 1-dim.
     inertia is included that takes into account the additional effects when the
     cylindrical body is moving relatively to its mounts</li>
</ul>

<p>
The simulation reveals that both the kinematic movement and the reaction forces on the
environment (object \"world\" and \"fixed\" respectively) are identical for both models.
</p>

<p>
A typical usage scenario is to model a complete drive train of a vehicle, including
the automatic gearbox, with elements of the \"Mechanics.Rotational\" library, but using
the \"Rotor1D\" model instead of the \"Rotational.Components.Inertia\" component.
This drive train model can be mounted on a 3-dim. multi-body model of the vehicle.
Additionally, one rigid body has to be fixed to the vehicle that has the mass, center
of mass and inertia tensor of the complete drive train. Both models together, give
exactly the same effect, as if every part of the drive train would have been modelled
solely with mult-body components. One benefit of this modeling is that the simulation
is much faster.
</p>

</html>"));
      end GyroscopicEffects;

      model ActuatedDrive
        extends Modelica_Icons.Example;
        Parts.BodyShape bodyCylinder(
          r={0.5,0,0},
          m=0,
          I_11=2,
          I_22=0,
          I_33=0,
          shapeType="cylinder",
          width=0.1,
          animateSphere=false,
          r_shape={0.1,0,0},
          r_CM={0,0,0}) annotation (Placement(transformation(extent={{8,0},{28,20}},
                rotation=0)));
        Joints.Revolute revolute(
          n={1,0,0},
          a(fixed=false),
          phi(fixed=true),
          w(fixed=true)) annotation (Placement(transformation(extent={{-26,0},{-6,
                  20}}, rotation=0)));
        inner World world(g=0, driveTrainMechanics3D=true) annotation (Placement(
              transformation(extent={{-60,0},{-40,20}}, rotation=0)));
        Forces.Torque torque annotation (Placement(transformation(extent={{8,30},{
                  28,50}}, rotation=0)));
        Modelica_Blocks.Sources.Sine sine[3](amplitude={1,0,0}, freqHz={1,1,1})
          annotation (Placement(transformation(extent={{-80,60},{-60,80}},
                rotation=0)));
        inner Parts.Fixed fixed annotation (Placement(transformation(extent={{-62,-90},
                  {-42,-70}}, rotation=0)));
        Parts.Rotor1D rotor1D(
          J=2,
          phi(fixed=true),
          w(fixed=true)) annotation (Placement(transformation(extent={{0,-40},{20,-20}},
                rotation=0)));
        Modelica_Mechanics_Rotational.Sources.Torque torque1(useSupport=true)
          annotation (Placement(transformation(extent={{-32,-40},{-12,-20}},
                rotation=0)));
        Parts.Mounting1D mounting1D annotation (Placement(transformation(extent={{-46,
                  -60},{-26,-40}}, rotation=0)));
      equation
        connect(world.frame_b, revolute.frame_a) annotation (Line(
            points={{-40,10},{-26,10}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(revolute.frame_b, bodyCylinder.frame_a) annotation (Line(
            points={{-6,10},{8,10}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(torque.frame_b, bodyCylinder.frame_b) annotation (Line(
            points={{28,40},{38,40},{38,10},{28,10}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(torque.frame_resolve, world.frame_b) annotation (Line(
            points={{22,50},{22,64},{-30,64},{-30,10},{-40,10}},
            color={95,95,95},
            pattern=LinePattern.Dot,
            smooth=Smooth.None));
        connect(torque.frame_a, world.frame_b) annotation (Line(
            points={{8,40},{-30,40},{-30,10},{-40,10}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sine.y, torque.torque) annotation (Line(
            points={{-59,70},{12,70},{12,52}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(fixed.frame_b, rotor1D.frame_a) annotation (Line(
            points={{-42,-80},{10,-80},{10,-40}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(torque1.flange, rotor1D.flange_a) annotation (Line(
            points={{-12,-30},{0,-30}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(mounting1D.flange_b, torque1.support) annotation (Line(
            points={{-26,-50},{-22,-50},{-22,-40}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(mounting1D.frame_a, fixed.frame_b) annotation (Line(
            points={{-36,-60},{-36,-80},{-42,-80}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sine[1].y, torque1.tau) annotation (Line(
            points={{-59,70},{-50,70},{-50,40},{-72,40},{-72,-30},{-34,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (experiment(StopTime=1.1));
      end ActuatedDrive;

      model MovingActuatedDrive
        extends Modelica_Icons.Example;
        Parts.BodyShape bodyCylinder(
          r={0.5,0,0},
          m=0,
          I_11=2,
          I_22=0,
          I_33=0,
          shapeType="cylinder",
          width=0.1,
          animateSphere=false,
          r_shape={0.1,0,0},
          r_CM={0,0,0}) annotation (Placement(transformation(extent={{50,10},{70,30}},
                rotation=0)));
        Joints.Revolute revolute(
          n={1,0,0},
          a(fixed=false),
          phi(fixed=true),
          w(fixed=true)) annotation (Placement(transformation(extent={{16,10},{36,
                  30}}, rotation=0)));
        inner World world(g=0, driveTrainMechanics3D=true) annotation (Placement(
              transformation(extent={{-84,10},{-64,30}}, rotation=0)));
        Forces.Torque torque annotation (Placement(transformation(extent={{50,40},{
                  70,60}}, rotation=0)));
        Modelica_Blocks.Sources.Sine sine1[3](amplitude={1,0,0}, freqHz={1,1,1})
          annotation (Placement(transformation(extent={{16,70},{36,90}},
                rotation=0)));
        Parts.Rotor1D rotor1D(
          J=2,
          phi(fixed=true),
          w(fixed=true)) annotation (Placement(transformation(extent={{50,-36},{70,
                  -16}}, rotation=0)));
        Modelica_Mechanics_Rotational.Sources.Torque torque1(useSupport=true)
          annotation (Placement(transformation(extent={{18,-36},{38,-16}},
                rotation=0)));
        Parts.Mounting1D mounting1D annotation (Placement(transformation(extent={{4,
                  -56},{24,-36}}, rotation=0)));
        Joints.Revolute r1(useAxisFlange=true, n={0,1,0}) annotation (Placement(
              transformation(extent={{-32,10},{-12,30}}, rotation=0)));
        Modelica_Mechanics_Rotational.Sources.Position position1(useSupport=
              true, w(fixed=true)) annotation (Placement(transformation(extent=
                  {{-46,60},{-26,80}}, rotation=0)));
        Modelica_Blocks.Sources.Sine sine2(amplitude=2, freqHz=1) annotation (
            Placement(transformation(extent={{-100,60},{-80,80}}, rotation=0)));
        Parts.Mounting1D mounting1D1(n={0,1,0})
                                     annotation (Placement(transformation(extent={{
                  -60,34},{-40,54}}, rotation=0)));
        Joints.Revolute r2(useAxisFlange=true, n={0,1,0}) annotation (Placement(
              transformation(extent={{-38,-80},{-18,-60}}, rotation=0)));
        Modelica_Mechanics_Rotational.Sources.Position position2(useSupport=
              true, w(fixed=true)) annotation (Placement(transformation(extent=
                  {{-52,-30},{-32,-10}}, rotation=0)));
        Parts.Mounting1D mounting1D2(n={0,1,0})
                                     annotation (Placement(transformation(extent={{
                  -66,-56},{-46,-36}}, rotation=0)));
        Parts.Fixed fixed annotation (Placement(transformation(extent={{-86,-80},{-66,
                  -60}}, rotation=0)));
      equation
        connect(revolute.frame_b, bodyCylinder.frame_a) annotation (Line(
            points={{36,20},{50,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(torque.frame_b, bodyCylinder.frame_b) annotation (Line(
            points={{70,50},{80,50},{80,20},{70,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sine1.y, torque.torque) annotation (Line(
            points={{37,80},{54,80},{54,62}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(torque1.flange, rotor1D.flange_a) annotation (Line(
            points={{38,-26},{50,-26}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(mounting1D.flange_b, torque1.support) annotation (Line(
            points={{24,-46},{28,-46},{28,-36}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(r1.frame_a, world.frame_b) annotation (Line(
            points={{-32,20},{-64,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(position1.flange, r1.axis) annotation (Line(
            points={{-26,70},{-22,70},{-22,30}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(position1.support, mounting1D1.flange_b) annotation (Line(
            points={{-36,60},{-36,44},{-40,44}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(mounting1D1.frame_a, world.frame_b) annotation (Line(
            points={{-50,34},{-50,20},{-64,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sine2.y, position1.phi_ref) annotation (Line(
            points={{-79,70},{-48,70}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(r1.frame_b, revolute.frame_a) annotation (Line(
            points={{-12,20},{16,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(torque.frame_resolve, revolute.frame_a) annotation (Line(
            points={{64,60},{8,60},{8,20},{16,20}},
            color={95,95,95},
            pattern=LinePattern.Dot,
            smooth=Smooth.None));
        connect(torque.frame_a, revolute.frame_a) annotation (Line(
            points={{50,50},{8,50},{8,20},{16,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(position2.flange, r2.axis) annotation (Line(
            points={{-32,-20},{-28,-20},{-28,-60}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(position2.support, mounting1D2.flange_b) annotation (Line(
            points={{-42,-30},{-42,-46},{-46,-46}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(fixed.frame_b, r2.frame_a) annotation (Line(
            points={{-66,-70},{-38,-70}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixed.frame_b, mounting1D2.frame_a) annotation (Line(
            points={{-66,-70},{-56,-70},{-56,-56}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sine2.y, position2.phi_ref) annotation (Line(
            points={{-79,70},{-70,70},{-70,46},{-92,46},{-92,-20},{-54,-20}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(r2.frame_b, rotor1D.frame_a) annotation (Line(
            points={{-18,-70},{60,-70},{60,-36}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(r2.frame_b, mounting1D.frame_a) annotation (Line(
            points={{-18,-70},{14,-70},{14,-56}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sine1[1].y, torque1.tau) annotation (Line(
            points={{37,80},{92,80},{92,-10},{0,-10},{0,-26},{16,-26}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (experiment(StopTime=1.1),
          Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}}), graphics),
          Documentation(info="<html>
<p>
This model demonstrates how a moving drive train modelled with 3-dim. multi-body elements
(revolute, bodyCylinder) can alternatively be modeled with component rotor1D to speed up
simulation. The movement of the two systems is identical and also the cut-torques in the
various frames (such as: r1.frame_b.t and r2.frame_b.t).
</p>

<p>
The driving joints (r1, r2) with rotation axis {0,1,0} are modelled to be driven by a motor torque
along the {1,0,0} axis. Basically, this means that an idealized bevel gear is used to drive the
axes of the revolute joints.
</p>
</html>"));
      end MovingActuatedDrive;

      model GearConstraint
        extends Modelica_Icons.Example;
        Joints.GearConstraint gearConstraint(
          ratio=10,
          phi_b(fixed=true),
          w_b(fixed=true)) annotation (Placement(transformation(extent={{34,40},{54,
                  60}}, rotation=0)));
        inner World world(driveTrainMechanics3D=true, g=0) annotation (Placement(
              transformation(extent={{-62,10},{-42,30}}, rotation=0)));
        Parts.BodyCylinder cyl1(
          diameter=0.1,
          color={0,128,0},
          r={0.4,0,0}) annotation (Placement(transformation(extent={{2,40},{22,60}},
                rotation=0)));
        Parts.BodyCylinder cyl2(r={0.4,0,0}, diameter=0.2) annotation (Placement(
              transformation(extent={{70,40},{90,60}}, rotation=0)));
        Forces.Torque torque1 annotation (Placement(transformation(extent={{-26,40},
                  {-6,60}}, rotation=0)));
        Modelica_Blocks.Sources.Sine sine[3](amplitude={2,0,0}, freqHz={1,1,1})
          annotation (Placement(transformation(extent={{-100,60},{-80,80}},
                rotation=0)));
        Parts.Fixed fixed annotation (Placement(transformation(extent={{-48,-90},{-28,
                  -70}}, rotation=0)));
        Modelica_Mechanics_Rotational.Components.Inertia inertia1(
          J=cyl1.I[1, 1],
          a(fixed=false),
          phi(fixed=true, start=0),
          w(fixed=true, start=0)) annotation (Placement(transformation(extent={
                  {-20,-40},{0,-20}}, rotation=0)));
        Modelica_Mechanics_Rotational.Components.IdealGear idealGear(ratio=10,
            useSupport=true) annotation (Placement(transformation(extent={{12,-40},
                  {32,-20}}, rotation=0)));
        Modelica_Mechanics_Rotational.Components.Inertia inertia2(J=cyl2.I[1, 1])
          annotation (Placement(transformation(extent={{44,-40},{64,-20}},
                rotation=0)));
        Modelica_Mechanics_Rotational.Sources.Torque torque2(useSupport=true)
          annotation (Placement(transformation(extent={{-48,-40},{-28,-20}},
                rotation=0)));
        Parts.Mounting1D mounting1D annotation (Placement(transformation(extent={{-20,
                  -70},{0,-50}}, rotation=0)));
      equation
        connect(world.frame_b, gearConstraint.bearing) annotation (Line(
            points={{-42,20},{44,20},{44,40}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(cyl1.frame_b, gearConstraint.frame_a) annotation (Line(
            points={{22,50},{34,50}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(gearConstraint.frame_b, cyl2.frame_a) annotation (Line(
            points={{54,50},{70,50}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(torque1.frame_b, cyl1.frame_a) annotation (Line(
            points={{-6,50},{2,50}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(torque1.frame_a, world.frame_b) annotation (Line(
            points={{-26,50},{-36,50},{-36,20},{-42,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sine.y, torque1.torque) annotation (Line(
            points={{-79,70},{-22,70},{-22,62}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(inertia1.flange_b, idealGear.flange_a) annotation (Line(
            points={{0,-30},{12,-30}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(idealGear.flange_b, inertia2.flange_a) annotation (Line(
            points={{32,-30},{44,-30}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(torque2.flange, inertia1.flange_a) annotation (Line(
            points={{-28,-30},{-20,-30}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(sine[1].y, torque2.tau) annotation (Line(
            points={{-79,70},{-72,70},{-72,-30},{-50,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(mounting1D.flange_b, idealGear.support) annotation (Line(
            points={{0,-60},{22,-60},{22,-40}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(mounting1D.flange_b, torque2.support) annotation (Line(
            points={{0,-60},{4,-60},{4,-48},{-38,-48},{-38,-40}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(fixed.frame_b, mounting1D.frame_a) annotation (Line(
            points={{-28,-80},{-10,-80},{-10,-70}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (experiment(StopTime=5));
      end GearConstraint;
      annotation (Documentation(info="<html>
<p>
This library demonstrates the usage of elements of the Mechanics.Rotational library
by taking into account all 3-dim. effects. The reason for this type of modeling is
to speedup the simulation drastically. This is possible if moving bodies have
rotational symmetry. A typical application area are drive trains, driving joints of
a multi-body system.
</p>
</html>"));
    end Rotational3DEffects;

    package Constraints "Examples with constraint joints"
    extends Modelica_Icons.ExamplesPackage;

      model PrismaticConstraint
        "Body attached by one spring and two prismatic joints or constrained to environment"
        extends Modelica_Icons.Example;
        parameter Boolean animation=true "True, if animation shall be enabled";

        Joints.Prismatic jointPrismatic_x(stateSelect=StateSelect.never, n={1,0,0},
          s(fixed=true),
          v(fixed=true))
          annotation (Placement(transformation(extent={{80,-30},{60,-10}})));
        Joints.Prismatic jointPrismatic_y(stateSelect=StateSelect.never, n={0,1,0},
          s(fixed=true),
          v(fixed=true))
          annotation (Placement(transformation(extent={{40,-30},{20,-10}})));
        Joints.Constraints.Prismatic constraint(x_locked=false, y_locked=
              false)
          annotation (Placement(transformation(extent={{60,10},{40,30}})));
        Modelica_Mechanics_MultiBody.Sensors.RelativeSensor sensorConstraintRelative(
          resolveInFrame=Types.ResolveInFrameAB.frame_a,
          get_r_rel=true,
          get_a_rel=false,
          get_angles=true)
          annotation (Placement(transformation(extent={{60,60},{40,40}})));
        Modelica_Mechanics_MultiBody.Parts.BodyShape bodyOfJoint(
          m=1,
          I_11=1,
          I_22=1,
          I_33=1,
          r={0.4,0,0},
          r_CM={0.2,0,0},
          width=0.05,
          r_0(start={0.2,-0.5,0.1}, each fixed=false),
          v_0(each fixed=false),
          angles_fixed=false,
          w_0_fixed=false,
          angles_start={0.17453292519943,0.95993108859688,1.1868238913561},
          final color={0,0,255}) annotation (Placement(transformation(
              extent={{-10,10},{10,-10}},
              rotation=180,
              origin={-10,-20})));
        Modelica_Mechanics_MultiBody.Parts.BodyShape bodyOfConstraint(
          I_11=1,
          I_22=1,
          I_33=1,
          width=0.05,
          w_0_fixed=false,
          final color={0,128,0},
          r=bodyOfJoint.r,
          r_CM=bodyOfJoint.r_CM,
          m=bodyOfJoint.m,
          angles_fixed=false,
          angles_start={0.17453292519943,0.95993108859688,1.1868238913561})
          annotation (Placement(transformation(
              extent={{-10,10},{10,-10}},
              rotation=180,
              origin={-10,20})));
        Modelica_Mechanics_MultiBody.Forces.Spring springOfJoint(
          c=20,
          s_unstretched=0,
          width=0.1,
          coilWidth=0.005,
          numberOfWindings=5) annotation (Placement(transformation(
              origin={-50,-20},
              extent={{-10,-10},{10,10}},
              rotation=0)));
        Modelica_Mechanics_MultiBody.Forces.Spring springOfConstraint(
          width=0.1,
          coilWidth=0.005,
          c=springOfJoint.c,
          s_unstretched=springOfJoint.s_unstretched,
          numberOfWindings=springOfJoint.numberOfWindings) annotation (
            Placement(transformation(
              origin={-50,20},
              extent={{-10,-10},{10,10}},
              rotation=0)));
        inner Modelica_Mechanics_MultiBody.World world annotation (Placement(
              transformation(extent={{-100,-100},{-80,-80}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedRotation fixedRotation(
          r={0.2,-0.3,0.2},
          rotationType=Types.RotationTypes.PlanarRotationSequence,
          angles={10,55,68}) annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={90,-50})));

        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation(animation=
             false, r={0.8,0,0.3}) annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-70,-50})));
        Joints.FreeMotionScalarInit freeMotionScalarInit(
          use_r=true,
          use_v=true,
          v_rel_a_2(fixed=true, start=0),
          v_rel_a_3(fixed=true, start=0),
          use_w=true,
          w_rel_b_1(fixed=false),
          w_rel_b_2(fixed=false),
          w_rel_b_3(fixed=false),
          angle_d_3(fixed=false),
          r_rel_a_2(fixed=true, start=0),
          r_rel_a_3(fixed=true, start=0),
          angle_1(fixed=false))
          annotation (Placement(transformation(extent={{40,60},{20,80}})));
      equation
        connect(fixedTranslation.frame_a, world.frame_b)
          annotation (Line(
            points={{-70,-60},{-70,-90},{-80,-90}},
            color={95,95,95},
            thickness=0.5));
        connect(bodyOfConstraint.frame_b, springOfConstraint.frame_b)
                                               annotation (Line(
            points={{-20,20},{-40,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(world.frame_b, fixedRotation.frame_a) annotation (Line(
            points={{-80,-90},{90,-90},{90,-60}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedRotation.frame_b, constraint.frame_a) annotation (Line(
            points={{90,-40},{90,20},{60,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(constraint.frame_a,sensorConstraintRelative. frame_a)
                                                            annotation (Line(
            points={{60,20},{70,20},{70,50},{60,50}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyOfJoint.frame_b, springOfJoint.frame_b)
                                               annotation (Line(
            points={{-20,-20},{-40,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sensorConstraintRelative.frame_b, constraint.frame_b) annotation (
            Line(
            points={{40,50},{30,50},{30,20},{40,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation.frame_b, springOfJoint.frame_a)
                                                    annotation (Line(
            points={{-70,-40},{-70,-20},{-60,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation.frame_b, springOfConstraint.frame_a)
                                                         annotation (Line(
            points={{-70,-40},{-70,20},{-60,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyOfConstraint.frame_a, constraint.frame_b) annotation (Line(
            points={{0,20},{40,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(jointPrismatic_x.frame_b, jointPrismatic_y.frame_a)
                                                        annotation (Line(
            points={{60,-20},{40,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedRotation.frame_b, jointPrismatic_x.frame_a) annotation (Line(
            points={{90,-40},{90,-20},{80,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyOfJoint.frame_a, jointPrismatic_y.frame_b) annotation (Line(
            points={{0,-20},{20,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(freeMotionScalarInit.frame_a, fixedRotation.frame_b) annotation (
            Line(
            points={{40,70},{90,70},{90,-40}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(freeMotionScalarInit.frame_b, bodyOfConstraint.frame_a) annotation (
           Line(
            points={{20,70},{10,70},{10,20},{0,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (
          experiment(StopTime=10),
          Documentation(info="<html>
<p>This example demonstrates the functionality of <b>constraint</b> representing <b>prismatic joint</b>. Each of two bodies is at one of its end connected by spring to the world. The other end is also connected to the world either by two serial coupled prismatic joints or by appropriate constraint. Therefore, the body can only perform translation in two directions specified in the two joints depending on working forces.</p>
<p><b>Simulation results</b> </p>
<p>After simulating the model, see the animation of the multibody system and compare movement of body connected by joint (blue colored) with movement of that one connected by constraint (of green color). Additionally, the outputs from <code>sensorConstraintRelative</code> depict both position and angle deviations in the constraining element.</p>
</html>"));
      end PrismaticConstraint;

      model RevoluteConstraint
        "Body attached by one spring and revolute joint or constrained to environment"
        extends Modelica_Icons.Example;
        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        Modelica_Mechanics_MultiBody.Joints.Revolute joint(
          stateSelect=StateSelect.never,
          n={0,1,0},
          phi(fixed=true),
          w(fixed=true))
          annotation (Placement(transformation(extent={{60,-30},{40,-10}})));
        Joints.Constraints.Revolute constraint(n=joint.n)
          annotation (Placement(transformation(extent={{60,10},{40,30}})));
        Modelica_Mechanics_MultiBody.Sensors.RelativeSensor sensorConstraintRelative(
          resolveInFrame=Types.ResolveInFrameAB.frame_a,
          get_r_rel=true,
          get_a_rel=false,
          get_angles=true)
          annotation (Placement(transformation(extent={{60,60},{40,40}})));
        Modelica_Mechanics_MultiBody.Parts.BodyShape bodyOfJoint(
          m=1,
          I_11=1,
          I_22=1,
          I_33=1,
          r={0.4,0,0},
          r_CM={0.2,0,0},
          width=0.05,
          r_0(start={0.2,-0.5,0.1}, each fixed=false),
          v_0(each fixed=false),
          angles_fixed=false,
          w_0_fixed=false,
          angles_start={0.17453292519943,0.95993108859688,1.1868238913561},
          final color={0,0,255}) annotation (Placement(transformation(
              extent={{-10,10},{10,-10}},
              rotation=180,
              origin={-10,-20})));
        Modelica_Mechanics_MultiBody.Parts.BodyShape bodyOfConstraint(
          I_11=1,
          I_22=1,
          I_33=1,
          width=0.05,
          r_0(start={0.2,-0.5,0.1}, each fixed=false),
          v_0(each fixed=false),
          angles_fixed=false,
          w_0_fixed=false,
          final color={0,128,0},
          r=bodyOfJoint.r,
          r_CM=bodyOfJoint.r_CM,
          m=bodyOfJoint.m,
          angles_start={0.17453292519943,0.95993108859688,1.1868238913561})
          annotation (Placement(transformation(
              extent={{-10,10},{10,-10}},
              rotation=180,
              origin={-10,20})));
        Modelica_Mechanics_MultiBody.Forces.Spring springOfJoint(
          c=20,
          s_unstretched=0,
          width=0.1,
          coilWidth=0.005,
          numberOfWindings=5) annotation (Placement(transformation(
              origin={-50,-20},
              extent={{-10,-10},{10,10}},
              rotation=0)));
        Modelica_Mechanics_MultiBody.Forces.Spring springOfConstraint(
          width=0.1,
          coilWidth=0.005,
          c=springOfJoint.c,
          s_unstretched=springOfJoint.s_unstretched,
          numberOfWindings=springOfJoint.numberOfWindings) annotation (
            Placement(transformation(
              origin={-50,20},
              extent={{-10,-10},{10,10}},
              rotation=0)));
        inner Modelica_Mechanics_MultiBody.World world annotation (Placement(
              transformation(extent={{-100,-100},{-80,-80}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedRotation fixedRotation(
          r={0.2,-0.3,0.2},
          rotationType=Types.RotationTypes.PlanarRotationSequence,
          angles={10,55,68}) annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={80,-50})));

        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation(animation=
             false, r={0.8,0,0.3}) annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-70,-50})));
        Joints.FreeMotionScalarInit freeMotionScalarInit(
          use_angle=true,
          use_angle_d=true,
          angle_2(start=0, fixed=true),
          angle_d_2(start=0, fixed=true))
          annotation (Placement(transformation(extent={{40,60},{20,80}})));
      equation
        connect(fixedTranslation.frame_a, world.frame_b)
          annotation (Line(
            points={{-70,-60},{-70,-90},{-80,-90}},
            color={95,95,95},
            thickness=0.5));
        connect(bodyOfConstraint.frame_b, springOfConstraint.frame_b)
                                               annotation (Line(
            points={{-20,20},{-40,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(world.frame_b, fixedRotation.frame_a) annotation (Line(
            points={{-80,-90},{80,-90},{80,-60}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedRotation.frame_b, constraint.frame_a) annotation (Line(
            points={{80,-40},{80,20},{60,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(constraint.frame_a,sensorConstraintRelative. frame_a)
                                                            annotation (Line(
            points={{60,20},{80,20},{80,50},{60,50}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyOfJoint.frame_b, springOfJoint.frame_b)
                                               annotation (Line(
            points={{-20,-20},{-40,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(joint.frame_b, bodyOfJoint.frame_a)                annotation (
            Line(
            points={{40,-20},{0,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sensorConstraintRelative.frame_b, constraint.frame_b) annotation (
            Line(
            points={{40,50},{30,50},{30,20},{40,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation.frame_b, springOfJoint.frame_a)
                                                    annotation (Line(
            points={{-70,-40},{-70,-20},{-60,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation.frame_b, springOfConstraint.frame_a)
                                                         annotation (Line(
            points={{-70,-40},{-70,20},{-60,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyOfConstraint.frame_a, constraint.frame_b) annotation (Line(
            points={{0,20},{40,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(joint.frame_a, fixedRotation.frame_b)  annotation (Line(
            points={{60,-20},{80,-20},{80,-40}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(freeMotionScalarInit.frame_a, fixedRotation.frame_b) annotation (
            Line(
            points={{40,70},{80,70},{80,-40}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyOfConstraint.frame_a, freeMotionScalarInit.frame_b) annotation (
           Line(
            points={{0,20},{8,20},{8,70},{20,70}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (
          experiment(StopTime=10),
          Documentation(info="<html>
<p>This example demonstrates the functionality of <b>constraint</b> representing <b>revolute joint</b>. Each of two bodies is at one of its end connected by spring to the world. The other end is also connected to the world either by revolute joint or by appropriate constraint. Therefore, the body can only perform rotation about the revolute axis depending on working forces.</p>
<p><b>Simulation results</b> </p>
<p>After simulating the model, see the animation of the multibody system and compare movement of body connected by joint (blue colored) with movement of that one connected by constraint (of green color). Additionally, the outputs from <code>sensorConstraintRelative</code> depict both position and angle deviations in the constraining element.</p>
</html>"));
      end RevoluteConstraint;

      model SphericalConstraint
        "Body attached by one spring and spherical joint or constrained to environment"
        extends Modelica_Icons.Example;
        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        Joints.Spherical joint(
          angles_fixed=true,
          w_rel_a_fixed=true,
          enforceStates=true)
          annotation (Placement(transformation(extent={{60,-30},{40,-10}})));
        Joints.Constraints.Spherical constraint
          annotation (Placement(transformation(extent={{60,10},{40,30}})));
        Modelica_Mechanics_MultiBody.Sensors.RelativeSensor sensorConstraintRelative(
          resolveInFrame=Types.ResolveInFrameAB.frame_a,
          get_r_rel=true,
          get_a_rel=false,
          get_angles=true)
          annotation (Placement(transformation(extent={{60,60},{40,40}})));
        Modelica_Mechanics_MultiBody.Parts.BodyShape bodyOfJoint(
          m=1,
          I_11=1,
          I_22=1,
          I_33=1,
          r={0.4,0,0},
          r_CM={0.2,0,0},
          width=0.05,
          r_0(start={0.2,-0.5,0.1}, each fixed=false),
          v_0(each fixed=false),
          angles_fixed=false,
          w_0_fixed=false,
          angles_start={0.17453292519943,0.95993108859688,1.1868238913561},
          final color={0,0,255}) annotation (Placement(transformation(
              extent={{-10,10},{10,-10}},
              rotation=180,
              origin={-10,-20})));
        Modelica_Mechanics_MultiBody.Parts.BodyShape bodyOfConstraint(
          I_11=1,
          I_22=1,
          I_33=1,
          width=0.05,
          r_0(start={0.2,-0.5,0.1}, each fixed=false),
          v_0(each fixed=false),
          angles_fixed=false,
          w_0_fixed=false,
          final color={0,128,0},
          r=bodyOfJoint.r,
          r_CM=bodyOfJoint.r_CM,
          m=bodyOfJoint.m,
          angles_start={0.17453292519943,0.95993108859688,1.1868238913561})
          annotation (Placement(transformation(
              extent={{-10,10},{10,-10}},
              rotation=180,
              origin={-10,20})));
        Modelica_Mechanics_MultiBody.Forces.Spring springOfJoint(
          c=20,
          s_unstretched=0,
          width=0.1,
          coilWidth=0.005,
          numberOfWindings=5) annotation (Placement(transformation(
              origin={-50,-20},
              extent={{-10,-10},{10,10}},
              rotation=0)));
        Modelica_Mechanics_MultiBody.Forces.Spring springOfConstraint(
          width=0.1,
          coilWidth=0.005,
          c=springOfJoint.c,
          s_unstretched=springOfJoint.s_unstretched,
          numberOfWindings=springOfJoint.numberOfWindings) annotation (
            Placement(transformation(
              origin={-50,20},
              extent={{-10,-10},{10,10}},
              rotation=0)));
        inner Modelica_Mechanics_MultiBody.World world annotation (Placement(
              transformation(extent={{-100,-100},{-80,-80}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedRotation fixedRotation(
          r={0.2,-0.3,0.2},
          rotationType=Types.RotationTypes.PlanarRotationSequence,
          angles={10,55,68}) annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={80,-50})));

        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation(animation=
             false, r={0.8,0,0.3}) annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-70,-50})));
        Joints.FreeMotionScalarInit freeMotionScalarInit(
          use_angle=true,
          use_angle_d=true,
          angle_1(fixed=true),
          angle_2(fixed=true),
          angle_3(fixed=true),
          angle_d_1(fixed=true),
          angle_d_2(fixed=true),
          angle_d_3(fixed=true))
          annotation (Placement(transformation(extent={{38,60},{18,80}})));
      equation
        connect(fixedTranslation.frame_a, world.frame_b)
          annotation (Line(
            points={{-70,-60},{-70,-90},{-80,-90}},
            color={95,95,95},
            thickness=0.5));
        connect(bodyOfConstraint.frame_b, springOfConstraint.frame_b)
                                               annotation (Line(
            points={{-20,20},{-40,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(world.frame_b, fixedRotation.frame_a) annotation (Line(
            points={{-80,-90},{80,-90},{80,-60}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedRotation.frame_b, constraint.frame_a) annotation (Line(
            points={{80,-40},{80,20},{60,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(constraint.frame_a,sensorConstraintRelative. frame_a)
                                                            annotation (Line(
            points={{60,20},{80,20},{80,50},{60,50}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyOfJoint.frame_b, springOfJoint.frame_b)
                                               annotation (Line(
            points={{-20,-20},{-40,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(joint.frame_b, bodyOfJoint.frame_a)                annotation (
            Line(
            points={{40,-20},{0,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sensorConstraintRelative.frame_b, constraint.frame_b) annotation (
            Line(
            points={{40,50},{30,50},{30,20},{40,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation.frame_b, springOfJoint.frame_a)
                                                    annotation (Line(
            points={{-70,-40},{-70,-20},{-60,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation.frame_b, springOfConstraint.frame_a)
                                                         annotation (Line(
            points={{-70,-40},{-70,20},{-60,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyOfConstraint.frame_a, constraint.frame_b) annotation (Line(
            points={{0,20},{40,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(joint.frame_a, fixedRotation.frame_b)  annotation (Line(
            points={{60,-20},{80,-20},{80,-40}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyOfConstraint.frame_a, freeMotionScalarInit.frame_b) annotation (
           Line(
            points={{0,20},{8,20},{8,70},{18,70}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(freeMotionScalarInit.frame_a, fixedRotation.frame_b) annotation (
            Line(
            points={{38,70},{80,70},{80,-40}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (
          experiment(StopTime=10),
          Documentation(info="<html>
<p>This example demonstrates the functionality of <b>constraint</b> representing <b>spherical joint</b>. Each of two bodies is at one of its end connected by spring to the world. The other end is also connected to the world either by spherical joint or by appropriate constraint. Therefore, the body can only perform spherical movement depending on working forces.</p>
<p><b>Simulation results</b> </p>
<p>After simulating the model, see the animation of the multibody system and compare movement of body connected by joint (blue colored) with movement of that one connected by constraint (of green color). Additionally, the outputs from <code>sensorConstraintRelative</code> depict position deviations in the constraining element.</p>
</html>"));
      end SphericalConstraint;

      model UniversalConstraint
        "Body attached by one spring and universal joint or constrained to environment"
        extends Modelica_Icons.Example;
        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        Joints.Universal joint(
          n_a={0,0,1},
          n_b={1,0,0},
          stateSelect=StateSelect.always,
          phi_a(fixed=true),
          phi_b(fixed=true),
          w_a(fixed=true),
          w_b(fixed=true))
          annotation (Placement(transformation(extent={{60,-30},{40,-10}})));
        Joints.Constraints.Universal constraint(n_a=joint.n_a, n_b=joint.n_b)
          annotation (Placement(transformation(extent={{60,10},{40,30}})));
        Modelica_Mechanics_MultiBody.Sensors.RelativeSensor sensorConstraintRelative(
          resolveInFrame=Types.ResolveInFrameAB.frame_a,
          get_r_rel=true,
          get_a_rel=false,
          get_angles=true,
          sequence={3,2,1})
          annotation (Placement(transformation(extent={{60,60},{40,40}})));
        Modelica_Mechanics_MultiBody.Parts.BodyShape bodyOfJoint(
          m=1,
          I_11=1,
          I_22=1,
          I_33=1,
          r={0.4,0,0},
          r_CM={0.2,0,0},
          width=0.05,
          r_0(start={0.2,-0.5,0.1}, each fixed=false),
          v_0(each fixed=false),
          angles_fixed=false,
          w_0_fixed=false,
          angles_start={0.17453292519943,0.95993108859688,1.1868238913561},
          final color={0,0,255}) annotation (Placement(transformation(
              extent={{-10,10},{10,-10}},
              rotation=180,
              origin={10,-20})));
        Modelica_Mechanics_MultiBody.Parts.BodyShape bodyOfConstraint(
          I_11=1,
          I_22=1,
          I_33=1,
          width=0.05,
          r_0(start={0.2,-0.5,0.1}, each fixed=false),
          v_0(each fixed=false),
          angles_fixed=false,
          w_0_fixed=false,
          final color={0,128,0},
          r=bodyOfJoint.r,
          r_CM=bodyOfJoint.r_CM,
          m=bodyOfJoint.m,
          angles_start={0.17453292519943,0.95993108859688,1.1868238913561})
          annotation (Placement(transformation(
              extent={{-10,10},{10,-10}},
              rotation=180,
              origin={10,20})));
        Modelica_Mechanics_MultiBody.Forces.Spring springOfJoint(
          c=20,
          s_unstretched=0,
          width=0.1,
          coilWidth=0.005,
          numberOfWindings=5) annotation (Placement(transformation(
              origin={-50,-20},
              extent={{-10,-10},{10,10}},
              rotation=0)));
        Modelica_Mechanics_MultiBody.Forces.Spring springOfConstraint(
          width=0.1,
          coilWidth=0.005,
          c=springOfJoint.c,
          s_unstretched=springOfJoint.s_unstretched,
          numberOfWindings=springOfJoint.numberOfWindings) annotation (
            Placement(transformation(
              origin={-50,20},
              extent={{-10,-10},{10,10}},
              rotation=0)));
        inner Modelica_Mechanics_MultiBody.World world annotation (Placement(
              transformation(extent={{-100,-100},{-80,-80}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedRotation fixedRotation(
          r={0.2,-0.3,0.2},
          rotationType=Types.RotationTypes.PlanarRotationSequence,
          angles={10,55,68}) annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={80,-50})));

        Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation(animation=
             false, r={0.8,0,0.3}) annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-70,-50})));
        Parts.FixedTranslation fixedTranslationOfJoint(r={0.1,0.15,0.2})
          annotation (Placement(transformation(extent={{-10,-30},{-30,-10}})));
        Parts.FixedTranslation fixedTranslationOfConstraint(r=fixedTranslationOfJoint.r)
          annotation (Placement(transformation(extent={{-10,10},{-30,30}})));
        Joints.FreeMotionScalarInit freeMotionScalarInit(
          use_angle=true,
          use_angle_d=true,
          angle_1(fixed=true),
          angle_3(fixed=true),
          angle_d_1(fixed=true),
          angle_d_3(fixed=true),
          sequence_start={1,2,3})
          annotation (Placement(transformation(extent={{60,70},{40,90}})));
      equation
        connect(fixedTranslation.frame_a, world.frame_b)
          annotation (Line(
            points={{-70,-60},{-70,-90},{-80,-90}},
            color={95,95,95},
            thickness=0.5));
        connect(world.frame_b, fixedRotation.frame_a) annotation (Line(
            points={{-80,-90},{80,-90},{80,-60}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedRotation.frame_b, constraint.frame_a) annotation (Line(
            points={{80,-40},{80,20},{60,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(constraint.frame_a,sensorConstraintRelative. frame_a)
                                                            annotation (Line(
            points={{60,20},{80,20},{80,50},{60,50}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(joint.frame_b, bodyOfJoint.frame_a)                annotation (
            Line(
            points={{40,-20},{20,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sensorConstraintRelative.frame_b, constraint.frame_b) annotation (
            Line(
            points={{40,50},{30,50},{30,20},{40,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation.frame_b, springOfJoint.frame_a)
                                                    annotation (Line(
            points={{-70,-40},{-70,-20},{-60,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation.frame_b, springOfConstraint.frame_a)
                                                         annotation (Line(
            points={{-70,-40},{-70,20},{-60,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyOfConstraint.frame_a, constraint.frame_b) annotation (Line(
            points={{20,20},{40,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(joint.frame_a, fixedRotation.frame_b)  annotation (Line(
            points={{60,-20},{80,-20},{80,-40}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyOfJoint.frame_b, fixedTranslationOfJoint.frame_a) annotation (
            Line(
            points={{0,-20},{-10,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyOfConstraint.frame_b, fixedTranslationOfConstraint.frame_a)
          annotation (Line(
            points={{0,20},{-10,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(springOfJoint.frame_b, fixedTranslationOfJoint.frame_b) annotation (
            Line(
            points={{-40,-20},{-30,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(springOfConstraint.frame_b, fixedTranslationOfConstraint.frame_b)
          annotation (Line(
            points={{-40,20},{-30,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedRotation.frame_b, freeMotionScalarInit.frame_a) annotation (
            Line(
            points={{80,-40},{80,80},{60,80}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyOfConstraint.frame_a, freeMotionScalarInit.frame_b) annotation (
           Line(
            points={{20,20},{30,20},{30,80},{40,80}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (
          experiment(StopTime=10),
          Documentation(info="<html>
<p>This example demonstrates the functionality of <b>constraint</b> representing <b>universal joint</b>. Each of two bodies is at one of its end connected by spring to the world. The other end is also connected to the world either by universal joint or by appropriate constraint. Therefore, the body can only perform rotation about two revolute axes depending on working forces.</p>
<p><b>Simulation results</b> </p>
<p>After simulating the model, see the animation of the multibody system and compare movement of body connected by joint (blue colored) with movement of that one connected by constraint (of green color). Additionally, the outputs from <code>sensorConstraintRelative</code> depict position deviations in the constraining element.</p>
</html>"));
      end UniversalConstraint;
      annotation (Documentation(info="<html>
<p>This package is a collection of simulatable models involving constraints in a multibody system.
  The examples mainly show comparison of constraints to the standard joints.</p>

</html>"));
    end Constraints;

    package Systems
      "Examples of complete system models including 3-dimensional mechanics"
    extends Modelica_Icons.ExamplesPackage;

      package RobotR3
        "Library to demonstrate robot system models based on the Manutec r3 robot"

        model oneAxis
          "Model of one axis of robot (controller, motor, gearbox) with simple load"

          extends Modelica_Icons.Example;
          parameter Modelica_SIunits.Mass mLoad(min=0) = 15 "Mass of load";
          parameter Real kp=5 "Gain of position controller of axis 2";
          parameter Real ks=0.5 "Gain of speed controller of axis 2";
          parameter Modelica_SIunits.Time Ts=0.05
            "Time constant of integrator of speed controller of axis 2";
          parameter Real startAngle(unit="deg") = 0 "Start angle of axis 2";
          parameter Real endAngle(unit="deg") = 120 "End angle of axis 2";

          parameter Modelica_SIunits.Time swingTime=0.5
            "Additional time after reference motion is in rest before simulation is stopped";
          parameter Modelica_SIunits.AngularVelocity refSpeedMax=3
            "Maximum reference speed";
          parameter Modelica_SIunits.AngularAcceleration refAccMax=10
            "Maximum reference acceleration";

          Components.AxisType1 axis(
            w=5500,
            ratio=210,
            c=8,
            cd=0.01,
            Rv0=0.5,
            Rv1=(0.1/130),
            kp=kp,
            ks=ks,
            Ts=Ts) annotation (Placement(transformation(extent={{20,0},{40,20}},
                  rotation=0)));
          Modelica_Mechanics_Rotational.Components.Inertia load(
                                                     J=1.3*mLoad)
            annotation (Placement(transformation(extent={{54,0},{74,20}}, rotation=0)));
          Components.PathPlanning1 pathPlanning(
            swingTime=swingTime,
            angleBegDeg=startAngle,
            angleEndDeg=endAngle,
            speedMax=refSpeedMax,
            accMax=refAccMax)   annotation (Placement(transformation(extent={{-60,0},
                    {-40,20}}, rotation=0)));
        protected
          Components.ControlBus controlBus annotation (Placement(transformation(
                  extent={{-32,10},{8,50}}, rotation=0)));
        equation
          connect(axis.flange, load.flange_a)
            annotation (Line(
              points={{40,10},{54,10}},
              color={128,128,128},
              thickness=0.5));
          connect(pathPlanning.controlBus, controlBus) annotation (Line(
              points={{-40,10},{-15,10},{-15,28},{-12,28},{-12,30}},
              color={255,204,51},
              thickness=0.5));
          connect(controlBus.axisControlBus1, axis.axisControlBus) annotation (
            Text(
              string="%first",
              index=-1,
              extent=[-6,3; -6,3]), Line(
              points={{-12,30},{-12,29},{-9,29},{-9,10},{20,10}},
              color={255,204,51},
              thickness=0.5));
          annotation (
            Documentation(info="<HTML>
<p>
With this model one axis of the r3 robot is checked.
The mechanical structure is replaced by a simple
load inertia.
</p>
</html>"),            experiment(StopTime=1.6),
            __Dymola_Commands(file="modelica://Modelica/Resources/Scripts/Dymola/Mechanics/MultiBody/Examples/Systems/oneAxisPlot.mos"
                "Plot result"));
        end oneAxis;

        model fullRobot
          "6 degree of freedom robot with path planning, controllers, motors, brakes, gears and mechanics"
          extends Modelica_Icons.Example;

          parameter Modelica_SIunits.Mass mLoad(min=0) = 15 "Mass of load";
          parameter Modelica_SIunits.Position rLoad[3]={0.1,0.25,0.1}
            "Distance from last flange to load mass";
          parameter Modelica_SIunits.Acceleration g=9.81 "Gravity acceleration";
          parameter Modelica_SIunits.Time refStartTime=0
            "Start time of reference motion";
          parameter Modelica_SIunits.Time refSwingTime=0.5
            "Additional time after reference motion is in rest before simulation is stopped";

          parameter Real startAngle1(unit="deg") = -60 "Start angle of axis 1"
            annotation (Dialog(tab="Reference", group="startAngles"));
          parameter Real startAngle2(unit="deg") = 20 "Start angle of axis 2"
            annotation (Dialog(tab="Reference", group="startAngles"));
          parameter Real startAngle3(unit="deg") = 90 "Start angle of axis 3"
            annotation (Dialog(tab="Reference", group="startAngles"));
          parameter Real startAngle4(unit="deg") = 0 "Start angle of axis 4"
            annotation (Dialog(tab="Reference", group="startAngles"));
          parameter Real startAngle5(unit="deg") = -110 "Start angle of axis 5"
            annotation (Dialog(tab="Reference", group="startAngles"));
          parameter Real startAngle6(unit="deg") = 0 "Start angle of axis 6"
            annotation (Dialog(tab="Reference", group="startAngles"));

          parameter Real endAngle1(unit="deg") = 60 "End angle of axis 1"
            annotation (Dialog(tab="Reference", group="endAngles"));
          parameter Real endAngle2(unit="deg") = -70 "End angle of axis 2"
            annotation (Dialog(tab="Reference", group="endAngles"));
          parameter Real endAngle3(unit="deg") = -35 "End angle of axis 3"
            annotation (Dialog(tab="Reference", group="endAngles"));
          parameter Real endAngle4(unit="deg") = 45 "End angle of axis 4"
            annotation (Dialog(tab="Reference", group="endAngles"));
          parameter Real endAngle5(unit="deg") = 110 "End angle of axis 5"
            annotation (Dialog(tab="Reference", group="endAngles"));
          parameter Real endAngle6(unit="deg") = 45 "End angle of axis 6"
            annotation (Dialog(tab="Reference", group="endAngles"));

          parameter Modelica_SIunits.AngularVelocity refSpeedMax[6]={3,1.5,5,
              3.1,3.1,4.1} "Maximum reference speeds of all joints"
            annotation (Dialog(tab="Reference", group="Limits"));
          parameter Modelica_SIunits.AngularAcceleration refAccMax[6]={15,15,15,
              60,60,60} "Maximum reference accelerations of all joints"
            annotation (Dialog(tab="Reference", group="Limits"));

          parameter Real kp1=5 "Gain of position controller"
            annotation (Dialog(tab="Controller", group="Axis 1"));
          parameter Real ks1=0.5 "Gain of speed controller"
            annotation (Dialog(tab="Controller", group="Axis 1"));
          parameter Modelica_SIunits.Time Ts1=0.05
            "Time constant of integrator of speed controller"
            annotation (Dialog(tab="Controller", group="Axis 1"));
          parameter Real kp2=5 "Gain of position controller"
            annotation (Dialog(tab="Controller", group="Axis 2"));
          parameter Real ks2=0.5 "Gain of speed controller"
            annotation (Dialog(tab="Controller", group="Axis 2"));
          parameter Modelica_SIunits.Time Ts2=0.05
            "Time constant of integrator of speed controller"
            annotation (Dialog(tab="Controller", group="Axis 2"));
          parameter Real kp3=5 "Gain of position controller"
            annotation (Dialog(tab="Controller", group="Axis 3"));
          parameter Real ks3=0.5 "Gain of speed controller"
            annotation (Dialog(tab="Controller", group="Axis 3"));
          parameter Modelica_SIunits.Time Ts3=0.05
            "Time constant of integrator of speed controller"
            annotation (Dialog(tab="Controller", group="Axis 3"));
          parameter Real kp4=5 "Gain of position controller"
            annotation (Dialog(tab="Controller", group="Axis 4"));
          parameter Real ks4=0.5 "Gain of speed controller"
            annotation (Dialog(tab="Controller", group="Axis 4"));
          parameter Modelica_SIunits.Time Ts4=0.05
            "Time constant of integrator of speed controller"
            annotation (Dialog(tab="Controller", group="Axis 4"));
          parameter Real kp5=5 "Gain of position controller"
            annotation (Dialog(tab="Controller", group="Axis 5"));
          parameter Real ks5=0.5 "Gain of speed controller"
            annotation (Dialog(tab="Controller", group="Axis 5"));
          parameter Modelica_SIunits.Time Ts5=0.05
            "Time constant of integrator of speed controller"
            annotation (Dialog(tab="Controller", group="Axis 5"));
          parameter Real kp6=5 "Gain of position controller"
            annotation (Dialog(tab="Controller", group="Axis 6"));
          parameter Real ks6=0.5 "Gain of speed controller"
            annotation (Dialog(tab="Controller", group="Axis 6"));
          parameter Modelica_SIunits.Time Ts6=0.05
            "Time constant of integrator of speed controller"
            annotation (Dialog(tab="Controller", group="Axis 6"));
          Components.MechanicalStructure mechanics(
            mLoad=mLoad,
            rLoad=rLoad,
            g=g) annotation (Placement(transformation(extent={{35,-35},{95,25}},
                  rotation=0)));
          Modelica_Mechanics_MultiBody.Examples.Systems.RobotR3.Components.PathPlanning6
            pathPlanning(
            naxis=6,
            angleBegDeg={startAngle1,startAngle2,startAngle3,startAngle4,
                startAngle5,startAngle6},
            angleEndDeg={endAngle1,endAngle2,endAngle3,endAngle4,endAngle5,
                endAngle6},
            speedMax=refSpeedMax,
            accMax=refAccMax,
            startTime=refStartTime,
            swingTime=refSwingTime) annotation (Placement(transformation(extent=
                   {{-5,50},{-25,70}}, rotation=0)));

          RobotR3.Components.AxisType1 axis1(
            w=4590,
            ratio=-105,
            c=43,
            cd=0.005,
            Rv0=0.4,
            Rv1=(0.13/160),
            kp=kp1,
            ks=ks1,
            Ts=Ts1) annotation (Placement(transformation(extent={{-25,-75},{-5,-55}},
                  rotation=0)));
          RobotR3.Components.AxisType1 axis2(
            w=5500,
            ratio=210,
            c=8,
            cd=0.01,
            Rv1=(0.1/130),
            Rv0=0.5,
            kp=kp2,
            ks=ks2,
            Ts=Ts2) annotation (Placement(transformation(extent={{-25,-55},{-5,-35}},
                  rotation=0)));

          RobotR3.Components.AxisType1 axis3(
            w=5500,
            ratio=60,
            c=58,
            cd=0.04,
            Rv0=0.7,
            Rv1=(0.2/130),
            kp=kp3,
            ks=ks3,
            Ts=Ts3) annotation (Placement(transformation(extent={{-25,-35},{-5,-15}},
                  rotation=0)));
          RobotR3.Components.AxisType2 axis4(
            k=0.2365,
            w=6250,
            D=0.55,
            J=1.6e-4,
            ratio=-99,
            Rv0=21.8,
            Rv1=9.8,
            peak=26.7/21.8,
            kp=kp4,
            ks=ks4,
            Ts=Ts4) annotation (Placement(transformation(extent={{-25,-15},{-5,5}},
                  rotation=0)));
          RobotR3.Components.AxisType2 axis5(
            k=0.2608,
            w=6250,
            D=0.55,
            J=1.8e-4,
            ratio=79.2,
            Rv0=30.1,
            Rv1=0.03,
            peak=39.6/30.1,
            kp=kp5,
            ks=ks5,
            Ts=Ts5) annotation (Placement(transformation(extent={{-25,5},{-5,25}},
                  rotation=0)));
          RobotR3.Components.AxisType2 axis6(
            k=0.0842,
            w=7400,
            D=0.27,
            J=4.3e-5,
            ratio=-99,
            Rv0=10.9,
            Rv1=3.92,
            peak=16.8/10.9,
            kp=kp6,
            ks=ks6,
            Ts=Ts6) annotation (Placement(transformation(extent={{-25,25},{-5,45}},
                  rotation=0)));
        protected
          Components.ControlBus controlBus
            annotation (Placement(transformation(
                origin={-80,-10},
                extent={{-20,-20},{20,20}},
                rotation=90)));
        equation
          connect(axis2.flange, mechanics.axis2) annotation (Line(points={{-5,-45},{
                  25,-45},{25,-21.5},{33.5,-21.5}}, color={0,0,0}));
          connect(axis1.flange, mechanics.axis1) annotation (Line(points={{-5,-65},{
                  30,-65},{30,-30.5},{33.5,-30.5}}, color={0,0,0}));
          connect(axis3.flange, mechanics.axis3) annotation (Line(points={{-5,-25},{
                  15,-25},{15,-12.5},{33.5,-12.5}}, color={0,0,0}));
          connect(axis4.flange, mechanics.axis4) annotation (Line(points={{-5,-5},{15,
                  -5},{15,-3.5},{33.5,-3.5}}, color={0,0,0}));
          connect(axis5.flange, mechanics.axis5)
            annotation (Line(points={{-5,15},{10,15},{10,5.5},{33.5,5.5}}, color={0,0,
                  0}));
          connect(axis6.flange, mechanics.axis6) annotation (Line(points={{-5,35},{20,
                  35},{20,14.5},{33.5,14.5}}, color={0,0,0}));
          connect(controlBus, pathPlanning.controlBus)
                                               annotation (Line(
              points={{-80,-10},{-80,60},{-25,60}},
              color={255,204,51},
              thickness=0.5));
          connect(controlBus.axisControlBus1, axis1.axisControlBus) annotation (
            Text(
              string="%first",
              index=-1,
              extent=[-6,3; -6,3]), Line(
              points={{-80,-10},{-80,-14.5},{-79,-14.5},{-79,-17},{-65,-17},{-65,-65},
                  {-25,-65}},
              color={255,204,51},
              thickness=0.5));

          connect(controlBus.axisControlBus2, axis2.axisControlBus) annotation (
            Text(
              string="%first",
              index=-1,
              extent=[-6,3; -6,3]), Line(
              points={{-80,-10},{-79,-10},{-79,-15},{-62.5,-15},{-62.5,-45},{-25,-45}},
              color={255,204,51},
              thickness=0.5));

          connect(controlBus.axisControlBus3, axis3.axisControlBus) annotation (
            Text(
              string="%first",
              index=-1,
              extent=[-6,3; -6,3]), Line(
              points={{-80,-10},{-77,-10},{-77,-12.5},{-61,-12.5},{-61,-25},{-25,-25}},
              color={255,204,51},
              thickness=0.5));

          connect(controlBus.axisControlBus4, axis4.axisControlBus) annotation (
            Text(
              string="%first",
              index=-1,
              extent=[-6,3; -6,3]), Line(
              points={{-80,-10},{-60.5,-10},{-60.5,-5},{-25,-5}},
              color={255,204,51},
              thickness=0.5));
          connect(controlBus.axisControlBus5, axis5.axisControlBus) annotation (
            Text(
              string="%first",
              index=-1,
              extent=[-6,3; -6,3]), Line(
              points={{-80,-10},{-77,-10},{-77,-7},{-63,-7},{-63,15},{-25,15}},
              color={255,204,51},
              thickness=0.5));
          connect(controlBus.axisControlBus6, axis6.axisControlBus) annotation (
            Text(
              string="%first",
              index=-1,
              extent=[-6,3; -6,3]), Line(
              points={{-80,-10},{-79,-10},{-79,-5},{-65,-5},{-65,35},{-25,35}},
              color={255,204,51},
              thickness=0.5));
          annotation (
            experiment(StopTime=2),
            __Dymola_Commands(
              file="modelica://Modelica/Resources/Scripts/Dymola/Mechanics/MultiBody/Examples/Systems/Run.mos"
                "Simulate",
              file="modelica://Modelica/Resources/Scripts/Dymola/Mechanics/MultiBody/Examples/Systems/fullRobotPlot.mos"
                "Plot result of axis 3 + animate"),
            Documentation(info="<HTML>
<p>
This is a detailed model of the robot. For animation CAD data
is used. Translate and simulate with the default settings
(default simulation time = 3 s). Use command script \"modelica://Modelica/Resources/Scripts/Dymola/Mechanics/MultiBody/Examples/Systems/fullRobotPlot.mos\"
to plot variables.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Systems/r3_fullRobot.png\" ALT=\"model Examples.Loops.Systems.RobotR3.fullRobot\">
</p>
</HTML>"));
        end fullRobot;
        extends Modelica_Icons.ExamplesPackage;

        package Components "Library of components of the robot"
          extends Modelica_Icons.Package;

          expandable connector AxisControlBus "Data bus for one robot axis"
            extends Modelica_Icons.SignalSubBus;

            Boolean motion_ref "= true, if reference motion is not in rest" annotation(HideResult=false);
            Modelica_SIunits.Angle angle_ref "Reference angle of axis flange"
              annotation (HideResult=false);
            Modelica_SIunits.Angle angle "Angle of axis flange"
              annotation (HideResult=false);
            Modelica_SIunits.AngularVelocity speed_ref
              "Reference speed of axis flange" annotation (HideResult=false);
            Modelica_SIunits.AngularVelocity speed "Speed of axis flange"
              annotation (HideResult=false);
            Modelica_SIunits.AngularAcceleration acceleration_ref
              "Reference acceleration of axis flange"
              annotation (HideResult=false);
            Modelica_SIunits.AngularAcceleration acceleration
              "Acceleration of axis flange" annotation (HideResult=false);
            Modelica_SIunits.Current current_ref "Reference current of motor"
              annotation (HideResult=false);
            Modelica_SIunits.Current current "Current of motor"
              annotation (HideResult=false);
            Modelica_SIunits.Angle motorAngle "Angle of motor flange"
              annotation (HideResult=false);
            Modelica_SIunits.AngularVelocity motorSpeed "Speed of motor flange"
              annotation (HideResult=false);

            annotation (defaultComponentPrefixes="protected",
                        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                      -100},{100,100}}), graphics={Rectangle(
                    extent={{-20,2},{22,-2}},
                    lineColor={255,204,51},
                    lineThickness=0.5)}),
              Documentation(info="<html>
<p>
Signal bus that is used to communicate all signals for <b>one</b> axis.
This is an expandable connector which has a \"default\" set of
signals. Note, the input/output causalities of the signals are
determined from the connections to this bus.
</p>

</html>"));
          end AxisControlBus;

          expandable connector ControlBus "Data bus for all axes of robot"
            extends Modelica_Icons.SignalBus;
            Modelica_Mechanics_MultiBody.Examples.Systems.RobotR3.Components.AxisControlBus
              axisControlBus1 "Bus of axis 1";
            Modelica_Mechanics_MultiBody.Examples.Systems.RobotR3.Components.AxisControlBus
              axisControlBus2 "Bus of axis 2";
            Modelica_Mechanics_MultiBody.Examples.Systems.RobotR3.Components.AxisControlBus
              axisControlBus3 "Bus of axis 3";
            Modelica_Mechanics_MultiBody.Examples.Systems.RobotR3.Components.AxisControlBus
              axisControlBus4 "Bus of axis 4";
            Modelica_Mechanics_MultiBody.Examples.Systems.RobotR3.Components.AxisControlBus
              axisControlBus5 "Bus of axis 5";
            Modelica_Mechanics_MultiBody.Examples.Systems.RobotR3.Components.AxisControlBus
              axisControlBus6 "Bus of axis 6";

            annotation (
              Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                      100,100}}), graphics={Rectangle(
                    extent={{-20,2},{22,-2}},
                    lineColor={255,204,51},
                    lineThickness=0.5)}),
              Documentation(info="<html>
<p>
Signal bus that is used to communicate <b>all signals</b> of the robot.
This is an expandable connector which has a \"default\" set of
signals. Note, the input/output causalities of the signals are
determined from the connections to this bus.
</p>
</html>"));
          end ControlBus;

          model PathPlanning1
            "Generate reference angles for fastest kinematic movement"

            parameter Real angleBegDeg(unit="deg") = 0 "Start angle";
            parameter Real angleEndDeg(unit="deg") = 1 "End angle";
            parameter Modelica_SIunits.AngularVelocity speedMax=3
              "Maximum axis speed";
            parameter Modelica_SIunits.AngularAcceleration accMax=2.5
              "Maximum axis acceleration";
            parameter Modelica_SIunits.Time startTime=0
              "Start time of movement";
            parameter Modelica_SIunits.Time swingTime=0.5
              "Additional time after reference motion is in rest before simulation is stopped";
            final parameter Modelica_SIunits.Angle angleBeg=Cv.from_deg(
                angleBegDeg) "Start angles";
            final parameter Modelica_SIunits.Angle angleEnd=Cv.from_deg(
                angleEndDeg) "End angles";
            ControlBus controlBus
              annotation (Placement(transformation(
                  origin={100,0},
                  extent={{-20,-20},{20,20}},
                  rotation=270)));
            Modelica_Blocks.Sources.KinematicPTP2 path(
              q_end={angleEnd},
              qd_max={speedMax},
              qdd_max={accMax},
              startTime=startTime,
              q_begin={angleBeg})
                                annotation (Placement(transformation(extent={{-50,-10},
                      {-30,10}}, rotation=0)));
            PathToAxisControlBus pathToAxis1(final nAxis=1, final axisUsed=1)
              annotation (Placement(transformation(extent={{0,-10},{20,10}}, rotation=
                     0)));

            Modelica_Blocks.Logical.TerminateSimulation terminateSimulation(condition=
                 time >= path.endTime + swingTime) annotation (Placement(
                  transformation(extent={{-50,-30},{30,-24}}, rotation=0)));
          equation
            connect(path.q, pathToAxis1.q)         annotation (Line(points={{-29,8},{
                    -2,8}}, color={0,0,127}));
            connect(path.qd, pathToAxis1.qd)         annotation (Line(points={{-29,3},
                    {-2,3}}, color={0,0,127}));
            connect(path.qdd, pathToAxis1.qdd)         annotation (Line(points={{-29,
                    -3},{-2,-3}}, color={0,0,127}));
            connect(path.moving, pathToAxis1.moving)             annotation (Line(
                  points={{-29,-8},{-2,-8}}, color={255,0,255}));
            connect(pathToAxis1.axisControlBus, controlBus.axisControlBus1) annotation (
              Text(
                string="%second",
                index=1,
                extent=[6,3; 6,3]), Line(
                points={{20,0},{100,0}},
                color={255,204,51},
                thickness=0.5));
            annotation (
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}), graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Polygon(
                    points={{-80,90},{-88,68},{-72,68},{-80,88},{-80,90}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-80,78},{-80,-82}}, color={192,192,192}),
                  Line(points={{-90,0},{82,0}}, color={192,192,192}),
                  Polygon(
                    points={{90,0},{68,8},{68,-8},{90,0}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-42,55},{29,12}},
                    lineColor={192,192,192},
                    textString="w"),
                  Line(points={{-80,0},{-41,69},{26,69},{58,0}}, color={0,0,0}),
                  Text(
                    extent={{-73,-44},{82,-69}},
                    lineColor={0,0,0},
                    textString="1 axis")}),
              Documentation(info="<html>
<p>
Given
</p>
<ul>
<li> start and end angle of an axis</li>
<li> maximum speed of the axis </li>
<li> maximum acceleration of the axis </li>
</ul>

<p>
this component computes the fastest movement under the
given constraints. This means, that:
</p>

<ol>
<li> The axis accelerates with the maximum acceleration
     until the maximum speed is reached.</li>
<li> Drives with the maximum speed as long as possible.</li>
<li> Decelerates with the negative of the maximum acceleration
     until rest.</li>
</ol>

<p>
The acceleration, constant velocity and deceleration
phase are determined in such a way that the movement
starts form the start angles and ends at the end angles.
The output of this block are the computed angles, angular velocities
and angular acceleration and this information is stored as reference
motion on the controlBus of the r3 robot.
</p>

</html>"));
          end PathPlanning1;

          model PathPlanning6
            "Generate reference angles for fastest kinematic movement"

            parameter Integer naxis=6 "number of driven axis";
            parameter Real angleBegDeg[naxis](each unit="deg") = zeros(naxis)
              "Start angles";
            parameter Real angleEndDeg[naxis](each unit="deg") = ones(naxis)
              "End angles";
            parameter Modelica_SIunits.AngularVelocity speedMax[naxis]=fill(3,
                naxis) "Maximum axis speed";
            parameter Modelica_SIunits.AngularAcceleration accMax[naxis]=fill(
                2.5, naxis) "Maximum axis acceleration";
            parameter Modelica_SIunits.Time startTime=0
              "Start time of movement";
            parameter Modelica_SIunits.Time swingTime=0.5
              "Additional time after reference motion is in rest before simulation is stopped";
            final parameter Modelica_SIunits.Angle angleBeg[:]=Cv.from_deg(
                angleBegDeg) "Start angles";
            final parameter Modelica_SIunits.Angle angleEnd[:]=Cv.from_deg(
                angleEndDeg) "End angles";
            ControlBus controlBus
              annotation (Placement(transformation(
                  origin={100,0},
                  extent={{-20,-20},{20,20}},
                  rotation=270)));
            Modelica_Blocks.Sources.KinematicPTP2 path(
              q_end=angleEnd,
              qd_max=speedMax,
              qdd_max=accMax,
              startTime=startTime,
              q_begin=angleBeg) annotation (Placement(transformation(extent={{-90,-80},
                      {-70,-60}}, rotation=0)));
            PathToAxisControlBus pathToAxis1(nAxis=naxis, axisUsed=1)
              annotation (Placement(transformation(extent={{-10,70},{10,90}},
                    rotation=0)));
            PathToAxisControlBus pathToAxis2(nAxis=naxis, axisUsed=2)
              annotation (Placement(transformation(extent={{-10,40},{10,60}},
                    rotation=0)));
            PathToAxisControlBus pathToAxis3(nAxis=naxis, axisUsed=3)
              annotation (Placement(transformation(extent={{-10,10},{10,30}},
                    rotation=0)));
            PathToAxisControlBus pathToAxis4(nAxis=naxis, axisUsed=4)
              annotation (Placement(transformation(extent={{-10,-20},{10,0}},
                    rotation=0)));
            PathToAxisControlBus pathToAxis5(nAxis=naxis, axisUsed=5)
              annotation (Placement(transformation(extent={{-10,-50},{10,-30}},
                    rotation=0)));
            PathToAxisControlBus pathToAxis6(nAxis=naxis, axisUsed=6)
              annotation (Placement(transformation(extent={{-10,-80},{10,-60}},
                    rotation=0)));

            Modelica_Blocks.Logical.TerminateSimulation terminateSimulation(condition=
                 time >= path.endTime + swingTime) annotation (Placement(
                  transformation(extent={{-50,-100},{30,-94}}, rotation=0)));
          equation
            connect(path.q, pathToAxis1.q)         annotation (Line(points={{-69,-62},
                    {-60,-62},{-60,88},{-12,88}}, color={0,0,127}));
            connect(path.qd, pathToAxis1.qd)         annotation (Line(points={{-69,
                    -67},{-59,-67},{-59,83},{-12,83}}, color={0,0,127}));
            connect(path.qdd, pathToAxis1.qdd)         annotation (Line(points={{-69,
                    -73},{-58,-73},{-58,77},{-12,77}}, color={0,0,127}));
            connect(path.moving, pathToAxis1.moving)             annotation (Line(
                  points={{-69,-78},{-57,-78},{-57,72},{-12,72}}, color={255,0,255}));
            connect(path.q, pathToAxis2.q)         annotation (Line(points={{-69,-62},
                    {-60,-62},{-60,58},{-12,58}}, color={0,0,127}));
            connect(path.qd, pathToAxis2.qd)         annotation (Line(points={{-69,
                    -67},{-59,-67},{-59,53},{-12,53}}, color={0,0,127}));
            connect(path.qdd, pathToAxis2.qdd)         annotation (Line(points={{-69,
                    -73},{-58,-73},{-58,47},{-12,47}}, color={0,0,127}));
            connect(path.moving, pathToAxis2.moving)             annotation (Line(
                  points={{-69,-78},{-57,-78},{-57,42},{-12,42}}, color={255,0,255}));
            connect(path.q, pathToAxis3.q)         annotation (Line(points={{-69,-62},
                    {-60,-62},{-60,28},{-12,28}}, color={0,0,127}));
            connect(path.qd, pathToAxis3.qd)         annotation (Line(points={{-69,
                    -67},{-59,-67},{-59,23},{-12,23}}, color={0,0,127}));
            connect(path.qdd, pathToAxis3.qdd)         annotation (Line(points={{-69,
                    -73},{-58,-73},{-58,17},{-12,17}}, color={0,0,127}));
            connect(path.moving, pathToAxis3.moving)             annotation (Line(
                  points={{-69,-78},{-57,-78},{-57,12},{-12,12}}, color={255,0,255}));
            connect(path.q, pathToAxis4.q)         annotation (Line(points={{-69,-62},
                    {-60,-62},{-60,-2},{-12,-2}}, color={0,0,127}));
            connect(path.qd, pathToAxis4.qd)         annotation (Line(points={{-69,
                    -67},{-59,-67},{-59,-7},{-12,-7}}, color={0,0,127}));
            connect(path.qdd, pathToAxis4.qdd)         annotation (Line(points={{-69,
                    -73},{-58,-73},{-58,-13},{-12,-13}}, color={0,0,127}));
            connect(path.moving, pathToAxis4.moving)             annotation (Line(
                  points={{-69,-78},{-57,-78},{-57,-18},{-12,-18}}, color={255,0,255}));
            connect(path.q, pathToAxis5.q)         annotation (Line(points={{-69,-62},
                    {-60,-62},{-60,-32},{-12,-32}}, color={0,0,127}));
            connect(path.qd, pathToAxis5.qd)         annotation (Line(points={{-69,
                    -67},{-59,-67},{-59,-37},{-12,-37}}, color={0,0,127}));
            connect(path.qdd, pathToAxis5.qdd)         annotation (Line(points={{-69,
                    -73},{-58,-73},{-58,-43},{-12,-43}}, color={0,0,127}));
            connect(path.moving, pathToAxis5.moving)             annotation (Line(
                  points={{-69,-78},{-57,-78},{-57,-48},{-12,-48}}, color={255,0,255}));
            connect(path.q, pathToAxis6.q)         annotation (Line(points={{-69,-62},
                    {-12,-62}}, color={0,0,127}));
            connect(path.qd, pathToAxis6.qd)         annotation (Line(points={{-69,
                    -67},{-12,-67}}, color={0,0,127}));
            connect(path.qdd, pathToAxis6.qdd)         annotation (Line(points={{-69,
                    -73},{-12,-73}}, color={0,0,127}));
            connect(path.moving, pathToAxis6.moving)             annotation (Line(
                  points={{-69,-78},{-12,-78}}, color={255,0,255}));
            connect(pathToAxis1.axisControlBus, controlBus.axisControlBus1) annotation (
              Text(
                string="%second",
                index=1,
                extent=[6,3; 6,3]), Line(
                points={{10,80},{80,80},{80,7},{98,7}},
                color={255,204,51},
                thickness=0.5));
            connect(pathToAxis2.axisControlBus, controlBus.axisControlBus2) annotation (
              Text(
                string="%second",
                index=1,
                extent=[6,3; 6,3]), Line(
                points={{10,50},{77,50},{77,5},{97,5}},
                color={255,204,51},
                thickness=0.5));
            connect(pathToAxis3.axisControlBus, controlBus.axisControlBus3) annotation (
              Text(
                string="%second",
                index=1,
                extent=[6,3; 6,3]), Line(
                points={{10,20},{75,20},{75,3},{96,3}},
                color={255,204,51},
                thickness=0.5));
            connect(pathToAxis4.axisControlBus, controlBus.axisControlBus4) annotation (
              Text(
                string="%second",
                index=1,
                extent=[6,3; 6,3]), Line(
                points={{10,-10},{73,-10},{73,0},{100,0}},
                color={255,204,51},
                thickness=0.5));
            connect(pathToAxis5.axisControlBus, controlBus.axisControlBus5) annotation (
              Text(
                string="%second",
                index=1,
                extent=[6,3; 6,3]), Line(
                points={{10,-40},{75,-40},{75,-3},{100,-3},{100,0}},
                color={255,204,51},
                thickness=0.5));
            connect(pathToAxis6.axisControlBus, controlBus.axisControlBus6) annotation (
              Text(
                string="%second",
                index=1,
                extent=[6,3; 6,3]), Line(
                points={{10,-70},{78,-70},{78,-6},{98,-6}},
                color={255,204,51},
                thickness=0.5));
            annotation (
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}), graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Polygon(
                    points={{-80,90},{-88,68},{-72,68},{-80,88},{-80,90}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-80,78},{-80,-82}}, color={192,192,192}),
                  Line(points={{-90,0},{82,0}}, color={192,192,192}),
                  Polygon(
                    points={{90,0},{68,8},{68,-8},{90,0}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-42,55},{29,12}},
                    lineColor={192,192,192},
                    textString="w"),
                  Line(points={{-80,0},{-41,69},{26,69},{58,0}}, color={0,0,0}),
                  Text(
                    extent={{-70,-43},{85,-68}},
                    lineColor={0,0,0},
                    textString="6 axes")}),
              Documentation(info="<html>
<p>
Given
</p>
<ul>
<li> start and end angles of every axis</li>
<li> maximum speed of every axis </li>
<li> maximum acceleration of every axis </li>
</ul>

<p>
this component computes the fastest movement under the
given constraints. This means, that:
</p>

<ol>
<li> Every axis accelerates with the maximum acceleration
     until the maximum speed is reached.</li>
<li> Drives with the maximum speed as long as possible.</li>
<li> Decelerates with the negative of the maximum acceleration
     until rest.</li>
</ol>

<p>
The acceleration, constant velocity and deceleration
phase are determined in such a way that the movement
starts form the start angles and ends at the end angles.
The output of this block are the computed angles, angular velocities
and angular acceleration and this information is stored as reference
motion on the controlBus of the r3 robot.
</p>

</html>"));
          end PathPlanning6;

          model PathToAxisControlBus
            "Map path planning to one axis control bus"
            extends Modelica_Blocks.Icons.Block;

            parameter Integer nAxis=6 "Number of driven axis";
            parameter Integer axisUsed=1
              "Map path planning of axisUsed to axisControlBus";
            Modelica_Blocks.Interfaces.RealInput q[nAxis] annotation (Placement(
                  transformation(extent={{-140,60},{-100,100}}, rotation=0)));
            Modelica_Blocks.Interfaces.RealInput qd[nAxis] annotation (
                Placement(transformation(extent={{-140,10},{-100,50}}, rotation=
                     0)));
            Modelica_Blocks.Interfaces.RealInput qdd[nAxis] annotation (
                Placement(transformation(extent={{-140,-50},{-100,-10}},
                    rotation=0)));
            AxisControlBus axisControlBus
              annotation (Placement(transformation(
                  origin={100,0},
                  extent={{-20,-20},{20,20}},
                  rotation=270)));
            Modelica_Blocks.Routing.RealPassThrough q_axisUsed annotation (
                Placement(transformation(extent={{-40,50},{-20,70}}, rotation=0)));
            Modelica_Blocks.Routing.RealPassThrough qd_axisUsed annotation (
                Placement(transformation(extent={{-40,10},{-20,30}}, rotation=0)));
            Modelica_Blocks.Routing.RealPassThrough qdd_axisUsed annotation (
                Placement(transformation(extent={{-40,-30},{-20,-10}}, rotation=
                     0)));
            Modelica_Blocks.Interfaces.BooleanInput moving[nAxis] annotation (
                Placement(transformation(extent={{-140,-100},{-100,-60}},
                    rotation=0)));
            Modelica_Blocks.Routing.BooleanPassThrough motion_ref_axisUsed
              annotation (Placement(transformation(extent={{-40,-70},{-20,-50}},
                    rotation=0)));
          equation
            connect(q_axisUsed.u, q[axisUsed]) annotation (Line(points={{-42,60},{-60,
                    60},{-60,80},{-120,80}}, color={0,0,127}));
            connect(qd_axisUsed.u, qd[axisUsed]) annotation (Line(points={{-42,20},{
                    -80,20},{-80,30},{-120,30}}, color={0,0,127}));
            connect(qdd_axisUsed.u, qdd[axisUsed]) annotation (Line(points={{-42,-20},
                    {-80,-20},{-80,-30},{-120,-30}}, color={0,0,127}));
            connect(motion_ref_axisUsed.u, moving[axisUsed])     annotation (Line(
                  points={{-42,-60},{-60,-60},{-60,-80},{-120,-80}}, color={255,0,255}));
            connect(motion_ref_axisUsed.y, axisControlBus.motion_ref) annotation (
              Text(
                string="%second",
                index=1,
                extent=[6,3; 6,3]), Line(points={{-19,-60},{44,-60},{
                    44,-8},{102,-8},{102,0},{100,0}}, color={255,0,255}));
            connect(qdd_axisUsed.y, axisControlBus.acceleration_ref) annotation (
              Text(
                string="%second",
                index=1,
                extent=[6,3; 6,3]), Line(points={{-19,-20},{40,-20},{
                    40,-4},{98,-4},{98,0},{100,0}}, color={0,0,127}));
            connect(qd_axisUsed.y, axisControlBus.speed_ref) annotation (
              Text(
                string="%second",
                index=1,
                extent=[6,3; 6,3]), Line(points={{-19,20},{20,20},{20,
                    0},{100,0}}, color={0,0,127}));
            connect(q_axisUsed.y, axisControlBus.angle_ref) annotation (
              Text(
                string="%second",
                index=1,
                extent=[6,3; 6,3]), Line(points={{-19,60},{40,60},{40,
                    4},{96,4}}, color={0,0,127}));
            annotation (defaultComponentName="pathToAxis1",
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  initialScale=0.1), graphics={
                  Text(
                    extent={{-100,98},{-24,68}},
                    lineColor={0,0,0},
                    textString="q"),
                  Text(
                    extent={{-94,46},{-18,16}},
                    lineColor={0,0,0},
                    textString="qd"),
                  Text(
                    extent={{-96,-16},{-20,-46}},
                    lineColor={0,0,0},
                    textString="qdd"),
                  Text(
                    extent={{-2,20},{80,-18}},
                    lineColor={0,0,0},
                    textString="%axisUsed"),
                  Text(
                    extent={{2,52},{76,28}},
                    lineColor={0,0,0},
                    textString="axis"),
                  Text(
                    extent={{-94,-70},{32,-96}},
                    lineColor={0,0,0},
                    textString="moving")}));
          end PathToAxisControlBus;

          model GearType1 "Motor inertia and gearbox model for r3 joints 1,2,3"
            extends Modelica_Mechanics_Rotational.Interfaces.PartialTwoFlanges;
            parameter Real i=-105 "gear ratio";
            parameter Real c(unit="N.m/rad") = 43 "Spring constant";
            parameter Real d(unit="N.m.s/rad") = 0.005 "Damper constant";
            parameter Modelica_SIunits.Torque Rv0=0.4
              "Viscous friction torque at zero velocity";
            parameter Real Rv1(unit="N.m.s/rad") = (0.13/160)
              "Viscous friction coefficient (R=Rv0+Rv1*abs(qd))";
            parameter Real peak=1
              "Maximum static friction torque is peak*Rv0 (peak >= 1)";
            Modelica_SIunits.AngularAcceleration a_rel=der(spring.w_rel)
              "Relative angular acceleration of spring";
            constant Modelica_SIunits.AngularVelocity unitAngularVelocity=1;
            constant Modelica_SIunits.Torque unitTorque=1;

            Modelica_Mechanics_Rotational.Components.IdealGear gear(
                                                         ratio=i, useSupport=false)
              annotation (Placement(transformation(extent={{50,-10},{70,10}},
                    rotation=0)));
            Modelica_Mechanics_Rotational.Components.SpringDamper spring(
                                                              c=c, d=d)
              annotation (Placement(transformation(extent={{0,-10},{20,10}}, rotation=
                     0)));
            Modelica_Mechanics_Rotational.Components.BearingFriction bearingFriction(
                                                                          tau_pos=[0,
                   Rv0/unitTorque; 1, (Rv0 + Rv1*unitAngularVelocity)/unitTorque],
                useSupport=false)                                                  annotation (Placement(
                  transformation(extent={{-60,-10},{-40,10}}, rotation=0)));
          equation
            connect(spring.flange_b, gear.flange_a)
              annotation (Line(
                points={{20,0},{50,0}},
                color={128,128,128},
                thickness=0.5));
            connect(bearingFriction.flange_b, spring.flange_a)
              annotation (Line(
                points={{-40,0},{0,0}},
                color={128,128,128},
                thickness=0.5));
            connect(gear.flange_b, flange_b)
              annotation (Line(
                points={{70,0},{100,0}},
                color={128,128,128},
                thickness=0.5));
            connect(bearingFriction.flange_a, flange_a)
              annotation (Line(
                points={{-60,0},{-100,0}},
                color={128,128,128},
                thickness=0.5));
          initial equation
            spring.w_rel = 0;
            a_rel = 0;
            annotation (
              Documentation(info="<html>
<p>
Models the gearbox used in the first three joints with all its effects,
like elasticity and friction.
Coulomb friction is approximated by a friction element acting
at the \"motor\"-side. In reality, bearing friction should be
also incorporated at the driven side of the gearbox. However,
this would require considerable more effort for the measurement
of the friction parameters.
Default values for all parameters are given for joint 1.
Model relativeStates is used to define the relative angle
and relative angular velocity across the spring (=gear elasticity)
as state variables. The reason is, that a default initial
value of zero of these states makes always sense.
If the absolute angle and the absolute angular velocity of model
Jmotor would be used as states, and the load angle (= joint angle of
robot) is NOT zero, one has always to ensure that the initial values
of the motor angle and of the joint angle are modified correspondingly.
Otherwise, the spring has an unrealistic deflection at initial time.
Since relative quantities are used as state variables, this simplifies
the definition of initial values considerably.
</p>
</html>"),           Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
                  Rectangle(
                    lineColor={64,64,64},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-90.0,-10.0},{-60.0,10.0}}),
                  Polygon(
                    fillColor={192,192,192},
                    fillPattern=FillPattern.HorizontalCylinder,
                    points={{-60.0,10.0},{-60.0,20.0},{-40.0,40.0},{-40.0,-40.0},{-60.0,-20.0},{-60.0,10.0}}),
                  Rectangle(
                    lineColor={64,64,64},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-40.0,-60.0},{40.0,60.0}},
                    radius=10.0),
                  Polygon(
                    fillColor={192,192,192},
                    fillPattern=FillPattern.HorizontalCylinder,
                    points={{60.0,20.0},{40.0,40.0},{40.0,-40.0},{60.0,-20.0},{60.0,20.0}}),
                  Rectangle(
                    lineColor={64,64,64},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{60.0,-10.0},{90.0,10.0}}),
                  Polygon(
                    fillColor={64,64,64},
                    fillPattern=FillPattern.Solid,
                    points={{-60.0,-90.0},{-50.0,-90.0},{-20.0,-30.0},{20.0,-30.0},{48.0,-90.0},{60.0,-90.0},{60.0,-100.0},{-60.0,-100.0},{-60.0,-90.0}}),
                  Text(
                    extent={{0,128},{0,68}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-36,40},{36,-30}},
                    textString="1",
                    lineColor={0,0,255})}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}), graphics={Text(
                    extent={{72,30},{130,22}},
                    lineColor={0,0,0},
                    textString="flange of joint axis"), Text(
                    extent={{-128,26},{-70,18}},
                    lineColor={0,0,0},
                    textString="flange of motor axis")}));
          end GearType1;

          model GearType2 "Motor inertia and gearbox model for r3 joints 4,5,6"
            extends Modelica_Mechanics_Rotational.Interfaces.PartialTwoFlanges;
            parameter Real i=-99 "Gear ratio";
            parameter Modelica_SIunits.Torque Rv0=21.8
              "Viscous friction torque at zero velocity";
            parameter Real Rv1=9.8
              "Viscous friction coefficient in [Nms/rad] (R=Rv0+Rv1*abs(qd))";
            parameter Real peak=(26.7/21.8)
              "Maximum static friction torque is peak*Rv0 (peak >= 1)";

            constant Modelica_SIunits.AngularVelocity unitAngularVelocity=1;
            constant Modelica_SIunits.Torque unitTorque=1;
            Modelica_Mechanics_Rotational.Components.IdealGear gear(
                                                         ratio=i, useSupport=false)
              annotation (Placement(transformation(extent={{-28,-10},{-8,10}},
                    rotation=0)));
            Modelica_Mechanics_Rotational.Components.BearingFriction bearingFriction(
                                                                          tau_pos=[0,
                   Rv0/unitTorque; 1, (Rv0 + Rv1*unitAngularVelocity)/unitTorque], peak=peak,
              useSupport=false)
              annotation (Placement(transformation(extent={{30,-10},{50,10}},
                    rotation=0)));
          equation
            connect(gear.flange_b, bearingFriction.flange_a)
              annotation (Line(
                points={{-8,0},{30,0}},
                color={128,128,128},
                thickness=0.5));
            connect(bearingFriction.flange_b, flange_b)
              annotation (Line(
                points={{50,0},{100,0}},
                color={128,128,128},
                thickness=0.5));
            connect(gear.flange_a, flange_a)
              annotation (Line(
                points={{-28,0},{-100,0}},
                color={128,128,128},
                thickness=0.5));
            annotation (
              Documentation(info="<html>
<p>
The elasticity and damping in the gearboxes of the outermost
three joints of the robot is neglected.
Default values for all parameters are given for joint 4.
</p>
</html>"),           Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
                  Rectangle(
                    lineColor={64,64,64},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-90.0,-10.0},{-60.0,10.0}}),
                  Polygon(
                    fillColor={192,192,192},
                    fillPattern=FillPattern.HorizontalCylinder,
                    points={{-60.0,10.0},{-60.0,20.0},{-40.0,40.0},{-40.0,-40.0},{-60.0,-20.0},{-60.0,10.0}}),
                  Rectangle(
                    lineColor={64,64,64},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-40.0,-60.0},{40.0,60.0}},
                    radius=10.0),
                  Polygon(
                    fillColor={192,192,192},
                    fillPattern=FillPattern.HorizontalCylinder,
                    points={{60.0,20.0},{40.0,40.0},{40.0,-40.0},{60.0,-20.0},{60.0,20.0}}),
                  Rectangle(
                    lineColor={64,64,64},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{60.0,-10.0},{90.0,10.0}}),
                  Polygon(
                    fillColor={64,64,64},
                    fillPattern=FillPattern.Solid,
                    points={{-60.0,-90.0},{-50.0,-90.0},{-20.0,-30.0},{20.0,-30.0},{48.0,-90.0},{60.0,-90.0},{60.0,-100.0},{-60.0,-100.0},{-60.0,-90.0}}),
                  Text(
                    extent={{0,128},{0,68}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-36,40},{38,-30}},
                    textString="2",
                    lineColor={0,0,255})}));
          end GearType2;

          model Motor "Motor model including current controller of r3 motors"
            extends Modelica_Mechanics_MultiBody.Icons.MotorIcon;
            parameter Modelica_SIunits.Inertia J(min=0) = 0.0013
              "Moment of inertia of motor";
            parameter Real k=1.1616 "Gain of motor";
            parameter Real w=4590 "Time constant of motor";
            parameter Real D=0.6 "Damping constant of motor";
            parameter Modelica_SIunits.AngularVelocity w_max=315
              "Maximum speed of motor";
            parameter Modelica_SIunits.Current i_max=9
              "Maximum current of motor";

            Modelica_Mechanics_Rotational.Interfaces.Flange_b flange_motor
              annotation (Placement(transformation(extent={{90,-10},{110,10}},
                    rotation=0)));
            Modelica_Electrical_Analog.Sources.SignalVoltage Vs
              annotation (Placement(transformation(
                  origin={-90,0},
                  extent={{-10,10},{10,-10}},
                  rotation=270)));
            Modelica_Electrical_Analog.Ideal.IdealOpAmp diff
              annotation (Placement(transformation(extent={{-64,15},{-44,35}},
                    rotation=0)));
            Modelica_Electrical_Analog.Ideal.IdealOpAmp power
              annotation (Placement(transformation(extent={{16,15},{36,35}}, rotation=
                     0)));
            Modelica_Electrical_Analog.Basic.EMF emf(k=k, useSupport=false)
              annotation (Placement(transformation(extent={{46,-10},{66,10}},
                    rotation=0)));
            Modelica_Electrical_Analog.Basic.Inductor La(L=(250/(2*D*w)))
              annotation (Placement(transformation(
                  origin={56,30},
                  extent={{-10,-10},{10,10}},
                  rotation=270)));
            Modelica_Electrical_Analog.Basic.Resistor Ra(R=250)
              annotation (Placement(transformation(
                  origin={56,60},
                  extent={{-10,-10},{10,10}},
                  rotation=270)));
            Modelica_Electrical_Analog.Basic.Resistor Rd2(R=100)
              annotation (Placement(transformation(extent={{-86,22},{-71,38}},
                    rotation=0)));
            Modelica_Electrical_Analog.Basic.Capacitor C(C=0.004*D/w)
              annotation (Placement(transformation(extent={{-14,36},{6,56}}, rotation=
                     0)));
            Modelica_Electrical_Analog.Ideal.IdealOpAmp OpI
              annotation (Placement(transformation(extent={{-14,10},{6,30}}, rotation=
                     0)));
            Modelica_Electrical_Analog.Basic.Resistor Rd1(R=100)
              annotation (Placement(transformation(extent={{-63,37},{-48,53}},
                    rotation=0)));
            Modelica_Electrical_Analog.Basic.Resistor Ri(R=10)
              annotation (Placement(transformation(extent={{-37,17},{-22,33}},
                    rotation=0)));
            Modelica_Electrical_Analog.Basic.Resistor Rp1(R=200)
              annotation (Placement(transformation(extent={{17,38},{32,54}}, rotation=
                     0)));
            Modelica_Electrical_Analog.Basic.Resistor Rp2(R=50)
              annotation (Placement(transformation(
                  origin={11,72},
                  extent={{-8,-7},{8,7}},
                  rotation=90)));
            Modelica_Electrical_Analog.Basic.Resistor Rd4(R=100)
              annotation (Placement(transformation(extent={{-55,-15},{-40,1}},
                    rotation=0)));
            Modelica_Electrical_Analog.Sources.SignalVoltage hall2
              annotation (Placement(transformation(
                  origin={-70,-50},
                  extent={{-10,10},{10,-10}},
                  rotation=90)));
            Modelica_Electrical_Analog.Basic.Resistor Rd3(R=100)
              annotation (Placement(transformation(
                  origin={-70,-22},
                  extent={{-8,-7},{8,7}},
                  rotation=90)));
            Modelica_Electrical_Analog.Basic.Ground g1
              annotation (Placement(transformation(extent={{-100,-37},{-80,-17}},
                    rotation=0)));
            Modelica_Electrical_Analog.Basic.Ground g2
              annotation (Placement(transformation(extent={{-80,-91},{-60,-71}},
                    rotation=0)));
            Modelica_Electrical_Analog.Basic.Ground g3
              annotation (Placement(transformation(extent={{-34,-27},{-14,-7}},
                    rotation=0)));
            Modelica_Electrical_Analog.Sensors.CurrentSensor hall1
              annotation (Placement(transformation(
                  origin={16,-50},
                  extent={{-10,-10},{10,10}},
                  rotation=270)));
            Modelica_Electrical_Analog.Basic.Ground g4
              annotation (Placement(transformation(extent={{6,-84},{26,-64}},
                    rotation=0)));
            Modelica_Electrical_Analog.Basic.Ground g5
              annotation (Placement(transformation(
                  origin={11,93},
                  extent={{-10,-10},{10,10}},
                  rotation=180)));
            Modelica_Mechanics_Rotational.Sensors.AngleSensor phi
              annotation (Placement(transformation(
                  origin={76,-40},
                  extent={{-10,-10},{10,10}},
                  rotation=270)));
            Modelica_Mechanics_Rotational.Sensors.SpeedSensor speed
              annotation (Placement(transformation(
                  origin={55,-40},
                  extent={{-10,-10},{10,10}},
                  rotation=270)));
            Modelica_Mechanics_Rotational.Components.Inertia Jmotor(
                                                         J=J)
              annotation (Placement(transformation(extent={{70,-10},{90,10}},
                    rotation=0)));
            Modelica_Mechanics_MultiBody.Examples.Systems.RobotR3.Components.AxisControlBus
              axisControlBus annotation (Placement(transformation(extent={{60,-120},
                      {100,-80}}, rotation=0)));
            Modelica_Blocks.Math.Gain convert1(k(unit="V/A") = 1) annotation (
                Placement(transformation(extent={{-30,-56},{-42,-44}}, rotation=
                     0)));
            Modelica_Blocks.Math.Gain convert2(k(unit="V/A") = 1) annotation (
                Placement(transformation(extent={{-30,-101},{-42,-89}},
                    rotation=0)));
          initial equation
            // initialize motor in steady state
            der(C.v) = 0;
            der(La.i) = 0;

          equation
            connect(La.n, emf.p) annotation (Line(points={{56,20},{56,15},{56,10}}));
            connect(Ra.n, La.p) annotation (Line(points={{56,50},{56,40}}));
            connect(Rd2.n, diff.n1) annotation (Line(points={{-71,30},{-64,30}}));
            connect(C.n, OpI.p2) annotation (Line(points={{6,46},{6,20}}));
            connect(OpI.p2, power.p1) annotation (Line(points={{6,20},{16,20}}));
            connect(Vs.p, Rd2.p) annotation (Line(points={{-90,10},{-90,30},{-86,30}}));
            connect(diff.n1, Rd1.p)
              annotation (Line(points={{-64,30},{-68,30},{-68,45},{-63,45}}));
            connect(Rd1.n, diff.p2) annotation (Line(points={{-48,45},{-44,45},{-44,
                    25}}));
            connect(diff.p2, Ri.p) annotation (Line(points={{-44,25},{-37,25}}));
            connect(Ri.n, OpI.n1) annotation (Line(points={{-22,25},{-14,25}}));
            connect(OpI.n1, C.p) annotation (Line(points={{-14,25},{-14,46}}));
            connect(power.n1, Rp1.p)
              annotation (Line(points={{16,30},{11,30},{11,46},{17,46}}));
            connect(power.p2, Rp1.n) annotation (Line(points={{36,25},{36,46},{32,46}}));
            connect(Rp1.p, Rp2.p) annotation (Line(points={{17,46},{11,46},{11,64}}));
            connect(power.p2, Ra.p)
              annotation (Line(points={{36,25},{42,25},{42,80},{56,80},{56,70}}));
            connect(Rd3.p, hall2.p) annotation (Line(points={{-70,-30},{-70,-60}}));
            connect(Rd3.n, diff.p1) annotation (Line(points={{-70,-14},{-70,20},{-64,
                    20}}));
            connect(Rd3.n, Rd4.p) annotation (Line(points={{-70,-14},{-70,-7},{-55,-7}}));
            connect(Vs.n, g1.p) annotation (Line(points={{-90,-10},{-90,-17}}));
            connect(g2.p, hall2.n) annotation (Line(points={{-70,-71},{-70,-40}}));
            connect(Rd4.n, g3.p) annotation (Line(points={{-40,-7},{-24,-7}}));
            connect(g3.p, OpI.p1) annotation (Line(points={{-24,-7},{-24,15},{-14,15}}));
            connect(g5.p, Rp2.n)
              annotation (Line(points={{11,83},{11,81.5},{11,80}}));
            connect(emf.n, hall1.p)
              annotation (Line(points={{56,-10},{56,-24},{16,-24},{16,-40}}));
            connect(hall1.n, g4.p) annotation (Line(points={{16,-60},{16,-62},{16,-64}}));
            connect(emf.flange, phi.flange)
              annotation (Line(points={{66,0},{66,-30},{76,-30}}, pattern=LinePattern.Dot));
            connect(emf.flange, speed.flange)
              annotation (Line(points={{66,0},{66,-30},{55,-30}}, pattern=LinePattern.Dot));
            connect(OpI.n2, power.n2)
              annotation (Line(points={{-4,10},{-4,4},{26,4},{26,15}}));
            connect(OpI.p1, OpI.n2) annotation (Line(points={{-14,15},{-14,10},{-4,10}}));
            connect(OpI.p1, diff.n2) annotation (Line(points={{-14,15},{-54,15}}));
            connect(Jmotor.flange_b, flange_motor)
              annotation (Line(
                points={{90,0},{100,0}},
                color={128,128,128},
                thickness=0.5));
            connect(phi.phi, axisControlBus.motorAngle)
                                             annotation (Line(points={{76,-51},{76,
                    -100},{80,-100}}, color={0,0,127}));
            connect(speed.w, axisControlBus.motorSpeed)
                                             annotation (Line(points={{55,-51},{55,
                    -95},{80,-95},{80,-100}}, color={0,0,127}));
            connect(hall1.i, axisControlBus.current)
                                          annotation (Line(points={{6,-50},{-10,-50},
                    {-10,-95},{80,-95},{80,-100}}, color={0,0,127}));
            connect(hall1.i, convert1.u) annotation (Line(points={{6,-50},{-28.8,-50}},
                  color={0,0,127}));
            connect(convert1.y, hall2.v) annotation (Line(points={{-42.6,-50},{-63,
                    -50}}, color={0,0,127}));
            connect(convert2.u, axisControlBus.current_ref)
                                                 annotation (Line(points={{-28.8,-95},
                    {80,-95},{80,-100}}, color={0,0,127}));
            connect(convert2.y, Vs.v) annotation (Line(points={{-42.6,-95},{-108,-95},
                    {-108,0},{-97,0}},                       color={0,0,127}));
            connect(emf.flange, Jmotor.flange_a) annotation (Line(
                points={{66,0},{70,0}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (
              Documentation(info="<html>
<p>
Default values are given for the motor of joint 1.
The input of the motor is the desired current
(the actual current is proportional to the torque
produced by the motor).
</p>
</html>"),           Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}), graphics={Text(
                    extent={{0,120},{0,60}},
                    textString="%name",
                    lineColor={0,0,255}), Line(
                    points={{80,-102},{80,-10}},
                    color={255,204,51},
                    thickness=0.5)}));
          end Motor;

          model Controller "P-PI cascade controller for one axis"
            parameter Real kp=10 "Gain of position controller";
            parameter Real ks=1 "Gain of speed controller";
            parameter Modelica_SIunits.Time Ts=0.01
              "Time constant of integrator of speed controller";
            parameter Real ratio=1 "Gear ratio of gearbox";

            Modelica_Blocks.Math.Gain gain1(k=ratio)
              annotation (Placement(transformation(extent={{-70,0},{-50,20}},
                    rotation=0)));
            Modelica_Blocks.Continuous.PI PI(k=ks, T=Ts)
              annotation (Placement(transformation(extent={{60,0},{80,20}}, rotation=
                      0)));
            Modelica_Blocks.Math.Feedback feedback1
              annotation (Placement(transformation(extent={{-46,0},{-26,20}},
                    rotation=0)));
            Modelica_Blocks.Math.Gain P(k=kp) annotation (Placement(transformation(
                    extent={{-16,0},{4,20}}, rotation=0)));
            Modelica_Blocks.Math.Add3 add3(k3=-1) annotation (Placement(
                  transformation(extent={{20,0},{40,20}}, rotation=0)));
            Modelica_Blocks.Math.Gain gain2(k=ratio)
              annotation (Placement(transformation(extent={{-60,40},{-40,60}},
                    rotation=0)));
            Modelica_Mechanics_MultiBody.Examples.Systems.RobotR3.Components.AxisControlBus
              axisControlBus annotation (Placement(transformation(extent={{-20,
                      -120},{20,-80}}, rotation=0)));
          equation
            connect(gain1.y, feedback1.u1)
              annotation (Line(points={{-49,10},{-44,10}}, color={0,0,127}));
            connect(feedback1.y, P.u)
              annotation (Line(points={{-27,10},{-18,10}}, color={0,0,127}));
            connect(P.y, add3.u2) annotation (Line(points={{5,10},{18,10}}, color={0,
                    0,127}));
            connect(gain2.y, add3.u1)
              annotation (Line(points={{-39,50},{10,50},{10,18},{18,18}}, color={0,0,
                    127}));
            connect(add3.y, PI.u)
              annotation (Line(points={{41,10},{58,10}}, color={0,0,127}));
            connect(gain2.u, axisControlBus.speed_ref)
                                            annotation (Line(points={{-62,50},{-90,50},
                    {-90,-100},{0,-100}}, color={0,0,127}));
            connect(gain1.u, axisControlBus.angle_ref)
                                            annotation (Line(points={{-72,10},{-80,10},
                    {-80,-100},{0,-100}}, color={0,0,127}));
            connect(feedback1.u2, axisControlBus.motorAngle)
                                                  annotation (Line(points={{-36,2},{
                    -36,-100},{0,-100}}, color={0,0,127}));
            connect(add3.u3, axisControlBus.motorSpeed)
                                             annotation (Line(points={{18,2},{0,2},{0,
                    -100}}, color={0,0,127}));
            connect(PI.y, axisControlBus.current_ref)
                                           annotation (Line(points={{81,10},{90,10},{
                    90,-100},{0,-100}}, color={0,0,127}));
            annotation (
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}), graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,0},
                    pattern=LinePattern.Solid,
                    lineThickness=0.25,
                    fillColor={235,235,235},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-30,54},{30,24}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,255}),
                  Polygon(
                    points={{-30,40},{-60,50},{-60,30},{-30,40}},
                    lineColor={0,0,255},
                    fillColor={0,0,255},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-31,-41},{-78,-41},{-78,39},{-30,39}}, color={0,0,255}),
                  Rectangle(
                    extent={{-30,-26},{30,-56}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,255}),
                  Polygon(
                    points={{60,-32},{30,-42},{60,-52},{60,-32}},
                    fillColor={0,0,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,255}),
                  Line(points={{30,39},{76,39},{76,-41},{30,-41}}, color={0,0,255}),
                  Text(
                    extent={{-100,150},{100,110}},
                    textString="%name",
                    lineColor={0,0,255})}),
              Documentation(info="<html>
<p>
This controller has an inner PI-controller to control the motor speed,
and an outer P-controller to control the motor position of one axis.
The reference signals are with respect to the gear-output, and the
gear ratio is used in the controller to determine the motor
reference signals. All signals are communicated via the
\"axisControlBus\".
</p>
</html>"));
          end Controller;

          model AxisType1 "Axis model of the r3 joints 1,2,3"
            extends AxisType2(redeclare GearType1 gear(c=c, d=cd));
            parameter Real c(unit="N.m/rad") = 43 "Spring constant"
              annotation (Dialog(group="Gear"));
            parameter Real cd(unit="N.m.s/rad") = 0.005 "Damper constant"
              annotation (Dialog(group="Gear"));
          end AxisType1;

          model AxisType2 "Axis model of the r3 joints 4,5,6"
            parameter Real kp=10 "Gain of position controller"
              annotation (Dialog(group="Controller"));
            parameter Real ks=1 "Gain of speed controller"
              annotation (Dialog(group="Controller"));
            parameter Modelica_SIunits.Time Ts=0.01
              "Time constant of integrator of speed controller"
              annotation (Dialog(group="Controller"));
            parameter Real k=1.1616 "Gain of motor"
              annotation (Dialog(group="Motor"));
            parameter Real w=4590 "Time constant of motor"
              annotation (Dialog(group="Motor"));
            parameter Real D=0.6 "Damping constant of motor"
              annotation (Dialog(group="Motor"));
            parameter Modelica_SIunits.Inertia J(min=0) = 0.0013
              "Moment of inertia of motor" annotation (Dialog(group="Motor"));
            parameter Real ratio=-105 "Gear ratio"  annotation (Dialog(group="Gear"));
            parameter Modelica_SIunits.Torque Rv0=0.4
              "Viscous friction torque at zero velocity in [Nm]"
              annotation (Dialog(group="Gear"));
            parameter Real Rv1(unit="N.m.s/rad") = (0.13/160)
              "Viscous friction coefficient in [Nms/rad]"
              annotation (Dialog(group="Gear"));
            parameter Real peak=1
              "Maximum static friction torque is peak*Rv0 (peak >= 1)"
              annotation (Dialog(group="Gear"));

            Modelica_Mechanics_Rotational.Interfaces.Flange_b flange
              annotation (Placement(transformation(extent={{90,-10},{110,10}},
                    rotation=0)));
            replaceable GearType2 gear(
              Rv0=Rv0,
              Rv1=Rv1,
              peak=peak,
              i=ratio) annotation (Placement(transformation(extent={{0,-10},{20,10}},
                    rotation=0)));
            Motor motor(
              J=J,
              k=k,
              w=w,
              D=D) annotation (Placement(transformation(extent={{-30,-10},{-10,10}},
                    rotation=0)));
            RobotR3.Components.Controller controller(
              kp=kp,
              ks=ks,
              Ts=Ts,
              ratio=ratio) annotation (Placement(transformation(extent={{-70,-10},{
                      -50,10}}, rotation=0)));
            Modelica_Mechanics_MultiBody.Examples.Systems.RobotR3.Components.AxisControlBus
              axisControlBus annotation (Placement(transformation(
                  origin={-100,0},
                  extent={{-20,-20},{20,20}},
                  rotation=270)));
            Modelica_Mechanics_Rotational.Sensors.AngleSensor angleSensor
              annotation (Placement(transformation(extent={{30,60},{50,80}}, rotation=
                     0)));
            Modelica_Mechanics_Rotational.Sensors.SpeedSensor speedSensor
              annotation (Placement(transformation(
                  origin={40,50},
                  extent={{10,10},{-10,-10}},
                  rotation=180)));
            Modelica_Mechanics_Rotational.Sensors.AccSensor accSensor
              annotation (Placement(transformation(extent={{30,20},{50,40}}, rotation=
                     0)));
            Modelica_Mechanics_Rotational.Components.InitializeFlange
              initializeFlange(                          stateSelect=StateSelect.prefer)
              annotation (Placement(transformation(extent={{-40,-60},{-20,-40}},
                    rotation=0)));
            Modelica_Blocks.Sources.Constant const(k=0) annotation (Placement(
                  transformation(extent={{-65,-65},{-55,-55}}, rotation=0)));
          equation
            connect(gear.flange_b, flange)
              annotation (Line(points={{20,0},{100,0}}, color={0,0,0}));
            connect(gear.flange_b, angleSensor.flange)
              annotation (Line(points={{20,0},{20,70},{30,70}}, color={0,0,0}));
            connect(gear.flange_b, speedSensor.flange)
              annotation (Line(points={{20,0},{24,0},{24,50},{30,50}}, color={0,0,0}));
            connect(motor.flange_motor, gear.flange_a)
              annotation (Line(points={{-10,0},{0,0}}, color={0,0,0}));
            connect(gear.flange_b, accSensor.flange)
              annotation (Line(points={{20,0},{28,0},{28,30},{30,30}}, color={0,0,0}));
            connect(controller.axisControlBus, axisControlBus) annotation (Line(
                points={{-60,-10},{-60,-20},{-95,-20},{-95,-4},{-100,-4},{-100,0}},
                color={255,204,51},
                thickness=0.5));
            connect(motor.axisControlBus, axisControlBus) annotation (Line(
                points={{-12,-10},{-12,-20},{-95,-20},{-95,-5},{-100,-5},{-100,0}},
                color={255,204,51},
                thickness=0.5));
            connect(angleSensor.phi, axisControlBus.angle) annotation (
              Text(
                string="%second",
                index=1,
                extent=[6,3; 6,3]), Line(points={{51,70},{70,70},{70,
                    84},{-98,84},{-98,9},{-100,9},{-100,0}}, color={0,0,127}));
            connect(speedSensor.w, axisControlBus.speed) annotation (
              Text(
                string="%second",
                index=1,
                extent=[6,3; 6,3]), Line(points={{51,50},{74,50},{74,
                    87},{-100,87},{-100,0}}, color={0,0,127}));
            connect(accSensor.a, axisControlBus.acceleration) annotation (
              Text(
                string="%second",
                index=1,
                extent=[6,3; 6,3]), Line(points={{51,30},{77,30},{77,
                    90},{-102,90},{-102,0},{-100,0}}, color={0,0,127}));
            connect(axisControlBus.angle_ref, initializeFlange.phi_start) annotation (
              Text(
                string="%first",
                index=-1,
                extent=[-6,3; -6,3]), Line(points={{-100,0},{-100,-7},{
                    -97,-7},{-97,-42},{-42,-42}}, color={0,0,0}));
            connect(axisControlBus.speed_ref, initializeFlange.w_start) annotation (
              Text(
                string="%first",
                index=-1,
                extent=[-6,3; -6,3]), Line(points={{-100,0},{-99,0},{-99,
                    -50},{-42,-50}}, color={0,0,127}));
            connect(initializeFlange.flange, flange) annotation (Line(points={{-20,
                    -50},{80,-50},{80,0},{100,0}}, color={0,0,0}));
            connect(const.y, initializeFlange.a_start) annotation (Line(points={{-54.5,
                    -60},{-48,-60},{-48,-58},{-42,-58}},       color={0,0,127}));
            annotation (
              Documentation(info="<HTML>
<p>
The axis model consists of the <b>controller</b>, the <b>motor</b> including current
controller and the <b>gearbox</b> including gear elasticity and bearing friction.
The only difference to the axis model of joints 4,5,6 (= model axisType2) is
that elasticity and damping in the gear boxes are not neglected.
</p>
<p>
The input signals of this component are the desired angle and desired angular
velocity of the joint. The reference signals have to be \"smooth\" (position
has to be differentiable at least 2 times). Otherwise, the gear elasticity
leads to significant oscillations.
</p>
<p>
Default values of the parameters are given for the axis of joint 1.
</p>
</html>"),           Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}), graphics={Rectangle(
                    extent={{-100,50},{100,-50}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={160,160,164}), Text(
                    extent={{-150,57},{150,97}},
                    textString="%name",
                    lineColor={0,0,255})}));
          end AxisType2;

          model MechanicalStructure
            "Model of the mechanical part of the r3 robot (without animation)"
            import Modelica_SIunits.Conversions.to_unit1;

            parameter Boolean animation=true
              "= true, if animation shall be enabled";
            parameter Modelica_SIunits.Mass mLoad(min=0) = 15 "Mass of load";
            parameter Modelica_SIunits.Position rLoad[3]={0,0.25,0}
              "Distance from last flange to load mass>";
            parameter Modelica_SIunits.Acceleration g=9.81
              "Gravity acceleration";
            Modelica_SIunits.Angle q[6] "Joint angles";
            Modelica_SIunits.AngularVelocity qd[6] "Joint speeds";
            Modelica_SIunits.AngularAcceleration qdd[6] "Joint accelerations";
            Modelica_SIunits.Torque tau[6] "Joint driving torques";
            //r0={0,0.351,0},

            Modelica_Mechanics_Rotational.Interfaces.Flange_a axis1
              annotation (Placement(transformation(extent={{-220,-180},{-200,-160}},
                    rotation=0)));
            Modelica_Mechanics_Rotational.Interfaces.Flange_a axis2
              annotation (Placement(transformation(extent={{-220,-120},{-200,-100}},
                    rotation=0)));
            Modelica_Mechanics_Rotational.Interfaces.Flange_a axis3
              annotation (Placement(transformation(extent={{-220,-60},{-200,-40}},
                    rotation=0)));
            Modelica_Mechanics_Rotational.Interfaces.Flange_a axis4
              annotation (Placement(transformation(extent={{-220,0},{-200,20}},
                    rotation=0)));
            Modelica_Mechanics_Rotational.Interfaces.Flange_a axis5
              annotation (Placement(transformation(extent={{-220,60},{-200,80}},
                    rotation=0)));
            Modelica_Mechanics_Rotational.Interfaces.Flange_a axis6
              annotation (Placement(transformation(extent={{-220,120},{-200,140}},
                    rotation=0)));
            inner Modelica_Mechanics_MultiBody.World world(
              g=(g)*Modelica_Math.Vectors.length(({0,-1,0})),
              n={0,-1,0},
              animateWorld=false,
              animateGravity=false,
              enableAnimation=animation) annotation (Placement(transformation(
                    extent={{-100,-200},{-80,-180}}, rotation=0)));
            Modelica_Mechanics_MultiBody.Joints.Revolute r1(
              n={0,1,0},
              useAxisFlange=true,
              animation=animation) annotation (Placement(transformation(
                  origin={-70,-160},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
            Modelica_Mechanics_MultiBody.Joints.Revolute r2(
              n={1,0,0},
              useAxisFlange=true,
              animation=animation) annotation (Placement(transformation(extent=
                      {{-50,-110},{-30,-90}}, rotation=0)));
            Modelica_Mechanics_MultiBody.Joints.Revolute r3(
              n={1,0,0},
              useAxisFlange=true,
              animation=animation) annotation (Placement(transformation(
                  origin={-50,-36},
                  extent={{-10,-10},{10,10}},
                  rotation=180)));
            Modelica_Mechanics_MultiBody.Joints.Revolute r4(
              n={0,1,0},
              useAxisFlange=true,
              animation=animation) annotation (Placement(transformation(
                  origin={-70,10},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
            Modelica_Mechanics_MultiBody.Joints.Revolute r5(
              n={1,0,0},
              useAxisFlange=true,
              animation=animation) annotation (Placement(transformation(extent=
                      {{-60,70},{-40,90}}, rotation=0)));
            Modelica_Mechanics_MultiBody.Joints.Revolute r6(
              n={0,1,0},
              useAxisFlange=true,
              animation=animation) annotation (Placement(transformation(
                  origin={-60,130},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
            Modelica_Mechanics_MultiBody.Parts.BodyShape b0(
              r={0,0.351,0},
              shapeType=
                  "modelica://Modelica/Resources/Data/Shapes/RobotR3/b0.dxf",
              r_shape={0,0,0},
              lengthDirection={1,0,0},
              widthDirection={0,1,0},
              length=0.225,
              width=0.3,
              height=0.3,
              color={0,0,255},
              animation=animation,
              animateSphere=false,
              r_CM={0,0,0},
              m=1) annotation (Placement(transformation(
                  origin={-30,-170},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
            Modelica_Mechanics_MultiBody.Parts.BodyShape b1(
              r={0,0.324,0.3},
              I_22=1.16,
              shapeType=
                  "modelica://Modelica/Resources/Data/Shapes/RobotR3/b1.dxf",
              lengthDirection={1,0,0},
              widthDirection={0,1,0},
              length=0.25,
              width=0.15,
              height=0.2,
              animation=animation,
              animateSphere=false,
              color={255,0,0},
              r_CM={0,0,0},
              m=1) annotation (Placement(transformation(
                  origin={-70,-118},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
            Modelica_Mechanics_MultiBody.Parts.BodyShape b2(
              r={0,0.65,0},
              r_CM={0.172,0.205,0},
              m=56.5,
              I_11=2.58,
              I_22=0.64,
              I_33=2.73,
              I_21=-0.46,
              shapeType=
                  "modelica://Modelica/Resources/Data/Shapes/RobotR3/b2.dxf",
              r_shape={0,0,0},
              lengthDirection={1,0,0},
              widthDirection={0,1,0},
              length=0.5,
              width=0.2,
              height=0.15,
              animation=animation,
              animateSphere=false,
              color={255,178,0}) annotation (Placement(transformation(
                  origin={-16,-70},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
            Modelica_Mechanics_MultiBody.Parts.BodyShape b3(
              r={0,0.414,-0.155},
              r_CM={0.064,-0.034,0},
              m=26.4,
              I_11=0.279,
              I_22=0.245,
              I_33=0.413,
              I_21=-0.070,
              shapeType=
                  "modelica://Modelica/Resources/Data/Shapes/RobotR3/b3.dxf",
              r_shape={0,0,0},
              lengthDirection={1,0,0},
              widthDirection={0,1,0},
              length=0.15,
              width=0.15,
              height=0.15,
              animation=animation,
              animateSphere=false,
              color={255,0,0}) annotation (Placement(transformation(
                  origin={-86,-22},
                  extent={{-10,10},{10,-10}},
                  rotation=90)));
            Modelica_Mechanics_MultiBody.Parts.BodyShape b4(
              r={0,0.186,0},
              r_CM={0,0,0},
              m=28.7,
              I_11=1.67,
              I_22=0.081,
              I_33=1.67,
              shapeType=
                  "modelica://Modelica/Resources/Data/Shapes/RobotR3/b4.dxf",
              r_shape={0,0,0},
              lengthDirection={1,0,0},
              widthDirection={0,1,0},
              length=0.73,
              width=0.1,
              height=0.1,
              animation=animation,
              animateSphere=false,
              color={255,178,0}) annotation (Placement(transformation(
                  origin={-70,50},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
            Modelica_Mechanics_MultiBody.Parts.BodyShape b5(
              r={0,0.125,0},
              r_CM={0,0,0},
              m=5.2,
              I_11=1.25,
              I_22=0.81,
              I_33=1.53,
              shapeType=
                  "modelica://Modelica/Resources/Data/Shapes/RobotR3/b5.dxf",
              r_shape={0,0,0},
              lengthDirection={1,0,0},
              widthDirection={0,1,0},
              length=0.225,
              width=0.075,
              height=0.1,
              animation=animation,
              animateSphere=false,
              color={0,0,255}) annotation (Placement(transformation(
                  origin={-20,98},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
            Modelica_Mechanics_MultiBody.Parts.BodyShape b6(
              r={0,0,0},
              r_CM={0.05,0.05,0.05},
              m=0.5,
              shapeType=
                  "modelica://Modelica/Resources/Data/Shapes/RobotR3/b6.dxf",
              r_shape={0,0,0},
              lengthDirection={1,0,0},
              widthDirection={0,1,0},
              animation=animation,
              animateSphere=false,
              color={0,0,255}) annotation (Placement(transformation(
                  origin={-60,160},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
            Modelica_Mechanics_MultiBody.Parts.BodyShape load(
              r={0,0,0},
              r_CM=rLoad,
              m=mLoad,
              r_shape={0,0,0},
              widthDirection={1,0,0},
              width=0.05,
              height=0.05,
              color={255,0,0},
              lengthDirection=to_unit1(rLoad),
              length=Modelica_Math.Vectors.length(rLoad),
              animation=animation) annotation (Placement(transformation(
                  origin={-60,188},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
          equation
            connect(r6.frame_b, b6.frame_a)
              annotation (Line(
                points={{-60,140},{-60,150}},
                color={95,95,95},
                thickness=0.5));
            q = {r1.phi,r2.phi,r3.phi,r4.phi,r5.phi,r6.phi};
            qd = der(q);
            qdd = der(qd);
            tau = {r1.tau, r2.tau, r3.tau, r4.tau, r5.tau, r6.tau};
            connect(load.frame_a, b6.frame_b)
              annotation (Line(
                points={{-60,178},{-60,170}},
                color={95,95,95},
                thickness=0.5));
            connect(world.frame_b, b0.frame_a) annotation (Line(
                points={{-80,-190},{-30,-190},{-30,-180}},
                color={95,95,95},
                thickness=0.5));
            connect(b0.frame_b, r1.frame_a) annotation (Line(
                points={{-30,-160},{-30,-146},{-48,-146},{-48,-180},{-70,-180},{-70,
                    -170}},
                color={95,95,95},
                thickness=0.5));
            connect(b1.frame_b, r2.frame_a) annotation (Line(
                points={{-70,-108},{-70,-100},{-50,-100}},
                color={95,95,95},
                thickness=0.5));
            connect(r1.frame_b, b1.frame_a) annotation (Line(
                points={{-70,-150},{-70,-128}},
                color={95,95,95},
                thickness=0.5));
            connect(r2.frame_b, b2.frame_a) annotation (Line(
                points={{-30,-100},{-16,-100},{-16,-80}},
                color={95,95,95},
                thickness=0.5));
            connect(b2.frame_b, r3.frame_a) annotation (Line(
                points={{-16,-60},{-16,-36},{-40,-36}},
                color={95,95,95},
                thickness=0.5));
            connect(r2.axis, axis2) annotation (Line(points={{-40,-90},{-42,-90},{-42,
                    -80},{-160,-80},{-160,-110},{-210,-110}}, color={0,0,0}));
            connect(r1.axis, axis1) annotation (Line(points={{-80,-160},{-160,-160},{
                    -160,-170},{-210,-170}}, color={0,0,0}));
            connect(r3.frame_b, b3.frame_a) annotation (Line(
                points={{-60,-36},{-88,-36},{-86,-32}},
                color={95,95,95},
                thickness=0.5));
            connect(b3.frame_b, r4.frame_a) annotation (Line(
                points={{-86,-12},{-86,-8},{-70,-8},{-70,0}},
                color={95,95,95},
                thickness=0.5));
            connect(r3.axis, axis3)
              annotation (Line(points={{-50,-46},{-50,-50},{-210,-50}}, color={0,0,0}));
            connect(r4.axis, axis4)
              annotation (Line(points={{-80,10},{-210,10}}, color={0,0,0}));
            connect(r4.frame_b, b4.frame_a)
              annotation (Line(
                points={{-70,20},{-70,40}},
                color={95,95,95},
                thickness=0.5));
            connect(b4.frame_b, r5.frame_a) annotation (Line(
                points={{-70,60},{-70,80},{-60,80}},
                color={95,95,95},
                thickness=0.5));
            connect(r5.axis, axis5) annotation (Line(points={{-50,90},{-50,94},{-160,
                    94},{-160,70},{-210,70}}, color={0,0,0}));
            connect(r5.frame_b, b5.frame_a) annotation (Line(
                points={{-40,80},{-20,80},{-20,88}},
                color={95,95,95},
                thickness=0.5));
            connect(b5.frame_b, r6.frame_a) annotation (Line(
                points={{-20,108},{-20,116},{-60,116},{-60,120}},
                color={95,95,95},
                thickness=0.5));
            connect(r6.axis, axis6)
              annotation (Line(points={{-70,130},{-210,130}}, color={0,0,0}));
            annotation (
              Documentation(info="<HTML>
<p>
This model contains the mechanical components of the r3 robot
(multibody system).
</p>
</html>"),           Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-200,-200},{200,200}}), graphics={
                  Rectangle(
                    extent={{-200,200},{200,-200}},
                    lineColor={0,0,0},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-200,250},{200,210}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-200,-150},{-140,-190}},
                    textString="1",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-200,-30},{-140,-70}},
                    textString="3",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-200,-90},{-140,-130}},
                    textString="2",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-200,90},{-140,50}},
                    textString="5",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-200,28},{-140,-12}},
                    textString="4",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-198,150},{-138,110}},
                    textString="6",
                    lineColor={0,0,255}),
                  Bitmap(extent={{-130,195},{195,-195}}, fileName=
                        "modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Systems/robot_kr15.png")}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-200,-200},{200,200}})));
          end MechanicalStructure;

          annotation (Documentation(info="<html>
<p>
This library contains the different components
of the r3 robot. Usually, there is no need to
use this library directly.
</p>
</html>"));
        end Components;

        annotation (
          Documentation(info="<HTML>
<p>
This package contains models of the robot r3 of the company Manutec.
These models are used to demonstrate in which way complex
robot models might be built up by testing first the component
models individually before composing them together.
Furthermore, it is shown how CAD data can be used
for animation.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Systems/robot_kr15.png\"
ALT=\"model Examples.Systems.RobotR3\">

<p>
The following models are available:
</p>
<pre>
   <b>oneAxis</b>   Test one axis (controller, motor, gearbox).
   <b>fullRobot</b> Test complete robot model.
</pre>
<p>
The r3 robot is no longer manufactured. In fact the company
Manutec does no longer exist.
The parameters of this robot have been determined by measurements
in the laboratory of DLR. The measurement procedure is described in:
</p>
<pre>
   Tuerk S. (1990): Zur Modellierung der Dynamik von Robotern mit
       rotatorischen Gelenken. Fortschrittberichte VDI, Reihe 8, Nr. 211,
       VDI-Verlag 1990.
</pre>
<p>
The robot model is described in detail in
</p>
<pre>
   Otter M. (1995): Objektorientierte Modellierung mechatronischer
       Systeme am Beispiel geregelter Roboter. Dissertation,
       Fortschrittberichte VDI, Reihe 20, Nr. 147, VDI-Verlag 1995.
       This report can be downloaded as compressed postscript file
       from: <a href=\"http://www.robotic.dlr.de/Martin.Otter\">http://www.robotic.dlr.de/Martin.Otter</a>.
</pre>
<p>
The path planning is performed in a simple way by using essentially
the Modelica.Mechanics.Rotational.KinematicPTP block. A user defines
a path by start and end angle of every axis. A path is planned such
that all axes are moving as fast as possible under the given
restrictions of maximum joint speeds and maximum joint accelerations.
The actual r3 robot from Manutec had a different path planning strategy.
Todays path planning algorithms from robot companies are much
more involved.
</p>
<p>
In order to get a nice animation, CAD data from a KUKA robot
is used, since CAD data of the original r3 robot was not available.
The KUKA CAD data was derived from public data of KUKA available at:
<a href=\"http://www.kuka-roboter.de/english/produkte/cad/low_payloads.html\">
http://www.kuka-roboter.de/english/produkte/cad/low_payloads.html</a>.
Since dimensions of the corresponding KUKA robot are similar but not
identical to the r3 robot, the data of the r3 robot (such as arm lengths) have been modified, such that it matches the CAD data.
</p>
<p>
In this model, a simplified P-PI cascade controller for every
axes is used. The parameters have been manually adjusted by
simulations. The original r3 controllers are more complicated.
The reason to use simplified controllers is to have a simpler demo.
</p>
</html>"));

      end RobotR3;
    annotation ( Documentation(info="<html>
<p>
This package contains complete <b>system models</b> where components
from different domains are used, including 3-dimensional mechanics.
</p>
<h4>Content</h4>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><b><i>Model</i></b></th><th><b><i>Description</i></b></th></tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3\">RobotR3</a><br>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.oneAxis\">RobotR3.oneAxis</a><br>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.fullRobot\">RobotR3.fullRobot</a></td>
      <td valign=\"top\"> 6 degree of freedom robot with path planning,
           controllers, motors, brakes, gears and mechanics.
           \"oneAxis\" models only one drive train. \"fullRobot\" is
           the complete, detailed robot model.<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Systems/r3_fullRobot_small.png\">
      </td>
  </tr>
</table>
</html>"));
    end Systems;
  annotation ( Documentation(info="<html>
<p>
This package contains example models to demonstrate the usage of the
MultiBody package. Open the models and
simulate them according to the provided description in the models.
</p>

</html>"));
  end Examples;

  package Forces "Components that exert forces and/or torques between frames"
    extends Modelica_Icons.SourcesPackage;

    model WorldForce
      "External force acting at frame_b, defined by 3 input signals and resolved in frame world, frame_b or frame_resolve"

      extends Interfaces.PartialOneFrame_b;
      Interfaces.Frame_resolve frame_resolve if resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameB.frame_resolve
        "The input signals are optionally resolved in this frame"
        annotation (Placement(transformation(
            origin={0,-100},
            extent={{-16,-16},{16,16}},
            rotation=270)));
      Modelica_Blocks.Interfaces.RealInput force[3](each final quantity="Force", each final unit="N")
        "x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
              rotation=0)));
      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameB resolveInFrame=Types.ResolveInFrameB.world
        "Frame in which input force is resolved (1: world, 2: frame_b, 3: frame_resolve)";
      parameter Real N_to_m(unit="N/m") = world.defaultN_to_m
        "Force arrow scaling (length = force/N_to_m)"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter diameter=world.defaultArrowDiameter
        "Diameter of force arrow"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Color color=Types.Defaults.ForceColor "Color of arrow"
        annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));

    protected
      Modelica_SIunits.Position f_in_m[3]=frame_b.f/N_to_m
        "Force mapped from N to m for animation";
      Visualizers.Advanced.Arrow arrow(
        diameter=diameter,
        color=color,
        specularCoefficient=specularCoefficient,
        R=frame_b.R,
        r=frame_b.r_0,
        r_tail=f_in_m,
        r_head=-f_in_m) if world.enableAnimation and animation;

    public
      Internal.BasicWorldForce basicWorldForce(resolveInFrame=resolveInFrame)
        annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
    protected
      Interfaces.ZeroPosition zeroPosition if not (resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameB.frame_resolve)
        annotation (Placement(transformation(extent={{20,-40},{40,-20}})));
    equation
      connect(basicWorldForce.frame_b, frame_b) annotation (Line(
          points={{10,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(basicWorldForce.force, force) annotation (Line(
          points={{-12,0},{-120,0}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(basicWorldForce.frame_resolve, frame_resolve) annotation (Line(
          points={{0,-10},{0,-100}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, basicWorldForce.frame_resolve)
        annotation (Line(
          points={{20,-30},{0,-30},{0,-10}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      annotation (defaultComponentName="force",
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Text(
              extent={{-100,-46},{100,-76}},
              lineColor={192,192,192},
              textString="resolve"),
            Polygon(
              points={{-100,10},{50,10},{50,31},{94,0},{50,-31},{50,-10},{-100,-10},
                  {-100,10}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,85},{150,45}},
              textString="%name",
              lineColor={0,0,255}),
            Line(
              points={{0,-10},{0,-95}},
              color={95,95,95},
              pattern=LinePattern.Dot)}),
        Documentation(info="<HTML>

<p>
The <b>3</b> signals of the <b>force</b> connector are interpreted
as the x-, y- and z-coordinates of a <b>force</b> acting at the frame
connector to which frame_b of this component is attached.
Via parameter <b>resolveInFrame</b> it is defined, in which frame these
coordinates shall be resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.ResolveInFrameB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve input force in world frame (= default)</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve input force in frame_b</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve input force in frame_resolve (frame_resolve must be connected)</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameB.frame_resolve, the force coordinates
are with respect to the frame, that is connected to <b>frame_resolve</b>.
</p>

<p>
If force={100,0,0}, and for all parameters the default setting is used,
then the interpretation is that a force of 100 N is acting along the positive
x-axis of frame_b.
</p>

<p>
Note, the cut-torque in frame_b (frame_b.t) is always set to zero.
Conceptually, a force and torque acts on the world frame in such a way that
the force and torque balance between world.frame_b and frame_b is fulfilled.
For efficiency reasons, this reaction torque is, however, not computed.
</p>

<p>
This force component is by default visualized as an arrow
acting at the connector to which it is connected. The diameter
and color of the arrow can be defined via
variables <b>diameter</b> and <b>color</b>. The arrow
points in the direction defined by the
force signal. The length of the arrow is proportional
to the length of the force vector using parameter
<b>N_to_m</b> as scaling factor. For example, if N_to_m = 100 N/m,
then a force of 350 N is displayed as an arrow of length 3.5 m.
</p>
<p>
An example how to use this model is given in the
following figure:
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/WorldForce1.png\">
</p>

<p>
This leads to the following animation
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/WorldForce2.png\">
</p>

</html>"));
    end WorldForce;

    model WorldTorque
      "External torque acting at frame_b, defined by 3 input signals and resolved in frame world, frame_b or frame_resolve"

      extends Interfaces.PartialOneFrame_b;

      Interfaces.Frame_resolve frame_resolve if resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameB.frame_resolve
        "The input signals are optionally resolved in this frame"
        annotation (Placement(transformation(
            origin={0,100},
            extent={{16,-16},{-16,16}},
            rotation=270)));
      Modelica_Blocks.Interfaces.RealInput torque[3](each final quantity="Torque", each final unit="N.m")
        "x-, y-, z-coordinates of torque resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
              rotation=0)));
      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameB resolveInFrame=Types.ResolveInFrameB.world
        "Frame in which input torque is resolved (1: world, 2: frame_b, 3: frame_resolve)";
      parameter Real Nm_to_m(unit="N.m/m") = world.defaultNm_to_m
        "Torque arrow scaling (length = torque/Nm_to_m)"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter diameter=world.defaultArrowDiameter
        "Diameter of torque arrow"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Color color=Types.Defaults.TorqueColor "Color of arrow"
        annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));

    protected
      Modelica_SIunits.Position t_in_m[3]=frame_b.t/Nm_to_m
        "Torque mapped from Nm to m for animation";
      Visualizers.Advanced.DoubleArrow arrow(
        diameter=diameter,
        color=color,
        specularCoefficient=specularCoefficient,
        R=frame_b.R,
        r=frame_b.r_0,
        r_tail=t_in_m,
        r_head=-t_in_m) if world.enableAnimation and animation;
    public
      Internal.BasicWorldTorque basicWorldTorque(resolveInFrame=resolveInFrame)
        annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
    protected
      Interfaces.ZeroPosition zeroPosition if not (resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameB.frame_resolve)
        annotation (Placement(transformation(extent={{20,10},{40,30}})));
    equation
      connect(basicWorldTorque.frame_b, frame_b) annotation (Line(
          points={{10,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(basicWorldTorque.torque, torque) annotation (Line(
          points={{-12,0},{-120,0}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(frame_resolve, basicWorldTorque.frame_resolve) annotation (Line(
          points={{0,100},{0,10}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, basicWorldTorque.frame_resolve)
        annotation (Line(
          points={{20,20},{0,20},{0,10}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      annotation (defaultComponentName="torque",
        Documentation(info="<HTML>

<p>
The <b>3</b> signals of the <b>torque</b> connector are interpreted
as the x-, y- and z-coordinates of a <b>torque</b> acting at the frame
connector to which frame_b of this component is attached.
Via parameter <b>resolveInFrame</b> it is defined, in which frame these
coordinates shall be resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.ResolveInFrameB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve input torque in world frame (= default)</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve input torque in frame_b</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve input torque in frame_resolve (frame_resolve must be connected)</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameB.frame_resolve, the torque coordinates
are with respect to the frame, that is connected to <b>frame_resolve</b>.
</p>

<p>
If torque={100,0,0}, and for all parameters the default setting is used,
then the interpretation is that a torque of 100 N is acting along the positive
x-axis of frame_b.
</p>

<p>
Note, the cut-force in frame_b (frame_b.f) is always set to zero.
Conceptually, a force and torque acts on the world frame in such a way that
the force and torque balance between world.frame_b and frame_b is fulfilled.
For efficiency reasons, this reaction torque is, however, not computed.
</p>

<p>
This torque component is by default visualized as a <b>double arrow</b>
acting at the connector to which it is connected. The diameter
and color of the arrow can be defined via
variables <b>diameter</b> and <b>color</b>. The double arrow points
in the direction defined by the
torque vector. The length of the double arrow is proportional
to the length of the torque vector using parameter
<b>Nm_to_m</b> as scaling factor. For example, if Nm_to_m = 100 Nm/m,
then a torque of 350 Nm is displayed as an arrow of length 3.5 m.
</p>
<p>
An example how to use this model is given in the
following figure:
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/WorldTorque1.png\">
</p>

<p>
This leads to the following animation
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/WorldTorque2.png\">
</p>

</html>"),     Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Text(
              extent={{-61,64},{46,27}},
              lineColor={192,192,192},
              textString="resolve"),
            Text(
              extent={{-150,-40},{150,-80}},
              textString="%name",
              lineColor={0,0,255}),
            Line(
              points={{0,95},{0,82}},
              color={95,95,95},
              pattern=LinePattern.Dot),
            Line(
              points={{-100,0},{-94,13},{-86,28},{-74,48},{-65,60},{-52,72},{-35,
                  81},{-22,84},{-8,84},{7,80},{19,73},{32,65},{44,55},{52,47},{58,
                  40}},
              color={0,0,0},
              thickness=0.5),
            Polygon(
              points={{94,10},{75,59},{41,24},{94,10}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid)}));
    end WorldTorque;

    model WorldForceAndTorque
      "External force and torque acting at frame_b, defined by 3+3 input signals and resolved in frame world, frame_b or in frame_resolve"

      import Modelica_Mechanics_MultiBody.Types;
      extends Interfaces.PartialOneFrame_b;
      Interfaces.Frame_resolve frame_resolve if resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameB.frame_resolve
        "The input signals are optionally resolved in this frame"
        annotation (Placement(transformation(
            origin={0,100},
            extent={{16,-16},{-16,16}},
            rotation=270)));
      Modelica_Blocks.Interfaces.RealInput force[3](each final quantity="Force",
          each final unit="N")
        "x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(extent={{-140,-80},{-100,-40}},
              rotation=0)));
      Modelica_Blocks.Interfaces.RealInput torque[3](each final quantity=
            "Torque", each final unit="N.m")
        "x-, y-, z-coordinates of torque resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(extent={{-140,40},{-100,80}},
              rotation=0)));

      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameB resolveInFrame=Types.ResolveInFrameB.world
        "Frame in which input force and torque are resolved (1: world, 2: frame_b, 3: frame_resolve)";

      parameter Real N_to_m(unit="N/m") = world.defaultN_to_m
        "Force arrow scaling (length = force/N_to_m)"
        annotation (Dialog(group="if animation = true", enable=animation));
      parameter Real Nm_to_m(unit="N.m/m") = world.defaultNm_to_m
        "Torque arrow scaling (length = torque/Nm_to_m)"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter forceDiameter=world.defaultArrowDiameter
        "Diameter of force arrow"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter torqueDiameter=forceDiameter
        "Diameter of torque arrow"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Color forceColor=Types.Defaults.ForceColor
        "Color of force arrow" annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.Color torqueColor=Types.Defaults.TorqueColor
        "Color of torque arrow" annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));

    protected
      Modelica_SIunits.Position f_in_m[3]=frame_b.f/N_to_m
        "Force mapped from N to m for animation";
      Modelica_SIunits.Position t_in_m[3]=frame_b.t/Nm_to_m
        "Torque mapped from Nm to m for animation";
      Visualizers.Advanced.Arrow forceArrow(
        diameter=forceDiameter,
        color=forceColor,
        specularCoefficient=specularCoefficient,
        R=frame_b.R,
        r=frame_b.r_0,
        r_tail=f_in_m,
        r_head=-f_in_m) if world.enableAnimation and animation;
      Visualizers.Advanced.DoubleArrow torqueArrow(
        diameter=torqueDiameter,
        color=torqueColor,
        specularCoefficient=specularCoefficient,
        R=frame_b.R,
        r=frame_b.r_0,
        r_tail=t_in_m,
        r_head=-t_in_m) if world.enableAnimation and animation;
    public
      Internal.BasicWorldForce basicWorldForce(resolveInFrame=resolveInFrame)
        annotation (Placement(transformation(extent={{18,-50},{38,-70}})));
      Internal.BasicWorldTorque basicWorldTorque(resolveInFrame=resolveInFrame)
        annotation (Placement(transformation(extent={{-10,50},{10,70}})));
    protected
      Interfaces.ZeroPosition zeroPosition if not (resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameB.frame_resolve)
        annotation (Placement(transformation(extent={{58,70},{78,90}})));
    equation
      connect(basicWorldForce.frame_b, frame_b) annotation (Line(
          points={{38,-60},{60,-60},{60,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(basicWorldForce.force, force) annotation (Line(
          points={{16,-60},{-120,-60}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(basicWorldTorque.frame_b, frame_b)
                                        annotation (Line(
          points={{10,60},{60,60},{60,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(basicWorldTorque.torque, torque)
                                      annotation (Line(
          points={{-12,60},{-120,60}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(basicWorldForce.frame_resolve, frame_resolve) annotation (Line(
          points={{28,-50},{28,80},{0,80},{0,100}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(basicWorldTorque.frame_resolve, frame_resolve)
                                                    annotation (Line(
          points={{0,70},{0,100}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, basicWorldTorque.frame_resolve)
                                                                 annotation (Line(
          points={{58,80},{0,80},{0,70}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, basicWorldForce.frame_resolve)
        annotation (Line(
          points={{58,80},{40,80},{40,-40},{28,-40},{28,-50}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      annotation (defaultComponentName="forceAndTorque",
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Text(
              extent={{-63,56},{44,19}},
              lineColor={192,192,192},
              textString="resolve"),
            Text(
              extent={{-150,-75},{150,-115}},
              textString="%name",
              lineColor={0,0,255}),
            Line(
              points={{-100,60},{-86,68},{-80,72},{-70,78},{-64,82},{-46,86},{-34,
                  88},{-16,88},{-2,86},{12,80},{24,74},{34,68},{46,58},{52,54},{
                  58,48}},
              color={0,0,0},
              thickness=0.5),
            Polygon(
              points={{89,17},{64,76},{30,41},{89,17}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(
              points={{0,95},{0,-26}},
              color={95,95,95},
              pattern=LinePattern.Dot),
            Line(
              points={{0,0},{96,0}},
              color={95,95,95},
              pattern=LinePattern.Dot),
            Polygon(
              points={{-104,-48},{54,0},{46,20},{96,0},{66,-42},{60,-22},{-96,-72},
                  {-104,-48}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid)}),
        Documentation(info="<HTML>
<p>
The <b>3</b> signals of the <b>force</b> and <b>torque</b>
connector are interpreted
as the x-, y- and z-coordinates of a <b>force</b> and
<b>torque</b> acting at the frame
connector to which frame_b of this component is attached.
Via parameter <b>resolveInFrame</b> it is defined, in which frame these
coordinates shall be resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.ResolveInFrameB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve input force and torque in world frame (= default)</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve input force and torque in frame_b</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve input force and torque in frame_resolve
                    (frame_resolve must be connected)</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameB.frame_resolve, the force and
torque coordinates
are with respect to the frame, that is connected to <b>frame_resolve</b>.
</p>

<p>
If force={100,0,0}, and for all parameters the default setting is used,
then the interpretation is that a force of 100 N is acting along the positive
x-axis of frame_b.
</p>

<p>
Conceptually, a force and torque acts on the world frame in such a way that
the force and torque balance between world.frame_b and frame_b is fulfilled.
For efficiency reasons, this reaction torque is, however, not computed.
</p>

<p>
The force and torque are by default visualized as an arrow (force)
and as a double arrow (torque) acting at the connector to which
they are connected. The diameters
and colors of the arrows can be defined via
variables <b>forceDiameter</b>, <b>torqueDiameter</b>,
<b>forceColor</b> and <b>torqueColor</b>. The arrows
point in the directions defined by the
force and torque vectors. The lengths of the arrows are proportional
to the length of the force and torque vectors, respectively, using parameters
<b>N_to_m</b> and <b>Nm_to_m</b> as scaling factors. For example, if N_to_m = 100 N/m,
then a force of 350 N is displayed as an arrow of length 3.5 m.
</p>
<p>
An example how to use this model is given in the
following figure:
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/WorldForceAndTorque1.png\">
</p>

<p>
This leads to the following animation
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/WorldForceAndTorque2.png\">
</p>

</html>"));
    end WorldForceAndTorque;

    model Force
      "Force acting between two frames, defined by 3 input signals and resolved in frame world, frame_a, frame_b or frame_resolve"
      import Modelica_SIunits.Conversions.to_unit1;
      extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;
      Interfaces.Frame_resolve frame_resolve if resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve
        "The input signals are optionally resolved in this frame"
        annotation (Placement(transformation(
            origin={40,100},
            extent={{-16,-16},{16,16}},
            rotation=90)));
      Modelica_Blocks.Interfaces.RealInput force[3](each final quantity="Force", each final unit="N")
        "x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(
            origin={-60,120},
            extent={{-20,-20},{20,20}},
            rotation=270)));
      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB resolveInFrame=Types.ResolveInFrameAB.frame_b
        "Frame in which input force is resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)";
      parameter Real N_to_m(unit="N/m") = world.defaultN_to_m
        "Force arrow scaling (length = force/N_to_m)"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter forceDiameter=world.defaultArrowDiameter
        "Diameter of force arrow"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter connectionLineDiameter=forceDiameter
        "Diameter of line connecting frame_a and frame_b"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Color forceColor=Types.Defaults.ForceColor
        "Color of force arrow" annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.Color connectionLineColor=Types.Defaults.SensorColor
        "Color of line connecting frame_a and frame_b"
        annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));

    protected
      Modelica_SIunits.Position f_in_m[3]=frame_b.f/N_to_m
        "Force mapped from N to m for animation";
      Visualizers.Advanced.Arrow forceArrow(
        diameter=forceDiameter,
        color=forceColor,
        specularCoefficient=specularCoefficient,
        R=frame_b.R,
        r=frame_b.r_0,
        r_tail=f_in_m,
        r_head=-f_in_m) if world.enableAnimation and animation;
      Visualizers.Advanced.Shape connectionLine(
        shapeType="cylinder",
        lengthDirection = to_unit1(basicForce.r_0),
        widthDirection={0,1,0},
        length=Modelica_Math.Vectors.length(basicForce.r_0),
        width=connectionLineDiameter,
        height=connectionLineDiameter,
        color=connectionLineColor,
        specularCoefficient=specularCoefficient,
        r=frame_a.r_0) if world.enableAnimation and animation;

    public
      Internal.BasicForce basicForce(resolveInFrame=resolveInFrame)
        annotation (Placement(transformation(extent={{0,-10},{20,10}})));
    protected
      Interfaces.ZeroPosition zeroPosition if not (resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve)
        annotation (Placement(transformation(extent={{40,10},{60,30}})));
    equation
      connect(basicForce.frame_a, frame_a) annotation (Line(
          points={{0,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(basicForce.frame_b, frame_b) annotation (Line(
          points={{20,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(force, basicForce.force) annotation (Line(
          points={{-60,120},{-60,40},{4,40},{4,12}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(basicForce.frame_resolve, frame_resolve) annotation (Line(
          points={{14,10},{14,40},{40,40},{40,100}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, basicForce.frame_resolve) annotation (
          Line(
          points={{40,20},{27,20},{27,10},{14,10}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-98,99},{99,-98}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-92,61},{87,35}},
              lineColor={192,192,192},
              textString="resolve"),
            Text(
              extent={{-150,-55},{150,-95}},
              textString="%name",
              lineColor={0,0,255}),
            Line(
              points={{40,100},{40,0}},
              color={95,95,95},
              pattern=LinePattern.Dot),
            Polygon(
              points={{-94,0},{-64,11},{-64,-10},{-94,0}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-60,100},{40,100}},
              color={95,95,95},
              pattern=LinePattern.Dot),
            Polygon(
              points={{94,0},{65,12},{65,-11},{94,0}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{-64,0},{-20,0}}, color={0,0,0}),
            Line(points={{20,0},{65,0}}, color={0,0,0})}),
        Documentation(info="<html>
<p>
The <b>3</b> signals of the <b>force</b> connector are interpreted
as the x-, y- and z-coordinates of a <b>force</b> acting at the frame
connector to which frame_b of this component is attached.
Via parameter <b>resolveInFrame</b> it is defined, in which frame these
coordinates shall be resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve input force in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve input force in frame_a</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve input force in frame_b (= default)</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve input force in frame_resolve (frame_resolve must be connected)</td></tr>
</table>

<p>
If resolveInFrame = ResolveInFrameAB.frame_resolve, the force coordinates
are with respect to the frame, that is connected to <b>frame_resolve</b>.
</p>

<p>
If force={100,0,0}, and for all parameters the default setting is used,
then the interpretation is that a force of 100 N is acting along the positive
x-axis of frame_b.
</p>

<p>
Note, the cut-torque in frame_b (frame_b.t) is always set to zero.
Additionally, a force and torque acts on frame_a in such a way that
the force and torque balance between frame_a and frame_b is fulfilled.
</p>

<p>
An example how to use this model is given in the
following figure:
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/Force1.png\">
</p>

<p>
This leads to the following animation (the yellow cylinder
characterizes the line between frame_a and frame_b of the
Force component, i.e., the force acts with negative sign
also on the opposite side of this cylinder, but for
clarity this is not shown in the animation):
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/Force2.png\">
</p>

</html>"));
    end Force;

    model Torque
      "Torque acting between two frames, defined by 3 input signals and resolved in frame world, frame_a, frame_b or frame_resolve"
      import Modelica_SIunits.Conversions.to_unit1;
      extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;
      Interfaces.Frame_resolve frame_resolve if resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve
        "The input signals are optionally resolved in this frame"
        annotation (Placement(transformation(
            origin={40,100},
            extent={{-16,-16},{16,16}},
            rotation=90)));

      Modelica_Blocks.Interfaces.RealInput torque[3](each final quantity="Torque", each final unit="N.m")
        "x-, y-, z-coordinates of torque resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(
            origin={-60,120},
            extent={{-20,-20},{20,20}},
            rotation=270)));
      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB resolveInFrame=Types.ResolveInFrameAB.frame_b
        "Frame in which input force is resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)";
      parameter Real Nm_to_m(unit="N.m/m") = world.defaultNm_to_m
        "Torque arrow scaling (length = torque/Nm_to_m)"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter torqueDiameter=world.defaultArrowDiameter
        "Diameter of torque arrow"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter connectionLineDiameter=torqueDiameter
        "Diameter of line connecting frame_a and frame_b"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Color torqueColor=Types.Defaults.TorqueColor
        "Color of torque arrow" annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.Color connectionLineColor=Types.Defaults.SensorColor
        "Color of line connecting frame_a and frame_b"
        annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));

    protected
      Modelica_SIunits.Position t_in_m[3]=frame_b.t/Nm_to_m
        "Torque mapped from Nm to m for animation";
      Visualizers.Advanced.DoubleArrow torqueArrow(
        diameter=torqueDiameter,
        color=torqueColor,
        specularCoefficient=specularCoefficient,
        R=frame_b.R,
        r=frame_b.r_0,
        r_tail=t_in_m,
        r_head=-t_in_m) if world.enableAnimation and animation;
      Visualizers.Advanced.Shape connectionLine(
        shapeType="cylinder",
        lengthDirection = to_unit1(basicTorque.r_0),
        widthDirection={0,1,0},
        length=Modelica_Math.Vectors.length(
                             basicTorque.r_0),
        width=connectionLineDiameter,
        height=connectionLineDiameter,
        color=connectionLineColor,
        specularCoefficient=specularCoefficient,
        r=frame_a.r_0) if world.enableAnimation and animation;

    public
      Internal.BasicTorque basicTorque(resolveInFrame=resolveInFrame)
        annotation (Placement(transformation(extent={{-8,-10},{12,10}})));
    protected
      Interfaces.ZeroPosition zeroPosition if not (resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve)
        annotation (Placement(transformation(extent={{34,10},{54,30}})));
    equation
      connect(basicTorque.frame_a, frame_a) annotation (Line(
          points={{-8,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(basicTorque.frame_b, frame_b) annotation (Line(
          points={{12,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(basicTorque.torque, torque) annotation (Line(
          points={{-4,12},{-4,60},{-60,60},{-60,120}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(basicTorque.frame_resolve, frame_resolve) annotation (Line(
          points={{6,10},{6,60},{40,60},{40,100}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, basicTorque.frame_resolve) annotation (
          Line(
          points={{34,20},{20,20},{20,10},{6,10}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-98,99},{99,-98}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-59,55},{72,30}},
              lineColor={192,192,192},
              textString="resolve"),
            Text(
              extent={{-150,-30},{150,-70}},
              textString="%name",
              lineColor={0,0,255}),
            Polygon(
              points={{100,20},{84,52},{69,39},{100,20}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(
              points={{40,100},{76,46}},
              color={95,95,95},
              pattern=LinePattern.Dot),
            Polygon(
              points={{-99,20},{-86,53},{-70,42},{-99,20}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-60,100},{40,100}},
              color={95,95,95},
              pattern=LinePattern.Dot),
            Line(points={{-79,47},{-70,61},{-59,72},{-45,81},{-32,84},{-20,85}},
                color={0,0,0}),
            Line(points={{77,45},{66,60},{55,69},{49,74},{41,80},{31,84},{20,85}},
                color={0,0,0})}),
        Documentation(info="<HTML>
<p>
The <b>3</b> signals of the <b>torque</b> connector are interpreted
as the x-, y- and z-coordinates of a <b>torque</b> acting at the frame
connector to which frame_b of this component is attached.
Via parameter <b>resolveInFrame</b> it is defined, in which frame these
coordinates shall be resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve input torque in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve input torque in frame_a</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve input torque in frame_b (= default)</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve input torque in frame_resolve (frame_resolve must be connected)</td></tr>
</table>

<p>
If resolveInFrame = ResolveInFrameAB.frame_resolve, the torque coordinates
are with respect to the frame, that is connected to <b>frame_resolve</b>.
</p>

<p>
If torque={100,0,0}, and for all parameters the default setting is used,
then the interpretation is that a torque of 100 N.m is acting along the positive
x-axis of frame_b.
</p>

<p>
Note, the cut-forces in frame_a and frame_b (frame_a.f, frame_b.f) are
always set to zero and the cut-torque at frame_a (frame_a.t) is the same
as the cut-torque at frame_b (frame_b.t) but with opposite sign.
</p>

<p>
An example how to use this model is given in the
following figure:
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/Torque1.png\">
</p>

<p>
This leads to the following animation (the yellow cylinder
characterizes the line between frame_a and frame_b of the
Torque component, i.e., the torque acts with negative sign
also on the opposite side of this cylinder, but for
clarity this is not shown in the animation):
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/Torque2.png\">
</p>

</html>"));
    end Torque;

    model ForceAndTorque
      "Force and torque acting between two frames, defined by 3+3 input signals and resolved in frame world, frame_a, frame_b or frame_resolve"

      import Modelica_Mechanics_MultiBody.Types;
      import Modelica_SIunits.Conversions.to_unit1;

      extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;

      Modelica_Blocks.Interfaces.RealInput force[3](each final quantity="Force",
          each final unit="N")
        "x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(
            origin={-80,120},
            extent={{-20,-20},{20,20}},
            rotation=270)));
      Modelica_Blocks.Interfaces.RealInput torque[3](each final quantity=
            "Torque", each final unit="N.m")
        "x-, y-, z-coordinates of torque resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(
            origin={0,120},
            extent={{-20,-20},{20,20}},
            rotation=270)));
      Interfaces.Frame_resolve frame_resolve if resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve
        "The input signals are optionally resolved in this frame"
        annotation (Placement(transformation(
            origin={80,100},
            extent={{-16,-16},{16,16}},
            rotation=90)));

      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB resolveInFrame=Types.ResolveInFrameAB.frame_b
        "Frame in which input force and torque are resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)";
      parameter Real N_to_m(unit="N/m") = world.defaultN_to_m
        "Force arrow scaling (length = force/N_to_m)"
        annotation (Dialog(group="if animation = true", enable=animation));
      parameter Real Nm_to_m(unit="N.m/m") = world.defaultNm_to_m
        "Torque arrow scaling (length = torque/Nm_to_m)"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter forceDiameter=world.defaultArrowDiameter
        "Diameter of force arrow"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter torqueDiameter=forceDiameter
        "Diameter of torque arrow"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter connectionLineDiameter=forceDiameter
        "Diameter of line connecting frame_a and frame_b"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Color forceColor=Types.Defaults.ForceColor
        "Color of force arrow" annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.Color torqueColor=Types.Defaults.TorqueColor
        "Color of torque arrow" annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.Color connectionLineColor=Types.Defaults.SensorColor
        "Color of line connecting frame_a and frame_b"
        annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));

    protected
      Modelica_SIunits.Position f_in_m[3]=frame_b.f/N_to_m
        "Force mapped from N to m for animation";
      Modelica_SIunits.Position t_in_m[3]=frame_b.t/Nm_to_m
        "Torque mapped from Nm to m for animation";
      Visualizers.Advanced.Arrow forceArrow(
        diameter=forceDiameter,
        color=forceColor,
        specularCoefficient=specularCoefficient,
        R=frame_b.R,
        r=frame_b.r_0,
        r_tail=f_in_m,
        r_head=-f_in_m) if world.enableAnimation and animation;
      Visualizers.Advanced.DoubleArrow torqueArrow(
        diameter=torqueDiameter,
        color=torqueColor,
        specularCoefficient=specularCoefficient,
        R=frame_b.R,
        r=frame_b.r_0,
        r_tail=t_in_m,
        r_head=-t_in_m) if world.enableAnimation and animation;
      Visualizers.Advanced.Shape connectionLine(
        shapeType="cylinder",
        lengthDirection = to_unit1(basicForce.r_0),
        widthDirection={0,1,0},
        length=Modelica_Math.Vectors.length(
                             basicForce.r_0),
        width=connectionLineDiameter,
        height=connectionLineDiameter,
        color=connectionLineColor,
        specularCoefficient=specularCoefficient,
        r=frame_a.r_0) if world.enableAnimation and animation;

    public
      Internal.BasicForce basicForce(resolveInFrame=resolveInFrame)
        annotation (Placement(transformation(extent={{-84,-10},{-64,10}})));
      Internal.BasicTorque basicTorque(resolveInFrame=resolveInFrame)
        annotation (Placement(transformation(extent={{-4,10},{16,30}})));
    protected
      Interfaces.ZeroPosition zeroPosition if not (resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve)
        annotation (Placement(transformation(extent={{20,30},{40,50}})));
    equation
      connect(basicForce.frame_a, frame_a) annotation (Line(
          points={{-84,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(basicForce.frame_b, frame_b) annotation (Line(
          points={{-64,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(basicTorque.frame_b, frame_b) annotation (Line(
          points={{16,20},{68,20},{68,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(basicTorque.frame_a, frame_a) annotation (Line(
          points={{-4,20},{-90,20},{-90,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(basicForce.force, force) annotation (Line(
          points={{-80,12},{-80,120}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(basicTorque.torque, torque) annotation (Line(
          points={{0,32},{0,120}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(basicTorque.frame_resolve, frame_resolve) annotation (Line(
          points={{10,30},{10,80},{80,80},{80,100}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(basicForce.frame_resolve, frame_resolve) annotation (Line(
          points={{-70,10},{-70,80},{80,80},{80,100}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, basicTorque.frame_resolve)  annotation (
          Line(
          points={{20,40},{10,40},{10,30}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, basicForce.frame_resolve) annotation (
          Line(
          points={{20,40},{-70,40},{-70,10}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-98,99},{99,-98}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-59,55},{72,30}},
              lineColor={192,192,192},
              textString="resolve"),
            Text(
              extent={{-150,-55},{150,-95}},
              textString="%name",
              lineColor={0,0,255}),
            Polygon(
              points={{100,21},{84,55},{69,39},{100,21}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(
              points={{80,100},{80,0}},
              color={95,95,95},
              pattern=LinePattern.Dot),
            Polygon(
              points={{-95,1},{-64,11},{-64,-10},{-95,1}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-100,20},{-86,53},{-70,42},{-100,20}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-80,100},{80,100}},
              color={95,95,95},
              pattern=LinePattern.Dot),
            Polygon(
              points={{94,0},{65,12},{65,-11},{94,0}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{-64,0},{-20,0}}, color={0,0,0}),
            Line(points={{20,0},{65,0}}, color={0,0,0}),
            Line(points={{-79,47},{-70,61},{-59,72},{-45,81},{-32,84},{-20,85}},
                color={0,0,0}),
            Line(points={{76,47},{66,60},{55,69},{49,74},{41,80},{31,84},{20,85}},
                color={0,0,0}),
            Text(
              extent={{-144,124},{-106,102}},
              lineColor={0,0,0},
              textString="f"),
            Text(
              extent={{20,124},{58,102}},
              lineColor={0,0,0},
              textString="t")}),
        Documentation(info="<HTML>
<p>
The <b>3</b> signals of the <b>force</b> connector and the
<b>3</b> signals of the <b>torque</b> connector
are interpreted
as the x-, y- and z-coordinates of a <b>force</b> and of a
<b>torque</b> acting at the frame
connector to which frame_b of this component is attached.
Via parameter <b>resolveInFrame</b> it is defined, in which frame these
coordinates shall be resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve input force/torque in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve input force/torque in frame_a</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve input force/torque in frame_b (= default)</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve input force/torque in frame_resolve (frame_resolve must be connected)</td></tr>
</table>

<p>
If resolveInFrame = ResolveInFrameAB.frame_resolve, the force and torque coordinates
are with respect to the frame, that is connected to <b>frame_resolve</b>.
</p>

<p>
If force={100,0,0}, and for all parameters the default setting is used,
then the interpretation is that a force of 100 N is acting along the positive
x-axis of frame_b.
</p>

<p>
Note, a force and torque acts on frame_a in such a way that
the force and torque balance between frame_a and frame_b is fulfilled.
</p>

<p>
An example how to use this model is given in the
following figure:
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/ForceAndTorque1.png\">
</p>

<p>
This leads to the following animation (the yellow cylinder
characterizes the line between frame_a and frame_b of the
ForceAndTorque component, i.e., the force and torque acts with
negative sign
also on the opposite side of this cylinder, but for
clarity this is not shown in the animation):
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/ForceAndTorque2.png\">
</p>

</html>"));
    end ForceAndTorque;

    model LineForceWithMass
      "General line force component with an optional point mass on the connection line"

      import Modelica_Mechanics_MultiBody.Types;
      extends Interfaces.PartialTwoFrames;
      Modelica_Mechanics_Translational.Interfaces.Flange_a flange_b
        "1-dim. translational flange (connect force of Translational library between flange_a and flange_b)"
        annotation (Placement(transformation(
            origin={60,100},
            extent={{-10,-10},{10,10}},
            rotation=90)));
      Modelica_Mechanics_Translational.Interfaces.Flange_b flange_a
        "1-dim. translational flange (connect force of Translational library between flange_a and flange_b)"
        annotation (Placement(transformation(
            origin={-60,100},
            extent={{-10,-10},{10,10}},
            rotation=90)));

      parameter Boolean animateLine=true
        "= true, if a line shape between frame_a and frame_b shall be visualized";
      parameter Boolean animateMass=true
        "= true, if point mass shall be visualized as sphere provided m > 0";
      parameter Modelica_SIunits.Mass m(min=0) = 0
        "Mass of point mass on the connection line between the origin of frame_a and the origin of frame_b";
      parameter Real lengthFraction(
        unit="1",
        min=0,
        max=1) = 0.5
        "Location of point mass with respect to frame_a as a fraction of the distance from frame_a to frame_b";
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(tab="Animation"));
      parameter Types.ShapeType lineShapeType="cylinder"
        "Type of shape visualizing the line from frame_a to frame_b"
        annotation (Dialog(tab="Animation", group="if animateLine = true", enable=animateLine));
      input Modelica_SIunits.Length lineShapeWidth=world.defaultArrowDiameter
        "Width of shape" annotation (Dialog(
          tab="Animation",
          group="if animateLine = true",
          enable=animateLine));
      input Modelica_SIunits.Length lineShapeHeight=lineShapeWidth
        "Height of shape" annotation (Dialog(
          tab="Animation",
          group="if animateLine = true",
          enable=animateLine));
      parameter Types.ShapeExtra lineShapeExtra=0.0 "Extra parameter for shape"
        annotation (Dialog(tab="Animation", group="if animateLine = true", enable=animateLine));
      input Types.Color lineShapeColor=Types.Defaults.SensorColor
        "Color of line shape"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animateLine = true", enable=animateLine));
      input Real massDiameter=world.defaultBodyDiameter
        "Diameter of point mass sphere"
        annotation (Dialog(tab="Animation", group="if animateMass = true", enable=animateMass));
      input Types.Color massColor=Types.Defaults.BodyColor
        "Color of point mass"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animateMass = true", enable=animateMass));
      parameter Modelica_SIunits.Position s_small=1.E-10
        "Prevent zero-division if distance between frame_a and frame_b is zero"
        annotation (Dialog(tab="Advanced"));
      parameter Boolean fixedRotationAtFrame_a=false
        "=true, if rotation frame_a.R is fixed (to directly connect line forces)"
         annotation (Evaluate=true, choices(checkBox=true),Dialog(tab="Advanced", group="If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces"));
      parameter Boolean fixedRotationAtFrame_b=false
        "=true, if rotation frame_b.R is fixed (to directly connect line forces)"
         annotation (Evaluate=true, choices(checkBox=true),Dialog(tab="Advanced", group="If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces"));

      Modelica_SIunits.Distance length
        "Distance between the origin of frame_a and the origin of frame_b";
      Modelica_SIunits.Position r_rel_0[3]
        "Position vector from frame_a to frame_b resolved in world frame";
      Real e_rel_0[3](each final unit="1")
        "Unit vector in direction from frame_a to frame_b, resolved in world frame";

    protected
      Modelica_SIunits.Force fa "Force from flange_a";
      Modelica_SIunits.Force fb "Force from flange_b";
      Modelica_SIunits.Position r_CM_0[3](each stateSelect=StateSelect.avoid)
        "Position vector from world frame to point mass, resolved in world frame";
      Modelica_SIunits.Velocity v_CM_0[3](each stateSelect=StateSelect.avoid)
        "First derivative of r_CM_0";
      Modelica_SIunits.Acceleration ag_CM_0[3]
        "der(v_CM_0) - gravityAcceleration";

      Visualizers.Advanced.Shape lineShape(
        shapeType=lineShapeType,
        color=lineShapeColor,
        specularCoefficient=specularCoefficient,
        length=length,
        width=lineShapeWidth,
        height=lineShapeHeight,
        lengthDirection=e_rel_0,
        widthDirection=Frames.resolve1(frame_a.R, {0,1,0}),
        extra=lineShapeExtra,
        r=frame_a.r_0) if world.enableAnimation and animateLine;

      Visualizers.Advanced.Shape massShape(
        shapeType="sphere",
        color=massColor,
        specularCoefficient=specularCoefficient,
        length=massDiameter,
        width=massDiameter,
        height=massDiameter,
        lengthDirection=e_rel_0,
        widthDirection={0,1,0},
        r_shape=e_rel_0*(length*lengthFraction - massDiameter/2),
        r=frame_a.r_0) if world.enableAnimation and animateMass and m > 0;
    equation
      assert(noEvent(length > s_small), "
The distance between the origin of frame_a and the origin of frame_b
of a LineForceWithMass component became smaller as parameter s_small
(= a small number, defined in the \"Advanced\" menu). The distance is
set to s_small, although it is smaller, to avoid a division by zero
when computing the direction of the line force. Possible reasons
for this situation:
- At initial time the distance may already be zero: Change the initial
  positions of the bodies connected by this element.
- Hardware stops are not modeled or are modeled not stiff enough.
  Include stops, e.g., stiff springs, or increase the stiffness
  if already present.
- Another error in your model may lead to unrealistically large forces
  and torques that would in reality destroy the stops.
- The flange_b connector might be defined by a pre-defined motion,
  e.g., with Modelica.Mechanics.Translational.Position and the
  predefined flange_b.s is zero or negative.
");

      // Determine relative position vector between the two frames
      r_rel_0 = frame_b.r_0 - frame_a.r_0;
      length = Modelica_Math.Vectors.length(
                             r_rel_0);
      flange_a.s = 0;
      flange_b.s = length;
      e_rel_0 = r_rel_0/Frames.Internal.maxWithoutEvent(length, s_small);

      // Determine translational flange forces
      if cardinality(flange_a) > 0 and cardinality(flange_b) > 0 then
        fa = flange_a.f;
        fb = flange_b.f;
      elseif cardinality(flange_a) > 0 and cardinality(flange_b) == 0 then
        fa = flange_a.f;
        fb = -fa;
      elseif cardinality(flange_a) == 0 and cardinality(flange_b) > 0 then
        fa = -fb;
        fb = flange_b.f;
      else
        fa = 0;
        fb = 0;
      end if;

      /* Force and torque balance of point mass
     - Kinematics for center of mass CM of point mass including gravity
       r_CM_0 = frame_a.r0 + r_rel_CM_0;
       v_CM_0 = der(r_CM_0);
       ag_CM_0 = der(v_CM_0) - world.gravityAcceleration(r_CM_0);
     - Power balance for the connection line
       (f1=force on frame_a side, f2=force on frame_b side, h=lengthFraction)
       0 = f1*va - m*ag_CM*(va+(vb-va)*h) + f2*vb
         = (f1 - m*ag_CM*(1-h))*va + (f2 - m*ag_CM*h)*vb
       since va and vb are completely independent from other
       the parenthesis must vanish:
         f1 := m*ag_CM*(1-h)
         f2 := m*ag_CM*h
     - Force balance on frame_a and frame_b finally results in
         0 = frame_a.f + e_rel_a*fa - f1_a
         0 = frame_b.f + e_rel_b*fb - f2_b
       and therefore
         frame_a.f = -e_rel_a*fa + m*ag_CM_a*(1-h)
         frame_b.f = -e_rel_b*fb + m*ag_CM_b*h
  */
      if m > 0 then
        r_CM_0 = frame_a.r_0 + r_rel_0*lengthFraction;
        v_CM_0 = der(r_CM_0);
        ag_CM_0 = der(v_CM_0) - world.gravityAcceleration(r_CM_0);
        frame_a.f = Frames.resolve2(frame_a.R, (m*(1 - lengthFraction))*ag_CM_0
           - e_rel_0*fa);
        frame_b.f = Frames.resolve2(frame_b.R, (m*lengthFraction)*ag_CM_0 -
          e_rel_0*fb);
      else
        r_CM_0 = zeros(3);
        v_CM_0 = zeros(3);
        ag_CM_0 = zeros(3);
        frame_a.f = -Frames.resolve2(frame_a.R, e_rel_0*fa);
        frame_b.f = -Frames.resolve2(frame_b.R, e_rel_0*fb);
      end if;

      // Provide appropriate equations, if direct connections of line forces
      if fixedRotationAtFrame_a then
        Connections.root(frame_a.R);
        frame_a.R = Frames.nullRotation();
      else
        frame_a.t = zeros(3);
      end if;

      if fixedRotationAtFrame_b then
        Connections.root(frame_b.R);
        frame_b.R = Frames.nullRotation();
      else
        frame_b.t = zeros(3);
      end if;
      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Ellipse(
              extent={{-95,-40},{-15,40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{-85,-30},{-25,30}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{15,-40},{95,40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{23,-30},{83,29}},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,-55},{150,-95}},
              textString="%name",
              lineColor={0,0,255}),
            Rectangle(
              extent={{-40,41},{44,-40}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-70,15},{-41,-13}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{40,14},{69,-14}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Line(points={{-56,0},{-56,23},{-30,23},{-30,70},{-60,70},{-60,101}},
                color={0,0,0}),
            Line(points={{55,-1},{55,20},{30,20},{30,70},{60,70},{60,100}}, color=
                 {0,0,0}),
            Line(
              points={{-56,0},{55,-1}},
              color={0,0,0},
              pattern=LinePattern.Dot),
            Ellipse(
              extent={{-8,8},{8,-8}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(visible=fixedRotationAtFrame_a, extent={{-70,30},{-130,-30}}, lineColor={255,0,0}),
            Text(visible=fixedRotationAtFrame_a,
              extent={{-62,50},{-140,30}},
              lineColor={255,0,0},
              textString="R=0"),
            Ellipse(visible=fixedRotationAtFrame_b, extent={{70,30},{130,-30}}, lineColor={255,0,0}),
            Text(visible=fixedRotationAtFrame_b,
              extent={{62,50},{140,30}},
              lineColor={255,0,0},
              textString="R=0")}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{-60,80},{46,80}}, color={0,0,255}),
            Polygon(
              points={{60,80},{45,86},{45,74},{60,80}},
              lineColor={0,0,255},
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-50,93},{32,78}},
              textString="length",
              lineColor={0,0,255}),
            Ellipse(
              extent={{-100,-40},{-20,40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{-90,-30},{-30,30}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{20,-40},{100,40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{31,-29},{91,30}},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-50,39},{50,-41}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-74,15},{-45,-13}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{45,15},{74,-13}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Line(points={{-60,0},{-60,24},{-40,24},{-40,60},{-60,60},{-60,100}},
                color={0,0,0}),
            Line(points={{60,1},{60,21},{40,21},{40,60},{60,60},{60,100}}, color=
                  {0,0,0}),
            Line(
              points={{-60,0},{60,0}},
              color={0,0,0},
              pattern=LinePattern.Dot),
            Ellipse(
              extent={{-8,8},{8,-8}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{-60,0},{-31,0}}, color={0,0,255}),
            Polygon(points={{-19,0},{-31,3},{-31,-3},{-19,0}}, lineColor={0,0,255}),
            Line(points={{-60,16},{0,16}}, color={0,0,255}),
            Line(points={{0,0},{0,20}}, color={0,0,255}),
            Text(
              extent={{-49,-11},{-8,-21}},
              lineColor={0,0,0},
              textString="e_rel_0"),
            Polygon(points={{0,16},{-12,19},{-12,13},{0,16}}, lineColor={0,0,255}),
            Text(
              extent={{-50,35},{51,26}},
              lineColor={0,0,0},
              textString="length*lengthFraction"),
            Line(
              points={{-17,26},{-26,16}},
              pattern=LinePattern.Dot,
              color={0,0,255}),
            Line(
              points={{-31,-13},{-40,0}},
              pattern=LinePattern.Dot,
              color={0,0,255})}),
        Documentation(info="<html>
<p>
This component is used to exert a <b>line force</b>
between the origin of frame_a and the origin of frame_b
by attaching components of the <b>1-dimensional translational</b>
mechanical library of Modelica (Modelica.Mechanics.Translational)
between the two flange connectors <b>flange_a</b> and
<b>flange_b</b>. Optionally, there is a <b>point mass</b> on the line
connecting the origin of frame_a and the origin of frame_b.
This point mass approximates the <b>mass</b> of the <b>force element</b>.
The distance of the point mass from frame_a as a fraction of the
distance between frame_a and frame_b is defined via
parameter <b>lengthFraction</b> (default is 0.5, i.e., the point
mass is in the middle of the line).
</p>
<p>
In the translational library there is the implicit assumption that
forces of components that have only one flange connector act with
opposite sign on the bearings of the component. This assumption
is also used in the LineForceWithMass component: If a connection
is present to only one of the flange connectors, then the force
in this flange connector acts implicitly with opposite sign also
in the other flange connector.
</p>
</html>"));
    end LineForceWithMass;

    model LineForceWithTwoMasses
      "General line force component with two optional point masses on the connection line"

      import Modelica_Mechanics_MultiBody.Types;

      extends Interfaces.PartialTwoFrames;
      Modelica_Mechanics_Translational.Interfaces.Flange_a flange_b
        "1-dim. translational flange (connect force of Translational library between flange_a and flange_b)"
        annotation (Placement(transformation(
            origin={60,110},
            extent={{-10,-10},{10,10}},
            rotation=90)));
      Modelica_Mechanics_Translational.Interfaces.Flange_b flange_a
        "1-dim. translational flange (connect force of Translational library between flange_a and flange_b)"
        annotation (Placement(transformation(
            origin={-60,110},
            extent={{-10,-10},{10,10}},
            rotation=90)));

      parameter Boolean animate=true "= true, if animation shall be enabled";
      parameter Boolean animateMasses=true
        "= true, if point masses shall be visualized provided animate=true and m_a, m_b > 0";
      parameter Modelica_SIunits.Mass m_a(min=0) = 0
        "Mass of point mass a on the connection line between the origin of frame_a and the origin of frame_b";
      parameter Modelica_SIunits.Mass m_b(min=0) = 0
        "Mass of point mass b on the connection line between the origin of frame_a and the origin of frame_b";
      parameter Modelica_SIunits.Position L_a=0
        "Distance between point mass a and frame_a (positive, if in direction of frame_b)";
      parameter Modelica_SIunits.Position L_b=L_a
        "Distance between point mass b and frame_b (positive, if in direction of frame_a)";
      input Modelica_SIunits.Diameter cylinderDiameter_a=world.defaultForceWidth
        "Diameter of cylinder at frame_a" annotation (Dialog(
          tab="Animation",
          group="Cylinder at frame_a if animation = true",
          enable=animate));
      parameter Modelica_SIunits.Length cylinderLength_a=2*L_a
        "Length of cylinder at frame_a" annotation (Dialog(
          tab="Animation",
          group="Cylinder at frame_a if animation = true",
          enable=animate));
      input Types.Color color_a={155,155,155} "Color of cylinder at frame_a"
        annotation (Dialog(colorSelector=true, tab="Animation", group="Cylinder at frame_a if animation = true", enable=animate));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(tab="Animation", group="Cylinder at frame_a if animation = true", enable=animate));
      input Real diameterFraction=0.8
        "Diameter of cylinder at frame_b with respect to diameter of cylinder at frame_a"
        annotation (Dialog(tab="Animation", group="Cylinder at frame_b if animation = true", enable=animate));
      parameter Modelica_SIunits.Length cylinderLength_b=2*L_b
        "Length of cylinder at frame_b" annotation (Dialog(
          tab="Animation",
          group="Cylinder at frame_b if animation = true",
          enable=animate));
      input Types.Color color_b={100,100,100} "Color of cylinder at frame_b"
        annotation (Dialog(colorSelector=true, tab="Animation", group="Cylinder at frame_b if animation = true", enable=animate));
      input Real massDiameterFaction=1.7
        "Diameter of point mass spheres with respect to cylinderDiameter_a"
        annotation (Dialog(tab="Animation", group="if animation = true and animateMasses = true", enable=animate and animateMasses));
      input Types.Color massColor=Types.Defaults.BodyColor
        "Color of point masses"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true and animateMasses = true", enable=animate and animateMasses));
      parameter Modelica_SIunits.Position s_small=1.E-10
        "Prevent zero-division if distance between frame_a and frame_b is zero"
        annotation (Dialog(tab="Advanced"));
      parameter Boolean fixedRotationAtFrame_a=false
        "=true, if rotation frame_a.R is fixed (to directly connect line forces)"
         annotation (Evaluate=true, choices(checkBox=true),Dialog(tab="Advanced", group="If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces"));
      parameter Boolean fixedRotationAtFrame_b=false
        "=true, if rotation frame_b.R is fixed (to directly connect line forces)"
         annotation (Evaluate=true, choices(checkBox=true),Dialog(tab="Advanced", group="If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces"));

      Modelica_SIunits.Distance length
        "Distance between the origin of frame_a and the origin of frame_b";
      Modelica_SIunits.Position r_rel_0[3]
        "Position vector from frame_a to frame_b resolved in world frame";
      Real e_rel_0[3](each final unit="1")
        "Unit vector in direction from frame_a to frame_b, resolved in world frame";

    protected
      Modelica_SIunits.Force fa "Force from flange_a";
      Modelica_SIunits.Force fb "Force from flange_b";
      Modelica_SIunits.Position r_CM1_0[3](each stateSelect=StateSelect.avoid)
        "Position vector from world frame to point mass 1, resolved in world frame";
      Modelica_SIunits.Position r_CM2_0[3](each stateSelect=StateSelect.avoid)
        "Position vector from world frame to point mass 2, resolved in world frame";
      Modelica_SIunits.Velocity v_CM1_0[3](each stateSelect=StateSelect.avoid)
        "der(r_CM_1_0) - velocity of point mass 1";
      Modelica_SIunits.Velocity v_CM2_0[3](each stateSelect=StateSelect.avoid)
        "der(r_CM_2_0) - velocity of point mass 2";
      Modelica_SIunits.Acceleration ag_CM1_0[3]
        "der(v_CM1_0) - gravityAcceleration(r_CM1_0)";
      Modelica_SIunits.Acceleration ag_CM2_0[3]
        "der(v_CM2_0) - gravityAcceleration(r_CM2_0)";
      Modelica_SIunits.Force aux1_0[3] "Auxiliary force 1";
      Modelica_SIunits.Force aux2_0[3] "Auxiliary force 2";

      input Modelica_SIunits.Length cylinderDiameter_b=cylinderDiameter_a*
          diameterFraction;
      input Modelica_SIunits.Length massDiameter=cylinderDiameter_a*
          massDiameterFaction;
      parameter Boolean animateMasses2=world.enableAnimation and animate and animateMasses and m_a > 0 and m_b > 0;
      Visualizers.Advanced.Shape cylinder_a(
        shapeType="cylinder",
        color=color_a,
        specularCoefficient=specularCoefficient,
        length=cylinderLength_a,
        width=cylinderDiameter_a,
        height=cylinderDiameter_a,
        lengthDirection=e_rel_0,
        widthDirection={0,1,0},
        r=frame_a.r_0) if world.enableAnimation and animate;

      Visualizers.Advanced.Shape cylinder_b(
        shapeType="cylinder",
        color=color_b,
        specularCoefficient=specularCoefficient,
        length=cylinderLength_b,
        width=cylinderDiameter_b,
        height=cylinderDiameter_b,
        lengthDirection=-e_rel_0,
        widthDirection={0,1,0},
        r=frame_b.r_0) if world.enableAnimation and animate;

      Visualizers.Advanced.Shape sphere_a(
        shapeType="sphere",
        color=massColor,
        specularCoefficient=specularCoefficient,
        length=massDiameter,
        width=massDiameter,
        height=massDiameter,
        lengthDirection=e_rel_0,
        widthDirection={0,1,0},
        r_shape=e_rel_0*(L_a - massDiameter/2),
        r=frame_a.r_0) if animateMasses2;

      Visualizers.Advanced.Shape sphere_b(
        shapeType="sphere",
        color=massColor,
        specularCoefficient=specularCoefficient,
        length=massDiameter,
        width=massDiameter,
        height=massDiameter,
        lengthDirection=-e_rel_0,
        widthDirection={0,1,0},
        r_shape=-e_rel_0*(L_b - massDiameter/2),
        r=frame_b.r_0) if animateMasses2;
    equation
      assert(noEvent(length > s_small), "
The distance between the origin of frame_a and the origin of frame_b
of a LineForceWithTwoMasses component became smaller as parameter s_small
(= a small number, defined in the \"Advanced\" menu). The distance is
set to s_small, although it is smaller, to avoid a division by zero
when computing the direction of the line force. Possible reasons
for this situation:
- At initial time the distance may already be zero: Change the initial
  positions of the bodies connected by this element.
- Hardware stops are not modeled or are modeled not stiff enough.
  Include stops, e.g., stiff springs, or increase the stiffness
  if already present.
- Another error in your model may lead to unrealistically large forces
  and torques that would in reality destroy the stops.
- The flange_b connector might be defined by a pre-defined motion,
  e.g., with Modelica.Mechanics.Translational.Position and the
  predefined flange_b.s is zero or negative.
");

      // Determine relative position vector between the two frames
      r_rel_0 = frame_b.r_0 - frame_a.r_0;
      length = Modelica_Math.Vectors.length(
                             r_rel_0);
      flange_a.s = 0;
      flange_b.s = length;
      e_rel_0 = r_rel_0/Frames.Internal.maxWithoutEvent(length, s_small);

      // Determine translational flange forces
      if cardinality(flange_a) > 0 and cardinality(flange_b) > 0 then
        fa = flange_a.f;
        fb = flange_b.f;
      elseif cardinality(flange_a) > 0 and cardinality(flange_b) == 0 then
        fa = flange_a.f;
        fb = -fa;
      elseif cardinality(flange_a) == 0 and cardinality(flange_b) > 0 then
        fa = -fb;
        fb = flange_b.f;
      else
        fa = 0;
        fb = 0;
      end if;

      /* Force and torque balance of the two point masses
     - Kinematics for center of masses CM1, CM2 of point masses including gravity
       (L = length, va = der(frame_a.r_0), vb = der(frame_b.r_0))
       r_CM1_0 = frame_a.r_0 + e_rel_0*L_a;
       r_CM2_0 = frame_b.r_0 - e_rel_0*L_b;
       v_CM1_0 = der(r_CM1_0);
       v_CM2_0 = der(r_CM2_0);
       ag_CM1_0 = der(v_CM1_0) - world.gravityAcceleration(r_CM1_0);
       ag_CM2_0 = der(v_CM2_0) - world.gravityAcceleration(r_CM2_0);
       der(e_rel_0) = der(r_rel_0/sqrt(r_rel_0*r_rel_0))
                    = 1/L*(I - e_rel_0*e_rel_0')*der(r_rel_0)
                    = 1/L*(I - e_rel_0*e_rel_0')*(vb - va)
       v_CM1_0 = va + L_a/L*(I - e_rel_0*e_rel_0')*(vb - va)
       v_CM2_0 = vb - L_b/L*(I - e_rel_0*e_rel_0')*(vb - va)
     - Power balance for the connection line
       (f1=force on frame_a side, f2=force on frame_b side)
       0 = f1*va - m_a*ag_CM1*v_CM1 + f2*vb - m_b*ag_CM2*v_CM2
         = f1*va - m_a*ag_CM1*(va + L_a/L*(I - e_rel*e_rel')*(vb - va)) +
           f2*vb - m_b*ag_CM2*(vb - L_b/L*(I - e_rel*e_rel')*(vb - va))
         = (f1 - m_a*ag_CM1*(I - L_a/L*(I - e_rel*e_rel'))
               - m_b*ag_CM2*(L_b/L*(I - e_rel*e_rel')))*va +
           (f2 - m_b*ag_CM2*(I - L_b/L*(I - e_rel_0*e_rel_0'))
               - m_a*ag_CM1*(L_a/L*(I - e_rel*e_rel')))*vb
         = va*(f1 - m_a*ag_CM1 +
               (m_a*ag_CM1*L_a/L - m_b*ag_CM2*L_b/L)*(I - e_rel*e_rel')) +
           vb*(f2 - m_b*ag_CM2 +
               (m_b*ag_CM2*L_b/L - m_a*ag_CM1*L_a/L)*(I - e_rel*e_rel'))
       since va and vb are completely independent from other
       the parenthesis must vanish:
         f1 := m_a*ag_CM1 - (m_a*ag_CM1*L_a/L - m_b*ag_CM2*L_b/L)*(I - e_rel*e_rel')
         f2 := m_b*ag_CM2 + (m_a*ag_CM1*L_a/L - m_b*ag_CM2*L_b/L)*(I - e_rel*e_rel')
       or
         aux1 := ag_CM1*(m_a*L_a/L) - ag_CM2*(m_b*L_b/L);
         aux2 := aux1 - (aux1'*e_rel)*e_rel
         f1 := m_a*ag_CM1 - aux2
         f2 := m_b*ag_CM2 + aux2
     - Force balance on frame_a and frame_b finally results in
         0 = frame_a.f + e_rel_a*fa - f1_a
         0 = frame_b.f + e_rel_b*fb - f2_b
       and therefore
         frame_a.f = -e_rel_a*fa + m_a*ag_CM1 - aux2
         frame_b.f = -e_rel_b*fb + m_b*ag_CM2 + aux2
  */
      if m_a > 0 or m_b > 0 then
        r_CM1_0 = frame_a.r_0 + e_rel_0*L_a;
        r_CM2_0 = frame_b.r_0 - e_rel_0*L_b;
        v_CM1_0 = der(r_CM1_0);
        v_CM2_0 = der(r_CM2_0);
        ag_CM1_0 = der(v_CM1_0) - world.gravityAcceleration(r_CM1_0);
        ag_CM2_0 = der(v_CM2_0) - world.gravityAcceleration(r_CM2_0);
        aux1_0 = ag_CM1_0*(m_a*L_a/length) - ag_CM2_0*(m_b*L_b/length);
        aux2_0 = aux1_0 - (aux1_0*e_rel_0)*e_rel_0;
        frame_a.f = Frames.resolve2(frame_a.R, m_a*ag_CM1_0 - aux2_0 - e_rel_0*fa);
        frame_b.f = Frames.resolve2(frame_b.R, m_b*ag_CM2_0 + aux2_0 - e_rel_0*fb);
      else
        r_CM1_0 = zeros(3);
        r_CM2_0 = zeros(3);
        v_CM1_0 = zeros(3);
        v_CM2_0 = zeros(3);
        ag_CM1_0 = zeros(3);
        ag_CM2_0 = zeros(3);
        aux1_0 = zeros(3);
        aux2_0 = zeros(3);
        frame_a.f = -Frames.resolve2(frame_a.R, e_rel_0*fa);
        frame_b.f = -Frames.resolve2(frame_b.R, e_rel_0*fb);
      end if;

      // Provide appropriate equations, if direct connections of line forces
      if fixedRotationAtFrame_a then
        Connections.root(frame_a.R);
        frame_a.R = Frames.nullRotation();
      else
        frame_a.t = zeros(3);
      end if;

      if fixedRotationAtFrame_b then
        Connections.root(frame_b.R);
        frame_b.R = Frames.nullRotation();
      else
        frame_b.t = zeros(3);
      end if;

      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Ellipse(
              extent={{-100,-40},{-20,40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{-90,-30},{-30,30}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{20,-40},{100,40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{31,-29},{91,30}},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,-55},{150,-95}},
              textString="%name",
              lineColor={0,0,255}),
            Rectangle(
              extent={{-52,40},{48,-40}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-74,15},{-45,-13}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{45,14},{74,-14}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Line(points={{-60,0},{-60,23},{-30,23},{-30,70},{-60,70},{-60,101}},
                color={0,0,0}),
            Line(points={{60,0},{60,20},{30,20},{30,70},{60,70},{60,100}}, color=
                  {0,0,0}),
            Line(
              points={{-23,0},{25,0}},
              color={0,0,0},
              pattern=LinePattern.Dot),
            Ellipse(
              extent={{23,8},{39,-8}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-39,8},{-23,-8}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{-60,0},{-29,0}}, color={0,0,0}),
            Line(points={{29,0},{60,0}}, color={0,0,0}),
            Ellipse(visible=fixedRotationAtFrame_a, extent={{-70,30},{-130,-30}}, lineColor={255,0,0}),
            Text(visible=fixedRotationAtFrame_a,
              extent={{-62,50},{-140,30}},
              lineColor={255,0,0},
              textString="R=0"),
            Ellipse(visible=fixedRotationAtFrame_b, extent={{70,30},{130,-30}}, lineColor={255,0,0}),
            Text(visible=fixedRotationAtFrame_b,
              extent={{62,50},{140,30}},
              lineColor={255,0,0},
              textString="R=0")}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{-60,80},{46,80}}, color={0,0,255}),
            Polygon(
              points={{60,80},{45,86},{45,74},{60,80}},
              lineColor={0,0,255},
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-42,91},{30,79}},
              textString="length",
              lineColor={0,0,255}),
            Ellipse(
              extent={{-100,-40},{-20,40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{-90,-30},{-30,30}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{20,-40},{100,40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{31,-29},{91,30}},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-49,39},{51,-41}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-74,15},{-45,-13}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{45,15},{74,-13}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Line(points={{-60,0},{-60,24},{-40,24},{-40,60},{-60,60},{-60,110}},
                color={0,0,0}),
            Line(points={{60,1},{60,21},{40,21},{40,60},{60,60},{60,110}}, color=
                  {0,0,0}),
            Line(
              points={{-60,0},{60,0}},
              color={0,0,0},
              pattern=LinePattern.Dot),
            Ellipse(
              extent={{20,8},{36,-8}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{-18,-18},{11,-18}}, color={0,0,255}),
            Polygon(points={{23,-18},{11,-15},{11,-21},{23,-18}}, lineColor={0,0,
                  255}),
            Line(points={{-60,16},{-37,16}}, color={0,0,255}),
            Line(points={{-25,0},{-25,20}}, color={0,0,255}),
            Text(
              extent={{-38,-20},{33,-35}},
              lineColor={0,0,0},
              textString="e_rel_0"),
            Polygon(points={{-25,16},{-37,19},{-37,13},{-25,16}}, lineColor={0,0,
                  255}),
            Text(
              extent={{-39,31},{-22,21}},
              lineColor={0,0,0},
              textString="L_a"),
            Ellipse(
              extent={{-33,7},{-17,-9}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{29,3},{29,22}}, color={0,0,255}),
            Line(points={{29,16},{60,16}}, color={0,0,255}),
            Polygon(points={{29,16},{41,19},{41,13},{29,16}}, lineColor={0,0,255}),
            Text(
              extent={{15,36},{32,26}},
              lineColor={0,0,0},
              textString="L_b"),
            Line(
              points={{37,18},{30,27}},
              pattern=LinePattern.Dot,
              color={0,0,255})}),
        Documentation(info="<html>
<p>
This component is used to exert a <b>line force</b>
between the origin of frame_a and the origin of frame_b
by attaching components of the <b>1-dimensional translational</b>
mechanical library of Modelica (Modelica.Mechanics.Translational)
between the two flange connectors <b>flange_a</b> and
<b>flange_b</b>. Optionally, there are <b>two point masses</b> on the line
connecting the origin of frame_a and the origin of frame_b.
These point masses approximate the <b>masses</b> of the <b>force element</b>.
The locations of the two point masses are defined by their
(fixed) distances of L_a relative to frame_a and of L_b relative
to frame_b, respectively.
</p>
<p>
In example
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses\">
MultiBody.Examples.Elementary.LineForceWithTwoMasses</a> the usage of this
line force element is shown and is compared with an alternative
implementation using a
<a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUPS\">
MultiBody.Joints.Assemblies.JointUPS</a> component.
The composition diagram of this example
is displayed in the figure below.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/LineForceWithTwoMasses1.png\">
</p>

<p>
The animation view at time = 0 is shown in the next figure.
The system on the left side in the front is the animation with
the LineForceWithTwoMasses component whereas the system on the right
side in the back is the animation with the JointUPS component.
Both implementations yield the same result. However, the implementation
with the LineForceWithTwoMasses component is simpler.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/LineForceWithTwoMasses2.png\">
</p>

<p>
In the translational library there is the implicit assumption that
forces of components that have only one flange connector act with
opposite sign on the bearings of the component. This assumption
is also used in the LineForceWithTwoMasses component: If a connection
is present to only one of the flange connectors, then the force
in this flange connector acts implicitly with opposite sign also
in the other flange connector.
</p>
</html>"));
    end LineForceWithTwoMasses;

    model Spring "Linear translational spring with optional mass"
      import Modelica_Mechanics_MultiBody.Types;
      extends Interfaces.PartialTwoFrames;
      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Boolean showMass=true
        "= true, if point mass shall be visualized as sphere if animation=true and m>0";

      parameter Modelica_SIunits.TranslationalSpringConstant c(final min=0)
        "Spring constant";
      parameter Modelica_SIunits.Length s_unstretched=0
        "Unstretched spring length";
      parameter Modelica_SIunits.Mass m(min=0) = 0
        "Spring mass located on the connection line between the origin of frame_a and the origin of frame_b";
      parameter Real lengthFraction(
        min=0,
        max=1) = 0.5
        "Location of spring mass with respect to frame_a as a fraction of the distance from frame_a to frame_b (=0: at frame_a; =1: at frame_b)";
      input Modelica_SIunits.Distance width=world.defaultForceWidth
        "Width of spring" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Modelica_SIunits.Distance coilWidth=width/10 "Width of spring coil"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Integer numberOfWindings=5 "Number of spring windings"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
      input Types.Color color=Types.Defaults.SpringColor "Color of spring"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter massDiameter=max(0, (width - 2*coilWidth)
          *0.9) "Diameter of mass point sphere" annotation (Dialog(
          tab="Animation",
          group="if animation = true and showMass = true",
          enable=animation and showMass));
      input Types.Color massColor=Types.Defaults.BodyColor
        "Color of mass point" annotation (Dialog(colorSelector=true, tab="Animation", group=
              "if animation = true and showMass = true", enable=animation and showMass));
      parameter Boolean fixedRotationAtFrame_a=false
        "=true, if rotation frame_a.R is fixed (to directly connect line forces)"
         annotation (Evaluate=true, choices(checkBox=true),Dialog(tab="Advanced", group="If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces"));
      parameter Boolean fixedRotationAtFrame_b=false
        "=true, if rotation frame_b.R is fixed (to directly connect line forces)"
         annotation (Evaluate=true, choices(checkBox=true),Dialog(tab="Advanced", group="If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces"));

      Forces.LineForceWithMass lineForce(
        animateLine=animation,
        animateMass=showMass,
        m=m,
        lengthFraction=lengthFraction,
        lineShapeType="spring",
        lineShapeHeight=coilWidth*2,
        lineShapeWidth=width,
        lineShapeExtra=numberOfWindings,
        lineShapeColor=color,
        specularCoefficient=specularCoefficient,
        massDiameter=massDiameter,
        massColor=massColor,
        fixedRotationAtFrame_a=fixedRotationAtFrame_a,
        fixedRotationAtFrame_b=fixedRotationAtFrame_b) annotation (Placement(transformation(extent={{-20,
                -20},{20,20}}, rotation=0)));
      Modelica_Mechanics_Translational.Components.Spring spring(
                                                     s_rel0=s_unstretched, c=c)
        annotation (Placement(transformation(extent={{-8,40},{12,60}}, rotation=0)));

    equation
      connect(lineForce.frame_a, frame_a)
        annotation (Line(
          points={{-20,0},{-100,0}},
          color={95,95,95},
          thickness=0.5));
      connect(lineForce.frame_b, frame_b)
        annotation (Line(
          points={{20,0},{100,0}},
          color={95,95,95},
          thickness=0.5));
      connect(spring.flange_b, lineForce.flange_b)
        annotation (Line(points={{12,50},{12,20}}, color={0,191,0}));
      connect(spring.flange_a, lineForce.flange_a)
        annotation (Line(points={{-8,50},{-12,50},{-12,20}}, color={0,191,0}));

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
                        graphics={
            Line(
              points={{-100,0},{-58,0},{-43,-30},{-13,30},{17,-30},{47,30},{62,0},
                  {100,0}},
              color={0,0,0},
              pattern=LinePattern.Solid,
              thickness=0.25,
              arrow={Arrow.None,Arrow.None}),
            Text(
              extent={{-150,56},{150,96}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{-150,-80},{150,-50}},
              lineColor={0,0,0},
              textString="c=%c"),
            Ellipse(
              extent={{-8,8},{8,-8}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(visible=fixedRotationAtFrame_a, extent={{-70,30},{-130,-30}}, lineColor={255,0,0}),
            Text(visible=fixedRotationAtFrame_a,
              extent={{-62,50},{-140,30}},
              lineColor={255,0,0},
              textString="R=0"),
            Ellipse(visible=fixedRotationAtFrame_b, extent={{70,30},{130,-30}}, lineColor={255,0,0}),
            Text(visible=fixedRotationAtFrame_b,
              extent={{62,50},{140,30}},
              lineColor={255,0,0},
              textString="R=0")}),
        Documentation(info="<HTML>
<p>
<b>Linear spring</b> acting as line force between frame_a and frame_b.
A <b>force f</b> is exerted on the origin of frame_b and with opposite sign
on the origin of frame_a along the line from the origin of frame_a to the origin
of frame_b according to the equation:
</p>
<pre>
   f = c*(s - s_unstretched);
</pre>
<p>
where \"c\" and \"s_unstretched\" are parameters and \"s\" is the
distance between the origin of frame_a and the origin of frame_b.
</p>
<p>
Optionally, the mass of the spring is taken into account by a
point mass located on the line between frame_a and frame_b
(default: middle of the line). If the spring mass is zero, the
additional equations to handle the mass are removed.
</p>
<p>
In the following figure a typical animation of the
spring is shown. The blue sphere in the middle of the
spring characterizes the location of the point mass.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Examples/Elementary/SpringWithMass.png\"
ALT=\"model Examples.Elementary.SpringWithMass\">
</p>

</HTML>"));
    end Spring;

    model Damper "Linear (velocity dependent) damper"
      import Modelica_Mechanics_MultiBody.Types;
      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Modelica_SIunits.TranslationalDampingConstant d(final min=0,
          start=0) "Damping constant";
      parameter Modelica_SIunits.Distance length_a=world.defaultForceLength
        "Length of cylinder at frame_a side" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Modelica_SIunits.Diameter diameter_a=world.defaultForceWidth
        "Diameter of cylinder at frame_a side" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Modelica_SIunits.Diameter diameter_b=0.6*diameter_a
        "Diameter of cylinder at frame_b side" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color color_a={100,100,100} "Color at frame_a"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      input Types.Color color_b={155,155,155} "Color at frame_b"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
      extends Interfaces.PartialLineForce;
      extends
        Modelica_Thermal_HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort(
         final T=293.15);
    protected
      Modelica_SIunits.Position r0_b[3]=e_a*noEvent(min(length_a, s));
      Visualizers.Advanced.Shape shape_a(
        shapeType="cylinder",
        color=color_a,
        specularCoefficient=specularCoefficient,
        length=noEvent(min(length_a, s)),
        width=diameter_a,
        height=diameter_a,
        lengthDirection=e_a,
        widthDirection={0,1,0},
        r=frame_a.r_0,
        R=frame_a.R) if
                       world.enableAnimation and animation;
      Visualizers.Advanced.Shape shape_b(
        shapeType="cylinder",
        color=color_b,
        specularCoefficient=specularCoefficient,
        length=noEvent(max(s - length_a, 0)),
        width=diameter_b,
        height=diameter_b,
        lengthDirection=e_a,
        widthDirection={0,1,0},
        r_shape=r0_b,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;
    equation
      f = d*der(s);
      lossPower = f*der(s);
      annotation (
        Documentation(info="<HTML>
<p>
<b>Linear damper</b> acting as line force between frame_a and frame_b.
A <b>force f</b> is exerted on the origin of frame_b and with opposite sign
on the origin of frame_a along the line from the origin of frame_a to the origin
of frame_b according to the equation:
</p>
<pre>
   f = d*<b>der</b>(s);
</pre>
<p>
where \"d\" is a parameter, \"s\" is the
distance between the origin of frame_a and the origin of frame_b
and der(s) is the time derivative of \"s\".
</p>
<p>
In the following figure a typical animation is shown
where a mass is hanging on a damper.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/Damper.png\">
</p>

</HTML>"),
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{-101,0},{-60,0}}, color={0,0,0}),
            Line(points={{-60,-30},{-60,30}}, color={0,0,0}),
            Line(points={{-60,-30},{60,-30}}, color={0,0,0}),
            Line(points={{-60,30},{60,30}}, color={0,0,0}),
            Rectangle(
              extent={{-60,30},{30,-30}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{30,0},{100,0}}, color={0,0,0}),
            Text(
              extent={{-150,50},{150,90}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{-150,-75},{150,-45}},
              lineColor={0,0,0},
              textString="d=%d"),
            Line(visible=useHeatPort,
              points={{-100,-99},{-100,-25},{-10,-25}},
              color={191,0,0},
              pattern=LinePattern.Dot,
              smooth=Smooth.None)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{-100,0},{-60,0}}, color={0,0,0}),
            Line(points={{-60,-30},{-60,30}}, color={0,0,0}),
            Line(points={{-60,-30},{60,-30}}, color={0,0,0}),
            Line(points={{-60,30},{60,30}}, color={0,0,0}),
            Rectangle(
              extent={{-60,30},{30,-30}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{30,0},{100,0}}, color={0,0,0}),
            Line(points={{-50,60},{50,60}}, color={128,128,128}),
            Text(
              extent={{-40,64},{23,77}},
              lineColor={128,128,128},
              textString="der(s)"),
            Polygon(
              points={{64,60},{42,68},{42,52},{62,60},{64,60}},
              lineColor={128,128,128},
              fillColor={160,160,164},
              fillPattern=FillPattern.Solid)}));
    end Damper;

    model SpringDamperParallel "Linear spring and linear damper in parallel"
      import Modelica_Mechanics_MultiBody.Types;
      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Modelica_SIunits.TranslationalSpringConstant c(final min=0)
        "Spring constant";
      parameter Modelica_SIunits.Length s_unstretched=0
        "Unstretched spring length";
      parameter Modelica_SIunits.TranslationalDampingConstant d(final min=0)=
        0 "Damping constant";
      input Modelica_SIunits.Distance width=world.defaultForceWidth
        "Width of spring" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Modelica_SIunits.Distance coilWidth=width/10 "Width of spring coil"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Integer numberOfWindings=5 "Number of spring windings"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
      input Types.Color color=Types.Defaults.SpringColor "Color of spring"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
      extends Interfaces.PartialLineForce;
      extends
        Modelica_Thermal_HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort(
         final T=293.15);

    protected
      Modelica_SIunits.Force f_d "Damping force";
      Visualizers.Advanced.Shape shape(
        shapeType="spring",
        color=color,
        length=s,
        width=width,
        height=coilWidth*2,
        lengthDirection=e_a,
        widthDirection={0,1,0},
        extra=numberOfWindings,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;
    equation
      f_d = d*der(s);
      f = c*(s - s_unstretched) + f_d;
      lossPower = f_d*der(s);
      annotation (
        Documentation(info="<HTML>
<p>
<b>Linear spring</b> and <b>linear damper</b>
in parallel acting as line force between frame_a and frame_b.
A <b>force f</b> is exerted on the origin of frame_b and with opposite sign
on the origin of frame_a along the line from the origin of frame_a to the origin
of frame_b according to the equation:
</p>
<pre>
   f = c*(s - s_unstretched) + d*<b>der</b>(s);
</pre>
<p>
where \"c\", \"s_unstretched\" and \"d\" are parameters, \"s\" is the
distance between the origin of frame_a and the origin of frame_b
and der(s) is the time derivative of s.
</p>
</html>"),     Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Text(
              extent={{-150,-150},{150,-110}},
              textString="%name",
              lineColor={0,0,255}),
            Line(points={{-80,40},{-60,40},{-45,10},{-15,70},{15,10},{45,70},{60,
                  40},{80,40}}, color={0,0,0}),
            Line(points={{-80,40},{-80,-70}}, color={0,0,0}),
            Line(points={{-80,-70},{-52,-70}}, color={0,0,0}),
            Rectangle(
              extent={{-52,-40},{38,-100}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-52,-40},{68,-40}}, color={0,0,0}),
            Line(points={{-52,-100},{68,-100}}, color={0,0,0}),
            Line(points={{38,-70},{80,-70}}, color={0,0,0}),
            Line(points={{80,40},{80,-70}}, color={0,0,0}),
            Line(points={{-100,0},{-80,0}}, color={0,0,0}),
            Line(points={{80,0},{100,0}}, color={0,0,0}),
            Text(
              extent={{-150,70},{150,100}},
              lineColor={0,0,0},
              textString="d=%d"),
            Line(visible=useHeatPort,
              points={{-100,-101},{-100,-80},{-6,-80}},
              color={191,0,0},
              pattern=LinePattern.Dot,
              smooth=Smooth.None),
            Text(
              extent={{-150,105},{150,135}},
              lineColor={0,0,0},
              textString="c=%c")}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(
              points={{-80,32},{-58,32},{-43,2},{-13,62},{17,2},{47,62},{62,32},{
                  80,32}},
              color={0,0,0},
              thickness=0.5),
            Line(points={{-68,32},{-68,97}}, color={128,128,128}),
            Line(points={{72,32},{72,97}}, color={128,128,128}),
            Line(points={{-68,92},{72,92}}, color={128,128,128}),
            Polygon(
              points={{62,95},{72,92},{62,89},{62,95}},
              lineColor={128,128,128},
              fillColor={128,128,128},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-20,72},{20,97}},
              lineColor={0,0,255},
              textString="s"),
            Rectangle(
              extent={{-52,-20},{38,-80}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-52,-80},{68,-80}}, color={0,0,0}),
            Line(points={{-52,-20},{68,-20}}, color={0,0,0}),
            Line(points={{38,-50},{80,-50}}, color={0,0,0}),
            Line(points={{-80,-50},{-52,-50}}, color={0,0,0}),
            Line(points={{-80,32},{-80,-50}}, color={0,0,0}),
            Line(points={{80,32},{80,-50}}, color={0,0,0}),
            Line(points={{-100,0},{-80,0}}, color={0,0,0}),
            Line(points={{100,0},{80,0}}, color={0,0,0})}));
    end SpringDamperParallel;

    model SpringDamperSeries
      "Linear spring and linear damper in series connection"

      parameter Modelica_SIunits.TranslationalSpringConstant c(final min=0)
        "Spring constant";
      parameter Modelica_SIunits.Length s_unstretched=0
        "Unstretched spring length";
      parameter Modelica_SIunits.TranslationalDampingConstant d(final min=0)=
        0 "Damping constant";
      parameter Modelica_SIunits.Length s_damper_start=0
        "Initial length of damper";
      Modelica_SIunits.Position s_damper(start=s_damper_start, fixed=true)
        "Actual length of damper (frame_a - damper - spring - frame_b)";
      extends Interfaces.PartialLineForce;
      extends
        Modelica_Thermal_HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort(
         final T=293.15);
    equation
      f = c*(s - s_unstretched - s_damper);
      d*der(s_damper) = f;
      lossPower = f*der(s_damper);
      annotation (
        Documentation(info="<HTML>
<p>
<b>Linear spring</b> and <b>linear damper</b> in series connection
acting as line force between frame_a and frame_b:
</p>
<pre>
  frame_a --> damper ----> spring --> frame_b
          |              |
          |-- s_damper --|  (s_damper is the state variable of this system)
</pre>
<p>
A <b>force f</b> is exerted on the origin of frame_b and with opposite sign
on the origin of frame_a along the line from the origin of frame_a to the origin
of frame_b according to the equations:
</p>
<pre>
   f = c*(s - s_unstretched - s_damper);
   f = d*der(s_damper);
</pre>
<p>
where \"c\", \"s_unstretched\" and \"d\" are parameters, \"s\" is the
distance between the origin of frame_a and the origin of frame_b.
\"s_damper\" is the length of the damper (= an internal state of this
force element) and der(s_damper) is the time derivative of s_damper.
</p>
</html>"),     Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{-100,0},{-15,0}}, color={0,0,0}),
            Line(points={{-60,-30},{-15,-30}}, color={0,0,0}),
            Line(points={{-60,30},{-15,30}}, color={0,0,0}),
            Rectangle(
              extent={{-60,30},{-30,-30}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-15,0},{-5,0},{5,-30},{25,30},{45,-30},{65,30},{75,0},{
                  100,0}}, color={0,0,0}),
            Text(
              extent={{-150,50},{150,90}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{-150,-65},{150,-35}},
              lineColor={0,0,0},
              textString="c=%c"),
            Line(visible=useHeatPort,
              points={{-100,-99},{-100,-24},{-45,-24}},
              color={191,0,0},
              smooth=Smooth.None,
              pattern=LinePattern.Dot),
            Text(
              extent={{-150,-100},{150,-70}},
              lineColor={0,0,0},
              textString="d=%d")}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{-100,0},{-15,0}}, color={0,0,0}),
            Line(points={{-60,-30},{-15,-30}}, color={0,0,0}),
            Line(points={{-60,30},{-15,30}}, color={0,0,0}),
            Rectangle(
              extent={{-60,30},{-30,-30}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-15,0},{-5,0},{5,-30},{25,30},{45,-30},{65,30},{75,0},{
                  99,0}}, color={0,0,0}),
            Line(points={{-75,0},{-75,85}}, color={160,160,164}),
            Line(points={{-10,0},{-10,65}}, color={160,160,164}),
            Line(points={{80,0},{80,85}}, color={160,160,164}),
            Line(points={{-75,80},{80,80}}, color={160,160,164}),
            Line(points={{-75,60},{-10,60}}, color={160,160,164}),
            Polygon(
              points={{-10,60},{-20,65},{-20,55},{-10,60}},
              lineColor={160,160,164},
              fillColor={160,160,164},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{80,80},{70,85},{70,75},{80,80}},
              lineColor={160,160,164},
              fillColor={160,160,164},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-72,63},{-11,78}},
              lineColor={160,160,164},
              textString="s_damper"),
            Text(
              extent={{0,80},{20,100}},
              lineColor={160,160,164},
              textString="s")}));
    end SpringDamperSeries;

    package Internal "Internal package, should not be used by user"
      extends Modelica_Icons.InternalPackage;

      model BasicForce
        "Force acting between two frames, defined by 3 input signals"
        extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;
        import Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB;
        Interfaces.Frame_resolve frame_resolve
          "The input signals are optionally resolved in this frame"
          annotation (Placement(transformation(
              origin={40,100},
              extent={{-16,-16},{16,16}},
              rotation=90)));
        Modelica_Blocks.Interfaces.RealInput force[3](each final quantity="Force", each final unit="N")
          "x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame"
          annotation (Placement(transformation(
              origin={-60,120},
              extent={{-20,-20},{20,20}},
              rotation=270)));
        parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB resolveInFrame=
            ResolveInFrameAB.frame_b
          "Frame in which force is resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)";

        Modelica_SIunits.Position r_0[3]
          "Position vector from origin of frame_a to origin of frame_b resolved in world frame";
        Modelica_SIunits.Force f_b_0[3] "frame_b.f resolved in world frame";

      equation
        assert(cardinality(frame_resolve) > 0, "Connector frame_resolve must be connected at least once and frame_resolve.r_0/.R must be set");
        frame_resolve.f = zeros(3);
        frame_resolve.t = zeros(3);

         if resolveInFrame == ResolveInFrameAB.frame_a then
            f_b_0     = -Frames.resolve1(frame_a.R, force);
            frame_b.f =  Frames.resolve2(frame_b.R, f_b_0);
         elseif resolveInFrame == ResolveInFrameAB.frame_b then
            f_b_0     = -Frames.resolve1(frame_b.R, force);
            frame_b.f = -force;
         elseif resolveInFrame == ResolveInFrameAB.world then
            f_b_0     = -force;
            frame_b.f =  Frames.resolve2(frame_b.R, f_b_0);
         elseif resolveInFrame == ResolveInFrameAB.frame_resolve then
            f_b_0     = -Frames.resolve1(frame_resolve.R, force);
            frame_b.f = Frames.resolve2(frame_b.R, f_b_0);
         else
            assert(false, "Wrong value for parameter resolveInFrame");
            f_b_0     = zeros(3);
            frame_b.f = zeros(3);
         end if;
         frame_b.t = zeros(3);

         // Force and torque balance
         r_0 = frame_b.r_0 - frame_a.r_0;
         zeros(3) = frame_a.f + Frames.resolve2(frame_a.R, f_b_0);
         zeros(3) = frame_a.t + Frames.resolve2(frame_a.R, cross(r_0, f_b_0));
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-98,99},{99,-98}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-92,61},{87,35}},
                lineColor={192,192,192},
                textString="resolve"),
              Text(
                extent={{-136,-52},{149,-113}},
                textString="%name",
                lineColor={0,0,255}),
              Line(
                points={{40,100},{40,0}},
                color={95,95,95},
                pattern=LinePattern.Dot),
              Polygon(
                points={{-94,0},{-64,11},{-64,-10},{-94,0}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-60,100},{40,100}},
                color={95,95,95},
                pattern=LinePattern.Dot),
              Polygon(
                points={{94,0},{65,12},{65,-11},{94,0}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Line(points={{-64,0},{-20,0}}, color={0,0,0}),
              Line(points={{20,0},{65,0}}, color={0,0,0})}),
          Documentation(info="<HTML>
<p>
The <b>3</b> signals of the <b>force</b> connector are interpreted
as the x-, y- and z-coordinates of a <b>force</b> acting at the frame
connector to which frame_b of this component is attached.
Via parameter <b>resolveInFrame</b> it is defined, in which frame these
coordinates shall be resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve input force in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve input force in frame_a</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve input force in frame_b (= default)</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve input force in frame_resolve (frame_resolve must be connected)</td></tr>
</table>

<p>
If resolveInFrame = ResolveInFrameAB.frame_resolve, the force coordinates
are with respect to the frame, that is connected to <b>frame_resolve</b>.
</p>

<p>
If resolveInFrame is not ResolveInFrameAB.frame_resolve, then the position
vector and the orientation object of frame_resolve must be set to constant
values from the outside in order that the model remains balanced
(these constant values are ignored).
</p>

</html>"));
      end BasicForce;

      model BasicTorque
        "Torque acting between two frames, defined by 3 input signals"
        import Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB;
        extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;
        Interfaces.Frame_resolve frame_resolve
          "The input signals are optionally resolved in this frame"
          annotation (Placement(transformation(
              origin={40,100},
              extent={{-16,-16},{16,16}},
              rotation=90)));

        Modelica_Blocks.Interfaces.RealInput torque[3](each final quantity="Torque", each final unit="N.m")
          "x-, y-, z-coordinates of torque resolved in frame defined by resolveInFrame"
          annotation (Placement(transformation(
              origin={-60,120},
              extent={{-20,-20},{20,20}},
              rotation=270)));
        parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB resolveInFrame=
            ResolveInFrameAB.frame_b
          "Frame in which torque is resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)";

        Modelica_SIunits.Position r_0[3]
          "Position vector from origin of frame_a to origin of frame_b resolved in world frame";
        Modelica_SIunits.Torque t_b_0[3] "frame_b.t resolved in world frame";

      equation
        assert(cardinality(frame_resolve) > 0, "Connector frame_resolve must be connected at least once and frame_resolve.r_0/.R must be set");
        frame_resolve.f = zeros(3);
        frame_resolve.t = zeros(3);

        r_0 = frame_b.r_0 - frame_a.r_0;
        frame_a.f = zeros(3);
        frame_b.f = zeros(3);

         if resolveInFrame == ResolveInFrameAB.frame_a then
            t_b_0     = -Frames.resolve1(frame_a.R, torque);
            frame_b.t =  Frames.resolve2(frame_b.R, t_b_0);
         elseif resolveInFrame == ResolveInFrameAB.frame_b then
            t_b_0     = -Frames.resolve1(frame_b.R, torque);
            frame_b.t = -torque;
         elseif resolveInFrame == ResolveInFrameAB.world then
            t_b_0     = -torque;
            frame_b.t =  Frames.resolve2(frame_b.R, t_b_0);
         elseif resolveInFrame == ResolveInFrameAB.frame_resolve then
            t_b_0     = -Frames.resolve1(frame_resolve.R, torque);
            frame_b.t =  Frames.resolve2(frame_b.R, t_b_0);
         else
            assert(false, "Wrong value for parameter resolveInFrame");
            t_b_0     = zeros(3);
            frame_b.t = zeros(3);
         end if;

         // torque balance
         zeros(3) = frame_a.t + Frames.resolve2(frame_a.R, t_b_0);
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-98,99},{99,-98}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-59,55},{72,30}},
                lineColor={192,192,192},
                textString="resolve"),
              Text(
                extent={{-139,-27},{146,-88}},
                textString="%name",
                lineColor={0,0,255}),
              Polygon(
                points={{100,20},{84,52},{69,39},{100,20}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Line(
                points={{40,100},{76,46}},
                color={95,95,95},
                pattern=LinePattern.Dot),
              Polygon(
                points={{-99,20},{-86,53},{-70,42},{-99,20}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-60,100},{40,100}},
                color={95,95,95},
                pattern=LinePattern.Dot),
              Line(points={{-79,47},{-70,61},{-59,72},{-45,81},{-32,84},{-20,85}},
                  color={0,0,0}),
              Line(points={{77,45},{66,60},{55,69},{49,74},{41,80},{31,84},{20,85}},
                  color={0,0,0})}),
          Documentation(info="<HTML>
<p>
The <b>3</b> signals of the <b>torque</b> connector are interpreted
as the x-, y- and z-coordinates of a <b>torque</b> acting at the frame
connector to which frame_b of this component is attached.
Via parameter <b>resolveInFrame</b> it is defined, in which frame these
coordinates shall be resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve input torque in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve input torque in frame_a</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve input torque in frame_b (= default)</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve input torque in frame_resolve (frame_resolve must be connected)</td></tr>
</table>

<p>
If resolveInFrame = ResolveInFrameAB.frame_resolve, the torque coordinates
are with respect to the frame, that is connected to <b>frame_resolve</b>.
</p>

<p>
If resolveInFrame is not ResolveInFrameAB.frame_resolve, then the position
vector and the orientation object of frame_resolve must be set to constant
values from the outside in order that the model remains balanced
(these constant values are ignored).
</p>
</html>"));
      end BasicTorque;

      model BasicWorldForce
        "External force acting at frame_b, defined by 3 input signals"
        import Modelica_Mechanics_MultiBody.Types.ResolveInFrameB;
        extends Interfaces.PartialOneFrame_b;
        Interfaces.Frame_resolve frame_resolve
          "The input signals are optionally resolved in this frame"
          annotation (Placement(transformation(
              origin={0,-100},
              extent={{-16,-16},{16,16}},
              rotation=270)));

        Modelica_Blocks.Interfaces.RealInput force[3](each final quantity="Force", each final unit="N")
          "x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
                rotation=0)));
        parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameB resolveInFrame=
            ResolveInFrameB.world
          "Frame in which force is resolved (1: world, 2: frame_b, 3: frame_resolve)";

      equation
         assert(cardinality(frame_resolve) > 0, "Connector frame_resolve must be connected at least once and frame_resolve.r_0/.R must be set");
         frame_resolve.f = zeros(3);
         frame_resolve.t = zeros(3);

         if resolveInFrame == ResolveInFrameB.world then
            frame_b.f = -Frames.resolve2(frame_b.R, force);
         elseif resolveInFrame == ResolveInFrameB.frame_b then
            frame_b.f = -force;
         elseif resolveInFrame == ResolveInFrameB.frame_resolve then
            frame_b.f = -Frames.resolveRelative(force, frame_resolve.R, frame_b.R);
         else
            assert(false, "Wrong value for parameter resolveInFrame");
            frame_b.f = zeros(3);
         end if;
         frame_b.t = zeros(3);
        annotation (
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={Polygon(
                points={{-100,10},{50,10},{50,31},{97,0},{50,-31},{50,-10},{-100,
                    -10},{-100,10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid), Line(
                points={{0,-10},{0,-97}},
                color={95,95,95},
                pattern=LinePattern.Dot)}),
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Text(
                extent={{-89,-46},{91,-76}},
                lineColor={192,192,192},
                textString="resolve"),
              Polygon(
                points={{-100,10},{50,10},{50,31},{94,0},{50,-31},{50,-10},{-100,
                    -10},{-100,10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-149,103},{136,42}},
                textString="%name",
                lineColor={0,0,255}),
              Line(
                points={{0,-10},{0,-95}},
                color={95,95,95},
                pattern=LinePattern.Dot)}),
          Documentation(info="<HTML>
<p>
The 3 signals of the <b>force</b> connector are interpreted
as the x-, y- and z-coordinates of a <b>force</b> acting at the frame
connector to which this component is attached.
Via parameter <b>resolveInFrame</b> it is defined, in which frame these
coordinates shall be resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.ResolveInFrameB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve input force in world frame (= default)</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve input force in frame_b</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve input force in frame_resolve (frame_resolve must be connected)</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameB.frame_resolve, the force coordinates
are with respect to the frame, that is connected to <b>frame_resolve</b>.
</p>

<p>
If resolveInFrame is not Types.ResolveInFrameB.frame_resolve, then the position
vector and the orientation object of frame_resolve must be set to constant
values from the outside in order that the model remains balanced
(these constant values are ignored).
</p>

</html>"));
      end BasicWorldForce;

      model BasicWorldTorque
        "External torque acting at frame_b, defined by 3 input signals"
        import Modelica_Mechanics_MultiBody.Types.ResolveInFrameB;
        extends Interfaces.PartialOneFrame_b;
        Interfaces.Frame_resolve frame_resolve
          "The input signals are optionally resolved in this frame"
          annotation (Placement(transformation(
              origin={0,100},
              extent={{16,-16},{-16,16}},
              rotation=270)));

        Modelica_Blocks.Interfaces.RealInput torque[3](each final quantity="Torque", each final unit="N.m")
          "x-, y-, z-coordinates of torque resolved in frame defined by resolveInFrame"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
                rotation=0)));
        parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameB resolveInFrame=
            ResolveInFrameB.world
          "Frame in which torque is resolved (1: world, 2: frame_b, 3: frame_resolve)";

      equation
         assert(cardinality(frame_resolve) > 0, "Connector frame_resolve must be connected at least once and frame_resolve.r_0/.R must be set");
         frame_resolve.f = zeros(3);
         frame_resolve.t = zeros(3);

         if resolveInFrame == ResolveInFrameB.world then
            frame_b.t = -Frames.resolve2(frame_b.R, torque);
         elseif resolveInFrame == ResolveInFrameB.frame_b then
            frame_b.t = -torque;
         elseif resolveInFrame == ResolveInFrameB.frame_resolve then
            frame_b.t = -Frames.resolveRelative(torque, frame_resolve.R, frame_b.R);
         else
            assert(false, "Wrong value for parameter resolveInFrame");
            frame_b.t = zeros(3);
         end if;
         frame_b.f = zeros(3);
        annotation (
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Line(
                points={{0,97},{0,82}},
                color={95,95,95},
                pattern=LinePattern.Dot),
              Line(
                points={{-100,0},{-94,13},{-86,28},{-74,48},{-65,60},{-52,72},{-35,
                    81},{-22,84},{-8,84},{7,80},{19,73},{32,65},{44,55},{52,47},{
                    58,40}},
                color={0,0,0},
                thickness=0.5),
              Polygon(
                points={{97,6},{75,59},{41,24},{97,6}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}),
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Text(
                extent={{-61,64},{46,27}},
                lineColor={192,192,192},
                textString="resolve"),
              Text(
                extent={{-145,-28},{140,-89}},
                textString="%name",
                lineColor={0,0,255}),
              Line(
                points={{0,95},{0,82}},
                color={95,95,95},
                pattern=LinePattern.Dot),
              Line(
                points={{-100,0},{-94,13},{-86,28},{-74,48},{-65,60},{-52,72},{-35,
                    81},{-22,84},{-8,84},{7,80},{19,73},{32,65},{44,55},{52,47},{
                    58,40}},
                color={0,0,0},
                thickness=0.5),
              Polygon(
                points={{94,10},{75,59},{41,24},{94,10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<HTML>
<p>
The 3 signals of the <b>torque</b> connector are interpreted
as the x-, y- and z-coordinates of a <b>torque</b> acting at the frame
connector to which this component is attached.
Via parameter <b>resolveInFrame</b> it is defined, in which frame these
coordinates shall be resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.ResolveInFrameB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve input torque in world frame (= default)</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve input torque in frame_b</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve input torque in frame_resolve (frame_resolve must be connected)</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameB.frame_resolve, the torque coordinates
are with respect to the frame, that is connected to <b>frame_resolve</b>.
</p>

<p>
If resolveInFrame is not Types.ResolveInFrameB.frame_resolve, then the position
vector and the orientation object of frame_resolve must be set to constant
values from the outside in order that the model remains balanced
(these constant values are ignored).
</p>

</html>"));
      end BasicWorldTorque;

      function standardGravityAcceleration
        "Standard gravity fields (no/parallel/point field)"
        extends Modelica_Icons.Function;
        extends
          Modelica_Mechanics_MultiBody.Interfaces.partialGravityAcceleration;
        import Modelica_Mechanics_MultiBody.Types.GravityTypes;
        input GravityTypes gravityType "Type of gravity field" annotation(Dialog);
        input Modelica_SIunits.Acceleration g[3]
          "Constant gravity acceleration, resolved in world frame, if gravityType=UniformGravity"
                                                                                                  annotation(Dialog);
        input Real mue(unit="m3/s2")
          "Field constant of point gravity field, if gravityType=PointGravity" annotation(Dialog);
      algorithm
      gravity := if gravityType == GravityTypes.UniformGravity then g else
                 if gravityType == GravityTypes.PointGravity then
                    -(mue/(r*r))*(r/Modelica_Math.Vectors.length(r)) else zeros(3);
        annotation(Inline=true, Documentation(info="<html>
<p>
This function defines the standard gravity fields for the World object.
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td><b><i>gravityType</i></b></td>
    <td><b><i>gravity [m/s2]</i></b></td>
    <td><b><i>description</i></b></td></tr>
<tr><td>Types.GravityType.NoGravity</td>
    <td>= {0,0,0}</td>
    <td>No gravity</td></tr>

<tr><td>Types.GravityType.UniformGravity</td>
    <td>= g</td>
    <td> Constant parallel gravity field</td></tr>

<tr><td>Types.GravityType.PointGravity</td>
    <td>= -(mue/(r*r))*r/|r|</td>
    <td> Point gravity field with spherical mass</td></tr>
</table>

</html>"));
      end standardGravityAcceleration;
    end Internal;
    annotation ( Documentation(info="<HTML>
<p>
This package contains components that exert forces and torques
between two frame connectors, e.g., between two parts.
</p>
<h4>Content</h4>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><b><i>Model</i></b></th><th><b><i>Description</i></b></th></tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.WorldForce\">WorldForce</a></td>
      <td valign=\"top\"> External force acting at the frame to which this component
           is connected and defined by 3 input signals,
           that are interpreted as one vector resolved in frame world, frame_b or frame_resolve. <br>
           <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/ArrowForce.png\"></td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.WorldTorque\">WorldTorque</a></td>
      <td valign=\"top\"> External torque acting at the frame to which this component
           is connected and defined by 3 input signals,
           that are interpreted as one vector resolved in frame world, frame_b or frame_resolve. <br>
           <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/ArrowTorque.png\"></td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque\">WorldForceAndTorque</a></td>
      <td valign=\"top\"> External force and external torque acting at the frame
           to which this component
           is connected and defined by 3+3 input signals,
           that are interpreted as a force and as a torque vector
           resolved in frame world, frame_b or frame_resolve. <br>
           <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/ArrowForce.png\"><br>
           <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/ArrowTorque.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.Force\">Force</a></td>
      <td valign=\"top\"> Force acting between two frames defined by 3 input signals
           resolved in frame world, frame_a, frame_b or in frame_resolve. <br>
           <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/ArrowForce2.png\"></td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.Torque\">Torque</a></td>
      <td valign=\"top\"> Torque acting between two frames defined by 3 input signals
           resolved in frame world, frame_a, frame_b or in frame_resolve. <br>
           <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/ArrowTorque2.png\"></td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.ForceAndTorque\">ForceAndTorque</a></td>
      <td valign=\"top\"> Force and torque acting between two frames defined by 3+3 input signals
           resolved in frame world, frame_a, frame_b or in frame_resolve. <br>
           <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/ArrowForce2.png\"><br>
           <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/ArrowTorque2.png\"></td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.LineForceWithMass\">LineForceWithMass</a></td>
      <td valign=\"top\">  General line force component with an optional point mass
            on the connection line. The force law can be defined by a
            component of Modelica.Mechanics.Translational<br>
           <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/LineForceWithMass.png\"></td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.LineForceWithTwoMasses\">LineForceWithTwoMasses</a></td>
      <td valign=\"top\">  General line force component with two optional point masses
            on the connection line. The force law can be defined by a
            component of Modelica.Mechanics.Translational<br>
           <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/LineForceWithTwoMasses.png\"></td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.Spring\">Spring</a></td>
      <td valign=\"top\"> Linear translational spring with optional mass <br>
           <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/Spring2.png\"></td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.Damper\">Damper</a></td>
      <td valign=\"top\"> Linear (velocity dependent) damper <br>
           <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Forces/Damper2.png\"></td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.SpringDamperParallel\">SpringDamperParallel</a></td>
      <td valign=\"top\"> Linear spring and damper in parallel connection </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Forces.SpringDamperSeries\">SpringDamperSeries</a></td>
      <td valign=\"top\"> Linear spring and damper in series connection </td>
  </tr>
</table>
</HTML>"));
  end Forces;

  package Frames "Functions to transform rotational frame quantities"

    extends Modelica_Icons.Package;

    record Orientation
      "Orientation object defining rotation from a frame 1 into a frame 2"

      extends Modelica_Icons.Record;
      Real T[3, 3] "Transformation matrix from world frame to local frame";
      Modelica_SIunits.AngularVelocity w[3]
        "Absolute angular velocity of local frame, resolved in local frame";

      encapsulated function equalityConstraint
        "Return the constraint residues to express that two frames have the same orientation"
        import Modelica_Icons;
        import Modelica_Math;

        import Modelica =
               M_S_L;
        import Modelica_Mechanics_MultiBody.Frames;
        extends Modelica_Icons.Function;
        input Frames.Orientation R1
          "Orientation object to rotate frame 0 into frame 1";
        input Frames.Orientation R2
          "Orientation object to rotate frame 0 into frame 2";
        output Real residue[3]
          "The rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation (should be zero)";
      algorithm
        residue := {
           Modelica_Math.atan2(cross(R1.T[1, :], R1.T[2, :])*R2.T[2, :],R1.T[1,:]*R2.T[1,:]),
           Modelica_Math.atan2(-cross(R1.T[1, :],R1.T[2, :])*R2.T[1, :],R1.T[2,:]*R2.T[2,:]),
           Modelica_Math.atan2(R1.T[2, :]*R2.T[1, :],R1.T[3,:]*R2.T[3,:])};
        annotation(Inline=true);
      end equalityConstraint;

      annotation (Documentation(info="<html>
<p>
This object describes the <b>rotation</b> from a <b>frame 1</b> into a <b>frame 2</b>.
An instance of this type should never be directly accessed but
only with the access functions provided
in package Modelica.Mechanics.MultiBody.Frames. As a consequence, it is not necessary to know
the internal representation of this object as described in the next paragraphs.
</p>
<p>
\"Orientation\" is defined to be a record consisting of two
elements: \"Real T[3,3]\", the transformation matrix to rotate frame 1
into frame 2 and \"Real w[3]\", the angular velocity of frame 2 with
respect to frame 1, resolved in frame 2. Element \"T\"
has the following interpretation:
</p>
<pre>
   Orientation R;
   <b>R.T</b> = [<b>e</b><sub>x</sub>, <b>e</b><sub>y</sub>, <b>e</b><sub>z</sub>];
       e.g., <b>R.T</b> = [1,0,0; 0,1,0; 0,0,1]
</pre>
<p>
where <b>e</b><sub>x</sub>,<b>e</b><sub>y</sub>,<b>e</b><sub>z</sub>
are unit vectors in the direction of the x-axis, y-axis, and z-axis
of frame 1, resolved in frame 2, respectively. Therefore, if <b>v</b><sub>1</sub>
is vector <b>v</b> resolved in frame 1 and <b>v</b><sub>2</sub> is
vector <b>v</b> resolved in frame 2, the following relationship holds:
</p>
<pre>
    <b>v</b><sub>2</sub> = <b>R.T</b> * <b>v</b><sub>1</sub>
</pre>
<p>
The <b>inverse</b> orientation
<b>R_inv.T</b> = <b>R.T</b><sup>T</sup> describes the rotation
from frame 2 into frame 1.
</p>
<p>
Since the orientation is described by 9 variables, there are
6 constraints between these variables. These constraints
are defined in function <b>Frames.orientationConstraint</b>.
</p>
<p>
R.w is the angular velocity of frame 2 with respect to frame 1, resolved
in frame 2. Formally, R.w is defined as:<br>
<b>skew</b>(R.w) = R.T*<b>der</b>(transpose(R.T))
with
</p>
<pre>
             |   0   -w[3]  w[2] |
   <b>skew</b>(w) = |  w[3]   0   -w[1] |
             | -w[2]  w[1]     0 |
</pre>
</html>"));
    end Orientation;

    function orientationConstraint
      "Return residues of orientation constraints (shall be zero)"
      extends Modelica_Icons.Function;
      input Orientation R "Orientation object to rotate frame 1 into frame 2";
      output Real residue[6]
        "Residues of constraints between elements of orientation object (shall be zero)";
    algorithm
      residue := {R.T[:, 1]*R.T[:, 1] - 1,R.T[:, 2]*R.T[:, 2] - 1,R.T[:, 3]*R.T[:,
         3] - 1,R.T[:, 1]*R.T[:, 2],R.T[:, 1]*R.T[:, 3],R.T[:, 2]*R.T[:, 3]};
      annotation(Inline=true);
    end orientationConstraint;

    function angularVelocity1
      "Return angular velocity resolved in frame 1 from orientation object"

      extends Modelica_Icons.Function;
      input Orientation R "Orientation object to rotate frame 1 into frame 2";
      output Modelica_SIunits.AngularVelocity w[3]
        "Angular velocity of frame 2 with respect to frame 1 resolved in frame 1";
    algorithm
      w := resolve1(R, R.w);
      annotation(Inline=true);
    end angularVelocity1;

    function angularVelocity2
      "Return angular velocity resolved in frame 2 from orientation object"

      extends Modelica_Icons.Function;
      input Orientation R "Orientation object to rotate frame 1 into frame 2";
      output Modelica_SIunits.AngularVelocity w[3]
        "Angular velocity of frame 2 with respect to frame 1 resolved in frame 2";
    algorithm
      w := R.w;
      annotation(Inline=true);
    end angularVelocity2;

    function resolve1 "Transform vector from frame 2 to frame 1"
      extends Modelica_Icons.Function;
      input Orientation R "Orientation object to rotate frame 1 into frame 2";
      input Real v2[3] "Vector in frame 2";
      output Real v1[3] "Vector in frame 1";
    algorithm
      v1 := transpose(R.T)*v2;
      annotation (derivative(noDerivative=R) = Internal.resolve1_der,
          InlineAfterIndexReduction=true);
    end resolve1;

    function resolve2 "Transform vector from frame 1 to frame 2"
      extends Modelica_Icons.Function;
      input Orientation R "Orientation object to rotate frame 1 into frame 2";
      input Real v1[3] "Vector in frame 1";
      output Real v2[3] "Vector in frame 2";
    algorithm
      v2 := R.T*v1;
      annotation (derivative(noDerivative=R) = Internal.resolve2_der,
          InlineAfterIndexReduction=true);
    end resolve2;

    function resolveRelative
      "Transform vector from frame 1 to frame 2 using absolute orientation objects of frame 1 and of frame 2"

      extends Modelica_Icons.Function;
      input Real v1[3] "Vector in frame 1";
      input Orientation R1 "Orientation object to rotate frame 0 into frame 1";
      input Orientation R2 "Orientation object to rotate frame 0 into frame 2";
      output Real v2[3] "Vector in frame 2";
    algorithm
      v2 := resolve2(R2, resolve1(R1, v1));
      annotation (derivative(noDerivative=R1, noDerivative=R2) = Internal.resolveRelative_der,
          InlineAfterIndexReduction=true);
    end resolveRelative;

    function resolveDyade1
      "Transform second order tensor from frame 2 to frame 1"
      extends Modelica_Icons.Function;
      input Orientation R "Orientation object to rotate frame 1 into frame 2";
      input Real D2[3, 3] "Second order tensor resolved in frame 2";
      output Real D1[3, 3] "Second order tensor resolved in frame 1";
    algorithm
      D1 := transpose(R.T)*D2*R.T;
      annotation(Inline=true);
    end resolveDyade1;

    function resolveDyade2
      "Transform second order tensor from frame 1 to frame 2"
      extends Modelica_Icons.Function;
      input Orientation R "Orientation object to rotate frame 1 into frame 2";
      input Real D1[3, 3] "Second order tensor resolved in frame 1";
      output Real D2[3, 3] "Second order tensor resolved in frame 2";
    algorithm
      D2 := R.T*D1*transpose(R.T);
      annotation(Inline=true);
    end resolveDyade2;

    function nullRotation
      "Return orientation object that does not rotate a frame"
      extends Modelica_Icons.Function;
      output Orientation R
        "Orientation object such that frame 1 and frame 2 are identical";
    algorithm
      R := Orientation(T=identity(3),w= zeros(3));
      annotation(Inline=true);
    end nullRotation;

    function inverseRotation "Return inverse orientation object"
      extends Modelica_Icons.Function;
      input Orientation R "Orientation object to rotate frame 1 into frame 2";
      output Orientation R_inv
        "Orientation object to rotate frame 2 into frame 1";
    algorithm
      R_inv := Orientation(T=transpose(R.T),w= -resolve1(R, R.w));
      annotation(Inline=true);
    end inverseRotation;

    function relativeRotation "Return relative orientation object"
      extends Modelica_Icons.Function;
      input Orientation R1 "Orientation object to rotate frame 0 into frame 1";
      input Orientation R2 "Orientation object to rotate frame 0 into frame 2";
      output Orientation R_rel
        "Orientation object to rotate frame 1 into frame 2";
    algorithm
      R_rel := Orientation(T=R2.T*transpose(R1.T),w= R2.w - resolve2(R2, resolve1(
         R1, R1.w)));
      annotation(Inline=true);
    end relativeRotation;

    function absoluteRotation
      "Return absolute orientation object from another absolute and a relative orientation object"

      extends Modelica_Icons.Function;
      input Orientation R1 "Orientation object to rotate frame 0 into frame 1";
      input Orientation R_rel
        "Orientation object to rotate frame 1 into frame 2";
      output Orientation R2 "Orientation object to rotate frame 0 into frame 2";
    algorithm
      R2 := Orientation(T=R_rel.T*R1.T,w= resolve2(R_rel, R1.w) + R_rel.w);
      annotation(Inline=true);
    end absoluteRotation;

    function planarRotation "Return orientation object of a planar rotation"
      import Math = Modelica_Math;
      extends Modelica_Icons.Function;
      input Real e[3](each final unit="1")
        "Normalized axis of rotation (must have length=1)";
      input Modelica_SIunits.Angle angle
        "Rotation angle to rotate frame 1 into frame 2 along axis e";
      input Modelica_SIunits.AngularVelocity der_angle "= der(angle)";
      output Orientation R "Orientation object to rotate frame 1 into frame 2";
    algorithm
      R := Orientation(T=[e]*transpose([e]) + (identity(3) - [e]*transpose([e]))*
        Math.cos(angle) - skew(e)*Math.sin(angle),w= e*der_angle);

      annotation(Inline=true);
    end planarRotation;

    function planarRotationAngle
      "Return angle of a planar rotation, given the rotation axis and the representations of a vector in frame 1 and frame 2"

      extends Modelica_Icons.Function;
      input Real e[3](each final unit="1")
        "Normalized axis of rotation to rotate frame 1 around e into frame 2 (must have length=1)";
      input Real v1[3]
        "A vector v resolved in frame 1 (shall not be parallel to e)";
      input Real v2[3]
        "Vector v resolved in frame 2, i.e., v2 = resolve2(planarRotation(e,angle),v1)";
      output Modelica_SIunits.Angle angle
        "Rotation angle to rotate frame 1 into frame 2 along axis e in the range: -pi <= angle <= pi";
    algorithm
      /* Vector v is resolved in frame 1 and frame 2 according to:
        (1)  v2 = (e*transpose(e) + (identity(3) - e*transpose(e))*cos(angle) - skew(e)*sin(angle))*v1;
                = e*(e*v1) + (v1 - e*(e*v1))*cos(angle) - cross(e,v1)*sin(angle)
       Equation (1) is multiplied with "v1" resulting in (note: e*e = 1)
            v1*v2 = (e*v1)*(e*v2) + (v1*v1 - (e*v1)*(e*v1))*cos(angle)
       and therefore:
        (2) cos(angle) = ( v1*v2 - (e*v1)*(e*v2)) / (v1*v1 - (e*v1)*(e*v1))
       Similarly, equation (1) is multiplied with cross(e,v1), i.e., a
       a vector that is orthogonal to e and to v1:
              cross(e,v1)*v2 = - cross(e,v1)*cross(e,v1)*sin(angle)
       and therefore:
          (3) sin(angle) = -cross(e,v1)*v2/(cross(e,v1)*cross(e,v1));
       We have e*e=1; Therefore:
          (4) v1*v1 - (e*v1)*(e*v1) = |v1|^2 - (|v1|*cos(e,v1))^2
       and
          (5) cross(e,v1)*cross(e,v1) = (|v1|*sin(e,v1))^2
                                      = |v1|^2*(1 - cos(e,v1)^2)
                                      = |v1|^2 - (|v1|*cos(e,v1))^2
       The denominators of (2) and (3) are identical, according to (4) and (5).
       Furthermore, the denominators are always positive according to (5).
       Therefore, in the equation "angle = atan2(sin(angle), cos(angle))" the
       denominators of sin(angle) and cos(angle) can be removed,
       resulting in:
          angle = atan2(-cross(e,v1)*v2, v1*v2 - (e*v1)*(e*v2));
    */
      angle := Modelica_Math.atan2(-cross(e, v1)*v2, v1*v2 - (e*v1)*(e*v2));
      annotation (Inline=true, Documentation(info="<HTML>
<p>
A call to this function of the form
</p>
<pre>
    Real[3]                e, v1, v2;
    Modelica.SIunits.Angle angle;
  <b>equation</b>
    angle = <b>planarRotationAngle</b>(e, v1, v2);
</pre>
<p>
computes the rotation angle \"<b>angle</b>\" of a planar
rotation along unit vector <b>e</b>, rotating frame 1 into frame 2, given
the coordinate representations of a vector \"v\" in frame 1 (<b>v1</b>)
and in frame 2 (<b>v2</b>). Therefore, the result of this function
fulfills the following equation:
</p>
<pre>
    v2 = <b>resolve2</b>(<b>planarRotation</b>(e,angle), v1)
</pre>
<p>
The rotation angle is returned in the range
</p>
<pre>
    -<font face=\"Symbol\">p</font> &lt;= angle &lt;= <font face=\"Symbol\">p</font>
</pre>
<p>
This function makes the following assumptions on the input arguments
</p>
<ul>
<li> Vector <b>e</b> has length 1, i.e., length(e) = 1</li>
<li> Vector \"v\" is not parallel to <b>e</b>, i.e.,
     length(cross(e,v1)) &ne; 0</li>
</ul>
<p>
The function does not check the above assumptions. If these
assumptions are violated, a wrong result will be returned
and/or a division by zero will occur.
</p>
</HTML>"));
    end planarRotationAngle;

    function axisRotation
      "Return rotation object to rotate around an angle along one frame axis"

      extends Modelica_Icons.Function;
      input Integer axis(min=1, max=3) "Rotate around 'axis' of frame 1";
      input Modelica_SIunits.Angle angle
        "Rotation angle to rotate frame 1 into frame 2 along 'axis' of frame 1";
      input Modelica_SIunits.AngularVelocity der_angle "= der(angle)";
      output Orientation R "Orientation object to rotate frame 1 into frame 2";
    algorithm
      R := Orientation(T=(if axis == 1 then [1, 0, 0; 0, cos(angle), sin(angle);
        0, -sin(angle), cos(angle)] else if axis == 2 then [cos(angle), 0, -sin(
        angle); 0, 1, 0; sin(angle), 0, cos(angle)] else [cos(angle), sin(angle),
         0; -sin(angle), cos(angle), 0; 0, 0, 1]),w= if axis == 1 then {der_angle,
        0,0} else if axis == 2 then {0,der_angle,0} else {0,0,der_angle});
      annotation(Inline=true);
    end axisRotation;

    function axesRotations
      "Return fixed rotation object to rotate in sequence around fixed angles along 3 axes"

      import TM = Modelica_Mechanics_MultiBody.Frames.TransformationMatrices;
      extends Modelica_Icons.Function;
      input Integer sequence[3](
        min={1,1,1},
        max={3,3,3}) = {1,2,3}
        "Sequence of rotations from frame 1 to frame 2 along axis sequence[i]";
      input Modelica_SIunits.Angle angles[3]
        "Rotation angles around the axes defined in 'sequence'";
      input Modelica_SIunits.AngularVelocity der_angles[3] "= der(angles)";
      output Orientation R "Orientation object to rotate frame 1 into frame 2";
    algorithm
      /*
  R := absoluteRotation(absoluteRotation(axisRotation(sequence[1], angles[1],
    der_angles[1]), axisRotation(sequence[2], angles[2], der_angles[2])),
    axisRotation(sequence[3], angles[3], der_angles[3]));
*/
      R := Orientation(T=TM.axisRotation(sequence[3], angles[3])*TM.axisRotation(
        sequence[2], angles[2])*TM.axisRotation(sequence[1], angles[1]),w=
        Frames.axis(sequence[3])*der_angles[3] + TM.resolve2(TM.axisRotation(
        sequence[3], angles[3]), Frames.axis(sequence[2])*der_angles[2]) +
        TM.resolve2(TM.axisRotation(sequence[3], angles[3])*TM.axisRotation(
        sequence[2], angles[2]), Frames.axis(sequence[1])*der_angles[1]));
      annotation(Inline=true);
    end axesRotations;

    function axesRotationsAngles
      "Return the 3 angles to rotate in sequence around 3 axes to construct the given orientation object"

      extends Modelica_Icons.Function;
      input Orientation R "Orientation object to rotate frame 1 into frame 2";
      input Integer sequence[3](
        min={1,1,1},
        max={3,3,3}) = {1,2,3}
        "Sequence of rotations from frame 1 to frame 2 along axis sequence[i]";
      input Modelica_SIunits.Angle guessAngle1=0
        "Select angles[1] such that |angles[1] - guessAngle1| is a minimum";
      output Modelica_SIunits.Angle angles[3]
        "Rotation angles around the axes defined in 'sequence' such that R=Frames.axesRotation(sequence,angles); -pi < angles[i] <= pi";
    protected
      Real e1_1[3](each final unit="1")
        "First rotation axis, resolved in frame 1";
      Real e2_1a[3](each final unit="1")
        "Second rotation axis, resolved in frame 1a";
      Real e3_1[3](each final unit="1")
        "Third rotation axis, resolved in frame 1";
      Real e3_2[3](each final unit="1")
        "Third rotation axis, resolved in frame 2";
      Real A
        "Coefficient A in the equation A*cos(angles[1])+B*sin(angles[1]) = 0";
      Real B
        "Coefficient B in the equation A*cos(angles[1])+B*sin(angles[1]) = 0";
      Modelica_SIunits.Angle angle_1a "Solution 1 for angles[1]";
      Modelica_SIunits.Angle angle_1b "Solution 2 for angles[1]";
      TransformationMatrices.Orientation T_1a
        "Orientation object to rotate frame 1 into frame 1a";
    algorithm
      /* The rotation object R is constructed by:
     (1) Rotating frame 1 along axis e1 (= axis sequence[1]) with angles[1]
         arriving at frame 1a.
     (2) Rotating frame 1a along axis e2 (= axis sequence[2]) with angles[2]
         arriving at frame 1b.
     (3) Rotating frame 1b along axis e3 (= axis sequence[3]) with angles[3]
         arriving at frame 2.
     The goal is to determine angles[1:3]. This is performed in the following way:
     1. e2 and e3 are perpendicular to each other, i.e., e2*e3 = 0;
        Both vectors are resolved in frame 1 (T_ij is transformation matrix
        from frame j to frame i; e1_1*e2_1a = 0, since the vectors are
        perpendicular to each other):
           e3_1 = T_12*e3_2
                = R[sequence[3],:];
           e2_1 = T_11a*e2_1a
                = ( e1_1*transpose(e1_1) + (identity(3) - e1_1*transpose(e1_1))*cos(angles[1])
                    + skew(e1_1)*sin(angles[1]) )*e2_1a
                = e2_1a*cos(angles[1]) + cross(e1_1, e2_1a)*sin(angles[1]);
        From this follows finally an equation for angles[1]
           e2_1*e3_1 = 0
                     = (e2_1a*cos(angles[1]) + cross(e1_1, e2_1a)*sin(angles[1]))*e3_1
                     = (e2_1a*e3_1)*cos(angles[1]) + cross(e1_1, e2_1a)*e3_1*sin(angles[1])
                     = A*cos(angles[1]) + B*sin(angles[1])
                       with A = e2_1a*e3_1, B = cross(e1_1, e2_1a)*e3_1
        This equation has two solutions in the range -pi < angles[1] <= pi:
           sin(angles[1]) =  k*A/sqrt(A*A + B*B)
           cos(angles[1]) = -k*B/sqrt(A*A + B*B)
                        k = +/-1
           tan(angles[1]) = k*A/(-k*B)
        that is:
           angles[1] = atan2(k*A, -k*B)
        If A and B are both zero at the same time, there is a singular configuration
        resulting in an infinite number of solutions for angles[1] (every value
        is possible).
     2. angles[2] is determined with function Frames.planarRotationAngle.
        This function requires to provide e_3 in frame 1a and in frame 1b:
          e3_1a = Frames.resolve2(planarRotation(e1_1,angles[1]), e3_1);
          e3_1b = e3_2
     3. angles[3] is determined with function Frames.planarRotationAngle.
        This function requires to provide e_2 in frame 1b and in frame 2:
          e2_1b = e2_1a
          e2_2  = Frames.resolve2( R, Frames.resolve1(planarRotation(e1_1,angles[1]), e2_1a));
  */
      assert(sequence[1] <> sequence[2] and sequence[2] <> sequence[3],
        "input argument 'sequence[1:3]' is not valid");
      e1_1 := if sequence[1] == 1 then {1,0,0} else if sequence[1] == 2 then {0,1,
        0} else {0,0,1};
      e2_1a := if sequence[2] == 1 then {1,0,0} else if sequence[2] == 2 then {0,
        1,0} else {0,0,1};
      e3_1 := R.T[sequence[3], :];
      e3_2 := if sequence[3] == 1 then {1,0,0} else if sequence[3] == 2 then {0,1,
        0} else {0,0,1};

      A := e2_1a*e3_1;
      B := cross(e1_1, e2_1a)*e3_1;
      if abs(A) <= 1.e-12 and abs(B) <= 1.e-12 then
        angles[1] := guessAngle1;
      else
        angle_1a := Modelica_Math.atan2(A, -B);
        angle_1b := Modelica_Math.atan2(-A, B);
        angles[1] := if abs(angle_1a - guessAngle1) <= abs(angle_1b - guessAngle1) then
                angle_1a else angle_1b;
      end if;
      T_1a := TransformationMatrices.planarRotation(e1_1, angles[1]);
      angles[2] := planarRotationAngle(e2_1a, TransformationMatrices.resolve2(
        T_1a, e3_1), e3_2);
      angles[3] := planarRotationAngle(e3_2, e2_1a,
        TransformationMatrices.resolve2(R.T, TransformationMatrices.resolve1(T_1a,
         e2_1a)));

      annotation (Documentation(info="<HTML>
<p>
A call to this function of the form
</p>
<pre>
    Frames.Orientation     R;
    <b>parameter</b> Integer      sequence[3] = {1,2,3};
    Modelica.SIunits.Angle angles[3];
  <b>equation</b>
    angle = <b>axesRotationAngles</b>(R, sequence);
</pre>
<p>
computes the rotation angles \"<b>angles</b>[1:3]\" to rotate frame 1
into frame 2 along axes <b>sequence</b>[1:3], given the orientation
object <b>R</b> from frame 1 to frame 2. Therefore, the result of
this function fulfills the following equation:
</p>
<pre>
    R = <b>axesRotation</b>(sequence, angles)
</pre>
<p>
The rotation angles are returned in the range
</p>
<pre>
    -<font face=\"Symbol\">p</font> &lt;= angles[i] &lt;= <font face=\"Symbol\">p</font>
</pre>
<p>
There are <b>two solutions</b> for \"angles[1]\" in this range.
Via the third argument <b>guessAngle1</b> (default = 0) the
returned solution is selected such that |angles[1] - guessAngle1| is
minimal. The orientation object R may be in a singular configuration, i.e.,
there is an infinite number of angle values leading to the same R. The returned solution is
selected by setting angles[1] = guessAngle1. Then angles[2]
and angles[3] can be uniquely determined in the above range.
</p>
<p>
Note, that input argument <b>sequence</b> has the restriction that
only values 1,2,3 can be used and that sequence[1] &ne; sequence[2]
and sequence[2] &ne; sequence[3]. Often used values are:
</p>
<pre>
  sequence = <b>{1,2,3}</b>  // Cardan angle sequence
           = <b>{3,1,3}</b>  // Euler angle sequence
           = <b>{3,2,1}</b>  // Tait-Bryan angle sequence
</pre>
</HTML>"));
    end axesRotationsAngles;

    function smallRotation
      "Return rotation angles valid for a small rotation and optionally residues that should be zero"

      extends Modelica_Icons.Function;
      input Orientation R "Orientation object to rotate frame 1 into frame 2";
      input Boolean withResidues=false
        "= false/true, if 'angles'/'angles and residues' are returned in phi";
      output Modelica_SIunits.Angle phi[if withResidues then 6 else 3]
        "The rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation + optionally 3 residues that should be zero";
    algorithm
      /* Planar rotation:
       Trel = [e]*transpose([e]) + (identity(3) - [e]*transpose([e]))*cos(angle) - skew(e)*sin(angle)
            = identity(3) - skew(e)*angle, for small angles
            = identity(3) - skew(e*angle)
               define phi = e*angle, then
       Trel = [1,      phi3,   -phi2;
               -phi3,     1,    phi1;
                phi2, -phi1,       1 ];
  */
      phi := if withResidues then {R.T[2, 3],-R.T[1, 3],R.T[1, 2],R.T[1, 1] - 1,R.
         T[2, 2] - 1,R.T[1, 1]*R.T[2, 2] - R.T[2, 1]*R.T[1, 2] - 1} else {R.T[2,
        3],-R.T[1, 3],R.T[1, 2]};
      annotation(Inline=true);
    end smallRotation;

    function from_nxy
      "Return fixed orientation object from n_x and n_y vectors"
      extends Modelica_Icons.Function;
      input Real n_x[3](each final unit="1")
        "Vector in direction of x-axis of frame 2, resolved in frame 1";
      input Real n_y[3](each final unit="1")
        "Vector in direction of y-axis of frame 2, resolved in frame 1";
      output Orientation R "Orientation object to rotate frame 1 into frame 2";
    protected
      Real abs_n_x=sqrt(n_x*n_x);
      Real e_x[3](each final unit="1")=if abs_n_x < 1.e-10 then {1,0,0} else n_x/abs_n_x;
      Real n_z_aux[3](each final unit="1")=cross(e_x, n_y);
      Real n_y_aux[3](each final unit="1")=if n_z_aux*n_z_aux > 1.0e-6 then n_y else (if abs(e_x[1])
           > 1.0e-6 then {0,1,0} else {1,0,0});
      Real e_z_aux[3](each final unit="1")=cross(e_x, n_y_aux);
      Real e_z[3](each final unit="1")=e_z_aux/sqrt(e_z_aux*e_z_aux);
    algorithm
      R := Orientation(T={e_x,cross(e_z, e_x),e_z},w= zeros(3));
      annotation (Documentation(info="<html>
<p>
It is assumed that the two input vectors n_x and n_y are
resolved in frame 1 and are directed along the x and y axis
of frame 2 (i.e., n_x and n_y are orthogonal to each other)
The function returns the orientation object R to rotate from
frame 1 to frame 2.
</p>
<p>
The function is robust in the sense that it returns always
an orientation object R, even if n_y is not orthogonal to n_x.
This is performed in the following way:
</p>
<p>
If n_x and n_y are not orthogonal to each other, first a unit
vector e_y is determined that is orthogonal to n_x and is lying
in the plane spanned by n_x and n_y. If n_x and n_y are parallel
or nearly parallel to each other, a vector e_y is selected
arbitrarily such that e_x and e_y are orthogonal to each other.
</p>
</html>"));
    end from_nxy;

    function from_nxz
      "Return fixed orientation object from n_x and n_z vectors"
      extends Modelica_Icons.Function;
      input Real n_x[3](each final unit="1")
        "Vector in direction of x-axis of frame 2, resolved in frame 1";
      input Real n_z[3](each final unit="1")
        "Vector in direction of z-axis of frame 2, resolved in frame 1";
      output Orientation R "Orientation object to rotate frame 1 into frame 2";
    protected
      Real abs_n_x=sqrt(n_x*n_x);
      Real e_x[3](each final unit="1")=if abs_n_x < 1.e-10 then {1,0,0} else n_x/abs_n_x;
      Real n_y_aux[3](each final unit="1")=cross(n_z, e_x);
      Real n_z_aux[3](each final unit="1")=if n_y_aux*n_y_aux > 1.0e-6 then n_z else (if abs(e_x[1])
           > 1.0e-6 then {0,0,1} else {1,0,0});
      Real e_y_aux[3](each final unit="1")=cross(n_z_aux, e_x);
      Real e_y[3](each final unit="1")=e_y_aux/sqrt(e_y_aux*e_y_aux);
    algorithm
      R := Orientation(T={e_x,e_y,cross(e_x, e_y)},w= zeros(3));
      annotation (Documentation(info="<html>
<p>
It is assumed that the two input vectors n_x and n_z are
resolved in frame 1 and are directed along the x and z axis
of frame 2 (i.e., n_x and n_z are orthogonal to each other)
The function returns the orientation object R to rotate from
frame 1 to frame 2.
</p>
<p>
The function is robust in the sense that it returns always
an orientation object R, even if n_z is not orthogonal to n_x.
This is performed in the following way:
</p>
<p>
If n_x and n_z are not orthogonal to each other, first a unit
vector e_z is determined that is orthogonal to n_x and is lying
in the plane spanned by n_x and n_z. If n_x and n_z are parallel
or nearly parallel to each other, a vector e_z is selected
arbitrarily such that n_x and e_z are orthogonal to each other.
</p>
</html>"));
    end from_nxz;

    function from_T "Return orientation object R from transformation matrix T"
      extends Modelica_Icons.Function;
      input Real T[3, 3]
        "Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)";
      input Modelica_SIunits.AngularVelocity w[3]
        "Angular velocity from frame 2 with respect to frame 1, resolved in frame 2 (skew(w)=T*der(transpose(T)))";
      output Orientation R "Orientation object to rotate frame 1 into frame 2";
    algorithm
      R := Orientation(T=T,w= w);
      annotation(Inline=true);
    end from_T;

    function from_T2
      "Return orientation object R from transformation matrix T and its derivative der(T)"
      extends Modelica_Icons.Function;
      input Real T[3, 3]
        "Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)";
      input Real der_T[3,3] "= der(T)";
      output Orientation R "Orientation object to rotate frame 1 into frame 2";

    algorithm
      R := Orientation(T=T,w={T[3, :]*der_T[2, :],-T[3, :]*der_T[1, :],T[2, :]*der_T[1, :]});
      annotation (Inline=true,Documentation(info="<html>
<p>
Computes the orientation object from a transformation matrix T and
the derivative der(T) of the transformation matrix.
Usually, it is more efficient to use function \"from_T\" instead, where
the angular velocity has to be given as input argument. Only if this
is not possible or too difficult to compute, use function from_T2(..).
</p>
</html>"));
    end from_T2;

    function from_T_inv
      "Return orientation object R from inverse transformation matrix T_inv"

      extends Modelica_Icons.Function;
      input Real T_inv[3, 3]
        "Inverse transformation matrix to transform vector from frame 2 to frame 1 (v1=T_inv*v2)";
      input Modelica_SIunits.AngularVelocity w[3]
        "Angular velocity from frame 1 with respect to frame 2, resolved in frame 1 (skew(w)=T_inv*der(transpose(T_inv)))";
      output Orientation R "Orientation object to rotate frame 1 into frame 2";
    algorithm
      R := Orientation(T=transpose(T_inv),w= -w);
      annotation(Inline=true);
    end from_T_inv;

    function from_Q
      "Return orientation object R from quaternion orientation object Q"

      extends Modelica_Icons.Function;
      input Quaternions.Orientation Q
        "Quaternions orientation object to rotate frame 1 into frame 2";
      input Modelica_SIunits.AngularVelocity w[3]
        "Angular velocity from frame 2 with respect to frame 1, resolved in frame 2";
      output Orientation R "Orientation object to rotate frame 1 into frame 2";
    algorithm
      /*
  T := (2*Q[4]*Q[4] - 1)*identity(3) + 2*([Q[1:3]]*transpose([Q[1:3]]) - Q[4]*
    skew(Q[1:3]));
*/
      R := Orientation([2*(Q[1]*Q[1] + Q[4]*Q[4]) - 1, 2*(Q[1]*Q[2] + Q[3]*Q[4]),
         2*(Q[1]*Q[3] - Q[2]*Q[4]); 2*(Q[2]*Q[1] - Q[3]*Q[4]), 2*(Q[2]*Q[2] + Q[4]
        *Q[4]) - 1, 2*(Q[2]*Q[3] + Q[1]*Q[4]); 2*(Q[3]*Q[1] + Q[2]*Q[4]), 2*(Q[3]
        *Q[2] - Q[1]*Q[4]), 2*(Q[3]*Q[3] + Q[4]*Q[4]) - 1],w= w);
      annotation(Inline=true);
    end from_Q;

    function to_T "Return transformation matrix T from orientation object R"
      extends Modelica_Icons.Function;
      input Orientation R "Orientation object to rotate frame 1 into frame 2";
      output Real T[3, 3]
        "Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)";
    algorithm
      T := R.T;
      annotation(Inline=true);
    end to_T;

    function to_T_inv
      "Return inverse transformation matrix T_inv from orientation object R"

      extends Modelica_Icons.Function;
      input Orientation R "Orientation object to rotate frame 1 into frame 2";
      output Real T_inv[3, 3]
        "Inverse transformation matrix to transform vector from frame 2 into frame 1 (v1=T_inv*v2)";
    algorithm
      T_inv := transpose(R.T);
      annotation(Inline=true);
    end to_T_inv;

    function to_Q
      "Return quaternion orientation object Q from orientation object R"

      extends Modelica_Icons.Function;
      input Orientation R "Orientation object to rotate frame 1 into frame 2";
      input Quaternions.Orientation Q_guess=Quaternions.nullRotation()
        "Guess value for output Q (there are 2 solutions; the one closer to Q_guess is used";
      output Quaternions.Orientation Q
        "Quaternions orientation object to rotate frame 1 into frame 2";
    algorithm
      Q := Quaternions.from_T(R.T, Q_guess);
      annotation(Inline=true);
    end to_Q;

    function to_vector "Map rotation object into vector"
      extends Modelica_Icons.Function;
      input Orientation R "Orientation object to rotate frame 1 into frame 2";
      output Real vec[9] "Elements of R in one vector";
    algorithm
      vec := {R.T[1, 1],R.T[2, 1],R.T[3, 1],R.T[1, 2],R.T[2, 2],R.T[3, 2],R.T[1,
        3],R.T[2, 3],R.T[3, 3]};
      annotation(Inline=true);
    end to_vector;

    function to_exy
      "Map rotation object into e_x and e_y vectors of frame 2, resolved in frame 1"

      extends Modelica_Icons.Function;
      input Orientation R "Orientation object to rotate frame 1 into frame 2";
      output Real exy[3, 2]
        "= [e_x, e_y] where e_x and e_y are axes unit vectors of frame 2, resolved in frame 1";
    algorithm
      exy := [R.T[1, :], R.T[2, :]];
      annotation(Inline=true);
    end to_exy;

    function axis "Return unit vector for x-, y-, or z-axis"
      extends Modelica_Icons.Function;
      input Integer axis(min=1, max=3) "Axis vector to be returned";
      output Real e[3](each final unit="1") "Unit axis vector";
    algorithm
      e := if axis == 1 then {1,0,0} else (if axis == 2 then {0,1,0} else {0,0,1});
      annotation(Inline=true);
    end axis;

    package Quaternions
      "Functions to transform rotational frame quantities based on quaternions (also called Euler parameters)"
      extends Modelica_Icons.Package;

      type Orientation
        "Orientation type defining rotation from a frame 1 into a frame 2 with quaternions {p1,p2,p3,p0}"

        extends Internal.QuaternionBase;

        encapsulated function equalityConstraint
          "Return the constraint residues to express that two frames have the same quaternion orientation"
          import Modelica_Icons;

          import Modelica =
                 M_S_L;
          import Modelica_Mechanics_MultiBody.Frames.Quaternions;
          extends Modelica_Icons.Function;
          input Quaternions.Orientation Q1
            "Quaternions orientation object to rotate frame 0 into frame 1";
          input Quaternions.Orientation Q2
            "Quaternions orientation object to rotate frame 0 into frame 2";
          output Real residue[3]
            "The half of the rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation (shall be zero)";
        algorithm
          residue := [Q1[4], Q1[3], -Q1[2], -Q1[1]; -Q1[3], Q1[4], Q1[1], -Q1[2];
             Q1[2], -Q1[1], Q1[4], -Q1[3]]*Q2;
          annotation(Inline=true);
        end equalityConstraint;

        annotation ( Documentation(info="<html>
<p>
This type describes the <b>rotation</b> to rotate a frame 1 into
a frame 2 using quaternions (also called <b>Euler parameters</b>)
according to the following definition:
</p>
<pre>
   Quaternions.Orientation Q;
   Real  n[3];
   Real  phi(unit=\"rad\");
   Q = [ n*sin(phi/2)
           cos(phi/2) ]
</pre>
<p>
where \"n\" is the <b>axis of rotation</b> to rotate frame 1 into
frame 2 and \"phi\" is the <b>rotation angle</b> for this rotation.
Vector \"n\" is either resolved in frame 1 or in frame 2
(the result is the same since the coordinates of \"n\" with respect to
frame 1 are identical to its coordinates with respect to frame 2).
</p>
<p>
The term \"quaternions\" is preferred over the historically
more reasonable \"Euler parameters\" in order to not get
confused with Modelica \"parameters\".
</p>
</html>"));
      end Orientation;

      type der_Orientation = Real[4] (each unit="1/s")
        "First time derivative of Quaternions.Orientation";

      function orientationConstraint
        "Return residues of orientation constraints (shall be zero)"
        extends Modelica_Icons.Function;
        input Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2";
        output Real residue[1] "Residue constraint (shall be zero)";
      algorithm
        residue := {Q*Q - 1};
        annotation(Inline=true);
      end orientationConstraint;

      function angularVelocity1
        "Compute angular velocity resolved in frame 1 from quaternion orientation object and its derivative"

        extends Modelica_Icons.Function;
        input Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2";
        input der_Orientation der_Q "Derivative of Q";
        output Modelica_SIunits.AngularVelocity w[3]
          "Angular velocity resolved in frame 1";
      algorithm
        w := 2*([Q[4], -Q[3], Q[2], -Q[1]; Q[3], Q[4], -Q[1], -Q[2]; -Q[2], Q[1],
           Q[4], -Q[3]]*der_Q);
        annotation(Inline=true);
      end angularVelocity1;

      function angularVelocity2
        "Compute angular velocity resolved in frame 2 from quaternions orientation object and its derivative"

        extends Modelica_Icons.Function;
        input Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2";
        input der_Orientation der_Q "Derivative of Q";
        output Modelica_SIunits.AngularVelocity w[3]
          "Angular velocity of frame 2 with respect to frame 1 resolved in frame 2";
      algorithm
        w := 2*([Q[4], Q[3], -Q[2], -Q[1]; -Q[3], Q[4], Q[1], -Q[2]; Q[2], -Q[1],
           Q[4], -Q[3]]*der_Q);
        annotation(Inline=true);
      end angularVelocity2;

      function resolve1 "Transform vector from frame 2 to frame 1"
        extends Modelica_Icons.Function;
        input Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2";
        input Real v2[3] "Vector in frame 2";
        output Real v1[3] "Vector in frame 1";
      algorithm
        v1 := 2*((Q[4]*Q[4] - 0.5)*v2 + (Q[1:3]*v2)*Q[1:3] + Q[4]*cross(Q[1:3],
          v2));
        annotation(Inline=true);
      end resolve1;

      function resolve2 "Transform vector from frame 1 to frame 2"
        extends Modelica_Icons.Function;
        input Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2";
        input Real v1[3] "Vector in frame 1";
        output Real v2[3] "Vector in frame 2";
      algorithm
        v2 := 2*((Q[4]*Q[4] - 0.5)*v1 + (Q[1:3]*v1)*Q[1:3] - Q[4]*cross(Q[1:3],
          v1));
        annotation(Inline=true);
      end resolve2;

      function multipleResolve1
        "Transform several vectors from frame 2 to frame 1"
        extends Modelica_Icons.Function;
        input Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2";
        input Real v2[3, :] "Vectors in frame 2";
        output Real v1[3, size(v2, 2)] "Vectors in frame 1";
      algorithm
        v1 := ((2*Q[4]*Q[4] - 1)*identity(3) + 2*([Q[1:3]]*transpose([Q[1:3]]) +
          Q[4]*skew(Q[1:3])))*v2;
        annotation(Inline=true);
      end multipleResolve1;

      function multipleResolve2
        "Transform several vectors from frame 1 to frame 2"
        extends Modelica_Icons.Function;
        input Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2";
        input Real v1[3, :] "Vectors in frame 1";
        output Real v2[3, size(v1, 2)] "Vectors in frame 2";
      algorithm
        v2 := ((2*Q[4]*Q[4] - 1)*identity(3) + 2*([Q[1:3]]*transpose([Q[1:3]]) -
          Q[4]*skew(Q[1:3])))*v1;
        annotation(Inline=true);
      end multipleResolve2;

      function nullRotation
        "Return quaternion orientation object that does not rotate a frame"

        extends Modelica_Icons.Function;
        output Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2";
      algorithm
        Q := {0,0,0,1};
        annotation(Inline=true);
      end nullRotation;

      function inverseRotation "Return inverse quaternions orientation object"
        extends Modelica_Icons.Function;
        input Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2";
        output Quaternions.Orientation Q_inv
          "Quaternions orientation object to rotate frame 2 into frame 1";
      algorithm
        Q_inv := {-Q[1],-Q[2],-Q[3],Q[4]};
        annotation(Inline=true);
      end inverseRotation;

      function relativeRotation
        "Return relative quaternions orientation object"
        extends Modelica_Icons.Function;
        input Quaternions.Orientation Q1
          "Quaternions orientation object to rotate frame 0 into frame 1";
        input Quaternions.Orientation Q2
          "Quaternions orientation object to rotate frame 0 into frame 2";
        output Quaternions.Orientation Q_rel
          "Quaternions orientation object to rotate frame 1 into frame 2";
      algorithm
        Q_rel := [Q1[4], Q1[3], -Q1[2], -Q1[1]; -Q1[3], Q1[4], Q1[1], -Q1[2]; Q1[
          2], -Q1[1], Q1[4], -Q1[3]; Q1[1], Q1[2], Q1[3], Q1[4]]*Q2;
        annotation(Inline=true);
      end relativeRotation;

      function absoluteRotation
        "Return absolute quaternions orientation object from another absolute and a relative quaternions orientation object"

        extends Modelica_Icons.Function;
        input Quaternions.Orientation Q1
          "Quaternions orientation object to rotate frame 0 into frame 1";
        input Quaternions.Orientation Q_rel
          "Quaternions orientation object to rotate frame 1 into frame 2";
        output Quaternions.Orientation Q2
          "Quaternions orientation object to rotate frame 0 into frame 2";
      algorithm
        Q2 := [Q_rel[4], Q_rel[3], -Q_rel[2], Q_rel[1]; -Q_rel[3], Q_rel[4],
          Q_rel[1], Q_rel[2]; Q_rel[2], -Q_rel[1], Q_rel[4], Q_rel[3]; -Q_rel[1],
           -Q_rel[2], -Q_rel[3], Q_rel[4]]*Q1;
        annotation(Inline=true);
      end absoluteRotation;

      function planarRotation
        "Return quaternion orientation object of a planar rotation"
        import Math = Modelica_Math;
        extends Modelica_Icons.Function;
        input Real e[3](each final unit="1")
          "Normalized axis of rotation (must have length=1)";
        input Modelica_SIunits.Angle angle
          "Rotation angle to rotate frame 1 into frame 2 along axis e";
        output Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2 along axis e";
      algorithm
        Q := vector([e*Math.sin(angle/2); Math.cos(angle/2)]);
        annotation(Inline=true);
      end planarRotation;

      function smallRotation
        "Return rotation angles valid for a small rotation"
        extends Modelica_Icons.Function;
        input Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2";
        output Modelica_SIunits.Angle phi[3]
          "The rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small relative rotation";
      algorithm
        phi := 2*{Q[1],Q[2],Q[3]};
        annotation(Inline=true);
      end smallRotation;

      function from_T
        "Return quaternion orientation object Q from transformation matrix T"

        extends Modelica_Icons.Function;
        input Real T[3, 3]
          "Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)";
        input Quaternions.Orientation Q_guess=nullRotation()
          "Guess value for Q (there are 2 solutions; the one close to Q_guess is used";
        output Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2 (Q and -Q have same transformation matrix)";
      protected
        Real paux;
        Real paux4;
        Real c1;
        Real c2;
        Real c3;
        Real c4;
        constant Real p4limit=0.1;
        constant Real c4limit=4*p4limit*p4limit;
      algorithm
        /*
   Note, for quaternions, Q and -Q have the same transformation matrix.
   Calculation of quaternions from transformation matrix T:
   It is guaranteed that c1>=0, c2>=0, c3>=0, c4>=0 and
   that not all of them can be zero at the same time
   (e.g., if 3 of them are zero, the 4th variable is 1).
   Since the sqrt(..) has to be performed on one of these variables,
   it is applied on a variable which is far enough from zero.
   This guarantees that the sqrt(..) is never taken near zero
   and therefore the derivative of sqrt(..) can never be infinity.
   There is an ambiguity for quaternions, since Q and -Q
   lead to the same transformation matrix. The ambiguity
   is resolved here by selecting the Q that is closer to
   the input argument Q_guess.
*/
        c1 := 1 + T[1, 1] - T[2, 2] - T[3, 3];
        c2 := 1 + T[2, 2] - T[1, 1] - T[3, 3];
        c3 := 1 + T[3, 3] - T[1, 1] - T[2, 2];
        c4 := 1 + T[1, 1] + T[2, 2] + T[3, 3];

        if c4 > c4limit or (c4 > c1 and c4 > c2 and c4 > c3) then
          paux := sqrt(c4)/2;
          paux4 := 4*paux;
          Q := {(T[2, 3] - T[3, 2])/paux4,(T[3, 1] - T[1, 3])/paux4,(T[1, 2] - T[
            2, 1])/paux4,paux};

        elseif c1 > c2 and c1 > c3 and c1 > c4 then
          paux := sqrt(c1)/2;
          paux4 := 4*paux;
          Q := {paux,(T[1, 2] + T[2, 1])/paux4,(T[1, 3] + T[3, 1])/paux4,(T[2, 3]
             - T[3, 2])/paux4};

        elseif c2 > c1 and c2 > c3 and c2 > c4 then
          paux := sqrt(c2)/2;
          paux4 := 4*paux;
          Q := {(T[1, 2] + T[2, 1])/paux4,paux,(T[2, 3] + T[3, 2])/paux4,(T[3, 1]
             - T[1, 3])/paux4};

        else
          paux := sqrt(c3)/2;
          paux4 := 4*paux;
          Q := {(T[1, 3] + T[3, 1])/paux4,(T[2, 3] + T[3, 2])/paux4,paux,(T[1, 2]
             - T[2, 1])/paux4};
        end if;

        if Q*Q_guess < 0 then
          Q := -Q;
        end if;
      end from_T;

      function from_T_inv
        "Return quaternion orientation object Q from inverse transformation matrix T_inv"

        extends Modelica_Icons.Function;
        input Real T_inv[3, 3]
          "Inverse transformation matrix to transform vector from frame 2 to frame 1 (v1=T_inv*v2)";
        input Quaternions.Orientation Q_guess=nullRotation()
          "Guess value for output Q (there are 2 solutions; the one closer to Q_guess is used";
        output Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2 (Q and -Q have same transformation matrix)";
      algorithm
        Q := from_T(transpose(T_inv), Q_guess);
        annotation(Inline=true);
      end from_T_inv;

      function to_T
        "Return transformation matrix T from quaternion orientation object Q"

        extends Modelica_Icons.Function;
        input Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2";
        output Real T[3, 3]
          "Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)";
      algorithm
        /*
  T := (2*Q[4]*Q[4] - 1)*identity(3) + 2*([Q[1:3]]*transpose([Q[1:3]]) - Q[4]*
    skew(Q[1:3]));
*/
        T := [2*(Q[1]*Q[1] + Q[4]*Q[4]) - 1, 2*(Q[1]*Q[2] + Q[3]*Q[4]), 2*(Q[1]*Q[
          3] - Q[2]*Q[4]); 2*(Q[2]*Q[1] - Q[3]*Q[4]), 2*(Q[2]*Q[2] + Q[4]*Q[4])
           - 1, 2*(Q[2]*Q[3] + Q[1]*Q[4]); 2*(Q[3]*Q[1] + Q[2]*Q[4]), 2*(Q[3]*Q[2]
           - Q[1]*Q[4]), 2*(Q[3]*Q[3] + Q[4]*Q[4]) - 1];
        annotation(Inline=true);
      end to_T;

      function to_T_inv
        "Return inverse transformation matrix T_inv from quaternion orientation object Q"

        extends Modelica_Icons.Function;
        input Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2";
        output Real T_inv[3, 3]
          "Transformation matrix to transform vector from frame 2 to frame 1 (v1=T*v2)";
      algorithm
        /*
  T_inv := (2*Q[4]*Q[4] - 1)*identity(3) + 2*([Q[1:3]]*transpose([Q[1:3]]) + Q[
    4]*skew(Q[1:3]));
*/
        T_inv := [2*(Q[1]*Q[1] + Q[4]*Q[4]) - 1, 2*(Q[2]*Q[1] - Q[3]*Q[4]), 2*(Q[
          3]*Q[1] + Q[2]*Q[4]); 2*(Q[1]*Q[2] + Q[3]*Q[4]), 2*(Q[2]*Q[2] + Q[4]*Q[
          4]) - 1, 2*(Q[3]*Q[2] - Q[1]*Q[4]); 2*(Q[1]*Q[3] - Q[2]*Q[4]), 2*(Q[2]*
          Q[3] + Q[1]*Q[4]), 2*(Q[3]*Q[3] + Q[4]*Q[4]) - 1];
        annotation(Inline=true);
      end to_T_inv;

      annotation ( Documentation(info="<HTML>
<p>
Package <b>Frames.Quaternions</b> contains type definitions and
functions to transform rotational frame quantities with quaternions.
Functions of this package are currently only utilized in
MultiBody.Parts.Body components, when quaternions shall be used
as parts of the body states.
Some functions are also used in a new Modelica package for
B-Spline interpolation that is able to interpolate paths consisting of
position vectors and orientation objects.
</p>
<h4>Content</h4>
<p>In the table below an example is given for every function definition.
The used variables have the following declaration:
</p>
<pre>
   Quaternions.Orientation Q, Q1, Q2, Q_rel, Q_inv;
   Real[3,3]   T, T_inv;
   Real[3]     v1, v2, w1, w2, n_x, n_y, n_z, res_ori, phi;
   Real[6]     res_equal;
   Real        L, angle;
</pre>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><b><i>Function/type</i></b></th><th><b><i>Description</i></b></th></tr>
  <tr><td valign=\"top\"><b>Orientation Q;</b></td>
      <td valign=\"top\">New type defining a quaternion object that describes<br>
          the rotation of frame 1 into frame 2.
      </td>
  </tr>
  <tr><td valign=\"top\"><b>der_Orientation</b> der_Q;</td>
      <td valign=\"top\">New type defining the first time derivative
         of Frames.Quaternions.Orientation.
      </td>
  </tr>
  <tr><td valign=\"top\">res_ori = <b>orientationConstraint</b>(Q);</td>
      <td valign=\"top\">Return the constraints between the variables of a quaternion object<br>
      (shall be zero).</td>
  </tr>
  <tr><td valign=\"top\">w1 = <b>angularVelocity1</b>(Q, der_Q);</td>
      <td valign=\"top\">Return angular velocity resolved in frame 1 from
          quaternion object Q<br> and its derivative der_Q.
     </td>
  </tr>
  <tr><td valign=\"top\">w2 = <b>angularVelocity2</b>(Q, der_Q);</td>
      <td valign=\"top\">Return angular velocity resolved in frame 2 from
          quaternion object Q<br> and its derivative der_Q.
     </td>
  </tr>
  <tr><td valign=\"top\">v1 = <b>resolve1</b>(Q,v2);</td>
      <td valign=\"top\">Transform vector v2 from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td valign=\"top\">v2 = <b>resolve2</b>(Q,v1);</td>
      <td valign=\"top\">Transform vector v1 from frame 1 to frame 2.
     </td>
  </tr>
  <tr><td valign=\"top\">[v1,w1] = <b>multipleResolve1</b>(Q, [v2,w2]);</td>
      <td valign=\"top\">Transform several vectors from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td valign=\"top\">[v2,w2] = <b>multipleResolve2</b>(Q, [v1,w1]);</td>
      <td valign=\"top\">Transform several vectors from frame 1 to frame 2.
      </td>
  </tr>
  <tr><td valign=\"top\">Q = <b>nullRotation</b>()</td>
      <td valign=\"top\">Return quaternion object R that does not rotate a frame.
  </tr>
  <tr><td valign=\"top\">Q_inv = <b>inverseRotation</b>(Q);</td>
      <td valign=\"top\">Return inverse quaternion object.
      </td>
  </tr>
  <tr><td valign=\"top\">Q_rel = <b>relativeRotation</b>(Q1,Q2);</td>
      <td valign=\"top\">Return relative quaternion object from two absolute
          quaternion objects.
      </td>
  </tr>
  <tr><td valign=\"top\">Q2 = <b>absoluteRotation</b>(Q1,Q_rel);</td>
      <td valign=\"top\">Return absolute quaternion object from another
          absolute<br> and a relative quaternion object.
      </td>
  </tr>
  <tr><td valign=\"top\">Q = <b>planarRotation</b>(e, angle);</td>
      <td valign=\"top\">Return quaternion object of a planar rotation.
      </td>
  </tr>
  <tr><td valign=\"top\">phi = <b>smallRotation</b>(Q);</td>
      <td valign=\"top\">Return rotation angles phi valid for a small rotation.
      </td>
  </tr>
  <tr><td valign=\"top\">Q = <b>from_T</b>(T);</td>
      <td valign=\"top\">Return quaternion object Q from transformation matrix T.
      </td>
  </tr>
  <tr><td valign=\"top\">Q = <b>from_T_inv</b>(T_inv);</td>
      <td valign=\"top\">Return quaternion object Q from inverse transformation matrix T_inv.
      </td>
  </tr>
  <tr><td valign=\"top\">T = <b>to_T</b>(Q);</td>
      <td valign=\"top\">Return transformation matrix T from quaternion object Q.
  </tr>
  <tr><td valign=\"top\">T_inv = <b>to_T_inv</b>(Q);</td>
      <td valign=\"top\">Return inverse transformation matrix T_inv from quaternion object Q.
      </td>
  </tr>
</table>
</HTML>"));
    end Quaternions;

    package TransformationMatrices "Functions for transformation matrices"
      extends Modelica_Icons.Package;
      type Orientation
        "Orientation type defining rotation from a frame 1 into a frame 2 with a transformation matrix"

        extends Internal.TransformationMatrix;

        encapsulated function equalityConstraint
          "Return the constraint residues to express that two frames have the same orientation"
          import Modelica_Icons;

          import Modelica =
                 M_S_L;
          import Modelica_Mechanics_MultiBody.Frames.TransformationMatrices;
          extends Modelica_Icons.Function;
          input TransformationMatrices.Orientation T1
            "Orientation object to rotate frame 0 into frame 1";
          input TransformationMatrices.Orientation T2
            "Orientation object to rotate frame 0 into frame 2";
          output Real residue[3]
            "The rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation (should be zero)";
        algorithm
          residue := {cross(T1[1, :], T1[2, :])*T2[2, :],-cross(T1[1, :], T1[2, :])
            *T2[1, :],T1[2, :]*T2[1, :]};
          annotation(Inline=true);
        end equalityConstraint;
        annotation (Documentation(info="<html>
<p>
This type describes the <b>rotation</b> from a <b>frame 1</b> into a <b>frame 2</b>.
An instance <b>R</b> of type <b>Orientation</b> has the following interpretation:
</p>
<pre>
   <b>T</b> = [<b>e</b><sub>x</sub>, <b>e</b><sub>y</sub>, <b>e</b><sub>z</sub>];
       e.g., <b>T</b> = [1,0,0; 0,1,0; 0,0,1]
</pre>
<p>
where <b>e</b><sub>x</sub>,<b>e</b><sub>y</sub>,<b>e</b><sub>z</sub>
are unit vectors in the direction of the x-axis, y-axis, and z-axis
of frame 1, resolved in frame 2, respectively. Therefore, if <b>v</b><sub>1</sub>
is vector <b>v</b> resolved in frame 1 and <b>v</b><sub>2</sub> is
vector <b>v</b> resolved in frame 2, the following relationship holds:
</p>
<pre>
    <b>v</b><sub>2</sub> = <b>T</b> * <b>v</b><sub>1</sub>
</pre>
<p>
The <b>inverse</b> orientation
<b>T_inv</b> = <b>T</b><sup>T</sup> describes the rotation
from frame 2 into frame 1.
</p>
<p>
Since the orientation is described by 9 variables, there are
6 constraints between these variables. These constraints
are defined in function <b>TransformationMatrices.orientationConstraint</b>.
</p>
<p>
Note, that in the MultiBody library the rotation object is
never directly accessed but only with the access functions provided
in package TransformationMatrices. As a consequence, other implementations of
Rotation can be defined by adapting this package correspondingly.
</p>
</html>"));
      end Orientation;

      type der_Orientation = Real[3, 3] (each unit="1/s")
        "New type defining the first time derivative of Orientation";

      function orientationConstraint
        "Return residues of orientation constraints (shall be zero)"
        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
        output Real residue[6]
          "Residues of constraints between elements of orientation object (shall be zero)";
      algorithm
        residue := {T[:, 1]*T[:, 1] - 1,T[:, 2]*T[:, 2] - 1,T[:, 3]*T[:, 3] - 1,T[
          :, 1]*T[:, 2],T[:, 1]*T[:, 3],T[:, 2]*T[:, 3]};
        annotation(Inline=true);
      end orientationConstraint;

      function angularVelocity1
        "Return angular velocity resolved in frame 1 from orientation object and its derivative"

        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
        input der_Orientation der_T "Derivative of T";
        output Modelica_SIunits.AngularVelocity w[3]
          "Angular velocity of frame 2 with respect to frame 1 resolved in frame 1";
      algorithm
        /* The angular velocity w of frame 2 with respect to frame 1 resolved in frame 1,
     is defined as:
        w = vec( der(transpose(T))*T );
     where
                   |   0 -w3  w2 |
         skew(w) = |  w3   0 -w1 | and w = vec(skew(w))
                   | -w2  w1   0 |
     i.e.
         W = der(transpose(T))*T)
         w = {W(3,2), -W(3,1), W(2,1)}
     Therefore, only 3 values of W need to be computed:
             | der(T[:,1]) |
         W = | der(T[:,2]) | * | T[:,1], T[:,2], T[:,3] |
             | der(T[:,3]) |
             |  W(3,2) |   |  der(T[:,3])*T[:,2] |
         w = | -W(3,1) | = | -der(T[:,3])*T[:,1] |
             |  W(2,1) |   |  der(T[:,2])*T[:,1] |
  */
        w := {der_T[:, 3]*T[:, 2],-der_T[:, 3]*T[:, 1],der_T[:, 2]*T[:, 1]};
        annotation(Inline=true);
      end angularVelocity1;

      function angularVelocity2
        "Return angular velocity resolved in frame 2 from orientation object and its derivative"

        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
        input der_Orientation der_T "Derivative of T";
        output Modelica_SIunits.AngularVelocity w[3]
          "Angular velocity of frame 2 with respect to frame 1 resolved in frame 2";
      algorithm
        /* The angular velocity w of frame 2 with respect to frame 1 resolved in frame 2,
     is defined as:
        w = vec(T*der(transpose(T)));
     where
                   |   0 -w3  w2 |
         skew(w) = |  w3   0 -w1 | and w = vec(skew(w))
                   | -w2  w1   0 |
     i.e.
         W = T*der(transpose(T))
         w = {W(3,2), -W(3,1), W(2,1)}
     Therefore, only 3 values of W need to be computed:
             | T[1,:] |
         W = | T[2,:] | * | der(T[1,:]), der(T[2,:]), der(T[3,:]) |
             | T[3,:] |
             |  W(3,2) |   |  T[3,:]*der(T[2,:]) |
         w = | -W(3,1) | = | -T[3,:]*der(T[1,:]) |
             |  W(2,1) |   |  T[2,:]*der(T[1,:]) |
  */
        w := {T[3, :]*der_T[2, :],-T[3, :]*der_T[1, :],T[2, :]*der_T[1, :]};
        annotation(Inline=true);
      end angularVelocity2;

      function resolve1 "Transform vector from frame 2 to frame 1"
        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
        input Real v2[3] "Vector in frame 2";
        output Real v1[3] "Vector in frame 1";
      algorithm
        v1 := transpose(T)*v2;
        annotation(Inline=true);
      end resolve1;

      function resolve2 "Transform vector from frame 1 to frame 2"
        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
        input Real v1[3] "Vector in frame 1";
        output Real v2[3] "Vector in frame 2";
      algorithm
        v2 := T*v1;
        annotation(Inline=true);
      end resolve2;

      function multipleResolve1
        "Transform several vectors from frame 2 to frame 1"

        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
        input Real v2[3, :] "Vectors in frame 2";
        output Real v1[3, size(v2, 2)] "Vectors in frame 1";
      algorithm
        v1 := transpose(T)*v2;
        annotation(Inline=true);
      end multipleResolve1;

      function multipleResolve2
        "Transform several vectors from frame 1 to frame 2"

        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
        input Real v1[3, :] "Vectors in frame 1";
        output Real v2[3, size(v1, 2)] "Vectors in frame 2";
      algorithm
        v2 := T*v1;
        annotation(Inline=true);
      end multipleResolve2;

      function resolveDyade1
        "Transform second order tensor from frame 2 to frame 1"
        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
        input Real D2[3, 3] "Second order tensor resolved in frame 2";
        output Real D1[3, 3] "Second order tensor resolved in frame 1";
      algorithm
        D1 := transpose(T)*D2*T;
        annotation(Inline=true);
      end resolveDyade1;

      function resolveDyade2
        "Transform second order tensor from frame 1 to frame 2"
        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
        input Real D1[3, 3] "Second order tensor resolved in frame 1";
        output Real D2[3, 3] "Second order tensor resolved in frame 2";
      algorithm
        D2 := T*D1*transpose(T);
        annotation(Inline=true);
      end resolveDyade2;

      function nullRotation
        "Return orientation object that does not rotate a frame"
        extends Modelica_Icons.Function;
        output TransformationMatrices.Orientation T
          "Orientation object such that frame 1 and frame 2 are identical";
      algorithm
        T := identity(3);
        annotation(Inline=true);
      end nullRotation;

      function inverseRotation "Return inverse orientation object"
        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
        output TransformationMatrices.Orientation T_inv
          "Orientation object to rotate frame 2 into frame 1";
      algorithm
        T_inv := transpose(T);
        annotation(Inline=true);
      end inverseRotation;

      function relativeRotation "Return relative orientation object"
        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T1
          "Orientation object to rotate frame 0 into frame 1";
        input TransformationMatrices.Orientation T2
          "Orientation object to rotate frame 0 into frame 2";
        output TransformationMatrices.Orientation T_rel
          "Orientation object to rotate frame 1 into frame 2";
      algorithm
        T_rel := T2*transpose(T1);
        annotation(Inline=true);
      end relativeRotation;

      function absoluteRotation
        "Return absolute orientation object from another absolute and a relative orientation object"

        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T1
          "Orientation object to rotate frame 0 into frame 1";
        input TransformationMatrices.Orientation T_rel
          "Orientation object to rotate frame 1 into frame 2";
        output TransformationMatrices.Orientation T2
          "Orientation object to rotate frame 0 into frame 2";
      algorithm
        T2 := T_rel*T1;
        annotation(Inline=true);
      end absoluteRotation;

      function planarRotation "Return orientation object of a planar rotation"
        import Math = Modelica_Math;
        extends Modelica_Icons.Function;
        input Real e[3](each final unit="1")
          "Normalized axis of rotation (must have length=1)";
        input Modelica_SIunits.Angle angle
          "Rotation angle to rotate frame 1 into frame 2 along axis e";
        output TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
      algorithm
        T := [e]*transpose([e]) + (identity(3) - [e]*transpose([e]))*Math.cos(
          angle) - skew(e)*Math.sin(angle);
        annotation(Inline=true);
      end planarRotation;

      function planarRotationAngle
        "Return angle of a planar rotation, given the rotation axis and the representations of a vector in frame 1 and frame 2"

        extends Modelica_Icons.Function;
        input Real e[3](each final unit="1")
          "Normalized axis of rotation to rotate frame 1 around e into frame 2 (must have length=1)";
        input Real v1[3]
          "A vector v resolved in frame 1 (shall not be parallel to e)";
        input Real v2[3]
          "Vector v resolved in frame 2, i.e., v2 = resolve2(planarRotation(e,angle),v1)";
        output Modelica_SIunits.Angle angle
          "Rotation angle to rotate frame 1 into frame 2 along axis e in the range: -pi <= angle <= pi";
      algorithm
        /* Vector v is resolved in frame 1 and frame 2 according to:
        (1)  v2 = (e*transpose(e) + (identity(3) - e*transpose(e))*cos(angle) - skew(e)*sin(angle))*v1;
                = e*(e*v1) + (v1 - e*(e*v1))*cos(angle) - cross(e,v1)*sin(angle)
       Equation (1) is multiplied with "v1" resulting in (note: e*e = 1)
            v1*v2 = (e*v1)*(e*v2) + (v1*v1 - (e*v1)*(e*v1))*cos(angle)
       and therefore:
        (2) cos(angle) = ( v1*v2 - (e*v1)*(e*v2)) / (v1*v1 - (e*v1)*(e*v1))
       Similarly, equation (1) is multiplied with cross(e,v1), i.e., a
       a vector that is orthogonal to e and to v1:
              cross(e,v1)*v2 = - cross(e,v1)*cross(e,v1)*sin(angle)
       and therefore:
          (3) sin(angle) = -cross(e,v1)*v2/(cross(e,v1)*cross(e,v1));
       We have e*e=1; Therefore:
          (4) v1*v1 - (e*v1)*(e*v1) = |v1|^2 - (|v1|*cos(e,v1))^2
       and
          (5) cross(e,v1)*cross(e,v1) = (|v1|*sin(e,v1))^2
                                      = |v1|^2*(1 - cos(e,v1)^2)
                                      = |v1|^2 - (|v1|*cos(e,v1))^2
       The denominators of (2) and (3) are identical, according to (4) and (5).
       Furthermore, the denominators are always positive according to (5).
       Therefore, in the equation "angle = atan2(sin(angle), cos(angle))" the
       denominators of sin(angle) and cos(angle) can be removed,
       resulting in:
          angle = atan2(-cross(e,v1)*v2, v1*v2 - (e*v1)*(e*v2));
    */
        angle := Modelica_Math.atan2(-cross(e, v1)*v2, v1*v2 - (e*v1)*(e*v2));
        annotation (Inline=true, Documentation(info="<HTML>
<p>
A call to this function of the form
</p>
<pre>
    Real[3]                e, v1, v2;
    Modelica.SIunits.Angle angle;
  <b>equation</b>
    angle = <b>planarRotationAngle</b>(e, v1, v2);
</pre>
<p>
computes the rotation angle \"<b>angle</b>\" of a planar
rotation along unit vector <b>e</b>, rotating frame 1 into frame 2, given
the coordinate representations of a vector \"v\" in frame 1 (<b>v1</b>)
and in frame 2 (<b>v2</b>). Therefore, the result of this function
fulfills the following equation:
</p>
<pre>
    v2 = <b>resolve2</b>(<b>planarRotation</b>(e,angle), v1)
</pre>
<p>
The rotation angle is returned in the range
</p>
<pre>
    -<font face=\"Symbol\">p</font> &lt;= angle &lt;= <font face=\"Symbol\">p</font>
</pre>
<p>
This function makes the following assumptions on the input arguments
</p>
<ul>
<li> Vector <b>e</b> has length 1, i.e., length(e) = 1</li>
<li> Vector \"v\" is not parallel to <b>e</b>, i.e.,
     length(cross(e,v1)) &ne; 0</li>
</ul>
<p>
The function does not check the above assumptions. If these
assumptions are violated, a wrong result will be returned
and/or a division by zero will occur.
</p>
</HTML>"));
      end planarRotationAngle;

      function axisRotation
        "Return rotation object to rotate around one frame axis"
        extends Modelica_Icons.Function;
        input Integer axis(min=1, max=3) "Rotate around 'axis' of frame 1";
        input Modelica_SIunits.Angle angle
          "Rotation angle to rotate frame 1 into frame 2 along 'axis' of frame 1";
        output TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
      algorithm
        T := if axis == 1 then [1, 0, 0; 0, cos(angle), sin(angle); 0, -sin(angle),
           cos(angle)] else if axis == 2 then [cos(angle), 0, -sin(angle); 0, 1,
          0; sin(angle), 0, cos(angle)] else [cos(angle), sin(angle), 0; -sin(
          angle), cos(angle), 0; 0, 0, 1];
        annotation(Inline=true);
      end axisRotation;

      function axesRotations
        "Return rotation object to rotate in sequence around 3 axes"
        extends Modelica_Icons.Function;
        input Integer sequence[3](
          min={1,1,1},
          max={3,3,3}) = {1,2,3}
          "Sequence of rotations from frame 1 to frame 2 along axis sequence[i]";
        input Modelica_SIunits.Angle angles[3]={0,0,0}
          "Rotation angles around the axes defined in 'sequence'";
        output TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
      algorithm
        T := absoluteRotation(absoluteRotation(axisRotation(sequence[1], angles[1]),
           axisRotation(sequence[2], angles[2])), axisRotation(sequence[3],
          angles[3]));
        annotation(Inline=true);
      end axesRotations;

      function axesRotationsAngles
        "Return the 3 angles to rotate in sequence around 3 axes to construct the given orientation object"

        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
        input Integer sequence[3](
          min={1,1,1},
          max={3,3,3}) = {1,2,3}
          "Sequence of rotations from frame 1 to frame 2 along axis sequence[i]";
        input Modelica_SIunits.Angle guessAngle1=0
          "Select angles[1] such that |angles[1] - guessAngle1| is a minimum";
        output Modelica_SIunits.Angle angles[3]
          "Rotation angles around the axes defined in 'sequence' such that T=TransformationMatrices.axesRotation(sequence,angles); -pi < angles[i] <= pi";
      protected
        Real e1_1[3](each final unit="1")
          "First rotation axis, resolved in frame 1";
        Real e2_1a[3](each final unit="1")
          "Second rotation axis, resolved in frame 1a";
        Real e3_1[3](each final unit="1")
          "Third rotation axis, resolved in frame 1";
        Real e3_2[3](each final unit="1")
          "Third rotation axis, resolved in frame 2";
        Real A
          "Coefficient A in the equation A*cos(angles[1])+B*sin(angles[1]) = 0";
        Real B
          "Coefficient B in the equation A*cos(angles[1])+B*sin(angles[1]) = 0";
        Modelica_SIunits.Angle angle_1a "Solution 1 for angles[1]";
        Modelica_SIunits.Angle angle_1b "Solution 2 for angles[1]";
        TransformationMatrices.Orientation T_1a
          "Orientation object to rotate frame 1 into frame 1a";
      algorithm
        /* The rotation object T is constructed by:
     (1) Rotating frame 1 along axis e1 (= axis sequence[1]) with angles[1]
         arriving at frame 1a.
     (2) Rotating frame 1a along axis e2 (= axis sequence[2]) with angles[2]
         arriving at frame 1b.
     (3) Rotating frame 1b along axis e3 (= axis sequence[3]) with angles[3]
         arriving at frame 2.
     The goal is to determine angles[1:3]. This is performed in the following way:
     1. e2 and e3 are perpendicular to each other, i.e., e2*e3 = 0;
        Both vectors are resolved in frame 1 (T_ij is transformation matrix
        from frame j to frame i; e1_1*e2_1a = 0, since the vectors are
        perpendicular to each other):
           e3_1 = T_12*e3_2
                = T[sequence[3],:];
           e2_1 = T_11a*e2_1a
                = ( e1_1*transpose(e1_1) + (identity(3) - e1_1*transpose(e1_1))*cos(angles[1])
                    + skew(e1_1)*sin(angles[1]) )*e2_1a
                = e2_1a*cos(angles[1]) + cross(e1_1, e2_1a)*sin(angles[1]);
        From this follows finally an equation for angles[1]
           e2_1*e3_1 = 0
                     = (e2_1a*cos(angles[1]) + cross(e1_1, e2_1a)*sin(angles[1]))*e3_1
                     = (e2_1a*e3_1)*cos(angles[1]) + cross(e1_1, e2_1a)*e3_1*sin(angles[1])
                     = A*cos(angles[1]) + B*sin(angles[1])
                       with A = e2_1a*e3_1, B = cross(e1_1, e2_1a)*e3_1
        This equation has two solutions in the range -pi < angles[1] <= pi:
           sin(angles[1]) =  k*A/sqrt(A*A + B*B)
           cos(angles[1]) = -k*B/sqrt(A*A + B*B)
                        k = +/-1
           tan(angles[1]) = k*A/(-k*B)
        that is:
           angles[1] = atan2(k*A, -k*B)
        If A and B are both zero at the same time, there is a singular configuration
        resulting in an infinite number of solutions for angles[1] (every value
        is possible).
     2. angles[2] is determined with function TransformationMatrices.planarRotationAngle.
        This function requires to provide e_3 in frame 1a and in frame 1b:
          e3_1a = TransformationMatrices.resolve2(planarRotation(e1_1,angles[1]), e3_1);
          e3_1b = e3_2
     3. angles[3] is determined with function TransformationMatrices.planarRotationAngle.
        This function requires to provide e_2 in frame 1b and in frame 2:
          e2_1b = e2_1a
          e2_2  = TransformationMatrices.resolve2( T, TransformationMatrices.resolve1(planarRotation(e1_1,angles[1]), e2_1a));
  */
        assert(sequence[1] <> sequence[2] and sequence[2] <> sequence[3],
          "input argument 'sequence[1:3]' is not valid");
        e1_1 := if sequence[1] == 1 then {1,0,0} else if sequence[1] == 2 then {0,
          1,0} else {0,0,1};
        e2_1a := if sequence[2] == 1 then {1,0,0} else if sequence[2] == 2 then {
          0,1,0} else {0,0,1};
        e3_1 := T[sequence[3], :];
        e3_2 := if sequence[3] == 1 then {1,0,0} else if sequence[3] == 2 then {0,
          1,0} else {0,0,1};

        A := e2_1a*e3_1;
        B := cross(e1_1, e2_1a)*e3_1;
        if abs(A) <= 1.e-12 and abs(B) <= 1.e-12 then
          angles[1] := guessAngle1;
        else
          angle_1a := Modelica_Math.atan2(A, -B);
          angle_1b := Modelica_Math.atan2(-A, B);
          angles[1] := if abs(angle_1a - guessAngle1) <= abs(angle_1b -
            guessAngle1) then angle_1a else angle_1b;
        end if;
        T_1a := planarRotation(e1_1, angles[1]);
        angles[2] := TransformationMatrices.planarRotationAngle(e2_1a,
          TransformationMatrices.resolve2(T_1a, e3_1), e3_2);
        angles[3] := TransformationMatrices.planarRotationAngle(e3_2, e2_1a,
          TransformationMatrices.resolve2(T, TransformationMatrices.resolve1(T_1a,
           e2_1a)));

        annotation (Documentation(info="<HTML>
<p>
A call to this function of the form
</p>
<pre>
    TransformationMatrices.Orientation     T;
    <b>parameter</b> Integer      sequence[3] = {1,2,3};
    Modelica.SIunits.Angle angles[3];
  <b>equation</b>
    angle = <b>axesRotationAngles</b>(T, sequence);
</pre>
<p>
computes the rotation angles \"<b>angles</b>[1:3]\" to rotate frame 1
into frame 2 along axes <b>sequence</b>[1:3], given the orientation
object <b>T</b> from frame 1 to frame 2. Therefore, the result of
this function fulfills the following equation:
</p>
<pre>
    T = <b>axesRotation</b>(sequence, angles)
</pre>
<p>
The rotation angles are returned in the range
</p>
<pre>
    -<font face=\"Symbol\">p</font> &lt;= angles[i] &lt;= <font face=\"Symbol\">p</font>
</pre>
<p>
There are <b>two solutions</b> for \"angles[1]\" in this range.
Via the third argument <b>guessAngle1</b> (default = 0) the
returned solution is selected such that |angles[1] - guessAngle1| is
minimal. The orientation object T may be in a singular configuration, i.e.,
there is an infinite number of angle values leading to the same T. The returned solution is
selected by setting angles[1] = guessAngle1. Then angles[2]
and angles[3] can be uniquely determined in the above range.
</p>
<p>
Note, that input argument <b>sequence</b> has the restriction that
only values 1,2,3 can be used and that sequence[1] &ne; sequence[2]
and sequence[2] &ne; sequence[3]. Often used values are:
</p>
<pre>
  sequence = <b>{1,2,3}</b>  // Cardan angle sequence
           = <b>{3,1,3}</b>  // Euler angle sequence
           = <b>{3,2,1}</b>  // Tait-Bryan angle sequence
</pre>
</HTML>"));
      end axesRotationsAngles;

      function smallRotation
        "Return rotation angles valid for a small rotation and optionally residues that should be zero"

        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
        input Boolean withResidues=false
          "= false/true, if 'angles'/'angles and residues' are returned in phi";
        output Modelica_SIunits.Angle phi[if withResidues then 6 else 3]
          "The rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation + optionally 3 residues that should be zero";
      algorithm
        /* Planar rotation:
       Trel = [e]*transpose([e]) + (identity(3) - [e]*transpose([e]))*cos(angle) - skew(e)*sin(angle)
            = identity(3) - skew(e)*angle, for small angles
            = identity(3) - skew(e*angle)
               define phi = e*angle, then
       Trel = [1,      phi3,   -phi2;
               -phi3,     1,    phi1;
                phi2, -phi1,       1 ];
  */
        phi := if withResidues then {T[2, 3],-T[1, 3],T[1, 2],T[1, 1] - 1,T[2, 2]
           - 1,T[1, 1]*T[2, 2] - T[2, 1]*T[1, 2] - 1} else {T[2, 3],-T[1, 3],T[1,
           2]};
        annotation(Inline=true);
      end smallRotation;

      function from_nxy "Return orientation object from n_x and n_y vectors"
        extends Modelica_Icons.Function;
        input Real n_x[3](each final unit="1")
          "Vector in direction of x-axis of frame 2, resolved in frame 1";
        input Real n_y[3](each final unit="1")
          "Vector in direction of y-axis of frame 2, resolved in frame 1";
        output TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
      protected
        Real abs_n_x=sqrt(n_x*n_x);
        Real e_x[3](each final unit="1")=if abs_n_x < 1.e-10 then {1,0,0} else n_x/abs_n_x;
        Real n_z_aux[3](each final unit="1")=cross(e_x, n_y);
        Real n_y_aux[3](each final unit="1")=if n_z_aux*n_z_aux > 1.0e-6 then n_y else (if abs(e_x[1])
             > 1.0e-6 then {0,1,0} else {1,0,0});
        Real e_z_aux[3](each final unit="1")=cross(e_x, n_y_aux);
        Real e_z[3](each final unit="1")=e_z_aux/sqrt(e_z_aux*e_z_aux);
      algorithm
        T := {e_x,cross(e_z, e_x),e_z};
        annotation (Documentation(info="<html>
<p>
It is assumed that the two input vectors n_x and n_y are
resolved in frame 1 and are directed along the x and y axis
of frame 2 (i.e., n_x and n_y are orthogonal to each other)
The function returns the orientation object T to rotate from
frame 1 to frame 2.
</p>
<p>
The function is robust in the sense that it returns always
an orientation object T, even if n_y is not orthogonal to n_x.
This is performed in the following way:
</p>
<p>
If n_x and n_y are not orthogonal to each other, first a unit
vector e_y is determined that is orthogonal to n_x and is lying
in the plane spanned by n_x and n_y. If n_x and n_y are parallel
or nearly parallel to each other, a vector e_y is selected
arbitrarily such that e_x and e_y are orthogonal to each other.
</p>
</html>"));
      end from_nxy;

      function from_nxz "Return orientation object from n_x and n_z vectors"
        extends Modelica_Icons.Function;
        input Real n_x[3](each final unit="1")
          "Vector in direction of x-axis of frame 2, resolved in frame 1";
        input Real n_z[3](each final unit="1")
          "Vector in direction of z-axis of frame 2, resolved in frame 1";
        output TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
      protected
        Real abs_n_x=sqrt(n_x*n_x);
        Real e_x[3](each final unit="1")=if abs_n_x < 1.e-10 then {1,0,0} else n_x/abs_n_x;
        Real n_y_aux[3](each final unit="1")=cross(n_z, e_x);
        Real n_z_aux[3](each final unit="1")=if n_y_aux*n_y_aux > 1.0e-6 then n_z else (if abs(e_x[1])
             > 1.0e-6 then {0,0,1} else {1,0,0});
        Real e_y_aux[3](each final unit="1")=cross(n_z_aux, e_x);
        Real e_y[3](each final unit="1")=e_y_aux/sqrt(e_y_aux*e_y_aux);
      algorithm
        T := {e_x,e_y,cross(e_x, e_y)};
        annotation (Documentation(info="<html>
<p>
It is assumed that the two input vectors n_x and n_z are
resolved in frame 1 and are directed along the x and z axis
of frame 2 (i.e., n_x and n_z are orthogonal to each other)
The function returns the orientation object T to rotate from
frame 1 to frame 2.
</p>
<p>
The function is robust in the sense that it returns always
an orientation object T, even if n_z is not orthogonal to n_x.
This is performed in the following way:
</p>
<p>
If n_x and n_z are not orthogonal to each other, first a unit
vector e_z is determined that is orthogonal to n_x and is lying
in the plane spanned by n_x and n_z. If n_x and n_z are parallel
or nearly parallel to each other, a vector e_z is selected
arbitrarily such that n_x and e_z are orthogonal to each other.
</p>
</html>"));
      end from_nxz;

      function from_T
        "Return orientation object R from transformation matrix T"
        extends Modelica_Icons.Function;
        input Real T[3, 3]
          "Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)";
        output TransformationMatrices.Orientation R
          "Orientation object to rotate frame 1 into frame 2";
      algorithm
        R := T;
        annotation(Inline=true);
      end from_T;

      function from_T_inv
        "Return orientation object R from inverse transformation matrix T_inv"

        extends Modelica_Icons.Function;
        input Real T_inv[3, 3]
          "Inverse transformation matrix to transform vector from frame 2 to frame 1 (v1=T_inv*v2)";
        output TransformationMatrices.Orientation R
          "Orientation object to rotate frame 1 into frame 2";
      algorithm
        R := transpose(T_inv);
        annotation(Inline=true);
      end from_T_inv;

      function from_Q
        "Return orientation object T from quaternion orientation object Q"

        extends Modelica_Icons.Function;
        input Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2";
        output TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
      algorithm
        /*
  T := (2*Q[4]*Q[4] - 1)*identity(3) + 2*([Q[1:3]]*transpose([Q[1:3]]) - Q[4]*
    skew(Q[1:3]));
*/
        T := [2*(Q[1]*Q[1] + Q[4]*Q[4]) - 1, 2*(Q[1]*Q[2] + Q[3]*Q[4]), 2*(Q[1]*Q[
          3] - Q[2]*Q[4]); 2*(Q[2]*Q[1] - Q[3]*Q[4]), 2*(Q[2]*Q[2] + Q[4]*Q[4])
           - 1, 2*(Q[2]*Q[3] + Q[1]*Q[4]); 2*(Q[3]*Q[1] + Q[2]*Q[4]), 2*(Q[3]*Q[2]
           - Q[1]*Q[4]), 2*(Q[3]*Q[3] + Q[4]*Q[4]) - 1];
        annotation(Inline=true);
      end from_Q;

      function to_T "Return transformation matrix T from orientation object R"
        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation R
          "Orientation object to rotate frame 1 into frame 2";
        output Real T[3, 3]
          "Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)";
      algorithm
        T := R;
        annotation(Inline=true);
      end to_T;

      function to_T_inv
        "Return inverse transformation matrix T_inv from orientation object R"

        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation R
          "Orientation object to rotate frame 1 into frame 2";
        output Real T_inv[3, 3]
          "Inverse transformation matrix to transform vector from frame 2 into frame 1 (v1=T_inv*v2)";
      algorithm
        T_inv := transpose(R);
        annotation(Inline=true);
      end to_T_inv;

      function to_Q
        "Return quaternion orientation object Q from orientation object T"

        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
        input Quaternions.Orientation Q_guess=Quaternions.nullRotation()
          "Guess value for output Q (there are 2 solutions; the one closer to Q_guess is used";
        output Quaternions.Orientation Q
          "Quaternions orientation object to rotate frame 1 into frame 2";
      algorithm
        Q := Quaternions.from_T(T, Q_guess);
        annotation(Inline=true);
      end to_Q;

      function to_vector "Map rotation object into vector"
        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
        output Real vec[9] "Elements of T in one vector";
      algorithm
        vec := {T[1, 1],T[2, 1],T[3, 1],T[1, 2],T[2, 2],T[3, 2],T[1, 3],T[2, 3],T[
          3, 3]};
        annotation(Inline=true);
      end to_vector;

      function to_exy
        "Map rotation object into e_x and e_y vectors of frame 2, resolved in frame 1"

        extends Modelica_Icons.Function;
        input TransformationMatrices.Orientation T
          "Orientation object to rotate frame 1 into frame 2";
        output Real exy[3, 2]
          "= [e_x, e_y] where e_x and e_y are axes unit vectors of frame 2, resolved in frame 1";
      algorithm
        exy := [T[1, :], T[2, :]];
        annotation(Inline=true);
      end to_exy;
      annotation (Documentation(info="<HTML>
<p>
Package <b>Frames.TransformationMatrices</b> contains type definitions and
functions to transform rotational frame quantities using
transformation matrices.
</p>
<h4>Content</h4>
<p>In the table below an example is given for every function definition.
The used variables have the following declaration:
</p>
<pre>
   Orientation T, T1, T2, T_rel, T_inv;
   Real[3]     v1, v2, w1, w2, n_x, n_y, n_z, e, e_x, res_ori, phi;
   Real[6]     res_equal;
   Real        L, angle;
</pre>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><b><i>Function/type</i></b></th><th><b><i>Description</i></b></th></tr>
  <tr><td valign=\"top\"><b>Orientation T;</b></td>
      <td valign=\"top\">New type defining an orientation object that describes<br>
          the rotation of frame 1 into frame 2.
      </td>
  </tr>
  <tr><td valign=\"top\"><b>der_Orientation</b> der_T;</td>
      <td valign=\"top\">New type defining the first time derivative
         of Frames.Orientation.
      </td>
  </tr>
  <tr><td valign=\"top\">res_ori = <b>orientationConstraint</b>(T);</td>
      <td valign=\"top\">Return the constraints between the variables of an orientation object<br>
      (shall be zero).</td>
  </tr>
  <tr><td valign=\"top\">w1 = <b>angularVelocity1</b>(T, der_T);</td>
      <td valign=\"top\">Return angular velocity resolved in frame 1 from
          orientation object T<br> and its derivative der_T.
     </td>
  </tr>
  <tr><td valign=\"top\">w2 = <b>angularVelocity2</b>(T, der_T);</td>
      <td valign=\"top\">Return angular velocity resolved in frame 2 from
          orientation object T<br> and its derivative der_T.
     </td>
  </tr>
  <tr><td valign=\"top\">v1 = <b>resolve1</b>(T,v2);</td>
      <td valign=\"top\">Transform vector v2 from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td valign=\"top\">v2 = <b>resolve2</b>(T,v1);</td>
      <td valign=\"top\">Transform vector v1 from frame 1 to frame 2.
     </td>
  </tr>
  <tr><td valign=\"top\">[v1,w1] = <b>multipleResolve1</b>(T, [v2,w2]);</td>
      <td valign=\"top\">Transform several vectors from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td valign=\"top\">[v2,w2] = <b>multipleResolve2</b>(T, [v1,w1]);</td>
      <td valign=\"top\">Transform several vectors from frame 1 to frame 2.
      </td>
  </tr>
  <tr><td valign=\"top\">D1 = <b>resolveDyade1</b>(T,D2);</td>
      <td valign=\"top\">Transform second order tensor D2 from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td valign=\"top\">D2 = <b>resolveDyade2</b>(T,D1);</td>
      <td valign=\"top\">Transform second order tensor D1 from frame 1 to frame 2.
     </td>
  </tr>
  <tr><td valign=\"top\">T= <b>nullRotation</b>()</td>
      <td valign=\"top\">Return orientation object T that does not rotate a frame.
  </tr>
  <tr><td valign=\"top\">T_inv = <b>inverseRotation</b>(T);</td>
      <td valign=\"top\">Return inverse orientation object.
      </td>
  </tr>
  <tr><td valign=\"top\">T_rel = <b>relativeRotation</b>(T1,T2);</td>
      <td valign=\"top\">Return relative orientation object from two absolute
          orientation objects.
      </td>
  </tr>
  <tr><td valign=\"top\">T2 = <b>absoluteRotation</b>(T1,T_rel);</td>
      <td valign=\"top\">Return absolute orientation object from another
          absolute<br> and a relative orientation object.
      </td>
  </tr>
  <tr><td valign=\"top\">T = <b>planarRotation</b>(e, angle);</td>
      <td valign=\"top\">Return orientation object of a planar rotation.
      </td>
  </tr>
  <tr><td valign=\"top\">angle = <b>planarRotationAngle</b>(e, v1, v2);</td>
      <td valign=\"top\">Return angle of a planar rotation, given the rotation axis<br>
        and the representations of a vector in frame 1 and frame 2.
      </td>
  </tr>
  <tr><td valign=\"top\">T = <b>axisRotation</b>(i, angle);</td>
      <td valign=\"top\">Return orientation object T for rotation around axis i of frame 1.
      </td>
  </tr>
  <tr><td valign=\"top\">T = <b>axesRotations</b>(sequence, angles);</td>
      <td valign=\"top\">Return rotation object to rotate in sequence around 3 axes. Example:<br>
          T = axesRotations({1,2,3},{90,45,-90});
      </td>
  </tr>
  <tr><td valign=\"top\">angles = <b>axesRotationsAngles</b>(T, sequence);</td>
      <td valign=\"top\">Return the 3 angles to rotate in sequence around 3 axes to<br>
          construct the given orientation object.
      </td>
  </tr>
  <tr><td valign=\"top\">phi = <b>smallRotation</b>(T);</td>
      <td valign=\"top\">Return rotation angles phi valid for a small rotation.
      </td>
  </tr>
  <tr><td valign=\"top\">T = <b>from_nxy</b>(n_x, n_y);</td>
      <td valign=\"top\">Return orientation object from n_x and n_y vectors.
      </td>
  </tr>
  <tr><td valign=\"top\">T = <b>from_nxz</b>(n_x, n_z);</td>
      <td valign=\"top\">Return orientation object from n_x and n_z vectors.
      </td>
  </tr>
  <tr><td valign=\"top\">R = <b>from_T</b>(T);</td>
      <td valign=\"top\">Return orientation object R from transformation matrix T.
      </td>
  </tr>
  <tr><td valign=\"top\">R = <b>from_T_inv</b>(T_inv);</td>
      <td valign=\"top\">Return orientation object R from inverse transformation matrix T_inv.
      </td>
  </tr>
  <tr><td valign=\"top\">T = <b>from_Q</b>(Q);</td>
      <td valign=\"top\">Return orientation object T from quaternion orientation object Q.
      </td>
  </tr>
  <tr><td valign=\"top\">T = <b>to_T</b>(R);</td>
      <td valign=\"top\">Return transformation matrix T from orientation object R.
  </tr>
  <tr><td valign=\"top\">T_inv = <b>to_T_inv</b>(R);</td>
      <td valign=\"top\">Return inverse transformation matrix T_inv from orientation object R.
      </td>
  </tr>
  <tr><td valign=\"top\">Q = <b>to_Q</b>(T);</td>
      <td valign=\"top\">Return quaternion orientation object Q from orientation object T.
      </td>
  </tr>
  <tr><td valign=\"top\">exy = <b>to_exy</b>(T);</td>
      <td valign=\"top\">Return [e_x, e_y] matrix of an orientation object T, <br>
          with e_x and e_y vectors of frame 2, resolved in frame 1.
  </tr>
</table>
</HTML>"));
    end TransformationMatrices;

    package Internal
      "Internal definitions that may be removed or changed (do not use)"
      extends Modelica_Icons.InternalPackage;

      type TransformationMatrix = Real[3, 3];
      type QuaternionBase = Real[4];

      function maxWithoutEvent
        "Maximum of the input arguments, without event and function can be differentiated"
        extends Modelica_Icons.Function;
        input Real u1;
        input Real u2;
        output Real y;
      algorithm
        y := if u1 > u2 then u1 else u2;
        annotation (Inline=false,
      derivative=maxWithoutEvent_d, Documentation(info="<html>
<p>
Function <b>maxWithoutEvent</b> returns the maximum of its two
input arguments. This functions is used instead of the Modelica
built-in function \"max\" or an if-statement with \"noEvent(..)\",
in order that the function can be differentiated by providing
the first and second derivatives with additional functions.
Note, from a strict mathematical point of view the derivatives
will be wrong, since a Dirac impulses would occur in the
derivatives. For the special cases as used in the MultiBody
library, this is irrelevant and therefore the usage of the function is correct.
</p>
</html>"));
      end maxWithoutEvent;

      function maxWithoutEvent_d
        "First derivative of function maxWithoutEvent(..)"
        extends Modelica_Icons.Function;

        input Real u1;
        input Real u2;
        input Real u1_d;
        input Real u2_d;
        output Real y_d;
      algorithm
        y_d := if u1 > u2 then u1_d else u2_d;
        annotation (Inline=false, derivative(order=2) = maxWithoutEvent_dd);
      end maxWithoutEvent_d;

      function maxWithoutEvent_dd
        "First derivative of function maxWithoutEvent_d(..)"
        extends Modelica_Icons.Function;

        input Real u1;
        input Real u2;
        input Real u1_d;
        input Real u2_d;
        input Real u1_dd;
        input Real u2_dd;
        output Real y_dd;
      algorithm
        y_dd := if u1 > u2 then u1_dd else u2_dd;
        annotation(Inline=true);
      end maxWithoutEvent_dd;

      function resolve1_der "Derivative of function Frames.resolve1(..)"
        import Modelica_Mechanics_MultiBody.Frames;
        extends Modelica_Icons.Function;
        input Orientation R "Orientation object to rotate frame 1 into frame 2";
        input Real v2[3] "Vector resolved in frame 2";
        input Real v2_der[3] "= der(v2)";
        output Real v1_der[3] "Derivative of vector v resolved in frame 1";
      algorithm
        v1_der := Frames.resolve1(R, v2_der + cross(R.w, v2));
        annotation(Inline=true);
      end resolve1_der;

      function resolve2_der "Derivative of function Frames.resolve2(..)"
        import Modelica_Mechanics_MultiBody.Frames;
        extends Modelica_Icons.Function;
        input Orientation R "Orientation object to rotate frame 1 into frame 2";
        input Real v1[3] "Vector resolved in frame 1";
        input Real v1_der[3] "= der(v1)";
        output Real v2_der[3] "Derivative of vector v resolved in frame 2";
      algorithm
        v2_der := Frames.resolve2(R, v1_der) - cross(R.w, Frames.resolve2(R, v1));
        annotation(Inline=true);
      end resolve2_der;

      function resolveRelative_der
        "Derivative of function Frames.resolveRelative(..)"
        import Modelica_Mechanics_MultiBody.Frames;
        extends Modelica_Icons.Function;
        input Real v1[3] "Vector in frame 1";
        input Orientation R1
          "Orientation object to rotate frame 0 into frame 1";
        input Orientation R2
          "Orientation object to rotate frame 0 into frame 2";
        input Real v1_der[3] "= der(v1)";
        output Real v2_der[3] "Derivative of vector v resolved in frame 2";
      algorithm
        v2_der := Frames.resolveRelative(v1_der+cross(R1.w,v1), R1, R2)
                  - cross(R2.w, Frames.resolveRelative(v1, R1, R2));

        /* skew(w) = T*der(T'), -skew(w) = der(T)*T'

     v2 = T2*(T1'*v1)
     der(v2) = der(T2)*T1'*v1 + T2*der(T1')*v1 + T2*T1'*der(v1)
             = der(T2)*T2'*T2*T1'*v1 + T2*T1'*T1*der(T1')*v1 + T2*T1'*der(v1)
             = -w2 x (T2*T1'*v1) + T2*T1'*(w1 x v1) + T2*T1'*der(v1)
             = T2*T1'*(der(v1) + w1 x v1) - w2 x (T2*T1'*v1)
  */
        annotation(Inline=true);
      end resolveRelative_der;
    end Internal;

    annotation ( Documentation(info="<HTML>
<p>
Package <b>Frames</b> contains type definitions and
functions to transform rotational frame quantities. The basic idea is to
hide the actual definition of an <b>orientation</b> in this package
by providing essentially type <b>Orientation</b> together with
<b>functions</b> operating on instances of this type.
</p>
<h4>Content</h4>
<p>In the table below an example is given for every function definition.
The used variables have the following declaration:
</p>
<pre>
   Frames.Orientation R, R1, R2, R_rel, R_inv;
   Real[3,3]   T, T_inv;
   Real[3]     v1, v2, w1, w2, n_x, n_y, n_z, e, e_x, res_ori, phi;
   Real[6]     res_equal;
   Real        L, angle;
</pre>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><b><i>Function/type</i></b></th><th><b><i>Description</i></b></th></tr>
  <tr><td valign=\"top\"><b>Orientation R;</b></td>
      <td valign=\"top\">New type defining an orientation object that describes<br>
          the rotation of frame 1 into frame 2.
      </td>
  </tr>
  <tr><td valign=\"top\">res_ori = <b>orientationConstraint</b>(R);</td>
      <td valign=\"top\">Return the constraints between the variables of an orientation object<br>
      (shall be zero).</td>
  </tr>
  <tr><td valign=\"top\">w1 = <b>angularVelocity1</b>(R);</td>
      <td valign=\"top\">Return angular velocity resolved in frame 1 from
          orientation object R.
     </td>
  </tr>
  <tr><td valign=\"top\">w2 = <b>angularVelocity2</b>(R);</td>
      <td valign=\"top\">Return angular velocity resolved in frame 2 from
          orientation object R.
     </td>
  </tr>
  <tr><td valign=\"top\">v1 = <b>resolve1</b>(R,v2);</td>
      <td valign=\"top\">Transform vector v2 from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td valign=\"top\">v2 = <b>resolve2</b>(R,v1);</td>
      <td valign=\"top\">Transform vector v1 from frame 1 to frame 2.
     </td>
  </tr>
  <tr><td valign=\"top\">v2 = <b>resolveRelative</b>(v1,R1,R2);</td>
      <td valign=\"top\">Transform vector v1 from frame 1 to frame 2
          using absolute orientation objects R1 of frame 1 and R2 of frame 2.
      </td>
  </tr>
  <tr><td valign=\"top\">D1 = <b>resolveDyade1</b>(R,D2);</td>
      <td valign=\"top\">Transform second order tensor D2 from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td valign=\"top\">D2 = <b>resolveDyade2</b>(R,D1);</td>
      <td valign=\"top\">Transform second order tensor D1 from frame 1 to frame 2.
     </td>
  </tr>
  <tr><td valign=\"top\">R = <b>nullRotation</b>()</td>
      <td valign=\"top\">Return orientation object R that does not rotate a frame.
  </tr>
  <tr><td valign=\"top\">R_inv = <b>inverseRotation</b>(R);</td>
      <td valign=\"top\">Return inverse orientation object.
      </td>
  </tr>
  <tr><td valign=\"top\">R_rel = <b>relativeRotation</b>(R1,R2);</td>
      <td valign=\"top\">Return relative orientation object from two absolute
          orientation objects.
      </td>
  </tr>
  <tr><td valign=\"top\">R2 = <b>absoluteRotation</b>(R1,R_rel);</td>
      <td valign=\"top\">Return absolute orientation object from another
          absolute<br> and a relative orientation object.
      </td>
  </tr>
  <tr><td valign=\"top\">R = <b>planarRotation</b>(e, angle, der_angle);</td>
      <td valign=\"top\">Return orientation object of a planar rotation.
      </td>
  </tr>
  <tr><td valign=\"top\">angle = <b>planarRotationAngle</b>(e, v1, v2);</td>
      <td valign=\"top\">Return angle of a planar rotation, given the rotation axis<br>
        and the representations of a vector in frame 1 and frame 2.
      </td>
  </tr>
  <tr><td valign=\"top\">R = <b>axisRotation</b>(axis, angle, der_angle);</td>
      <td valign=\"top\">Return orientation object R to rotate around angle along axis of frame 1.
      </td>
  </tr>
  <tr><td valign=\"top\">R = <b>axesRotations</b>(sequence, angles, der_angles);</td>
      <td valign=\"top\">Return rotation object to rotate in sequence around 3 axes. Example:<br>
          R = axesRotations({1,2,3},{pi/2,pi/4,-pi}, zeros(3));
      </td>
  </tr>
  <tr><td valign=\"top\">angles = <b>axesRotationsAngles</b>(R, sequence);</td>
      <td valign=\"top\">Return the 3 angles to rotate in sequence around 3 axes to<br>
          construct the given orientation object.
      </td>
  </tr>
  <tr><td valign=\"top\">phi = <b>smallRotation</b>(R);</td>
      <td valign=\"top\">Return rotation angles phi valid for a small rotation R.
      </td>
  </tr>
  <tr><td valign=\"top\">R = <b>from_nxy</b>(n_x, n_y);</td>
      <td valign=\"top\">Return orientation object from n_x and n_y vectors.
      </td>
  </tr>
  <tr><td valign=\"top\">R = <b>from_nxz</b>(n_x, n_z);</td>
      <td valign=\"top\">Return orientation object from n_x and n_z vectors.
      </td>
  </tr>
  <tr><td valign=\"top\">R = <b>from_T</b>(T,w);</td>
      <td valign=\"top\">Return orientation object R from transformation matrix T and
          its angular velocity w.
      </td>
  </tr>
  <tr><td valign=\"top\">R = <b>from_T2</b>(T,der(T));</td>
      <td valign=\"top\">Return orientation object R from transformation matrix T and
          its derivative der(T).
      </td>
  </tr>
  <tr><td valign=\"top\">R = <b>from_T_inv</b>(T_inv,w);</td>
      <td valign=\"top\">Return orientation object R from inverse transformation matrix T_inv and
          its angular velocity w.
      </td>
  </tr>
  <tr><td valign=\"top\">R = <b>from_Q</b>(Q,w);</td>
      <td valign=\"top\">Return orientation object R from quaternion orientation object Q
          and its angular velocity w.
      </td>
  </tr>
  <tr><td valign=\"top\">T = <b>to_T</b>(R);</td>
      <td valign=\"top\">Return transformation matrix T from orientation object R.
  </tr>
  <tr><td valign=\"top\">T_inv = <b>to_T_inv</b>(R);</td>
      <td valign=\"top\">Return inverse transformation matrix T_inv from orientation object R.
      </td>
  </tr>
  <tr><td valign=\"top\">Q = <b>to_Q</b>(R);</td>
      <td valign=\"top\">Return quaternion orientation object Q from orientation object R.
      </td>
  </tr>
  <tr><td valign=\"top\">exy = <b>to_exy</b>(R);</td>
      <td valign=\"top\">Return [e_x, e_y] matrix of an orientation object R, <br>
          with e_x and e_y vectors of frame 2, resolved in frame 1.
  </tr>
  <tr><td valign=\"top\">L = <b>length</b>(n_x);</td>
      <td valign=\"top\">Return length L of a vector n_x.
      </td>
  </tr>
  <tr><td valign=\"top\">e_x = <b>normalize</b>(n_x);</td>
      <td valign=\"top\">Return normalized vector e_x of n_x such that length of e_x is one.
      </td>
  </tr>
  <tr><td valign=\"top\">e = <b>axis</b>(i);</td>
      <td valign=\"top\">Return unit vector e directed along axis i
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.Quaternions\">Quaternions</a></td>
      <td valign=\"top\"><b>Package</b> with functions to transform rotational frame quantities based
          on quaternions (also called Euler parameters).
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.TransformationMatrices\">TransformationMatrices</a></td>
      <td valign=\"top\"><b>Package</b> with functions to transform rotational frame quantities based
          on transformation matrices.
      </td>
  </tr>
</table>
</HTML>"),   Icon(graphics={
          Line(points={{-2,-18},{80,-60}}, color={95,95,95}),
          Line(points={{-2,-18},{-2,80}}, color={95,95,95}),
          Line(points={{-78,-56},{-2,-18}}, color={95,95,95})}));
  end Frames;

  package Interfaces
    "Connectors and partial models for 3-dim. mechanical components"

    extends Modelica_Icons.InterfacesPackage;

    connector Frame
      "Coordinate system fixed to the component with one cut-force and cut-torque (no icon)"

      Modelica_SIunits.Position r_0[3]
        "Position vector from world frame to the connector frame origin, resolved in world frame";
      Frames.Orientation R
        "Orientation object to rotate the world frame into the connector frame";
      flow Modelica_SIunits.Force f[3] "Cut-force resolved in connector frame"
        annotation (unassignedMessage="All Forces cannot be uniquely calculated.
The reason could be that the mechanism contains
a planar loop or that joints constrain the
same motion. For planar loops, use for one
revolute joint per loop the joint
Joints.RevolutePlanarLoopConstraint instead of
Joints.Revolute.");
      flow Modelica_SIunits.Torque t[3]
        "Cut-torque resolved in connector frame";
      annotation (Documentation(info="<html>
<p>
Basic definition of a coordinate system that is fixed to a mechanical
component. In the origin of the coordinate system the cut-force
and the cut-torque is acting. This component has no icon definition
and is only used by inheritance from frame connectors to define
different icons.
</p>
</html>"));
    end Frame;

    connector Frame_a
      "Coordinate system fixed to the component with one cut-force and cut-torque (filled rectangular icon)"
      extends Frame;

      annotation (defaultComponentName="frame_a",
       Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            initialScale=0.16), graphics={Rectangle(
              extent={{-10,10},{10,-10}},
              lineColor={95,95,95},
              lineThickness=0.5), Rectangle(
              extent={{-30,100},{30,-100}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid)}),
       Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            initialScale=0.16), graphics={Text(
              extent={{-140,-50},{140,-88}},
              lineColor={0,0,0},
              textString="%name"), Rectangle(
              extent={{-12,40},{12,-40}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
<p>
Basic definition of a coordinate system that is fixed to a mechanical
component. In the origin of the coordinate system the cut-force
and the cut-torque is acting.
This component has a filled rectangular icon.
</p>
</html>"));
    end Frame_a;

    connector Frame_b
      "Coordinate system fixed to the component with one cut-force and cut-torque (non-filled rectangular icon)"
      extends Frame;

      annotation (defaultComponentName="frame_b",
       Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            initialScale=0.16), graphics={Rectangle(
              extent={{-10,10},{10,-10}},
              lineColor={95,95,95},
              lineThickness=0.5), Rectangle(
              extent={{-30,100},{30,-100}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
       Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            initialScale=0.16), graphics={Text(
              extent={{-140,-50},{140,-88}},
              lineColor={0,0,0},
              textString="%name"), Rectangle(
              extent={{-12,40},{12,-40}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
<p>
Basic definition of a coordinate system that is fixed to a mechanical
component. In the origin of the coordinate system the cut-force
and the cut-torque is acting. This component has a non-filled rectangular icon.
</p>
</html>"));
    end Frame_b;

  connector Frame_resolve "Coordinate system fixed to the component used to express in which
coordinate system a vector is resolved (non-filled rectangular icon)"
    extends Frame;

    annotation (defaultComponentName="frame_resolve",
      Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            initialScale=0.16), graphics={Rectangle(
              extent={{-10,10},{10,-10}},
              lineColor={95,95,95},
              pattern=LinePattern.Dot), Rectangle(
              extent={{-30,100},{30,-100}},
              lineColor={95,95,95},
              pattern=LinePattern.Dot,
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
      Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            initialScale=0.16), graphics={Text(
              extent={{-140,-50},{140,-88}},
              lineColor={0,0,0},
              textString="%name"), Rectangle(
              extent={{-12,40},{12,-40}},
              lineColor={95,95,95},
              pattern=LinePattern.Dot,
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
      Documentation(info="<html>
<p>
Basic definition of a coordinate system that is fixed to a mechanical
component. In the origin of the coordinate system the cut-force
and the cut-torque is acting. This coordinate system is used to
express in which coordinate system a vector is resolved.
A component that uses a Frame_resolve connector has to set the
cut-force and cut-torque of this frame to zero. When connecting
from a Frame_resolve connector to another frame connector,
by default the connecting line has line style \"dotted\".
This component has a non-filled rectangular icon.
</p>
</html>"));
  end Frame_resolve;

    connector FlangeWithBearing
      "Connector consisting of 1-dim. rotational flange and its bearing frame"
      parameter Boolean includeBearingConnector=false
        "= true, if bearing frame connector is present, otherwise not present";
      Modelica_Mechanics_Rotational.Interfaces.Flange_a flange
        "1-dim. rotational flange";
      Modelica_Mechanics_MultiBody.Interfaces.Frame bearingFrame if
        includeBearingConnector
        "3-dim. frame in which the 1-dim. shaft is mounted";

      annotation (
        defaultComponentName="flange",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-20,1},{20,-1}},
              lineColor={135,135,135},
              lineThickness=0.5),
            Rectangle(
              extent={{-100,100},{100,-100}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-100,25},{100,-25}},
              lineColor={64,64,64},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={192,192,192}),
            Line(points={{-80,60},{80,60}}, color={0,0,0}),
            Line(points={{-80,-60},{80,-60}}, color={0,0,0}),
            Line(points={{0,100},{0,60}}, color={0,0,0}),
            Line(points={{0,-60},{0,-100}}, color={0,0,0}),
            Rectangle(extent={{-100,100},{100,-100}}, lineColor={135,135,135}),
            Rectangle(extent={{-100,25},{100,-25}}, lineColor={64,64,64})}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(
              points={{-50,-40},{50,-40}},
              color={0,0,0},
              thickness=0.5),
            Line(
              points={{-50,40},{50,40}},
              color={0,0,0},
              thickness=0.5),
            Text(
              extent={{-158,-66},{158,-124}},
              lineColor={0,0,0},
              lineThickness=0.5,
              textString="%name"),
            Rectangle(
              extent={{-60,60},{60,-60}},
              lineColor={255,255,255},
              lineThickness=0.5,
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-60,15},{60,-15}},
              lineColor={64,64,64},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={192,192,192}),
            Line(points={{0,60},{0,40}}, color={0,0,0}),
            Line(points={{0,-40},{0,-60}}, color={0,0,0}),
            Line(points={{-50,40},{50,40}}, color={0,0,0}),
            Line(points={{-50,-40},{50,-40}}, color={0,0,0}),
            Rectangle(extent={{-60,60},{60,-60}}, lineColor={135,135,135}),
            Rectangle(extent={{-60,15},{60,-15}}, lineColor={64,64,64})}),
        Documentation(info="<html>
<p>
This hierarchical connector models a 1-dim. rotational flange
connector and its optional bearing defined by a 3-dim. frame connector.
If a connection to the subconnectors should be clearly visible,
connect first an  instance of
<a href=\"modelica://Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearingAdaptor\">FlangeWithBearingAdaptor</a>
to the FlangeWithBearing connector.
</p>
</html>"));

    end FlangeWithBearing;

    model FlangeWithBearingAdaptor
      "Adaptor to allow direct connections to the sub-connectors of FlangeWithBearing"
      parameter Boolean includeBearingConnector=false
        "= true, if bearing frame connector is present, otherwise not present";

      Modelica_Mechanics_MultiBody.Interfaces.FlangeWithBearing flangeAndFrame(
          includeBearingConnector=includeBearingConnector)
        "Compound connector consisting of 1-dim. rotational flange and 3-dim. frame mounting"
        annotation (Placement(transformation(extent={{-130,-30},{-70,30}},
              rotation=0)));
      Modelica_Mechanics_Rotational.Interfaces.Flange_b flange
        "1-dim. rotational flange"
        annotation (Placement(transformation(extent={{-10,-10},{10,10}}, rotation=
               0)));
      Frame_a frame if includeBearingConnector
        "3-dim. frame in which the 1-dim. shaft is mounted"             annotation (Placement(
            transformation(
            origin={0,-100},
            extent={{-16,-16},{16,16}},
            rotation=90)));

    equation
      connect(flange, flangeAndFrame.flange) annotation (Line(
          points={{0,0},{-100,0}},
          color={0,0,0}));
      connect(frame, flangeAndFrame.bearingFrame) annotation (Line(
          points={{0,-100},{0,-40},{-100,-40},{-100,0}},
          color={0,0,0},
          thickness=0.5));
      annotation (
        defaultComponentName="adaptor",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-100,30},{20,-100}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-100,-10},{-100,-40},{0,-40},{0,-100}},
              color={0,0,0},
              thickness=0.5),
            Line(points={{-90,0},{0,0}}, color={0,0,0}),
            Text(
              extent={{-216,88},{86,36}},
              lineColor={0,0,255},
              textString="%name")}),
        Documentation(info="<html>
<p>
Adaptor object to make a more visible connection to the flange and frame
subconnectors of a
<a href=\"modelica://Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing\">FlangeWithBearing</a>
connector.
</p>
</html>"));
    end FlangeWithBearingAdaptor;

    partial model PartialTwoFrames
      "Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected"

      Interfaces.Frame_a frame_a
        "Coordinate system fixed to the component with one cut-force and cut-torque"
                                 annotation (Placement(transformation(extent={{
                -116,-16},{-84,16}}, rotation=0)));
      Interfaces.Frame_b frame_b
        "Coordinate system fixed to the component with one cut-force and cut-torque"
                                 annotation (Placement(transformation(extent={{84,
                -16},{116,16}}, rotation=0)));
    protected
      outer Modelica_Mechanics_MultiBody.World world;
    equation
      assert(cardinality(frame_a) > 0,
        "Connector frame_a of component is not connected");
      assert(cardinality(frame_b) > 0,
        "Connector frame_b of component is not connected");
      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Text(
              extent={{-136,-25},{-100,-50}},
              lineColor={128,128,128},
              textString="a"), Text(
              extent={{100,-25},{136,-50}},
              lineColor={128,128,128},
              textString="b")}),
        Documentation(info="<HTML>
<p>
This partial model provides two frame connectors, access to the world
object and an assert to check that both frame connectors are connected.
Therefore, inherit from this partial model if the two frame connectors are
needed and if the two frame connectors should be connected for a correct model.
</p>
</HTML>"));
    end PartialTwoFrames;

    partial model PartialTwoFramesDoubleSize
      "Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected (default icon size is factor 2 larger as usual)"

      Interfaces.Frame_a frame_a
        "Coordinate system fixed to the component with one cut-force and cut-torque"
       annotation (Placement(transformation(extent={{-108,-8},{-92,8}})));
      Interfaces.Frame_b frame_b
        "Coordinate system fixed to the component with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{92,-8},{108,8}})));

    protected
      outer Modelica_Mechanics_MultiBody.World world;
    equation
      assert(cardinality(frame_a) > 0,
        "Connector frame_a of component is not connected");
      assert(cardinality(frame_b) > 0,
        "Connector frame_b of component is not connected");
      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            initialScale=0.2), graphics={Text(
              extent={{-117,-13},{-106,-23}},
              lineColor={128,128,128},
              textString="a"), Text(
              extent={{110,-15},{122,-25}},
              lineColor={128,128,128},
              textString="b")}),
        Documentation(info="<HTML>
<p>
This partial model provides two frame connectors, access to the world
object and an assert to check that both frame connectors are connected.
Therefore, inherit from this partial model if the two frame connectors are
needed and if the two frame connectors should be connected for a correct model.
</p>
<p>
When dragging \"PartialTwoFrames\", the default size is a factor of two
larger as usual. This partial model is used by the Joint.Assemblies
joint aggregation models.
</p>
</HTML>"));
    end PartialTwoFramesDoubleSize;

    partial model PartialOneFrame_a
      "Base model for components providing one frame_a connector + outer world + assert to guarantee that the component is connected"

      Interfaces.Frame_a frame_a
        "Coordinate system fixed to the component with one cut-force and cut-torque"
                                                                                                            annotation (Placement(
            transformation(extent={{-116,-16},{-84,16}}, rotation=0)));
    protected
      outer Modelica_Mechanics_MultiBody.World world;
    equation
      assert(cardinality(frame_a) > 0,
        "Connector frame_a of component is not connected");
      annotation (                      Documentation(info="<html>
<p>
This partial model provides one frame_a connector, access to the world
object and an assert to check that the frame_a connector is connected.
Therefore, inherit from this partial model if the frame_a connector is
needed and if this connector should be connected for a correct model.
</p>
</html>"));
    end PartialOneFrame_a;

    partial model PartialOneFrame_b
      "Base model for components providing one frame_b connector + outer world + assert to guarantee that the component is connected"

      Interfaces.Frame_b frame_b
        "Coordinate system fixed to the component with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{84,-16},{116,16}}, rotation=
               0)));
    protected
      outer Modelica_Mechanics_MultiBody.World world;
    equation
      assert(cardinality(frame_b) > 0,
        "Connector frame_b of component is not connected");
      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Text(
              extent={{94,-20},{130,-45}},
              lineColor={128,128,128},
              textString="b")}),
        Documentation(info="<HTML>
<p>
This partial model provides one frame_b connector, access to the world
object and an assert to check that the frame_b connector is connected.
Therefore, inherit from this partial model if the frame_b connector is
needed and if this connector should be connected for a correct model.
</p>
</HTML>"));
    end PartialOneFrame_b;

    partial model PartialElementaryJoint
      "Base model for elementary joints (has two frames + outer world + assert to guarantee that the joint is connected)"

      Interfaces.Frame_a frame_a
        "Coordinate system fixed to the joint with one cut-force and cut-torque"
                                 annotation (Placement(transformation(extent={{
                -116,-16},{-84,16}}, rotation=0)));
      Interfaces.Frame_b frame_b
        "Coordinate system fixed to the joint with one cut-force and cut-torque"
                                 annotation (Placement(transformation(extent={{84,
                -16},{116,16}}, rotation=0)));

    protected
      outer Modelica_Mechanics_MultiBody.World world;
    equation
      Connections.branch(frame_a.R, frame_b.R);
      assert(cardinality(frame_a) > 0,
        "Connector frame_a of joint object is not connected");
      assert(cardinality(frame_b) > 0,
        "Connector frame_b of joint object is not connected");
      annotation (Documentation(info="<HTML>
<p>
All <b>elementary joints</b> should inherit from this base model, i.e.,
joints that are directly defined by equations, provided they compute
either the rotation object of frame_b from the rotation object of frame_a
and from relative quantities (or vice versa), or there is a constraint
equation between the rotation objects of the two frames.
In other cases, a joint object should inherit from
<b>Interfaces.PartialTwoFrames</b> (e.g., joint Spherical, because there
is no constraint between the rotation objects of frame_a and frame_b
or joint Cylindrical because it is not an elementary joint).
</p>
<p>
This partial model provides two frame connectors, a \"Connections.branch\"
between frame_a and frame_b, access to the world
object and an assert to check that both frame connectors are connected.
</p>
</html>"));
    end PartialElementaryJoint;

    partial model PartialForce
      "Base model for force elements (provide frame_b.f and frame_b.t in subclasses)"

      Interfaces.Frame_a frame_a
        "Coordinate system fixed to the joint with one cut-force and cut-torque"
                                 annotation (Placement(transformation(extent={{
                -116,-16},{-84,16}}, rotation=0)));
      Interfaces.Frame_b frame_b
        "Coordinate system fixed to the joint with one cut-force and cut-torque"
                                 annotation (Placement(transformation(extent={{84,
                -16},{116,16}}, rotation=0)));

      Modelica_SIunits.Position r_rel_b[3]
        "Position vector from origin of frame_a to origin of frame_b, resolved in frame_b";
    protected
      outer Modelica_Mechanics_MultiBody.World world;
    equation
      assert(cardinality(frame_a) > 0,
        "Connector frame_a of force object is not connected");
      assert(cardinality(frame_b) > 0,
        "Connector frame_b of force object is not connected");

      /* Determine relative position vector
     between frame_a and frame_b
  */
      r_rel_b = Frames.resolve2(frame_b.R, frame_b.r_0 - frame_a.r_0);

      /* Force and torque balance between frame_a and frame_b */
      zeros(3) = frame_a.f + Frames.resolveRelative(frame_b.f, frame_b.R, frame_a.
         R);
      zeros(3) = frame_a.t + Frames.resolveRelative(frame_b.t + cross(r_rel_b,
        frame_b.f), frame_b.R, frame_a.R);
      annotation (Documentation(info="<HTML>
<p>
All <b>3-dimensional force</b> and <b>torque elements</b>
should be based on this superclass.
This model defines frame_a and frame_b, computes the relative
translation and rotation between the two frames and calculates
the cut-force and cut-torque at frame_a by a force and torque
balance from the cut-force and cut-torque at frame_b.
As a result, in a subclass, only the relationship between
the cut-force and cut-torque at frame_b has to be defined as
a function of the following relative quantities:
</p>
<pre>
  r_rel_b[3]: Position vector from origin of frame_a to origin
              of frame_b, resolved in frame_b
  R_rel     : Relative orientation object to rotate from frame_a to frame_b
</pre>
<p>
Assume that force f = {100,0,0} should be applied on the body
to which this force element is attached at frame_b, then
the definition should be:
</p>
<pre>
   <b>model</b> Constant_x_Force
      extends Modelica.Mechanics.MultiBody.Interfaces.PartialForce;
   <b>equation</b>
      frame_b.f = {-100, 0, 0};
      frame_b.t = zeros(3);
   <b>end</b> Constant_x_Force;
</pre>
<p>
Note, that frame_b.f and frame_b.t are flow variables and therefore
the negative value of frame_b.f and frame_b.t is acting at the part
to which this force element is connected.
</p>
</HTML>"),   Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                {100,100}}), graphics={Text(
              extent={{-136,42},{-100,17}},
              lineColor={128,128,128},
              textString="a"), Text(
              extent={{102,44},{138,19}},
              lineColor={128,128,128},
              textString="b")}));
    end PartialForce;

    partial model PartialLineForce "Base model for line force elements"

      parameter Modelica_SIunits.Position s_small=1.E-6
        "Prevent zero-division if relative distance s=0"
        annotation (Dialog(tab="Advanced"));
      parameter Boolean fixedRotationAtFrame_a=false
        "=true, if rotation frame_a.R is fixed (to directly connect line forces)"
         annotation (Evaluate=true, choices(checkBox=true),Dialog(tab="Advanced", group="If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces"));
      parameter Boolean fixedRotationAtFrame_b=false
        "=true, if rotation frame_b.R is fixed (to directly connect line forces)"
         annotation (Evaluate=true, choices(checkBox=true),Dialog(tab="Advanced", group="If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces"));

      Interfaces.Frame_a frame_a
        "Coordinate system fixed to the force element with one cut-force and cut-torque"
                                 annotation (Placement(transformation(extent={{
                -116,-16},{-84,16}}, rotation=0)));
      Interfaces.Frame_b frame_b
        "Coordinate system fixed to the force element with one cut-force and cut-torque"
                                 annotation (Placement(transformation(extent={{84,
                -16},{116,16}}, rotation=0)));
      Modelica_SIunits.Force f
        "Line force acting on frame_a and on frame_b (positive, if acting on frame_b and directed from frame_a to frame_b)";
      Modelica_SIunits.Position s
        "(Guarded) distance between the origin of frame_a and the origin of frame_b (>= s_small))";
      Real e_a[3](each final unit="1")
        "Unit vector on the line connecting the origin of frame_a with the origin of frame_b resolved in frame_a (directed from frame_a to frame_b)";
      Modelica_SIunits.Position r_rel_a[3]
        "Position vector from origin of frame_a to origin of frame_b, resolved in frame_a";
    protected
      outer Modelica_Mechanics_MultiBody.World world;
    equation
      assert(cardinality(frame_a) > 0,
        "Connector frame_a of line force object is not connected");
      assert(cardinality(frame_b) > 0,
        "Connector frame_b of line force object is not connected");

      // Determine distance s and n_a
      r_rel_a = Frames.resolve2(frame_a.R, frame_b.r_0 - frame_a.r_0);
      s = noEvent(max(Modelica_Math.Vectors.length(
                                    r_rel_a), s_small));
      e_a = r_rel_a/s;

      /* Determine forces and torques at frame_a and frame_b */
      frame_a.f = -e_a*f;
      frame_b.f = -Frames.resolve2(Frames.relativeRotation(frame_a.R, frame_b.R),
         frame_a.f);

      // Additional equations, if direct connections of line forces
      if fixedRotationAtFrame_a then
        Connections.root(frame_a.R);
        frame_a.R = Frames.nullRotation();
      else
        frame_a.t = zeros(3);
      end if;

      if fixedRotationAtFrame_b then
        Connections.root(frame_b.R);
        frame_b.R = Frames.nullRotation();
      else
        frame_b.t = zeros(3);
      end if;

      annotation (Documentation(info="<HTML>
<p>
All <b>line force</b> elements should be based on this base model.
This model defines frame_a and frame_b, computes the relative
distance <b>s</b> and provides the force and torque
balance of the cut-forces and cut-torques at frame_a and
frame_b, respectively. In sub-models, only the line force <b>f</b>,
acting at frame_b on the line from frame_a to frame_b, as a function
of the relative distance <b>s</b> and its derivative <b>der</b>(<b>s</b>)
has to be defined. Example:
</p>
<pre>
   <b>model</b> Spring
      <b>parameter</b> Real c \"spring constant\",
      <b>parameter</b> Real s_unstretched \"unstretched spring length\";
      <b>extends</b> Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce;
   <b>equation</b>
      f = c*(s-s_unstretched);
   <b>end</b> Spring;
</pre>
</HTML>"),   Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                {100,100}}), graphics={Text(
              extent={{-136,-44},{-100,-19}},
              lineColor={128,128,128},
              textString="a"), Text(
              extent={{100,-42},{136,-17}},
              lineColor={128,128,128},
              textString="b"),
            Ellipse(visible=fixedRotationAtFrame_a, extent={{-70,30},{-130,-30}}, lineColor={255,0,0}),
            Text(visible=fixedRotationAtFrame_a,
              extent={{-62,50},{-140,30}},
              lineColor={255,0,0},
              textString="R=0"),
            Ellipse(visible=fixedRotationAtFrame_b, extent={{70,30},{130,-30}}, lineColor={255,0,0}),
            Text(visible=fixedRotationAtFrame_b,
              extent={{62,50},{140,30}},
              lineColor={255,0,0},
              textString="R=0")}));
    end PartialLineForce;

    partial model PartialAbsoluteSensor
      "Base model to measure an absolute frame variable"
      extends Modelica_Icons.RotationalSensor;
      parameter Integer n_out = 1 "Number of output signals";
      Interfaces.Frame_a frame_a
        "Coordinate system from which absolute quantities are provided as output signals"
        annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
              rotation=0)));

      Modelica_Blocks.Interfaces.RealOutput y[n_out]
        "Measured data as signal vector"
        annotation (Placement(transformation(extent={{100,-10},{120,10}},
              rotation=0)));
    protected
      outer Modelica_Mechanics_MultiBody.World world;

    equation
      assert(cardinality(frame_a) > 0,
        "Connector frame_a of absolute sensor object is not connected");
      annotation (
        Documentation(info="<html>
<p>
This is the base class of a 3-dim. mechanics component with one frame and one
output port in order to measure an absolute quantity in the frame connector
and to provide the measured signal as output for further processing
with the blocks of package Modelica.Blocks.
</p>
</html>"),     Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{-70,0},{-100,0}}, color={0,0,0}),
            Line(points={{70,0},{100,0}}, color={0,0,255}),
            Text(
              extent={{-132,-125},{131,-79}},
              textString="%name",
              lineColor={0,0,255})}));
    end PartialAbsoluteSensor;

    partial model PartialRelativeSensor
      "Base model to measure a relative variable between two frames"
      extends Modelica_Icons.RotationalSensor;
      parameter Integer n_out = 1 "Number of output signals";
      Interfaces.Frame_a frame_a "Coordinate system a" annotation (Placement(
            transformation(extent={{-116,-16},{-84,16}}, rotation=0)));
      Interfaces.Frame_b frame_b "Coordinate system b" annotation (Placement(
            transformation(extent={{84,-16},{116,16}}, rotation=0)));

      Modelica_Blocks.Interfaces.RealOutput y[n_out]
        "Measured data as signal vector"
        annotation (Placement(transformation(
            origin={0,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));
    protected
      outer Modelica_Mechanics_MultiBody.World world;

    equation
      assert(cardinality(frame_a) > 0,
        "Connector frame_a of relative sensor object is not connected");
      assert(cardinality(frame_b) > 0,
        "Connector frame_b of relative sensor object is not connected");

      annotation (
        Documentation(info="<html>
<p>
This is a base class for 3-dim. mechanical components with two frames
and one output port in order to measure relative quantities
between the two frames or the cut-forces/torques in the frame and
to provide the measured signals as output for further processing
with the blocks of package Modelica.Blocks.
</p>
</html>"),     Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{-70,0},{-101,0}}, color={0,0,0}),
            Line(points={{70,0},{100,0}}, color={0,0,0}),
            Line(points={{0,-100},{0,-70}}, color={0,0,127}),
            Text(
              extent={{-132,76},{129,124}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{-118,52},{-82,27}},
              lineColor={128,128,128},
              textString="a"),
            Text(
              extent={{85,53},{121,28}},
              lineColor={128,128,128},
              textString="b")}));
    end PartialRelativeSensor;

    partial model PartialVisualizer
      "Base model for visualizers (has a frame_a on the left side + outer world + assert to guarantee that the component is connected)"

      Interfaces.Frame_a frame_a
        "Coordinate system in which visualization data is resolved"                          annotation (Placement(
            transformation(extent={{-116,-16},{-84,16}}, rotation=0)));
    protected
      outer Modelica_Mechanics_MultiBody.World world;
    equation
      assert(cardinality(frame_a) > 0,
        "Connector frame_a of visualizer object is not connected");
      annotation (Documentation(info="<html>
<p>
This partial model provides one frame_a connector, access to the world
object and an assert to check that the frame_a connector is connected.
It is used by inheritance from all visualizer objects.
</p>
</html>"));
    end PartialVisualizer;

    model ZeroPosition
      "Set absolute position vector of frame_resolve to a zero vector and the orientation object to a null rotation"
       extends Modelica_Blocks.Icons.Block;
      Interfaces.Frame_resolve frame_resolve
        annotation (Placement(transformation(extent={{-116,-16},{-84,16}})));
    equation
      Connections.root(frame_resolve.R);
      frame_resolve.R = Modelica_Mechanics_MultiBody.Frames.nullRotation();
      frame_resolve.r_0 = zeros(3);
      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                -100},{100,100}}), graphics={Text(
              extent={{-74,24},{80,-20}},
              lineColor={0,0,0},
              textString="r = 0")}));
    end ZeroPosition;

    partial function partialGravityAcceleration
      extends Modelica_Icons.Function;
       input Modelica_SIunits.Position r[3]
        "Position vector from world frame to actual point, resolved in world frame";
       output Modelica_SIunits.Acceleration gravity[3]
        "Gravity acceleration at position r, resolved in world frame";
      annotation (Documentation(info="<html>
<p>
This partial function defines the interface to the gravity function
used in the World object. All gravity field functions must inherit
from this function. The input to the function is the absolute position
vector of a point in the gravity field, whereas the output is the
gravity acceleration at this point, resolved in the world frame.
</p>
</html>"));
    end partialGravityAcceleration;

    partial function partialSurfaceCharacteristic
      extends Modelica_Icons.Function;
       input Integer nu "Number of points in u-Dimension";
       input Integer nv "Number of points in v-Dimension";
       input Boolean multiColoredSurface=false
        "= true: Color is defined for each surface point";
       output Modelica_SIunits.Position X[nu,nv]
        "[nu,nv] positions of points in x-Direction resolved in surface frame";
       output Modelica_SIunits.Position Y[nu,nv]
        "[nu,nv] positions of points in y-Direction resolved in surface frame";
       output Modelica_SIunits.Position Z[nu,nv]
        "[nu,nv] positions of points in z-Direction resolved in surface frame";
       output Real C[if multiColoredSurface then nu else 0,
                     if multiColoredSurface then nv else 0,3]
        "[nu,nv,3] Color array, defining the color for each surface point";
    end partialSurfaceCharacteristic;

    partial function partialColorMap
      "Interface for a function returning a color map"
      extends Modelica_Icons.Function;
      input Integer n_colors=64 "Number of colors in the color map";
      output Real colorMap[n_colors,3] "Color map to map a scalar to a color";
      annotation (Documentation(info="<html>
<p>
This partial function defines the interface of a function that returns
a color map. Predefined color map functions are defined in package
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps\">Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps</a>.
</p>
</html>"));
    end partialColorMap;

    annotation ( Documentation(info="<html>
<p>
This package contains connectors and partial models (i.e., models
that are only used to build other models) of the MultiBody library.
</p>
</html>"));
  end Interfaces;

  package Joints "Components that constrain the motion between two frames"
    extends Modelica_Icons.Package;

    model Prismatic
      "Prismatic joint (1 translational degree-of-freedom, 2 potential states, optional axis flange)"

      extends Modelica_Mechanics_MultiBody.Interfaces.PartialElementaryJoint;
      Modelica_Mechanics_Translational.Interfaces.Flange_a axis if useAxisFlange
        "1-dim. translational flange that drives the joint"
        annotation (Placement(transformation(extent={{90,50},{70,70}}, rotation=0)));
      Modelica_Mechanics_Translational.Interfaces.Flange_b support if useAxisFlange
        "1-dim. translational flange of the drive drive support (assumed to be fixed in the world frame, NOT in the joint)"
        annotation (Placement(transformation(extent={{-30,50},{-50,70}}, rotation=
               0)));

      parameter Boolean useAxisFlange=false "= true, if axis flange is enabled"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Modelica_Mechanics_MultiBody.Types.Axis n={1,0,0}
        "Axis of translation resolved in frame_a (= same as in frame_b)"
        annotation (Evaluate=true);
      constant Modelica_SIunits.Position s_offset=0
        "Relative distance offset (distance between frame_a and frame_b = s_offset + s)"
        annotation (Evaluate=false);
      parameter Types.Axis boxWidthDirection={0,1,0}
        "Vector in width direction of box, resolved in frame_a"
        annotation (Evaluate=true, Dialog(tab="Animation", group=
              "if animation = true", enable=animation));
      parameter Modelica_SIunits.Distance boxWidth=world.defaultJointWidth
        "Width of prismatic joint box" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance boxHeight=boxWidth
        "Height of prismatic joint box" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color boxColor=Types.Defaults.JointColor
        "Color of prismatic joint box"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
      parameter StateSelect stateSelect=StateSelect.prefer
        "Priority to use distance s and v=der(s) as states" annotation(Dialog(tab="Advanced"));
      final parameter Real e[3](each final unit="1")=
         Modelica_Math.Vectors.normalizeWithAssert(n)
        "Unit vector in direction of prismatic axis n";

      Modelica_SIunits.Position s(start=0, final stateSelect=stateSelect)
        "Relative distance between frame_a and frame_b" annotation (
          unassignedMessage="
The relative distance s of a prismatic joint cannot be determined.
Possible reasons:
- A non-zero mass might be missing on either side of the parts
  connected to the prismatic joint.
- Too many StateSelect.always are defined and the model
  has less degrees of freedom as specified with this setting
  (remove all StateSelect.always settings).
");

      Modelica_SIunits.Velocity v(start=0, final stateSelect=stateSelect)
        "First derivative of s (relative velocity)";
      Modelica_SIunits.Acceleration a(start=0)
        "Second derivative of s (relative acceleration)";
      Modelica_SIunits.Force f "Actuation force in direction of joint axis";

    protected
      Visualizers.Advanced.Shape box(
        shapeType="box",
        color=boxColor,
        specularCoefficient=specularCoefficient,
        length=if noEvent(abs(s + s_offset) > 1.e-6) then s + s_offset else 1.e-6,
        width=boxWidth,
        height=boxHeight,
        lengthDirection=e,
        widthDirection=boxWidthDirection,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;
      Modelica_Mechanics_Translational.Components.Fixed fixed
        annotation (Placement(transformation(extent={{-50,30},{-30,50}})));
      Modelica_Mechanics_Translational.Interfaces.InternalSupport internalAxis(
          f=f) annotation (Placement(transformation(extent={{70,50},{90,30}})));
      Modelica_Mechanics_Translational.Sources.ConstantForce constantForce(
          f_constant=0) if                                               not useAxisFlange
        annotation (Placement(transformation(extent={{40,30},{60,50}})));
    equation
      v = der(s);
      a = der(v);

      // relationships between kinematic quantities of frame_a and of frame_b
      frame_b.r_0 = frame_a.r_0 + Frames.resolve1(frame_a.R, e*(s_offset + s));
      frame_b.R = frame_a.R;

      // Force and torque balance
      zeros(3) = frame_a.f + frame_b.f;
      zeros(3) = frame_a.t + frame_b.t + cross(e*(s_offset + s), frame_b.f);

      // d'Alemberts principle
      f = -e*frame_b.f;

      // Connection to internal connectors
      s = internalAxis.s;

      connect(fixed.flange, support) annotation (Line(
          points={{-40,40},{-40,60}},
          color={0,127,0},
          smooth=Smooth.None));
      connect(internalAxis.flange, axis)    annotation (Line(
          points={{80,40},{80,60}},
          color={0,127,0},
          smooth=Smooth.None));
      connect(constantForce.flange, internalAxis.flange)    annotation (Line(
          points={{60,40},{80,40}},
          color={0,127,0},
          smooth=Smooth.None));
      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-100,-50},{-30,41}},
              pattern=LinePattern.None,
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,255}),
            Rectangle(
              extent={{-100,40},{-30,50}},
              pattern=LinePattern.None,
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,255}),
            Rectangle(
              extent={{-30,-30},{100,20}},
              pattern=LinePattern.None,
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,255}),
            Rectangle(
              extent={{-30,20},{100,30}},
              pattern=LinePattern.None,
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,255}),
            Line(points={{-30,-50},{-30,50}}, color={0,0,0}),
            Line(points={{100,-30},{100,21}}, color={0,0,0}),
            Text(
              extent={{60,12},{96,-13}},
              lineColor={128,128,128},
              textString="b"),
            Text(
              extent={{-95,13},{-60,-9}},
              lineColor={128,128,128},
              textString="a"),
            Text(
              visible=useAxisFlange,
              extent={{-150,-135},{150,-95}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{-150,-90},{150,-60}},
              lineColor={0,0,0},
              textString="n=%n"),
            Rectangle(
              visible=useAxisFlange,
              extent={{90,30},{100,70}},
              pattern=LinePattern.None,
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,255}),
            Text(
              visible=not useAxisFlange,
              extent={{-150,60},{150,100}},
              textString="%name",
              lineColor={0,0,255})}),
        Documentation(info="<HTML>
<p>
Joint where frame_b is translated along axis n which is fixed in frame_a.
The two frames coincide when the relative distance \"s = 0\".
</p>

<p>
Optionally, two additional 1-dimensional mechanical flanges
(flange \"axis\" represents the driving flange and
flange \"support\" represents the bearing) can be enabled via
parameter <b>useAxisFlange</b>. The enabled axis flange can be
driven with elements of the
<a href=\"modelica://Modelica.Mechanics.Translational\">Modelica.Mechanics.Translational</a>
library.

</p>

<p>
In the \"Advanced\" menu it can be defined via parameter <b>stateSelect</b>
that the relative distance \"s\" and its derivative shall be definitely
used as states by setting stateSelect=StateSelect.always.
Default is StateSelect.prefer to use the relative distance and its
derivative as preferred states. The states are usually selected automatically.
In certain situations, especially when closed kinematic loops are present,
it might be slightly more efficient, when using the StateSelect.always setting.
</p>

<p>
In the following figure the animation of a prismatic
joint is shown. The light blue coordinate system is
frame_a and the dark blue coordinate system is
frame_b of the joint. The black arrow is parameter
vector \"n\" defining the translation axis
(here: n = {1,1,0}).
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/Prismatic.png\">
</p>

</html>"));
    end Prismatic;

    model Revolute
      "Revolute joint (1 rotational degree-of-freedom, 2 potential states, optional axis flange)"

      Modelica_Mechanics_Rotational.Interfaces.Flange_a axis if useAxisFlange
        "1-dim. rotational flange that drives the joint"
        annotation (Placement(transformation(extent={{10,90},{-10,110}}, rotation=
               0)));
      Modelica_Mechanics_Rotational.Interfaces.Flange_b support if useAxisFlange
        "1-dim. rotational flange of the drive support (assumed to be fixed in the world frame, NOT in the joint)"
        annotation (Placement(transformation(extent={{-70,90},{-50,110}},
              rotation=0)));

      Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a
        "Coordinate system fixed to the joint with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
              rotation=0)));
      Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_b
        "Coordinate system fixed to the joint with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{84,-16},{116,16}},
              rotation=0)));

      parameter Boolean useAxisFlange=false "= true, if axis flange is enabled"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Boolean animation=true
        "= true, if animation shall be enabled (show axis as cylinder)";
      parameter Modelica_Mechanics_MultiBody.Types.Axis n={0,0,1}
        "Axis of rotation resolved in frame_a (= same as in frame_b)"
        annotation (Evaluate=true);
      constant Modelica_SIunits.Angle phi_offset=0
        "Relative angle offset (angle = phi_offset + phi)";
      parameter Modelica_SIunits.Distance cylinderLength=world.defaultJointLength
        "Length of cylinder representing the joint axis" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance cylinderDiameter=world.defaultJointWidth
        "Diameter of cylinder representing the joint axis" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Modelica_Mechanics_MultiBody.Types.Color cylinderColor=Types.Defaults.JointColor
        "Color of cylinder representing the joint axis" annotation (Dialog(
          colorSelector=true,
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Modelica_Mechanics_MultiBody.Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter StateSelect stateSelect=StateSelect.prefer
        "Priority to use joint angle phi and w=der(phi) as states" annotation(Dialog(tab="Advanced"));

      Modelica_SIunits.Angle phi(start=0, final stateSelect=stateSelect)
        "Relative rotation angle from frame_a to frame_b" annotation (
          unassignedMessage="
The rotation angle phi of a revolute joint cannot be determined.
Possible reasons:
- A non-zero mass might be missing on either side of the parts
  connected to the revolute joint.
- Too many StateSelect.always are defined and the model
  has less degrees of freedom as specified with this setting
  (remove all StateSelect.always settings).
");
      Modelica_SIunits.AngularVelocity w(start=0, stateSelect=stateSelect)
        "First derivative of angle phi (relative angular velocity)";
      Modelica_SIunits.AngularAcceleration a(start=0)
        "Second derivative of angle phi (relative angular acceleration)";
      Modelica_SIunits.Torque tau
        "Driving torque in direction of axis of rotation";
      Modelica_SIunits.Angle angle "= phi_offset + phi";

    protected
      outer Modelica_Mechanics_MultiBody.World world;
      parameter Real e[3](each final unit="1")=Modelica_Math.Vectors.normalizeWithAssert(n)
        "Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)";
      Frames.Orientation R_rel
        "Relative orientation object from frame_a to frame_b or from frame_b to frame_a";
      Visualizers.Advanced.Shape cylinder(
        shapeType="cylinder",
        color=cylinderColor,
        specularCoefficient=specularCoefficient,
        length=cylinderLength,
        width=cylinderDiameter,
        height=cylinderDiameter,
        lengthDirection=e,
        widthDirection={0,1,0},
        r_shape=-e*(cylinderLength/2),
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;

    protected
      Modelica_Mechanics_Rotational.Components.Fixed fixed
        "support flange is fixed to ground"
        annotation (Placement(transformation(extent={{-70,70},{-50,90}})));
      Modelica_Mechanics_Rotational.Interfaces.InternalSupport internalAxis(tau=
           tau)
        annotation (Placement(transformation(extent={{-10,90},{10,70}})));
      Modelica_Mechanics_Rotational.Sources.ConstantTorque constantTorque(
          tau_constant=0) if                                              not useAxisFlange
        annotation (Placement(transformation(extent={{40,70},{20,90}})));
    equation
      Connections.branch(frame_a.R, frame_b.R);

      assert(cardinality(frame_a) > 0,
        "Connector frame_a of revolute joint is not connected");
      assert(cardinality(frame_b) > 0,
        "Connector frame_b of revolute joint is not connected");

      angle = phi_offset + phi;
      w = der(phi);
      a = der(w);

      // relationships between quantities of frame_a and of frame_b
      frame_b.r_0 = frame_a.r_0;

      if rooted(frame_a.R) then
        R_rel = Frames.planarRotation(e, phi_offset + phi, w);
        frame_b.R = Frames.absoluteRotation(frame_a.R, R_rel);
        frame_a.f = -Frames.resolve1(R_rel, frame_b.f);
        frame_a.t = -Frames.resolve1(R_rel, frame_b.t);
      else
        R_rel = Frames.planarRotation(-e, phi_offset + phi, w);
        frame_a.R = Frames.absoluteRotation(frame_b.R, R_rel);
        frame_b.f = -Frames.resolve1(R_rel, frame_a.f);
        frame_b.t = -Frames.resolve1(R_rel, frame_a.t);
      end if;

      // d'Alemberts principle
      tau = -frame_b.t*e;

      // Connection to internal connectors
      phi = internalAxis.phi;

      connect(fixed.flange, support) annotation (Line(
          points={{-60,80},{-60,100}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(internalAxis.flange, axis) annotation (Line(
          points={{0,80},{0,100}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(constantTorque.flange, internalAxis.flange) annotation (Line(
          points={{20,80},{0,80}},
          color={0,0,0},
          smooth=Smooth.None));
      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-100,-60},{-30,60}},
              lineColor={64,64,64},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={255,255,255},
              radius=10),
            Rectangle(
              extent={{30,-60},{100,60}},
              lineColor={64,64,64},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={255,255,255},
              radius=10),
            Rectangle(extent={{-100,60},{-30,-60}}, lineColor={64,64,64}, radius=10),
            Rectangle(extent={{30,60},{100,-60}}, lineColor={64,64,64}, radius=10),
            Text(
              extent={{-90,14},{-54,-11}},
              lineColor={128,128,128},
              textString="a"),
            Text(
              extent={{51,11},{87,-14}},
              lineColor={128,128,128},
              textString="b"),
            Line(
              visible=useAxisFlange,
              points={{-20,80},{-20,60}},
              color={0,0,0}),
            Line(
              visible=useAxisFlange,
              points={{20,80},{20,60}},
              color={0,0,0}),
            Rectangle(
              visible=useAxisFlange,
              extent={{-10,100},{10,50}},
              lineColor={0,0,0},
              fillPattern=FillPattern.VerticalCylinder,
              fillColor={192,192,192}),
            Polygon(
              visible=useAxisFlange,
              points={{-10,30},{10,30},{30,50},{-30,50},{-10,30}},
              lineColor={64,64,64},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-30,11},{30,-10}},
              lineColor={64,64,64},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Polygon(
              visible=useAxisFlange,
              points={{10,30},{30,50},{30,-50},{10,-30},{10,30}},
              lineColor={64,64,64},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,-110},{150,-80}},
              lineColor={0,0,0},
              textString="n=%n"),
            Text(
              visible=useAxisFlange,
              extent={{-150,-155},{150,-115}},
              textString="%name",
              lineColor={0,0,255}),
            Line(
              visible=useAxisFlange,
              points={{-20,70},{-60,70},{-60,60}},
              color={0,0,0},
              smooth=Smooth.None),
            Line(
              visible=useAxisFlange,
              points={{20,70},{50,70},{50,60}},
              color={0,0,0},
              smooth=Smooth.None),
            Line(
              visible=useAxisFlange,
              points={{-90,100},{-30,100}},
              color={0,0,0}),
            Line(
              visible=useAxisFlange,
              points={{-30,100},{-50,80}},
              color={0,0,0}),
            Line(
              visible=useAxisFlange,
              points={{-49,100},{-70,80}},
              color={0,0,0}),
            Line(
              visible=useAxisFlange,
              points={{-70,100},{-90,80}},
              color={0,0,0}),
            Text(
              visible=not useAxisFlange,
              extent={{-150,70},{150,110}},
              textString="%name",
              lineColor={0,0,255})}),
        Documentation(info="<html>

<p>
Joint where frame_b rotates around axis n which is fixed in frame_a.
The two frames coincide when the rotation angle \"phi = 0\".
</p>

<p>
Optionally, two additional 1-dimensional mechanical flanges
(flange \"axis\" represents the driving flange and
flange \"support\" represents the bearing) can be enabled via
parameter <b>useAxisFlange</b>. The enabled axis flange can be
driven with elements of the
<a href=\"modelica://Modelica.Mechanics.Rotational\">Modelica.Mechanics.Rotational</a>
library.

</p>

<p>
In the \"Advanced\" menu it can be defined via parameter <b>stateSelect</b>
that the rotation angle \"phi\" and its derivative shall be definitely
used as states by setting stateSelect=StateSelect.always.
Default is StateSelect.prefer to use the joint angle and its
derivative as preferred states. The states are usually selected automatically.
In certain situations, especially when closed kinematic loops are present,
it might be slightly more efficient, when using the StateSelect.always setting.
</p>
<p>
If a <b>planar loop</b> is present, e.g., consisting of 4 revolute joints
where the joint axes are all parallel to each other, then there is no
longer a unique mathematical solution and the symbolic algorithms will
fail. Usually, an error message will be printed pointing out this
situation. In this case, one revolute joint of the loop has to be replaced
by a Joints.RevolutePlanarLoopConstraint joint. The
effect is that from the 5 constraints of a usual revolute joint,
3 constraints are removed and replaced by appropriate known
variables (e.g., the force in the direction of the axis of rotation is
treated as known with value equal to zero; for standard revolute joints,
this force is an unknown quantity).
</p>

<p>
In the following figure the animation of a revolute
joint is shown. The light blue coordinate system is
frame_a and the dark blue coordinate system is
frame_b of the joint. The black arrow is parameter
vector \"n\" defining the translation axis
(here: n = {0,0,1}, phi.start = 45<sup>o</sup>).
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/Revolute.png\">
</p>

</html>"));
    end Revolute;

    model RevolutePlanarLoopConstraint
      "Revolute joint that is described by 2 positional constraints for usage in a planar loop (the ambiguous cut-force perpendicular to the loop and the ambiguous cut-torques are set arbitrarily to zero)"

      import T = Modelica_Mechanics_MultiBody.Frames.TransformationMatrices;
      import Modelica_Mechanics_MultiBody.Types;

      Interfaces.Frame_a frame_a
        "Coordinate system fixed to the joint with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
              rotation=0)));
      Interfaces.Frame_b frame_b
        "Coordinate system fixed to the joint with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{84,-16},{116,16}}, rotation=
               0)));

      parameter Boolean animation=true
        "= true, if animation shall be enabled (show axis as cylinder)";
      parameter Modelica_Mechanics_MultiBody.Types.Axis n={0,0,1}
        "Axis of rotation resolved in frame_a (= same as in frame_b)"
        annotation (Evaluate=true);
      parameter Modelica_SIunits.Distance cylinderLength=world.defaultJointLength
        "Length of cylinder representing the joint axis"
        annotation (Dialog(group="if animation = true", enable=animation));
      parameter Modelica_SIunits.Distance cylinderDiameter=world.defaultJointWidth
        "Diameter of cylinder representing the joint axis"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Color cylinderColor=Types.Defaults.JointColor
        "Color of cylinder representing the joint axis"
        annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));
    protected
      outer Modelica_Mechanics_MultiBody.World world;
      parameter Real e[3](each final unit="1")=Modelica_Math.Vectors.normalizeWithAssert(n)
        "Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)";
      parameter Real nnx_a[3](each final unit="1")=if abs(e[1]) > 0.1 then {0,1,0} else (if abs(e[2])
           > 0.1 then {0,0,1} else {1,0,0})
        "Arbitrary vector that is not aligned with rotation axis n"
        annotation (Evaluate=true);
      parameter Real ey_a[3](each final unit="1")=Modelica_Math.Vectors.normalizeWithAssert(cross(e, nnx_a))
        "Unit vector orthogonal to axis n of revolute joint, resolved in frame_a"
        annotation (Evaluate=true);
      parameter Real ex_a[3](each final unit="1")=cross(ey_a, e)
        "Unit vector orthogonal to axis n of revolute joint and to ey_a, resolved in frame_a"
        annotation (Evaluate=true);
      Real ey_b[3](each final unit="1") "ey_a, resolved in frame_b";
      Real ex_b[3](each final unit="1") "ex_a, resolved in frame_b";
      Frames.Orientation R_rel
        "Dummy or relative orientation object from frame_a to frame_b";
      Modelica_SIunits.Position r_rel_a[3]
        "Position vector from origin of frame_a to origin of frame_b, resolved in frame_a";
      Modelica_SIunits.Force f_c[2]
        "Dummy or constraint forces in direction of ex_a, ey_a";

      Visualizers.Advanced.Shape cylinder(
        shapeType="cylinder",
        color=cylinderColor,
        specularCoefficient=specularCoefficient,
        length=cylinderLength,
        width=cylinderDiameter,
        height=cylinderDiameter,
        lengthDirection=e,
        widthDirection={0,1,0},
        r_shape=-e*(cylinderLength/2),
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;
    equation
      assert(cardinality(frame_a) > 0,
        "Connector frame_a of revolute joint is not connected");
      assert(cardinality(frame_b) > 0,
        "Connector frame_b of revolute joint is not connected");

      // Determine relative position vector resolved in frame_a
      R_rel = Frames.relativeRotation(frame_a.R, frame_b.R);
      r_rel_a = Frames.resolve2(frame_a.R, frame_b.r_0 - frame_a.r_0);
      // r_rel_a = T.resolve1(R_rel.T, T.resolve2(frame_b.R.T, frame_b.r_0 - frame_a.r_0));

      // Constraint equations
      0 = ex_a*r_rel_a;
      0 = ey_a*r_rel_a;

      /* Transform forces and torques
     (the torques are assumed to be zero by the assumption
      of a planar joint)
  */
      frame_a.t = zeros(3);
      frame_b.t = zeros(3);

      frame_a.f = [ex_a, ey_a]*f_c;
      frame_b.f = -Frames.resolve2(R_rel, frame_a.f);

      // check that revolute joint is used in planar loop
      ex_b = Frames.resolve2(R_rel, ex_a);
      ey_b = Frames.resolve2(R_rel, ey_a);
      assert(noEvent(abs(e*r_rel_a) <= 1.e-10 and abs(e*ex_b) <= 1.e-10 and
          abs(e*ey_b) <= 1.e-10), "
The MultiBody.Joints.RevolutePlanarLoopConstraint joint is used as cut-joint of a
planar loop. However, the revolute joint is not part of a planar loop where the
axis of the revolute joint (parameter n) is orthogonal to the possible movements.
Either use instead joint MultiBody.Joints.Revolute or correct the
definition of the axes vectors n in the revolute joints of the planar loop.
");
      annotation (defaultComponentName="revolute",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Text(
              extent={{-150,70},{150,100}},
              lineColor={0,0,0},
              textString="n=%n"),
            Text(
              extent={{-150,-110},{150,-70}},
              textString="%name",
              lineColor={0,0,255}),
            Rectangle(
              extent={{-20,10},{20,-10}},
              lineColor={64,64,64},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-100,-60},{-20,60}},
              lineColor={64,64,64},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={255,255,255},
              radius=10),
            Rectangle(
              extent={{20,-60},{100,60}},
              lineColor={64,64,64},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={255,255,255},
              radius=10),
            Rectangle(extent={{-100,60},{-20,-60}}, lineColor={64,64,64}, radius=10),
            Rectangle(extent={{20,60},{100,-60}}, lineColor={64,64,64}, radius=10),
            Text(
              extent={{-90,14},{-54,-11}},
              lineColor={128,128,128},
              textString="a"),
            Text(
              extent={{51,11},{87,-14}},
              lineColor={128,128,128},
              textString="b"),
            Line(
              points={{-91,-76},{-33,15},{30,-49},{87,61}},
              color={255,0,0},
              thickness=0.5,
              smooth=Smooth.None)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-100,-60},{-20,60}},
              lineColor={64,64,64},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={255,255,255},
              radius=10),
            Rectangle(
              extent={{-100,-60},{-20,60}},
              lineColor={64,64,64},
              fillPattern=FillPattern.None,
              radius=10),
            Rectangle(
              extent={{-20,10},{20,-10}},
              lineColor={64,64,64},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{20,-60},{100,60}},
              lineColor={64,64,64},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={255,255,255},
              radius=10),
            Rectangle(
              extent={{20,-60},{100,60}},
              lineColor={64,64,64},
              fillPattern=FillPattern.None,
              radius=10)}),
        Documentation(info="<HTML>
<p>
Joint where frame_b rotates around axis n which is fixed in frame_a and
where this joint is used in a planar loop providing 2 constraint equations
on position level.
</p>

<p>
If a <b>planar loop</b> is present, e.g., consisting of 4 revolute joints
where the joint axes are all parallel to each other, then there is no
unique mathematical solution if all revolute joints are modelled with
Joints.Revolute and the symbolic algorithms will
fail. The reason is that, e.g., the cut-forces in the revolute joints perpendicular
to the planar loop are not uniquely defined when 3-dim. descriptions of revolute
joints are used. Usually, an error message will be printed pointing out this
situation. In this case, <b>one</b> revolute joint in the loop has to be replaced by
model Joints.RevolutePlanarLoopCutJoint. The
effect is that from the 5 constraints of a 3-dim. revolute joint,
3 constraints are removed and replaced by appropriate known
variables (e.g., the force in the direction of the axis of rotation is
treated as known with value equal to zero; for standard revolute joints,
this force is an unknown quantity).
</p>

</html>"));
    end RevolutePlanarLoopConstraint;

    model Cylindrical
      "Cylindrical joint (2 degrees-of-freedom, 4 potential states)"
      extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;
      parameter Boolean animation=true
        "= true, if animation shall be enabled (show cylinder)";
      parameter Modelica_Mechanics_MultiBody.Types.Axis n={1,0,0}
        "Cylinder axis resolved in frame_a (= same as in frame_b)"
        annotation (Evaluate=true);
      parameter Modelica_SIunits.Distance cylinderDiameter=world.defaultJointWidth
        "Diameter of cylinder" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color cylinderColor=Types.Defaults.JointColor
        "Color of cylinder"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
      parameter StateSelect stateSelect=StateSelect.prefer
        "Priority to use joint coordinates (phi, s, w, v) as states" annotation(Dialog(tab="Advanced"));

      Prismatic prismatic(
        n=n,
        animation=false,
        stateSelect=StateSelect.never) annotation (Placement(transformation(extent={{-70,-25},{
                -15,25}}, rotation=0)));
      Revolute revolute(
        n=n,
        animation=false,
        stateSelect=StateSelect.never) annotation (Placement(transformation(extent={{10,-25},{
                65,25}}, rotation=0)));

      Modelica_SIunits.Position s(start=0, stateSelect=stateSelect)
        "Relative distance between frame_a and frame_b";
      Modelica_SIunits.Angle phi(start=0, stateSelect=stateSelect)
        "Relative rotation angle from frame_a to frame_b";
      Modelica_SIunits.Velocity v(start=0, stateSelect=stateSelect)
        "First derivative of s (relative velocity)";
      Modelica_SIunits.AngularVelocity w(start=0, stateSelect=stateSelect)
        "First derivative of angle phi (relative angular velocity)";
      Modelica_SIunits.Acceleration a(start=0)
        "Second derivative of s (relative acceleration)";
      Modelica_SIunits.AngularAcceleration wd(start=0)
        "Second derivative of angle phi (relative angular acceleration)";

    protected
      Visualizers.Advanced.Shape cylinder(
        shapeType="cylinder",
        color=cylinderColor,
        specularCoefficient=specularCoefficient,
        length=prismatic.s,
        width=cylinderDiameter,
        height=cylinderDiameter,
        lengthDirection=prismatic.n,
        widthDirection={0,1,0},
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation
        annotation (Placement(transformation(extent={{-20,40},{0,60}},  rotation=
                0)));
    equation
      phi = revolute.phi;
      w = der(phi);
      wd = der(w);
      s = prismatic.s;
      v = der(s);
      a = der(v);
      connect(frame_a, prismatic.frame_a)
        annotation (Line(
          points={{-100,0},{-70,0}},
          color={95,95,95},
          thickness=0.5));
      connect(prismatic.frame_b, revolute.frame_a)
        annotation (Line(
          points={{-15,0},{10,0}},
          color={95,95,95},
          thickness=0.5));
      connect(revolute.frame_b, frame_b)
        annotation (Line(
          points={{65,0},{100,0}},
          color={95,95,95},
          thickness=0.5));
      annotation (
        Documentation(info="<HTML>
<p>
Joint where frame_b rotates around and translates along axis n
which is fixed in frame_a. The two frames coincide when
\"phi=revolute.phi=0\" and \"s=prismatic.s=0\". This joint
has the following potential states;
<ul>
<li> The relative angle phi [rad] around axis n, </li>
<li> the relative distance s [m] along axis n, </li>
<li> the relative angular velocity w [rad/s] (= der(phi))
     and </li>
<li> the relative velocity v [m/s] (= der(s)).</li>
</ul>
<p>
They are used as candidates for automatic selection of states
from the tool. This may be enforced by setting \"stateSelect=StateSelect.<b>always</b>\"
in the <b>Advanced</b> menu. The states are usually selected automatically.
In certain situations, especially when closed kinematic loops are present,
it might be slightly more efficient, when using the \"StateSelect.always\" setting.
</p>
<p>
In the following figure the animation of a cylindrical
joint is shown. The light blue coordinate system is
frame_a and the dark blue coordinate system is
frame_b of the joint. The black arrow is parameter
vector \"n\" defining the cylinder axis
(here: n = {0,0,1}).
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/Cylindrical.png\">
</p>
</html>"),     Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-30,-30},{100,30}},
              lineColor={64,64,64},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={255,255,255},
              radius=10),
            Rectangle(
              extent={{-30,-30},{100,30}},
              lineColor={64,64,64},
              fillPattern=FillPattern.None,
              radius=10),
            Rectangle(
              extent={{-100,-50},{0,50}},
              lineColor={64,64,64},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={255,255,255},
              radius=10),
            Rectangle(
              extent={{-100,-50},{0,50}},
              lineColor={64,64,64},
              fillPattern=FillPattern.None,
              radius=10),
            Text(
              extent={{-150,100},{150,60}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{-150,-65},{150,-95}},
              lineColor={0,0,0},
              textString="n=%n")}));
    end Cylindrical;

    model Universal
      "Universal joint (2 degrees-of-freedom, 4 potential states)"

      extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;
      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Modelica_Mechanics_MultiBody.Types.Axis n_a={1,0,0}
        "Axis of revolute joint 1 resolved in frame_a"
        annotation (Evaluate=true);
      parameter Modelica_Mechanics_MultiBody.Types.Axis n_b={0,1,0}
        "Axis of revolute joint 2 resolved in frame_b"
        annotation (Evaluate=true);

      parameter Modelica_SIunits.Distance cylinderLength=world.defaultJointLength
        "Length of cylinders representing the joint axes" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance cylinderDiameter=world.defaultJointWidth
        "Diameter of cylinders representing the joint axes" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color cylinderColor=Types.Defaults.JointColor
        "Color of cylinders representing the joint axes"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
      parameter StateSelect stateSelect=StateSelect.prefer
        "Priority to use joint coordinates (phi_a, phi_b, w_a, w_b) as states" annotation(Dialog(tab="Advanced"));

      Modelica_Mechanics_MultiBody.Joints.Revolute revolute_a(
        n=n_a,
        stateSelect=StateSelect.never,
        cylinderDiameter=cylinderDiameter,
        cylinderLength=cylinderLength,
        cylinderColor=cylinderColor,
        specularCoefficient=specularCoefficient,
        animation=animation) annotation (Placement(transformation(extent={{-60,
                -25},{-10,25}}, rotation=0)));
      Modelica_Mechanics_MultiBody.Joints.Revolute revolute_b(
        n=n_b,
        stateSelect=StateSelect.never,
        animation=animation,
        cylinderDiameter=cylinderDiameter,
        cylinderLength=cylinderLength,
        cylinderColor=cylinderColor,
        specularCoefficient=specularCoefficient) annotation (Placement(
            transformation(
            origin={35,45},
            extent={{-25,-25},{25,25}},
            rotation=90)));

      Modelica_SIunits.Angle phi_a(start=0, stateSelect=stateSelect)
        "Relative rotation angle from frame_a to intermediate frame";
      Modelica_SIunits.Angle phi_b(start=0, stateSelect=stateSelect)
        "Relative rotation angle from intermediate frame to frame_b";
      Modelica_SIunits.AngularVelocity w_a(start=0, stateSelect=stateSelect)
        "First derivative of angle phi_a (relative angular velocity a)";
      Modelica_SIunits.AngularVelocity w_b(start=0, stateSelect=stateSelect)
        "First derivative of angle phi_b (relative angular velocity b)";
      Modelica_SIunits.AngularAcceleration a_a(start=0)
        "Second derivative of angle phi_a (relative angular acceleration a)";
      Modelica_SIunits.AngularAcceleration a_b(start=0)
        "Second derivative of angle phi_b (relative angular acceleration b)";

    equation
      phi_a = revolute_a.phi;
      phi_b = revolute_b.phi;
      w_a = der(phi_a);
      w_b = der(phi_b);
      a_a = der(w_a);
      a_b = der(w_b);
      connect(frame_a, revolute_a.frame_a)
        annotation (Line(
          points={{-100,0},{-60,0}},
          color={95,95,95},
          thickness=0.5));
      connect(revolute_b.frame_b, frame_b) annotation (Line(
          points={{35,70},{35,90},{70,90},{70,0},{100,0}},
          color={95,95,95},
          thickness=0.5));
      connect(revolute_a.frame_b, revolute_b.frame_a) annotation (Line(
          points={{-10,0},{35,0},{35,20}},
          color={95,95,95},
          thickness=0.5));
      annotation (
        Documentation(info="<HTML>
<p>
Joint where frame_a rotates around axis n_a which is fixed in frame_a
and frame_b rotates around axis n_b which is fixed in frame_b.
The two frames coincide when
\"revolute_a.phi=0\" and \"revolute_b.phi=0\". This joint
has the following potential states;
<ul>
<li> The relative angle phi_a = revolute_a.phi [rad] around axis n_a, </li>
<li> the relative angle phi_b = revolute_b.phi [rad] around axis n_b, </li>
<li> the relative angular velocity w_a (= der(phi_a))  and </li>
<li> the relative angular velocity w_b (= der(phi_b)).</li>
</ul>
<p>
They are used as candidates for automatic selection of states
from the tool. This may be enforced by setting \"stateSelect=StateSelect.<b>always</b>\"
in the <b>Advanced</b> menu. The states are usually selected automatically.
In certain situations, especially when closed kinematic loops are present,
it might be slightly more efficient, when using the \"StateSelect.always\" setting.
</p>

<p>
In the following figure the animation of a universal
joint is shown. The light blue coordinate system is
frame_a and the dark blue coordinate system is
frame_b of the joint
(here: n_a = {0,0,1}, n_b = {0,1,0}, phi_a.start = 90<sup>o</sup>,
phi_b.start = 45<sup>o</sup>).
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/Universal.png\">
</p>
</HTML>"),
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-100,15},{-65,-15}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={235,235,235}),
            Ellipse(
              extent={{-80,-80},{80,80}},
              lineColor={160,160,164},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-60,-60},{60,60}},
              lineColor={160,160,164},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,-80},{150,-120}},
              textString="%name",
              lineColor={0,0,255}),
            Rectangle(
              extent={{12,82},{80,-82}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{56,15},{100,-15}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={235,235,235}),
            Line(
              points={{12,78},{12,-78}},
              color={0,0,0},
              thickness=0.5),
            Ellipse(
              extent={{-52,-40},{80,40}},
              lineColor={160,160,164},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-32,-20},{60,26}},
              lineColor={160,160,164},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-22,-54},{-60,0},{-22,50},{40,52},{-22,-54}},
              pattern=LinePattern.None,
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,255}),
            Line(
              points={{12,78},{12,-20}},
              color={0,0,0},
              thickness=0.5),
            Line(
              points={{32,38},{-12,-36}},
              color={0,0,0},
              thickness=0.5)}));
    end Universal;

    model Planar "Planar joint (3 degrees-of-freedom, 6 potential states)"

      extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;
      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Modelica_Mechanics_MultiBody.Types.Axis n={0,0,1}
        "Axis orthogonal to unconstrained plane, resolved in frame_a (= same as in frame_b)"
        annotation (Evaluate=true);
      parameter Modelica_Mechanics_MultiBody.Types.Axis n_x={1,0,0}
        "Vector in direction of x-axis of plane, resolved in frame_a (n_x shall be orthogonal to n)"
        annotation (Evaluate=true);
      parameter Modelica_SIunits.Distance cylinderLength=world.defaultJointLength
        "Length of revolute cylinder" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance cylinderDiameter=world.defaultJointWidth
        "Diameter of revolute cylinder" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color cylinderColor=Types.Defaults.JointColor
        "Color of revolute cylinder"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      parameter Modelica_SIunits.Distance boxWidth=0.3*cylinderDiameter
        "Width of prismatic joint boxes" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance boxHeight=boxWidth
        "Height of prismatic joint boxes" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color boxColor=Types.Defaults.JointColor
        "Color of prismatic joint boxes"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      parameter StateSelect stateSelect=StateSelect.prefer
        "Priority to use joint coordinates (s_x, s_y, phi, v_x, v_y, w) as states"
                                                                                   annotation(Dialog(tab="Advanced"));

      Prismatic prismatic_x(
        stateSelect=StateSelect.never,
        n=(cross(cross(n, n_x), n)),
        animation=false) annotation (Placement(transformation(extent={{-69,-20},{
                -29,20}},  rotation=0)));
      Prismatic prismatic_y(
        stateSelect=StateSelect.never,
        n=(cross(n, n_x)),
        animation=false) annotation (Placement(transformation(
            origin={0,50},
            extent={{-20,-20},{20,20}},
            rotation=90)));
      Revolute revolute(
        stateSelect=StateSelect.never,
        n=n,
        animation=false) annotation (Placement(transformation(extent={{41,-20},{
                81,20}}, rotation=0)));

      Modelica_SIunits.Position s_x(start=0, stateSelect=stateSelect)
        "Relative distance along first prismatic joint starting at frame_a";
      Modelica_SIunits.Position s_y(start=0, stateSelect=stateSelect)
        "Relative distance along second prismatic joint starting at first prismatic joint";
      Modelica_SIunits.Angle phi(start=0, stateSelect=stateSelect)
        "Relative rotation angle from frame_a to frame_b";
      Modelica_SIunits.Velocity v_x(start=0, stateSelect=stateSelect)
        "First derivative of s_x (relative velocity in s_x direction)";
      Modelica_SIunits.Velocity v_y(start=0, stateSelect=stateSelect)
        "First derivative of s_y (relative velocity in s_y direction)";
      Modelica_SIunits.AngularVelocity w(start=0, stateSelect=stateSelect)
        "First derivative of angle phi (relative angular velocity)";
      Modelica_SIunits.Acceleration a_x(start=0)
        "Second derivative of s_x (relative acceleration in s_x direction)";
      Modelica_SIunits.Acceleration a_y(start=0)
        "Second derivative of s_y (relative acceleration in s_y direction)";
      Modelica_SIunits.AngularAcceleration wd(start=0)
        "Second derivative of angle phi (relative angular acceleration)";

    protected
      parameter Integer ndim=if world.enableAnimation and animation then 1 else 0;
      parameter Real e[3](each final unit="1")=Modelica_Math.Vectors.normalize(
                                           n);
    protected
      Visualizers.Advanced.Shape box_x[ndim](
        each shapeType="box",
        each color=boxColor,
        each length=prismatic_x.s,
        each width=boxWidth,
        each height=boxWidth,
        each lengthDirection=prismatic_x.e,
        each widthDirection={0,1,0},
        each r=frame_a.r_0,
        each R=frame_a.R) annotation (Placement(transformation(extent={{-80,30},{
                -60,50}}, rotation=0)));
      Visualizers.Advanced.Shape box_y[ndim](
        each shapeType="box",
        each color=boxColor,
        each length=prismatic_y.s,
        each width=boxWidth,
        each height=boxWidth,
        each lengthDirection=prismatic_y.e,
        each widthDirection={1,0,0},
        each r=prismatic_y.frame_a.r_0,
        each R=prismatic_y.frame_a.R) annotation (Placement(transformation(extent={{-46,69},
                {-26,89}},          rotation=0)));
      Visualizers.Advanced.Shape cylinder[ndim](
        each shapeType="cylinder",
        each color=cylinderColor,
        each length=cylinderLength,
        each width=cylinderDiameter,
        each height=cylinderDiameter,
        each lengthDirection=n,
        each widthDirection={0,1,0},
        each r_shape=-e*(cylinderLength/2),
        each r=revolute.frame_b.r_0,
        each R=revolute.frame_b.R) annotation (Placement(transformation(extent={{50,30},
                {70,50}},        rotation=0)));
    equation
      s_x = prismatic_x.s;
      s_y = prismatic_y.s;
      phi = revolute.phi;
      v_x = der(s_x);
      v_y = der(s_y);
      w   = der(phi);
      a_x = der(v_x);
      a_y = der(v_y);
      wd  = der(w);

      connect(frame_a, prismatic_x.frame_a)
        annotation (Line(
          points={{-100,0},{-84,0},{-84,0},{-69,0}},
          color={95,95,95},
          thickness=0.5));
      connect(prismatic_x.frame_b, prismatic_y.frame_a) annotation (Line(
          points={{-29,0},{0,0},{0,30}},
          color={95,95,95},
          thickness=0.5));
      connect(prismatic_y.frame_b, revolute.frame_a) annotation (Line(
          points={{0,70},{0,80},{30,80},{30,0},{41,0}},
          color={95,95,95},
          thickness=0.5));
      connect(revolute.frame_b, frame_b)
        annotation (Line(
          points={{81,0},{92,0},{92,0},{100,0}},
          color={95,95,95},
          thickness=0.5));
      annotation (
        Documentation(info="<HTML>
<p>
Joint where frame_b can move in a plane and can rotate around an
axis orthogonal to the plane. The plane is defined by
vector n which is perpendicular to the plane and by vector n_x,
which points in the direction of the x-axis of the plane.
frame_a and frame_b coincide when s_x=prismatic_x.s=0,
s_y=prismatic_y.s=0 and phi=revolute.phi=0. This joint has the following
potential states:
<ul>
<li> the relative distance s_x = prismatic_x.s [m] along axis n_x, </li>
<li> the relative distance s_y = prismatic_y.s [m] along axis n_y = cross(n,n_x), </li>
<li> the relative angle phi = revolute.phi [rad] around axis n, </li>
<li> the relative velocity v_x (= der(s_x)).</li>
<li> the relative velocity v_y (= der(s_y)).</li>
<li> the relative angular velocity w (= der(phi))</li>
</ul>
<p>
They are used as candidates for automatic selection of states
from the tool. This may be enforced by setting \"stateSelect=StateSelect.<b>always</b>\"
in the <b>Advanced</b> menu. The states are usually selected automatically.
In certain situations, especially when closed kinematic loops are present,
it might be slightly more efficient, when using the \"StateSelect.always\" setting.
</p>
<p>
In the following figure the animation of a planar
joint is shown. The light blue coordinate system is
frame_a and the dark blue coordinate system is
frame_b of the joint. The black arrows are parameter
vectors \"n\" and \"n_x\"
(here: n = {0,1,0}, n_x = {0,0,1}, s_x.start = 0.5,
s_y.start = 0.5, phi.start = 45<sup>o</sup>).
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/Planar.png\">
</p>
</html>"),     Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-30,-60},{-10,60}},
              lineColor={0,0,0},
              pattern=LinePattern.None,
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{10,-60},{30,60}},
              lineColor={0,0,0},
              pattern=LinePattern.None,
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-100,-10},{-30,10}},
              lineColor={0,0,0},
              pattern=LinePattern.None,
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{100,-10},{30,10}},
              lineColor={0,0,0},
              pattern=LinePattern.None,
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,-75},{150,-105}},
              lineColor={0,0,0},
              textString="n=%n"),
            Text(
              extent={{-150,110},{150,70}},
              textString="%name",
              lineColor={0,0,255})}));
    end Planar;

    model Spherical
      "Spherical joint (3 constraints and no potential states, or 3 degrees-of-freedom and 3 states)"

      import Modelica_Mechanics_MultiBody.Frames;

      extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;
      parameter Boolean animation=true
        "= true, if animation shall be enabled (show sphere)";
      parameter Modelica_SIunits.Distance sphereDiameter=world.defaultJointLength
        "Diameter of sphere representing the spherical joint"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Color sphereColor=Types.Defaults.JointColor
        "Color of sphere representing the spherical joint"
        annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));

      parameter Boolean angles_fixed = false
        "= true, if angles_start are used as initial values, else as guess values"
        annotation(Evaluate=true, choices(checkBox=true), Dialog(tab="Initialization"));
      parameter Modelica_SIunits.Angle angles_start[3]={0,0,0}
        "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b"
        annotation (Dialog(tab="Initialization"));
      parameter Types.RotationSequence sequence_start={1,2,3}
        "Sequence of rotations to rotate frame_a into frame_b at initial time"
        annotation (Evaluate=true, Dialog(tab="Initialization"));

      parameter Boolean w_rel_a_fixed = false
        "= true, if w_rel_a_start are used as initial values, else as guess values"
        annotation(Evaluate=true, choices(checkBox=true), Dialog(tab="Initialization"));
      parameter Modelica_SIunits.AngularVelocity w_rel_a_start[3]={0,0,0}
        "Initial values of angular velocity of frame_b with respect to frame_a, resolved in frame_a"
        annotation (Dialog(tab="Initialization"));

      parameter Boolean z_rel_a_fixed = false
        "= true, if z_rel_a_start are used as initial values, else as guess values"
        annotation(Evaluate=true, choices(checkBox=true), Dialog(tab="Initialization"));
      parameter Modelica_SIunits.AngularAcceleration z_rel_a_start[3]={0,0,0}
        "Initial values of angular acceleration z_rel_a = der(w_rel_a)"
        annotation (Dialog(tab="Initialization"));

      parameter Boolean enforceStates=false
        "= true, if relative variables of spherical joint shall be used as states (StateSelect.always)"
        annotation (Dialog(tab="Advanced"));
      parameter Boolean useQuaternions=true
        "= true, if quaternions shall be used as states otherwise use 3 angles as states (provided enforceStates=true)"
        annotation (Dialog(tab="Advanced", enable=enforceStates));
      parameter Types.RotationSequence sequence_angleStates={1,2,3}
        "Sequence of rotations to rotate frame_a into frame_b around the 3 angles used as states"
         annotation (Evaluate=true, Dialog(tab="Advanced", enable=enforceStates
               and not useQuaternions));

      final parameter Frames.Orientation R_rel_start=
          Frames.axesRotations(sequence_start, angles_start, zeros(3))
        "Orientation object from frame_a to frame_b at initial time";

    protected
      Visualizers.Advanced.Shape sphere(
        shapeType="sphere",
        color=sphereColor,
        specularCoefficient=specularCoefficient,
        length=sphereDiameter,
        width=sphereDiameter,
        height=sphereDiameter,
        lengthDirection={1,0,0},
        widthDirection={0,1,0},
        r_shape={-0.5,0,0}*sphereDiameter,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;

      // Declarations for quaternions (dummies, if quaternions are not used)
      parameter Frames.Quaternions.Orientation Q_start=
                Frames.to_Q(                             R_rel_start)
        "Quaternion orientation object from frame_a to frame_b at initial time";
      Frames.Quaternions.Orientation Q(start=Q_start, each stateSelect=if
            enforceStates and useQuaternions then StateSelect.prefer else
            StateSelect.never)
        "Quaternion orientation object from frame_a to frame_b (dummy value, if quaternions are not used as states)";

      // Declaration for 3 angles
      parameter Modelica_SIunits.Angle phi_start[3]=if sequence_start[1] ==
          sequence_angleStates[1] and sequence_start[2] == sequence_angleStates[
          2] and sequence_start[3] == sequence_angleStates[3] then angles_start
           else Frames.axesRotationsAngles(R_rel_start, sequence_angleStates)
        "Potential angle states at initial time";
      Modelica_SIunits.Angle phi[3](start=phi_start, each stateSelect=if
            enforceStates and not useQuaternions then StateSelect.always else
            StateSelect.never)
        "Dummy or 3 angles to rotate frame_a into frame_b";
      Modelica_SIunits.AngularVelocity phi_d[3](each stateSelect=if
            enforceStates and not useQuaternions then StateSelect.always else
            StateSelect.never) "= der(phi)";
      Modelica_SIunits.AngularAcceleration phi_dd[3] "= der(phi_d)";

      // Other declarations
      Modelica_SIunits.AngularVelocity w_rel[3](
        start=Frames.resolve2(R_rel_start, w_rel_a_start),
        fixed=fill(w_rel_a_fixed, 3),
        each stateSelect=if enforceStates and useQuaternions then StateSelect.always
             else StateSelect.never)
        "Dummy or relative angular velocity of frame_b with respect to frame_a, resolved in frame_b";
      Frames.Orientation R_rel
        "Dummy or relative orientation object to rotate from frame_a to frame_b";
      Frames.Orientation R_rel_inv
        "Dummy or relative orientation object to rotate from frame_b to frame_a";
    initial equation
      if angles_fixed then
        if not enforceStates then
          // no states defined in spherical object
          zeros(3) = Frames.Orientation.equalityConstraint(Frames.absoluteRotation(frame_a.R,R_rel_start),frame_b.R);
        elseif useQuaternions then
          // Quaternions Q are used as states
          zeros(3) = Frames.Quaternions.Orientation.equalityConstraint(Q, Q_start);
        else
          // The 3 angles 'phi' are used as states
          phi = phi_start;
        end if;
      end if;

      if z_rel_a_fixed then
        // Initialize acceleration variables
        der(w_rel) = Frames.resolve2(R_rel_start, z_rel_a_start);
      end if;
    equation
      // torque balance
      zeros(3) = frame_a.t;
      zeros(3) = frame_b.t;

      if enforceStates then
        Connections.branch(frame_a.R, frame_b.R);

        frame_b.r_0 = frame_a.r_0;
        if rooted(frame_a.R) then
          R_rel_inv = Frames.nullRotation();
          frame_b.R = Frames.absoluteRotation(frame_a.R, R_rel);
          zeros(3) = frame_a.f + Frames.resolve1(R_rel, frame_b.f);
        else
          R_rel_inv = Frames.inverseRotation(R_rel);
          frame_a.R = Frames.absoluteRotation(frame_b.R, R_rel_inv);
          zeros(3) = frame_b.f + Frames.resolve2(R_rel, frame_a.f);
        end if;

        // Compute relative orientation object
        if useQuaternions then
          // Use Quaternions as states (with dynamic state selection)
          {0} = Frames.Quaternions.orientationConstraint(Q);
          w_rel = Frames.Quaternions.angularVelocity2(Q, der(Q));
          R_rel = Frames.from_Q(Q, w_rel);

          // Dummies
          phi = zeros(3);
          phi_d = zeros(3);
          phi_dd = zeros(3);

        else
          // Use angles as states
          phi_d = der(phi);
          phi_dd = der(phi_d);
          R_rel = Frames.axesRotations(sequence_angleStates, phi, phi_d);
          w_rel = Frames.angularVelocity2(R_rel);

          // Dummies
          Q = zeros(4);
        end if;

      else
        // Spherical joint does not have states
        frame_b.r_0 = frame_a.r_0;
        //frame_b.r_0 = transpose(frame_b.R.T)*(frame_b.R.T*(transpose(frame_a.R.T)*(frame_a.R.T*frame_a.r_0)));

        zeros(3) = frame_a.f + Frames.resolveRelative(frame_b.f, frame_b.R, frame_a.R);

        if w_rel_a_fixed or z_rel_a_fixed then
          w_rel = Frames.angularVelocity2(frame_b.R) - Frames.resolve2(frame_b.R,
             Frames.angularVelocity1(frame_a.R));
        else
          w_rel = zeros(3);
        end if;

        // Dummies
        R_rel = Frames.nullRotation();
        R_rel_inv = Frames.nullRotation();
        Q = zeros(4);
        phi = zeros(3);
        phi_d = zeros(3);
        phi_dd = zeros(3);
      end if;
      annotation (
        Documentation(info="<html>
<p>
Joint with <b>3 constraints</b> that define that the origin of
frame_a and the origin of frame_b coincide. By default this joint
defines only the 3 constraints without any potential states.
If parameter <b>enforceStates</b> is set to <b>true</b>
in the \"Advanced\" menu, three states are introduced.
Depending on parameter <b>useQuaternions</b> these are either
quaternions and the relative angular velocity or 3 angles
and the angle derivatives. In the latter case the orientation
of frame_b is computed by rotating frame_a along the axes defined
in parameter vector \"sequence_angleStates\" (default = {1,2,3}, i.e.,
the Cardan angle sequence) around the angles used as states.
For example, the default is to rotate the x-axis of frame_a
around angles[1], the new y-axis around angles[2] and the new z-axis
around angles[3], arriving at frame_b. If angles are used
as states there is the slight disadvantage that
a singular configuration is present leading to a division by zero.
</p>
<p>
If this joint is used in a <b>chain</b> structure, a Modelica translator
has to select orientation coordinates of a body as states, if the
default setting is used. It is usually better to use relative coordinates
in the spherical joint as states, and therefore in this situation
parameter enforceStates might be set to <b>true</b>.
</p>
<p>
If this joint is used in a <b>loop</b> structure, the default
setting results in a <b>cut-joint</b> that
breaks the loop in independent kinematic pieces, hold together
by the constraints of this joint. As a result, a Modelica translator
will first try to select 3 generalized coordinates in the joints of
the remaining parts of the loop and their first derivative as states
and if this is not possible, e.g., because there are only spherical
joints in the loop, will select coordinates from a body of the loop
as states.
</p>
<p>
In the following figure the animation of a spherical
joint is shown. The light blue coordinate system is
frame_a and the dark blue coordinate system is
frame_b of the joint.
(here: angles_start = {45, 45, 45}<sup>o</sup>).
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/Spherical.png\">
</p>
</html>"),     Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Ellipse(
              extent={{-70,-70},{70,70}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{-49,-50},{51,50}},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{30,70},{71,-68}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-100,10},{-68,-10}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={192,192,192}),
            Rectangle(
              extent={{23,10},{100,-10}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={192,192,192}),
            Ellipse(
              extent={{-24,25},{26,-25}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={160,160,164}),
            Text(
              extent={{-150,-115},{150,-75}},
              textString="%name",
              lineColor={0,0,255})}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Ellipse(
              extent={{-70,-70},{70,70}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{-49,-50},{51,50}},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{30,70},{71,-68}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-100,10},{-68,-10}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={192,192,192}),
            Rectangle(
              extent={{23,10},{100,-10}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={192,192,192}),
            Ellipse(
              extent={{-24,25},{26,-25}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={160,160,164})}));
    end Spherical;

    model FreeMotion
      "Free motion joint (6 degrees-of-freedom, 12 potential states)"

      extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;

      parameter Boolean animation=true
        "= true, if animation shall be enabled (show arrow from frame_a to frame_b)";

      Modelica_SIunits.Position r_rel_a[3](start={0,0,0}, each stateSelect=if
            enforceStates then StateSelect.always else StateSelect.prefer)
        "Position vector from origin of frame_a to origin of frame_b, resolved in frame_a"
        annotation (Dialog(group="Initialization", showStartAttribute=true));
      Modelica_SIunits.Velocity v_rel_a[3](start={0,0,0}, each stateSelect=if
            enforceStates then StateSelect.always else StateSelect.prefer)
        "= der(r_rel_a), i.e., velocity of origin of frame_b with respect to origin of frame_a, resolved in frame_a"
        annotation (Dialog(group="Initialization", showStartAttribute=true));
      Modelica_SIunits.Acceleration a_rel_a[3](start={0,0,0}) "= der(v_rel_a)"
        annotation (Dialog(group="Initialization", showStartAttribute=true));

      parameter Boolean angles_fixed = false
        "= true, if angles_start are used as initial values, else as guess values"
        annotation(Evaluate=true, choices(checkBox=true), Dialog(group="Initialization"));
      parameter Modelica_SIunits.Angle angles_start[3]={0,0,0}
        "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b"
        annotation (Dialog(group="Initialization"));
      parameter Types.RotationSequence sequence_start={1,2,3}
        "Sequence of rotations to rotate frame_a into frame_b at initial time"
        annotation (Evaluate=true, Dialog(group="Initialization"));

      parameter Boolean w_rel_a_fixed = false
        "= true, if w_rel_a_start are used as initial values, else as guess values"
        annotation(Evaluate=true, choices(checkBox=true), Dialog(group="Initialization"));
      parameter Modelica_SIunits.AngularVelocity w_rel_a_start[3]={0,0,0}
        "Initial values of angular velocity of frame_b with respect to frame_a, resolved in frame_a"
        annotation (Dialog(group="Initialization"));

      parameter Boolean z_rel_a_fixed = false
        "= true, if z_rel_a_start are used as initial values, else as guess values"
        annotation(Evaluate=true, choices(checkBox=true), Dialog(group="Initialization"));
      parameter Modelica_SIunits.AngularAcceleration z_rel_a_start[3]={0,0,0}
        "Initial values of angular acceleration z_rel_a = der(w_rel_a)"
        annotation (Dialog(group="Initialization"));

      parameter Modelica_SIunits.Length arrowDiameter=world.defaultArrowDiameter
        "Diameter of arrow from frame_a to frame_b" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color arrowColor=Types.Defaults.SensorColor "Color of arrow"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
      parameter Boolean enforceStates=true
        "= true, if relative variables between frame_a and frame_b shall be used as states"
        annotation (Dialog(tab="Advanced"));
      parameter Boolean useQuaternions=true
        "= true, if quaternions shall be used as states otherwise use 3 angles as states"
        annotation (Dialog(tab="Advanced"));
      parameter Types.RotationSequence sequence_angleStates={1,2,3}
        "Sequence of rotations to rotate frame_a into frame_b around the 3 angles used as states"
         annotation (Evaluate=true, Dialog(tab="Advanced", enable=not
              useQuaternions));

      final parameter Frames.Orientation R_rel_start=
          Frames.axesRotations(                             sequence_start, angles_start,zeros(3))
        "Orientation object from frame_a to frame_b at initial time";

    protected
      Visualizers.Advanced.Arrow arrow(
        r_head=r_rel_a,
        diameter=arrowDiameter,
        color=arrowColor,
        specularCoefficient=specularCoefficient,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;

      // Declarations for quaternions (dummies, if quaternions are not used)
      parameter Frames.Quaternions.Orientation Q_start=Frames.to_Q(R_rel_start)
        "Quaternion orientation object from frame_a to frame_b at initial time";
      Frames.Quaternions.Orientation Q(start=Q_start, each stateSelect=if
            enforceStates then (if useQuaternions then StateSelect.prefer else
            StateSelect.never) else StateSelect.default)
        "Quaternion orientation object from frame_a to frame_b (dummy value, if quaternions are not used as states)";

      // Declaration for 3 angles
      parameter Modelica_SIunits.Angle phi_start[3]=if sequence_start[1] ==
          sequence_angleStates[1] and sequence_start[2] == sequence_angleStates[
          2] and sequence_start[3] == sequence_angleStates[3] then angles_start
           else Frames.axesRotationsAngles(R_rel_start, sequence_angleStates)
        "Potential angle states at initial time";
      Modelica_SIunits.Angle phi[3](start=phi_start, each stateSelect=if
            enforceStates then (if useQuaternions then StateSelect.never else
            StateSelect.always) else StateSelect.prefer)
        "Dummy or 3 angles to rotate frame_a into frame_b";
      Modelica_SIunits.AngularVelocity phi_d[3](each stateSelect=if
            enforceStates then (if useQuaternions then StateSelect.never else
            StateSelect.always) else StateSelect.prefer) "= der(phi)";
      Modelica_SIunits.AngularAcceleration phi_dd[3] "= der(phi_d)";

      // Other declarations
      Modelica_SIunits.AngularVelocity w_rel_b[3](
        start=Frames.resolve2(R_rel_start, w_rel_a_start),
        fixed=fill(w_rel_a_fixed, 3),
        each stateSelect=if enforceStates then (if useQuaternions then
            StateSelect.always else StateSelect.avoid) else StateSelect.prefer)
        "Dummy or relative angular velocity of frame_b with respect to frame_a, resolved in frame_b";
      Frames.Orientation R_rel
        "Dummy or relative orientation object to rotate from frame_a to frame_b";
      Frames.Orientation R_rel_inv
        "Dummy or relative orientation object to rotate from frame_b to frame_a";

    initial equation
      if angles_fixed then
        // Initialize positional variables
        if not enforceStates then
          // no states defined
          zeros(3) = Frames.Orientation.equalityConstraint(Frames.absoluteRotation(frame_a.R,R_rel_start),frame_b.R);
        elseif useQuaternions then
          // Quaternions Q are used as states
          zeros(3) = Frames.Quaternions.Orientation.equalityConstraint(Q, Q_start);
        else
          // The 3 angles 'phi' are used as states
          phi = phi_start;
        end if;
      end if;

      if z_rel_a_fixed then
        // Initialize acceleration variables
        der(w_rel_b) = Frames.resolve2(R_rel_start, z_rel_a_start);
      end if;

    equation
      // Kinematic differential equations for translational motion
      der(r_rel_a) = v_rel_a;
      der(v_rel_a) = a_rel_a;

      // Kinematic relationships
      frame_b.r_0 = frame_a.r_0 + Frames.resolve1(frame_a.R, r_rel_a);

      // Cut-forces and cut-torques are zero
      frame_a.f = zeros(3);
      frame_a.t = zeros(3);
      frame_b.f = zeros(3);
      frame_b.t = zeros(3);

      if enforceStates then
        Connections.branch(frame_a.R, frame_b.R);

        if rooted(frame_a.R) then
          R_rel_inv = Frames.nullRotation();
          frame_b.R = Frames.absoluteRotation(frame_a.R, R_rel);
        else
          R_rel_inv = Frames.inverseRotation(R_rel);
          frame_a.R = Frames.absoluteRotation(frame_b.R, R_rel_inv);
        end if;

        // Compute relative orientation object
        if useQuaternions then
          // Use Quaternions as states (with dynamic state selection)
          {0} = Frames.Quaternions.orientationConstraint(Q);
          w_rel_b = Frames.Quaternions.angularVelocity2(Q, der(Q));
          R_rel = Frames.from_Q(Q, w_rel_b);

          // Dummies
          phi = zeros(3);
          phi_d = zeros(3);
          phi_dd = zeros(3);

        else
          // Use angles as states
          phi_d = der(phi);
          phi_dd = der(phi_d);
          R_rel = Frames.axesRotations(sequence_angleStates, phi, phi_d);
          w_rel_b = Frames.angularVelocity2(R_rel);

          // Dummies
          Q = zeros(4);
        end if;

      else
        // Free motion joint does not have states
        if w_rel_a_fixed or z_rel_a_fixed then
          w_rel_b = Frames.angularVelocity2(frame_b.R) - Frames.resolve2(frame_b.
            R, Frames.angularVelocity1(frame_a.R));
        else
          // dummy
          w_rel_b = zeros(3);
        end if;

        // Dummies
        R_rel = Frames.nullRotation();
        R_rel_inv = Frames.nullRotation();
        Q = zeros(4);
        phi = zeros(3);
        phi_d = zeros(3);
        phi_dd = zeros(3);
      end if;
      annotation (
        Documentation(info="<HTML>
<p>
Joint which does not constrain the motion between frame_a and frame_b.
Such a joint is only meaningful if the <b>relative</b> distance and orientation
between frame_a and frame_b, and their derivatives, shall be used
as <b>states</b>.
</p>
<p>
Note, that <b>bodies</b> such as Parts.Body, Parts.BodyShape,
have potential states describing the distance
and orientation, and their derivatives, between the <b>world frame</b> and
a <b>body fixed frame</b>.
Therefore, if these potential state variables are suited,
a FreeMotion joint is not needed.
</p>
<p>
The states of the FreeMotion object are:
</p>
<ul>
<li> The <b>relative position vector</b> r_rel_a from the origin of
     frame_a to the origin of frame_b, resolved in
     frame_a and the <b>relative velocity</b> v_rel_a of the origin of
     frame_b with respect to the origin of frame_a, resolved in frame_a
     (= der(r_rel_a)).
</li>
<li> If parameter <b>useQuaternions</b> in the \"Advanced\" menu
     is <b>true</b> (this is the default), then <b>4 quaternions</b>
     are states. Additionally, the coordinates of the
     relative angular velocity vector are 3 potential states.<br>
     If <b>useQuaternions</b> in the \"Advanced\" menu
     is <b>false</b>, then <b>3 angles</b> and the derivatives of
     these angles are potential states. The orientation of frame_b
     is computed by rotating frame_a along the axes defined
     in parameter vector \"sequence_angleStates\" (default = {1,2,3}, i.e.,
     the Cardan angle sequence) around the angles used as states.
     For example, the default is to rotate the x-axis of frame_a
     around angles[1], the new y-axis around angles[2] and the new z-axis
     around angles[3], arriving at frame_b.
 </li>
</ul>
<p>
The quaternions have the slight disadvantage that there is a
non-linear constraint equation between the 4 quaternions.
Therefore, at least one non-linear equation has to be solved
during simulation. A tool might, however, analytically solve this
simple constraint equation. Using the 3 angles as states has the
disadvantage that there is a singular configuration in which a
division by zero will occur. If it is possible to determine in advance
for an application class that this singular configuration is outside
of the operating region, the 3 angles might be used as
states by setting <b>useQuaternions</b> = <b>false</b>.
</p>
<p>
In text books about 3-dimensional mechanics often 3 angles and the
angular velocity are used as states. This is not the case here, since
3 angles and their derivatives are used as states
(if useQuaternions = false). The reason
is that for real-time simulation the discretization formula of the
integrator might be \"inlined\" and solved together with the model equations.
By appropriate symbolic transformation the performance is
drastically increased if angles and their
derivatives are used as states, instead of angles and the angular
velocity.
</p>
<p>
If parameter
<b>enforceStates</b> is set to <b>true</b> (= the default)
in the \"Advanced\" menu,
then FreeMotion variables are forced to be used as states according
to the setting of parameters \"useQuaternions\" and
\"sequence_angleStates\".
</p>
<p>
In the following figure the animation of a FreeMotion
joint is shown. The light blue coordinate system is
frame_a and the dark blue coordinate system is
frame_b of the joint.
(here: r_rel_a_start = {0.5, 0, 0.5}, angles_start = {45, 45, 45}<sup>o</sup>).
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/FreeMotion.png\">
</p>

</html>"),     Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(
              points={{-86,31},{-74,61},{-49,83},{-17,92},{19,88},{40,69},{59,48}},
              color={160,160,164},
              thickness=0.5,
              smooth=Smooth.Bezier),
            Polygon(
              points={{90,0},{50,20},{50,-20},{90,0}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{69,58},{49,40},{77,28},{69,58}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{150,-35},{-150,-75}},
              lineColor={0,0,255},
              textString="%name"),
            Rectangle(
              extent={{-70,-5},{-90,5}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{50,-5},{30,5}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{11,-5},{-9,5}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-30,-5},{-50,5}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(
              points={{-86,31},{-74,61},{-49,83},{-17,92},{19,88},{40,69},{59,48}},
              color={160,160,164},
              thickness=0.5,
              smooth=Smooth.Bezier),
            Polygon(
              points={{90,0},{50,20},{50,-20},{90,0}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{69,58},{49,40},{77,28},{69,58}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{50,-5},{30,5}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{11,-5},{-9,5}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-30,-5},{-50,5}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-70,-5},{-90,5}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid)}));
    end FreeMotion;

    model FreeMotionScalarInit
      "Free motion joint with scalar initialization and state selection (6 degrees-of-freedom, 12 potential states)"

      extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;

      parameter Boolean animation=true
        "= true, if animation shall be enabled (show arrow from frame_a to frame_b)"
        annotation(Dialog(enable=use_r));

      parameter Boolean use_r = false "= true, if r_rel_a shall be used"
          annotation(Evaluate=true, HideResult=true,Dialog(tab="Translational Initialization", group="Position vector r_rel_a from origin of frame_a to origin of frame_b, resolved in frame_a"));
      Modelica_Blocks.Interfaces.RealOutput r_rel_a_1(final quantity="Length", final unit="m", start=0, final stateSelect=r_rel_a_1_stateSelect) if use_r
        "Relative distance r_rel_a[1]"
        annotation(Dialog(enable=use_r, tab="Translational Initialization", group="Position vector r_rel_a from origin of frame_a to origin of frame_b, resolved in frame_a",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput r_rel_a_2(final quantity="Length", final unit="m", start=0, final stateSelect=r_rel_a_2_stateSelect) if use_r
        "Relative distance r_rel_a[2]"
        annotation(Dialog(enable=use_r, tab="Translational Initialization", group="Position vector r_rel_a from origin of frame_a to origin of frame_b, resolved in frame_a",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput r_rel_a_3(final quantity="Length", final unit="m", start=0, final stateSelect=r_rel_a_3_stateSelect) if use_r
        "Relative distance r_rel_a[3]"
        annotation(Dialog(enable=use_r, tab="Translational Initialization", group="Position vector r_rel_a from origin of frame_a to origin of frame_b, resolved in frame_a",showStartAttribute=true));

      parameter StateSelect r_rel_a_1_stateSelect=StateSelect.never
        "StateSelect of r_rel_a[1]" annotation(HideResult=true,
         Dialog(enable=use_r, tab="Translational Initialization", group="Position vector r_rel_a from origin of frame_a to origin of frame_b, resolved in frame_a"));
      parameter StateSelect r_rel_a_2_stateSelect=StateSelect.never
        "StateSelect of r_rel_a[2]" annotation(HideResult=true,
         Dialog(enable=use_r, tab="Translational Initialization", group="Position vector r_rel_a from origin of frame_a to origin of frame_b, resolved in frame_a"));
      parameter StateSelect r_rel_a_3_stateSelect=StateSelect.never
        "StateSelect of r_rel_a[3]" annotation(HideResult=true,
         Dialog(enable=use_r, tab="Translational Initialization", group="Position vector r_rel_a from origin of frame_a to origin of frame_b, resolved in frame_a"));

      parameter Boolean use_v = false "= true, if v_rel_a shall be used"
          annotation(Evaluate=true, HideResult=true,Dialog(enable=use_r, tab="Translational Initialization", group="Velocity vector v_rel_a = der(r_rel_a)"));
      Modelica_Blocks.Interfaces.RealOutput v_rel_a_1(final quantity="Velocity", final unit="m/s", start=0, final stateSelect=v_rel_a_1_stateSelect) if use_r and use_v
        "Relative velocity v_rel_a[1]"
        annotation(Dialog(enable=use_r and use_v, tab="Translational Initialization", group="Velocity vector v_rel_a = der(r_rel_a)",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput v_rel_a_2(final quantity="Velocity", final unit="m/s", start=0, final stateSelect=v_rel_a_2_stateSelect) if use_r and use_v
        "Relative velocity v_rel_a[2]"
        annotation(Dialog(enable=use_r and use_v, tab="Translational Initialization", group="Velocity vector v_rel_a = der(r_rel_a)",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput v_rel_a_3(final quantity="Velocity", final unit="m/s", start=0, final stateSelect=v_rel_a_3_stateSelect) if use_r and use_v
        "Relative velocity v_rel_a[3]"
        annotation(Dialog(enable=use_r and use_v, tab="Translational Initialization", group="Velocity vector v_rel_a = der(r_rel_a)",showStartAttribute=true));

      parameter StateSelect v_rel_a_1_stateSelect=StateSelect.never
        "StateSelect of v_rel_a[1]" annotation(HideResult=true,
         Dialog(enable=use_r and use_v, tab="Translational Initialization", group="Velocity vector v_rel_a = der(r_rel_a)"));
      parameter StateSelect v_rel_a_2_stateSelect=StateSelect.never
        "StateSelect of v_rel_a[2]" annotation(HideResult=true,
         Dialog(enable=use_r and use_v, tab="Translational Initialization", group="Velocity vector v_rel_a = der(r_rel_a)"));
      parameter StateSelect v_rel_a_3_stateSelect=StateSelect.never
        "StateSelect of v_rel_a[3]" annotation(HideResult=true,
         Dialog(enable=use_r and use_v, tab="Translational Initialization", group="Velocity vector v_rel_a = der(r_rel_a)"));

      parameter Boolean use_a = false "= true, if a_rel_a shall be used"
          annotation(Evaluate=true, HideResult=true,Dialog(enable=use_r and use_v, tab="Translational Initialization", group="Acceleration vector a_rel_a = der(v_rel_a)"));
      Modelica_Blocks.Interfaces.RealOutput a_rel_a_1(final quantity="Acceleration", final unit="m/s2", start=0) if use_r and use_v and use_a
        "Relative acceleration a_rel_a[1]"
        annotation(Dialog(enable=use_r and use_v and use_a, tab="Translational Initialization", group="Acceleration vector a_rel_a = der(v_rel_a)",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput a_rel_a_2(final quantity="Acceleration", final unit="m/s2", start=0) if use_r and use_v and use_a
        "Relative acceleration a_rel_a[2]"
        annotation(Dialog(enable=use_r and use_v and use_a, tab="Translational Initialization", group="Acceleration vector a_rel_a = der(v_rel_a)",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput a_rel_a_3(final quantity="Acceleration", final unit="m/s2", start=0) if use_r and use_v and use_a
        "Relative acceleration a_rel_a[3]"
        annotation(Dialog(enable=use_r and use_v and use_a, tab="Translational Initialization", group="Acceleration vector a_rel_a = der(v_rel_a)",showStartAttribute=true));

      parameter Boolean use_angle = false "= true, if angle shall be used"
        annotation(Evaluate=true, HideResult=true,Dialog(tab="Angle Initialization", group="Angles to rotate frame_a to frame_b along sequence_start"));

      parameter Types.RotationSequence sequence_start={1,2,3}
        "Sequence of angle rotations"
        annotation(Evaluate=true,Dialog(enable=use_angle, tab="Angle Initialization", group="Angles to rotate frame_a to frame_b along sequence_start"));

      Modelica_Blocks.Interfaces.RealOutput angle_1(final quantity="Angle", final unit="rad", start=0, stateSelect=angle_1_stateSelect) if use_angle
        "First rotation angle or dummy"
        annotation(Dialog(enable=use_angle, tab="Angle Initialization", group="Angles to rotate frame_a to frame_b along sequence_start",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput angle_2(final quantity="Angle", final unit="rad", start=0, stateSelect=angle_2_stateSelect) if use_angle
        "Second rotation angle or dummy"
        annotation(Dialog(enable=use_angle, tab="Angle Initialization", group="Angles to rotate frame_a to frame_b along sequence_start",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput angle_3(final quantity="Angle", final unit="rad", start=0, stateSelect=angle_3_stateSelect) if use_angle
        "Third rotation angle or dummy"
        annotation(Dialog(enable=use_angle, tab="Angle Initialization", group="Angles to rotate frame_a to frame_b along sequence_start",showStartAttribute=true));

      parameter StateSelect angle_1_stateSelect=StateSelect.never
        "StateSelect of angle_1"
         annotation(HideResult=true, Dialog(enable=use_angle, tab="Angle Initialization", group="Angles to rotate frame_a to frame_b along sequence_start"));
      parameter StateSelect angle_2_stateSelect=StateSelect.never
        "StateSelect of angle_2"
         annotation(HideResult=true, Dialog(enable=use_angle, tab="Angle Initialization", group="Angles to rotate frame_a to frame_b along sequence_start"));
      parameter StateSelect angle_3_stateSelect=StateSelect.never
        "StateSelect of angle_3"
         annotation(HideResult=true, Dialog(enable=use_angle, tab="Angle Initialization", group="Angles to rotate frame_a to frame_b along sequence_start"));

      parameter Boolean use_angle_d= false "= true, if angle_d shall be used"
        annotation(Evaluate=true, HideResult=true,Dialog(enable=use_angle, tab="Angle Initialization", group="angle_d = der(angle)"));

      Modelica_Blocks.Interfaces.RealOutput angle_d_1(final quantity="AngularVelocity", final unit="rad/s", start=0, final stateSelect=angle_d_1_stateSelect) if use_angle and use_angle_d
        "= der(angle_1)"
        annotation(Dialog(enable=use_angle and use_angle_d, tab="Angle Initialization", group="angle_d = der(angle)",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput angle_d_2(final quantity="AngularVelocity", final unit="rad/s", start=0, final stateSelect=angle_d_2_stateSelect) if use_angle and use_angle_d
        "= der(angle_2)"
        annotation(Dialog(enable=use_angle and use_angle_d, tab="Angle Initialization", group="angle_d = der(angle)",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput angle_d_3(final quantity="AngularVelocity", final unit="rad/s", start=0, final stateSelect=angle_d_3_stateSelect) if use_angle and use_angle_d
        "= der(angle_3)"
        annotation(Dialog(enable=use_angle and use_angle_d, tab="Angle Initialization", group="angle_d = der(angle)",showStartAttribute=true));

      parameter StateSelect angle_d_1_stateSelect=StateSelect.never
        "StateSelect of angle_d_1" annotation(HideResult=true,
         Dialog(enable=use_angle and use_angle_d, tab="Angle Initialization", group="angle_d = der(angle)"));
      parameter StateSelect angle_d_2_stateSelect=StateSelect.never
        "StateSelect of angle_d_2" annotation(HideResult=true,
         Dialog(enable=use_angle and use_angle_d, tab="Angle Initialization", group="angle_d = der(angle)"));
      parameter StateSelect angle_d_3_stateSelect=StateSelect.never
        "StateSelect of angle_d_3" annotation(HideResult=true,
         Dialog(enable=use_angle and use_angle_d, tab="Angle Initialization", group="angle_d = der(angle)"));

      parameter Boolean use_angle_dd = false
        "= true, if angle_dd shall be used"
          annotation(Evaluate=true, HideResult=true,Dialog(enable=use_angle and use_angle_d, tab="Angle Initialization", group="angle_dd = der(angle_d)"));
      Modelica_Blocks.Interfaces.RealOutput angle_dd_1(final quantity="AngularAcceleration", final unit="rad/s2", start=0) if use_angle and use_angle_d and use_angle_dd
        "= der(angle_d_1)"
        annotation(Dialog(enable=use_angle and use_angle_d and use_angle_dd, tab="Angle Initialization", group="angle_dd = der(angle_d)",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput angle_dd_2(final quantity="AngularAcceleration", final unit="rad/s2", start=0) if use_angle and use_angle_d and use_angle_dd
        "= der(angle_d_2)"
        annotation(Dialog(enable=use_angle and use_angle_d and use_angle_dd, tab="Angle Initialization", group="angle_dd = der(angle_d)",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput angle_dd_3(final quantity="AngularAcceleration", final unit="rad/s2", start=0) if use_angle and use_angle_d and use_angle_dd
        "= der(angle_d_3)"
        annotation(Dialog(enable=use_angle and use_angle_d and use_angle_dd, tab="Angle Initialization", group="angle_dd = der(angle_d)",showStartAttribute=true));

      parameter Boolean use_w = false "= true, if w_rel_b shall be used"
        annotation(Evaluate=true, HideResult=true,Dialog(tab="Angular Velocity Initialization", group="Angular velocity w_rel_b of frame_b with respect to frame_a, resolved in frame_b"));

      Modelica_Blocks.Interfaces.RealOutput w_rel_b_1(final quantity="AngularVelocity", final unit="rad/s", start=0, stateSelect=w_rel_b_1_stateSelect) if use_w
        "Relative angular velocity w_rel_b[1]"
        annotation(Dialog(enable=use_w, tab="Angular Velocity Initialization", group="Angular velocity w_rel_b of frame_b with respect to frame_a, resolved in frame_b",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput w_rel_b_2(final quantity="AngularVelocity", final unit="rad/s", start=0, stateSelect=w_rel_b_2_stateSelect) if use_w
        "Relative angular velocity w_rel_b[2]"
        annotation(Dialog(enable=use_w, tab="Angular Velocity Initialization", group="Angular velocity w_rel_b of frame_b with respect to frame_a, resolved in frame_b",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput w_rel_b_3(final quantity="AngularVelocity", final unit="rad/s", start=0, stateSelect=w_rel_b_3_stateSelect) if use_w
        "Relative angular velocity w_rel_b[3]"
        annotation(Dialog(enable=use_w, tab="Angular Velocity Initialization", group="Angular velocity w_rel_b of frame_b with respect to frame_a, resolved in frame_b",showStartAttribute=true));

      parameter StateSelect w_rel_b_1_stateSelect=StateSelect.never
        "StateSelect of w_rel_b[1]" annotation(HideResult=true,
         Dialog(enable=use_w, tab="Angular Velocity Initialization", group="Angular velocity w_rel_b of frame_b with respect to frame_a, resolved in frame_b"));
      parameter StateSelect w_rel_b_2_stateSelect=StateSelect.never
        "StateSelect of w_rel_b[2]" annotation(HideResult=true,
         Dialog(enable=use_w, tab="Angular Velocity Initialization", group="Angular velocity w_rel_b of frame_b with respect to frame_a, resolved in frame_b"));
      parameter StateSelect w_rel_b_3_stateSelect=StateSelect.never
        "StateSelect of w_rel_b[3]" annotation(HideResult=true,
         Dialog(enable=use_w, tab="Angular Velocity Initialization", group="Angular velocity w_rel_b of frame_b with respect to frame_a, resolved in frame_b"));

      parameter Boolean use_z = false "= true, if z_rel_b shall be used"
        annotation(Evaluate=true, HideResult=true,Dialog(enable=use_w, tab="Angular Velocity Initialization", group="Angular acceleration z_rel_b = der(w_rel_b)"));
      Modelica_Blocks.Interfaces.RealOutput z_rel_b_1(final quantity="AngularAcceleration", final unit="rad/s2", start=0) if use_w and use_z
        "Relative angular acceleration z_rel_b[1]"
        annotation(Dialog(enable=use_w and use_z, tab="Angular Velocity Initialization", group="Angular acceleration z_rel_b = der(w_rel_b)",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput z_rel_b_2(final quantity="AngularAcceleration", final unit="rad/s2", start=0) if use_w and use_z
        "Relative angular acceleration z_rel_b[2]"
        annotation(Dialog(enable=use_w and use_z, tab="Angular Velocity Initialization", group="Angular acceleration z_rel_b = der(w_rel_b)",showStartAttribute=true));
      Modelica_Blocks.Interfaces.RealOutput z_rel_b_3(final quantity="AngularAcceleration", final unit="rad/s2", start=0) if use_w and use_z
        "Relative angular acceleration z_rel_b[3]"
        annotation(Dialog(enable=use_w and use_z, tab="Angular Velocity Initialization", group="Angular acceleration z_rel_b = der(w_rel_b)",showStartAttribute=true));

      parameter Modelica_SIunits.Length arrowDiameter=world.defaultArrowDiameter
        "Diameter of arrow from frame_a to frame_b" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation and use_r));
      input Types.Color arrowColor=Types.Defaults.SensorColor "Color of arrow"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation and use_r));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation and use_r));

    protected
      Modelica_Mechanics_MultiBody.Joints.Internal.InitPosition initPosition(
        r_a_0=frame_a.r_0,
        r_b_0=frame_b.r_0,
        R_a=frame_a.R) if use_r
        annotation (Placement(transformation(extent={{-20,60},{0,80}})));
      Modelica_Mechanics_MultiBody.Joints.Internal.InitAngle initAngle(
          sequence_start=sequence_start) if use_angle
        annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
      Modelica_Mechanics_MultiBody.Joints.Internal.InitAngularVelocity initAngularVelocity(R_a=
            frame_a.R, R_b=frame_b.R) if use_w
        annotation (Placement(transformation(extent={{-20,20},{0,40}})));
      Modelica_Blocks.Continuous.Der derv[3] if use_r and use_v
        annotation (Placement(transformation(extent={{20,60},{40,80}})));
      Modelica_Blocks.Continuous.Der dera[3] if use_r and use_v and use_a
        annotation (Placement(transformation(extent={{60,60},{80,80}})));
      Modelica_Blocks.Continuous.Der derd[3] if use_angle and use_angle_d
        annotation (Placement(transformation(extent={{-20,-30},{0,-10}})));
      Modelica_Blocks.Continuous.Der derdd[3] if use_angle and use_angle_d and use_angle_dd
        annotation (Placement(transformation(extent={{20,-30},{40,-10}})));
      Modelica_Blocks.Continuous.Der derz[3] if use_w and use_z
        annotation (Placement(transformation(extent={{20,20},{40,40}})));
      Modelica_Mechanics_MultiBody.Sensors.Internal.ZeroForceAndTorque zeroForceAndTorque1
        annotation (Placement(transformation(extent={{-80,-50},{-60,-30}})));
      Modelica_Mechanics_MultiBody.Sensors.Internal.ZeroForceAndTorque zeroForceAndTorque2
        annotation (Placement(transformation(extent={{80,-50},{60,-30}})));
      Modelica_Mechanics_MultiBody.Visualizers.SignalArrow arrow(
        diameter=arrowDiameter,
        color=arrowColor,
        specularCoefficient=specularCoefficient) if world.enableAnimation and
        animation and use_r
        annotation (Placement(transformation(extent={{-80,60},{-60,80}})));
    equation
      // r_rel_a
      connect(initPosition.r_rel_a[1], r_rel_a_1);
      connect(initPosition.r_rel_a[2], r_rel_a_2);
      connect(initPosition.r_rel_a[3], r_rel_a_3);

      // v_rel_a
      connect(derv[1].y, v_rel_a_1);
      connect(derv[2].y, v_rel_a_2);
      connect(derv[3].y, v_rel_a_3);

      // a_rel_a
      connect(dera[1].y, a_rel_a_1);
      connect(dera[2].y, a_rel_a_2);
      connect(dera[3].y, a_rel_a_3);

      // angle
      connect(initAngle.angle[1], angle_1);
      connect(initAngle.angle[2], angle_2);
      connect(initAngle.angle[3], angle_3);

      // angle_d
      connect(derd[1].y, angle_d_1);
      connect(derd[2].y, angle_d_2);
      connect(derd[3].y, angle_d_3);

      // angle_dd
      connect(derdd[1].y, angle_dd_1);
      connect(derdd[2].y, angle_dd_2);
      connect(derdd[3].y, angle_dd_3);

      // w_rel_b
      connect(initAngularVelocity.w_rel_b[1], w_rel_b_1);
      connect(initAngularVelocity.w_rel_b[2], w_rel_b_2);
      connect(initAngularVelocity.w_rel_b[3], w_rel_b_3);

      // z_rel_b
      connect(derz[1].y, z_rel_b_1);
      connect(derz[2].y, z_rel_b_2);
      connect(derz[3].y, z_rel_b_3);

      connect(initPosition.r_rel_a, derv.u) annotation (Line(
          points={{1,70},{18,70}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(derv.y, dera.u) annotation (Line(
          points={{41,70},{58,70}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(initAngle.frame_a, frame_a) annotation (Line(
          points={{-60,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(initAngle.frame_b, frame_b) annotation (Line(
          points={{-40,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(initAngle.angle, derd.u) annotation (Line(
          points={{-50,-11},{-50,-20},{-22,-20}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(derd.y, derdd.u) annotation (Line(
          points={{1,-20},{18,-20}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(zeroForceAndTorque1.frame_a, frame_a) annotation (Line(
          points={{-80,-40},{-88,-40},{-88,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(zeroForceAndTorque2.frame_a, frame_b) annotation (Line(
          points={{80,-40},{90,-40},{90,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(initAngularVelocity.w_rel_b, derz.u) annotation (Line(
          points={{1,30},{18,30}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(frame_a, arrow.frame_a)       annotation (Line(
          points={{-100,0},{-88,0},{-88,70},{-80,70}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(initPosition.r_rel_a, arrow.r_head)       annotation (Line(
          points={{1,70},{10,70},{10,52},{-70,52},{-70,58}},
          color={0,0,127},
          smooth=Smooth.None));
      annotation (
        Documentation(info="<HTML>
<p>
Joint which does not constrain the motion between frame_a and frame_b.
Such a joint is meaningful if the <b>relative</b> distance and orientation
between frame_a and frame_b, and their derivatives, shall be used
as <b>states</b> or shall be used for non-standard
<b>initialization</b>. This joint allows to <b>initialize</b>
every <b>scalar</b> element of the relative quantities, as well
as to define <b>StateSelect</b> attributes for every
<b>scalar</b> element separately.
</p>

<p>
In the following figure the animation of a FreeMotionScalarInit
joint is shown. The light blue coordinate system is
frame_a and the dark blue coordinate system is
frame_b of the joint.
(here: r_rel_a_1(start = 0.5), r_rel_a_2(start = 0), r_rel_a_3(start = 0.5),
       angle_1(start = 45<sup>o</sup>), angle_2(start = 45<sup>o</sup>), angle_3(start = 45<sup>o</sup>)).
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/FreeMotion.png\">
</p>

<p>
A example to use this joint for the initialization of a planar double pendulum by providing
its tip position, is shown in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.DoublePendulumInitTip\">Examples.Elementary.DoublePendulumInitTip</a>.
</p>
</html>"),     Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(
              points={{-86,31},{-74,61},{-49,83},{-17,92},{19,88},{40,69},{59,48}},
              color={160,160,164},
              thickness=0.5,
              smooth=Smooth.Bezier),
            Polygon(
              points={{90,0},{50,20},{50,-20},{90,0}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{69,58},{49,40},{77,28},{69,58}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{150,-44},{-150,-84}},
              lineColor={0,0,255},
              textString="%name"),
            Rectangle(
              extent={{-70,-5},{-90,5}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{50,-5},{30,5}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{11,-5},{-9,5}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-30,-5},{-50,5}},
              lineColor={0,0,0},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}}), graphics));
    end FreeMotionScalarInit;

    model SphericalSpherical
      "Spherical - spherical joint aggregation (1 constraint, no potential states) with an optional point mass in the middle"

      import Modelica_Mechanics_MultiBody.Types;
      extends Interfaces.PartialTwoFrames;

      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Boolean showMass=true
        "= true, if mass shall be shown (provided animation = true and m > 0)";
      parameter Boolean computeRodLength=false
        "= true, if rodLength shall be computed during initialization (see info)";
      parameter Modelica_SIunits.Length rodLength(
        min=Modelica_Constants.eps,
        fixed=not computeRodLength,
        start=1)
        "Distance between the origins of frame_a and frame_b (if computeRodLength=true, guess value)";
      parameter Modelica_SIunits.Mass m(min=0) = 0
        "Mass of rod (= point mass located in middle of rod)";
      parameter Modelica_SIunits.Diameter sphereDiameter=world.defaultJointLength
        "Diameter of spheres representing the spherical joints" annotation (
          Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color sphereColor=Types.Defaults.JointColor
        "Color of spheres representing the spherical joints"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      parameter Modelica_SIunits.Diameter rodDiameter=sphereDiameter/Types.Defaults.JointRodDiameterFraction
        "Diameter of rod connecting the two spherical joint" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color rodColor=Types.Defaults.RodColor
        "Color of rod connecting the two spherical joints"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      parameter Modelica_SIunits.Diameter massDiameter=sphereDiameter
        "Diameter of sphere representing the mass point" annotation (Dialog(
          tab="Animation",
          group="if animation = true and showMass = true and m > 0",
          enable=animation and showMass and m > 0));
      input Types.Color massColor=Types.Defaults.BodyColor
        "Color of sphere representing the mass point"  annotation (
          Dialog(colorSelector=true, tab="Animation", group=
              "if animation = true and showMass = true and m > 0",
              enable=animation and showMass and m > 0));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));

      parameter Boolean kinematicConstraint=true
        "= false, if no constraint shall be defined, due to analytically solving a kinematic loop (\"false\" should not be used by user, but only by MultiBody.Joints.Assemblies joints)"
        annotation (Dialog(tab="Advanced"));
      Real constraintResidue = rRod_0*rRod_0 - rodLength*rodLength
        "Constraint equation of joint in residue form: Either length constraint (= default) or equation to compute rod force (for analytic solution of loops in combination with Internal.RevoluteWithLengthConstraint/PrismaticWithLengthConstraint)"
        annotation (Dialog(tab="Advanced", enable=not kinematicConstraint));
      parameter Boolean checkTotalPower=false
        "= true, if total power flowing into this component shall be determined (must be zero)"
        annotation (Dialog(tab="Advanced"));

      Modelica_SIunits.Force f_rod
        "Constraint force in direction of the rod (positive on frame_a, when directed from frame_a to frame_b)";
      Modelica_SIunits.Position rRod_0[3]
        "Position vector from frame_a to frame_b resolved in world frame";
      Modelica_SIunits.Position rRod_a[3]
        "Position vector from frame_a to frame_b resolved in frame_a";
      Real eRod_a[3](each final unit="1")
        "Unit vector in direction from frame_a to frame_b, resolved in frame_a";
      Modelica_SIunits.Position r_CM_0[3]
        "Dummy if m==0, or position vector from world frame to mid-point of rod, resolved in world frame";
      Modelica_SIunits.Velocity v_CM_0[3] "First derivative of r_CM_0";
      Modelica_SIunits.Force f_CM_a[3]
        "Dummy if m==0, or inertial force acting at mid-point of rod due to mass oint acceleration, resolved in frame_a";
      Modelica_SIunits.Force f_CM_e[3]
        "Dummy if m==0, or projection of f_CM_a onto eRod_a, resolved in frame_a";
      Modelica_SIunits.Force f_b_a1[3]
        "Force acting at frame_b, but without force in rod, resolved in frame_a";
      Modelica_SIunits.Power totalPower
        "Total power flowing into this element, if checkTotalPower=true (otherwise dummy)";

    protected
      Visualizers.Advanced.Shape shape_rod(
        shapeType="cylinder",
        color=rodColor,
        specularCoefficient=specularCoefficient,
        length=rodLength,
        width=rodDiameter,
        height=rodDiameter,
        lengthDirection=eRod_a,
        widthDirection={0,1,0},
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;
      Visualizers.Advanced.Shape shape_a(
        shapeType="sphere",
        color=sphereColor,
        specularCoefficient=specularCoefficient,
        length=sphereDiameter,
        width=sphereDiameter,
        height=sphereDiameter,
        lengthDirection=eRod_a,
        widthDirection={0,1,0},
        r_shape=-eRod_a*(sphereDiameter/2),
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;
      Visualizers.Advanced.Shape shape_b(
        shapeType="sphere",
        color=sphereColor,
        specularCoefficient=specularCoefficient,
        length=sphereDiameter,
        width=sphereDiameter,
        height=sphereDiameter,
        lengthDirection=eRod_a,
        widthDirection={0,1,0},
        r_shape=eRod_a*(rodLength - sphereDiameter/2),
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;
      Visualizers.Advanced.Shape shape_mass(
        shapeType="sphere",
        color=massColor,
        specularCoefficient=specularCoefficient,
        length=massDiameter,
        width=massDiameter,
        height=massDiameter,
        lengthDirection=eRod_a,
        widthDirection={0,1,0},
        r_shape=eRod_a*(rodLength/2 - sphereDiameter/2),
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation and showMass and m > 0;
    equation
      // Determine relative position vector between the two frames
      if kinematicConstraint then
        rRod_0 = transpose(frame_b.R.T)*(frame_b.R.T*frame_b.r_0) - transpose(
          frame_a.R.T)*(frame_a.R.T*frame_a.r_0);
      else
        rRod_0 = frame_b.r_0 - frame_a.r_0;
      end if;

      //rRod_0 = frame_b.r_0 - frame_a.r_0;
      rRod_a = Frames.resolve2(frame_a.R, rRod_0);
      eRod_a = rRod_a/rodLength;

      // Constraint equation
      constraintResidue = 0;

      // Cut-torques at frame_a and frame_b
      frame_a.t = zeros(3);
      frame_b.t = zeros(3);

      /* Force and torque balance of rod
     - Kinematics for center of mass CM of mass point
       r_CM_0 = frame_a.r_0 + rRod_0/2;
       v_CM_0 = der(r_CM_0);
       a_CM_a = resolve2(frame_a.R, der(v_CM_0) - world.gravityAcceleration(r_CM_0));
     - Inertial and gravity force in direction (f_CM_e) and orthogonal (f_CM_n) to rod
       f_CM_a = m*a_CM_a
       f_CM_e = f_CM_a*eRod_a;           // in direction of rod
       f_CM_n = rodLength(f_CM_a - f_CM_e);  // orthogonal to rod
     - Force balance in direction of rod
       f_CM_e = fa_rod_e + fb_rod_e;
     - Force balance orthogonal to rod
       f_CM_n = fa_rod_n + fb_rod_n;
     - Torque balance with respect to frame_a
       0 = (-f_CM_n)*rodLength/2 + fb_rod_n*rodLength
     The result is:
     fb_rod_n = f_CM_n/2;
     fa_rod_n = fb_rod_n;
     fb_rod_e = f_CM_e - fa_rod_e;
     fa_rod_e is the unknown computed from loop
  */

        // f_b_a1 is needed in aggregation joints to solve kinematic loops analytically
      if m > 0 then
        r_CM_0 = frame_a.r_0 + rRod_0/2;
        v_CM_0 = der(r_CM_0);
        f_CM_a = m*Frames.resolve2(frame_a.R, der(v_CM_0) -
          world.gravityAcceleration(r_CM_0));
        f_CM_e = (f_CM_a*eRod_a)*eRod_a;
        frame_a.f = (f_CM_a - f_CM_e)/2 + f_rod*eRod_a;
        f_b_a1 = (f_CM_a + f_CM_e)/2;
        frame_b.f = Frames.resolveRelative(f_b_a1 - f_rod*eRod_a, frame_a.R,
          frame_b.R);
      else
        r_CM_0 = zeros(3);
        v_CM_0 = zeros(3);
        f_CM_a = zeros(3);
        f_CM_e = zeros(3);
        f_b_a1 = zeros(3);
        frame_a.f = f_rod*eRod_a;
        frame_b.f = -Frames.resolveRelative(frame_a.f, frame_a.R, frame_b.R);
      end if;

      if checkTotalPower then
        totalPower = frame_a.f*Frames.resolve2(frame_a.R, der(frame_a.r_0)) +
          frame_b.f*Frames.resolve2(frame_b.R, der(frame_b.r_0)) + (-m)*(der(
          v_CM_0) - world.gravityAcceleration(r_CM_0))*v_CM_0 + frame_a.t*
          Frames.angularVelocity2(frame_a.R) + frame_b.t*Frames.angularVelocity2(
          frame_b.R);
      else
        totalPower = 0;
      end if;
      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Ellipse(
              extent={{-95,-40},{-15,40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{-84,-30},{-24,30}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{15,-40},{95,40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{25,-29},{85,30}},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,90},{150,50}},
              textString="%name",
              lineColor={0,0,255}),
            Rectangle(
              extent={{-40,40},{41,-41}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-51,6},{48,-4}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={192,192,192}),
            Ellipse(
              extent={{-68,15},{-39,-13}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{39,14},{68,-14}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Text(
              extent={{-150,-60},{150,-90}},
              lineColor={0,0,0},
              textString="%rodLength")}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Ellipse(
              extent={{-98,-40},{-18,40}},
              lineColor={0,0,0},
              fillColor={160,160,164},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-88,-30},{-28,30}},
              lineColor={160,160,164},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{18,-40},{98,40}},
              lineColor={160,160,164},
              fillColor={160,160,164},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{29,-30},{89,29}},
              lineColor={192,192,192},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(points={{-56,-60},{46,-60}}, color={0,0,255}),
            Polygon(
              points={{56,-60},{41,-54},{41,-66},{56,-60}},
              lineColor={0,0,255},
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-37,-63},{33,-79}},
              textString="rodLength",
              lineColor={0,0,255}),
            Rectangle(
              extent={{-40,41},{40,-40}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-51,6},{48,-4}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={192,192,192}),
            Ellipse(
              extent={{-71,15},{-42,-13}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{42,14},{71,-14}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{-56,-71},{-56,1}}, color={0,0,255}),
            Line(points={{56,-72},{56,0}}, color={0,0,255}),
            Polygon(points={{11,1},{-1,4},{-1,-2},{11,1}}, lineColor={0,0,255}),
            Line(points={{-56,1},{-1,1}}, color={0,0,255}),
            Text(
              extent={{-32,-4},{4,-29}},
              lineColor={0,0,0},
              textString="eRod_a")}),
        Documentation(info="<html>
<p>
Joint that has a spherical joint on each of its two ends.
The rod connecting the two spherical joints is approximated by a
point mass that is located in the middle of the rod. When the mass
is set to zero (default), special code for a massless body is generated.
In the following default animation figure, the two spherical joints are
represented by two red spheres, the connecting rod by a grey cylinder
and the point mass in the middle of the rod by a light blue sphere:
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/SphericalSpherical.png\" ALT=\"model Joints.SphericalSpherical\">
</p>

<p>
This joint introduces <b>one constraint</b> defining that the distance between
the origin of frame_a and the origin of frame_b is constant (= rodLength).
It is highly recommended to use this joint in loops
whenever possible, because this enhances the efficiency
considerably due to smaller systems of non-linear algebraic
equations.
</p>
<p>
It is sometimes desirable to <b>compute</b> the <b>rodLength</b>
of the connecting rod during initialization. For this, parameter
<b>computeLength</b> has to be set to <b>true</b> and instead <b>one</b> other,
easier to determine, position variable in the same loop
needs to have a fixed attribute of <b>true</b>. For example,
if a loop consists of one Revolute joint, one Prismatic joint and
a SphericalSpherical joint, one may fix the start values of the revolute
joint angle and of the relative distance of the prismatic joint
in order to compute the rodLength of the rod.
</p>
<p>
It is not possible to connect other components, such as a body with mass
properties or a special visual shape object to the rod connecting
the two spherical joints. If this is needed, use instead joint Joints.<b>UniversalSpherical</b>
that has this property.
</p>
</html>"));
    end SphericalSpherical;

    model UniversalSpherical
      "Universal - spherical joint aggregation (1 constraint, no potential states)"

      import Modelica_Mechanics_MultiBody.Types;

      extends Interfaces.PartialTwoFrames;
      Interfaces.Frame_a frame_ia
        "Coordinate system at the origin of frame_a, fixed at the rod connecting the universal with the spherical joint"
        annotation (Placement(transformation(
            origin={-40,100},
            extent={{-16,-16},{16,16}},
            rotation=270)));
      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Boolean showUniversalAxes=true
        "= true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)";
      parameter Boolean computeRodLength=false
        "= true, if distance between frame_a and frame_b shall be computed during initialization (see info)";
      parameter Modelica_Mechanics_MultiBody.Types.Axis n1_a={0,0,1}
        "Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod)"
        annotation (Evaluate=true);
      parameter Modelica_SIunits.Position rRod_ia[3]={1,0,0}
        "Vector from origin of frame_a to origin of frame_b, resolved in frame_ia (if computeRodLength=true, rRod_ia is only an axis vector along the connecting rod)"
        annotation (Evaluate=true);
      parameter Modelica_SIunits.Diameter sphereDiameter=world.defaultJointLength
        "Diameter of spheres representing the universal and the spherical joint"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color sphereColor=Types.Defaults.JointColor
        "Color of spheres representing the universal and the spherical joint"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      parameter Types.ShapeType rodShapeType="cylinder"
        "Shape type of rod connecting the universal and the spherical joint"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
      parameter Modelica_SIunits.Distance rodWidth=sphereDiameter/Types.Defaults.JointRodDiameterFraction
        "Width of rod shape in direction of axis 2 of universal joint."
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance rodHeight=rodWidth
        "Height of rod shape in direction that is orthogonal to rod and to axis 2"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Types.ShapeExtra rodExtra=0.0
        "Additional parameter depending on rodShapeType"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
      input Types.Color rodColor=Types.Defaults.RodColor
        "Color of rod shape connecting the universal and the spherical joints"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      parameter Modelica_SIunits.Distance cylinderLength=world.defaultJointLength
        "Length of cylinders representing the two universal joint axes"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true and showUniversalAxes",
          enable=animation and showUniversalAxes));
      parameter Modelica_SIunits.Distance cylinderDiameter=world.defaultJointWidth
        "Diameter of cylinders representing the two universal joint axes"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true and showUniversalAxes",
          enable=animation and showUniversalAxes));
      input Types.Color cylinderColor=Types.Defaults.JointColor
        "Color of cylinders representing the two universal joint axes" annotation (
          Dialog(colorSelector=true, tab="Animation", group="if animation = true and showUniversalAxes",
                                  enable=animation and showUniversalAxes));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));

      parameter Boolean kinematicConstraint=true
        "= false, if no constraint shall be defined, due to analytically solving a kinematic loop"
        annotation (Dialog(tab="Advanced"));
      Real constraintResidue = rRod_0*rRod_0 - rodLength*rodLength
        "Constraint equation of joint in residue form: Either length constraint (= default) or equation to compute rod force (for analytic solution of loops in combination with Internal.RevoluteWithLengthConstraint/PrismaticWithLengthConstraint)"
        annotation (Dialog(tab="Advanced", enable=not kinematicConstraint));
      parameter Boolean checkTotalPower=false
        "= true, if total power flowing into this component shall be determined (must be zero)"
        annotation (Dialog(tab="Advanced"));
      Modelica_SIunits.Force f_rod
        "Constraint force in direction of the rod (positive, if rod is pressed)";
      final parameter Modelica_SIunits.Distance rodLength(fixed=false, start=
            Modelica_Math.Vectors.length(rRod_ia))
        "Length of rod (distance between origin of frame_a and origin of frame_b)";
      final parameter Real eRod_ia[3](each final unit="1")=Modelica_Math.Vectors.normalizeWithAssert(rRod_ia)
        "Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia";
      final parameter Real e2_ia[3](each final unit="1")=Modelica_Math.Vectors.normalize(
                                                     cross(n1_a, eRod_ia))
        "Unit vector in direction of axis 2 of universal joint, resolved in frame_ia (orthogonal to n1_a and eRod_ia; note: frame_ia is parallel to frame_a when the universal joint angles are zero)";
      final parameter Real e3_ia[3](each final unit="1")=cross(eRod_ia, e2_ia)
        "Unit vector perpendicular to eRod_ia and e2_ia, resolved in frame_ia";
      Modelica_SIunits.Power totalPower
        "Total power flowing into this element, if checkTotalPower=true (otherwise dummy)";
      Modelica_SIunits.Force f_b_a1[3]
        "frame_b.f without f_rod part, resolved in frame_a (needed for analytic loop handling)";
      Real eRod_a[3](each final unit="1")
        "Unit vector in direction of rRod_a, resolved in frame_a (needed for analytic loop handling)";
      Modelica_SIunits.Position rRod_0[3](start=rRod_ia)
        "Position vector from origin of frame_a to origin of frame_b resolved in world frame";
      Modelica_SIunits.Position rRod_a[3](start=rRod_ia)
        "Position vector from origin of frame_a to origin of frame_b resolved in frame_a";

    protected
      Modelica_SIunits.Force f_b_a[3] "frame_b.f resolved in frame_a";
      Modelica_SIunits.Force f_ia_a[3] "frame_ia.f resolved in frame_a";
      Modelica_SIunits.Torque t_ia_a[3] "frame_ia.t resolved in frame_a";
      Real n2_a[3](each final unit="1")
        "Vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a";
      Real length2_n2_a(start=1, unit="1") "Square of length of vector n2_a";
      Real length_n2_a(unit="1") "Length of vector n2_a";
      Real e2_a[3](each final unit="1")
        "Unit vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a";
      Real e3_a[3](each final unit="1")
        "Unit vector perpendicular to eRod_ia and e2_a, resolved in frame_a";
      Real der_rRod_a_L[3](each unit="1/s") "= der(rRod_a)/rodLength";
      Modelica_SIunits.AngularVelocity w_rel_ia1[3];
      Frames.Orientation R_rel_ia1;
      Frames.Orientation R_rel_ia2;
      // Real T_rel_ia[3, 3];
      Frames.Orientation R_rel_ia "Rotation from frame_a to frame_ia";

      Visualizers.Advanced.Shape rodShape(
        shapeType=rodShapeType,
        color=rodColor,
        specularCoefficient=specularCoefficient,
        length=rodLength,
        width=rodWidth,
        height=rodHeight,
        lengthDirection=eRod_ia,
        widthDirection=e2_ia,
        r=frame_ia.r_0,
        R=frame_ia.R) if world.enableAnimation and animation;
      Visualizers.Advanced.Shape sphericalShape_b(
        shapeType="sphere",
        color=sphereColor,
        specularCoefficient=specularCoefficient,
        length=sphereDiameter,
        width=sphereDiameter,
        height=sphereDiameter,
        lengthDirection={1,0,0},
        widthDirection={0,1,0},
        r_shape={-0.5,0,0}*sphereDiameter,
        r=frame_b.r_0,
        R=frame_b.R) if world.enableAnimation and animation;
      Visualizers.Advanced.Shape sphericalShape_a(
        shapeType="sphere",
        color=sphereColor,
        specularCoefficient=specularCoefficient,
        length=sphereDiameter,
        width=sphereDiameter,
        height=sphereDiameter,
        lengthDirection={1,0,0},
        widthDirection={0,1,0},
        r_shape={-0.5,0,0}*sphereDiameter,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation and not showUniversalAxes;
      Visualizers.Advanced.Shape universalShape1(
        shapeType="cylinder",
        color=cylinderColor,
        specularCoefficient=specularCoefficient,
        length=cylinderLength,
        width=cylinderDiameter,
        height=cylinderDiameter,
        lengthDirection=n1_a,
        widthDirection={0,1,0},
        r_shape=-n1_a*(cylinderLength/2),
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation and showUniversalAxes;
      Visualizers.Advanced.Shape universalShape2(
        shapeType="cylinder",
        color=cylinderColor,
        specularCoefficient=specularCoefficient,
        length=cylinderLength,
        width=cylinderDiameter,
        height=cylinderDiameter,
        lengthDirection=e2_ia,
        widthDirection={0,1,0},
        r_shape=-e2_ia*(cylinderLength/2),
        r=frame_ia.r_0,
        R=frame_ia.R) if world.enableAnimation and animation and showUniversalAxes;

    initial equation
    if not computeRodLength then
      rodLength = Modelica_Math.Vectors.length(rRod_ia);
    end if;

    equation
      Connections.branch(frame_a.R, frame_ia.R);
      if kinematicConstraint then
        rRod_0 = transpose(frame_b.R.T)*(frame_b.R.T*frame_b.r_0) - transpose(
          frame_a.R.T)*(frame_a.R.T*frame_a.r_0);
      else
        rRod_0 = frame_b.r_0 - frame_a.r_0;
      end if;
      //rRod_0 = frame_b.r_0 - frame_a.r_0;
      rRod_a = Frames.resolve2(frame_a.R, rRod_0);

      // Constraint equation
      constraintResidue = 0;

      /* Determine relative Rotation R_rel_ia from frame_a to frame_ia
     and absolute rotation of frame_a.R.
  */
      eRod_a = rRod_a/rodLength;
      n2_a = cross(n1_a, eRod_a);
      length2_n2_a = n2_a*n2_a;

      assert(length2_n2_a > 1.e-10, "
A Modelica.Mechanics.MultiBody.Joints.UniversalSpherical joint (consisting of
a universal joint and a spherical joint connected together
by a rigid rod) is in the singular configuration of the
universal joint. This means that axis 1 of the universal
joint defined via parameter \"n1_a\" is parallel to vector
\"rRod_ia\" that is directed from the origin of frame_a to the
origin of frame_b.
   You may try to use another \"n1_a\" vector. If this fails,
use instead Modelica.Mechanics.MultiBody.Joints.SphericalSpherical, if this is
possible, because this joint aggregation does not have a
singular configuration.
");

      length_n2_a = sqrt(length2_n2_a);
      e2_a = n2_a/length_n2_a;
      e3_a = cross(eRod_a, e2_a);

      /* The statements below are an efficient implementation of the
   original equations:
     T_rel_ia = [eRod_ia, e2_ia, e3_ia]*transpose([eRod_a, e2_a, e3_a]);
     R_rel_ia = Frames.from_T(T_rel_ia,
                   Frames.TransformationMatrices.angularVelocity2(T_rel_ia, der(T_rel_ia)));
   To perform this, the rotation is split into two parts:
     R_rel_ia : Rotation object from frame_a to frame_ia
     R_rel_ia1: Rotation object from frame_a to frame_ia1
                (frame that is fixed in frame_ia such that x-axis
                is along the rod axis)
                T = transpose([eRod_a, e2_a, e3_a]; w = w_rel_ia1
     R_rel_ia2: Fixed rotation object from frame_ia1 to frame_ia
                T = [eRod_ia, e2_ia, e3_ia]; w = zeros(3)

   The difficult part is to compute w_rel_ia1:
      w_rel_ia1 = [  e3_a*der(e2_a);
                    -e3_a*der(eRod_a);
                     e2_a*der(eRod_a)]
   der(eRod_a) is directly given, since eRod_a is a function
   of translational quantities only.
      der(eRod_a) = (der(rRod_a) - eRod_a*(eRod_a*der(rRod_a)))/rodLength
      der(n2_a)   = cross(n1_a, der(eRod_a))
      der(e2_a)   = (der(n2_a) - e2_a*(e2_a*der(n2_a)))/length_n2_a
   Inserting these equations in w_rel_ia1 results in:
      e3_a*der(eRod_a) = e3_a*der(rRod_a)/rodLength       // e3_a*eRod_a = 0
      e2_a*der(eRod_a) = e2_a*der(rRod_a)/rodLength       // e2_a*eRod_a = 0
      e3_a*der(e2_a)   = e3_a*der(n2_a)/lenght_n2_a       // e3_a*e2_a = 0
                       = e3_a*cross(n1_a, der(eRod_a))/length_n2_a
                       = e3_a*cross(n1_a, der(rRod_a) - eRod_a*(eRod_a*der(rRod_a)))/(length_n2_a*rodLength)
                       = e3_a*cross(n1_a, der(rRod_a))/(length_n2_a*rodLength)
   Furthermore, we have:
     rRod_a            = resolve2(frame_a.R, rRod_0);
     der(rRod_a)       = resolve2(frame_a.R, der(rRod_0)) - cross(frame_a.R.w, rRod_a));
*/
      der_rRod_a_L = (Frames.resolve2(frame_a.R, der(rRod_0)) - cross(frame_a.R.w,
         rRod_a))/rodLength;
      w_rel_ia1 = {e3_a*cross(n1_a, der_rRod_a_L)/length_n2_a,-e3_a*der_rRod_a_L,
        e2_a*der_rRod_a_L};
      R_rel_ia1 = Frames.from_T(transpose([eRod_a, e2_a, e3_a]), w_rel_ia1);
      R_rel_ia2 = Frames.from_T([eRod_ia, e2_ia, e3_ia], zeros(3));
      R_rel_ia = Frames.absoluteRotation(R_rel_ia1, R_rel_ia2);
      /*
  T_rel_ia = [eRod_ia, e2_ia, e3_ia]*transpose([eRod_a, e2_a, e3_a]);
  R_rel_ia = Frames.from_T(T_rel_ia,
    Frames.TransformationMatrices.angularVelocity2(T_rel_ia, der(T_rel_ia)));
*/

      // Compute kinematic quantities of frame_ia
      frame_ia.r_0 = frame_a.r_0;
      frame_ia.R = Frames.absoluteRotation(frame_a.R, R_rel_ia);

      /* In the following formulas f_a, f_b, f_ia, t_a, t_b, t_ia are
     the forces and torques at frame_a, frame_b, frame_ia, respectively,
     resolved in frame_a. e_x, e_y, e_z are the unit vectors resolved in frame_a.
     Torque balance at the rod around the origin of frame_a:
       0 = t_a + t_ia + cross(rRod_a, f_b)
     with
         rRod_a = rodLength*e_x
         f_b     = -f_rod*e_x + f_b[2]*e_y + f_b[3]*e_z
     follows:
       0 = t_a + t_ia + rodLength*(f_b[2]*e_z - f_b[3]*e_y)
     The projection of t_a with respect to universal joint axes vanishes:
       n1_a*t_a = 0
       e_y*t_a = 0
     Therefore:
        0 = n1_a*t_ia + rodLength*f_b[2]*(n1_a*e_z)
        0 = e_y*t_ia - rodLength*f_b[3]
     or
        f_b = -f_rod*e_x - e_y*(n1_a*t_ia)/(rodLength*(n1_a*e_z)) + e_z*(e_y*t_ia)/rodLength
     Force balance:
        0 = f_a + f_b + f_ia
  */
      f_ia_a = Frames.resolve1(R_rel_ia, frame_ia.f);
      t_ia_a = Frames.resolve1(R_rel_ia, frame_ia.t);

        // f_b_a1 is needed in aggregation joints to solve kinematic loops analytically
      f_b_a1 = -e2_a*((n1_a*t_ia_a)/(rodLength*(n1_a*e3_a))) + e3_a*((e2_a*t_ia_a)
        /rodLength);
      f_b_a = -f_rod*eRod_a + f_b_a1;
      frame_b.f = Frames.resolveRelative(f_b_a, frame_a.R, frame_b.R);
      frame_b.t = zeros(3);
      zeros(3) = frame_a.f + f_b_a + f_ia_a;
      zeros(3) = frame_a.t + t_ia_a + cross(rRod_a, f_b_a);

      // Measure power for test purposes
      if checkTotalPower then
        totalPower = frame_a.f*Frames.resolve2(frame_a.R, der(frame_a.r_0)) +
          frame_b.f*Frames.resolve2(frame_b.R, der(frame_b.r_0)) + frame_ia.f*
          Frames.resolve2(frame_ia.R, der(frame_ia.r_0)) + frame_a.t*
          Frames.angularVelocity2(frame_a.R) + frame_b.t*Frames.angularVelocity2(
          frame_b.R) + frame_ia.t*Frames.angularVelocity2(frame_ia.R);
      else
        totalPower = 0;
      end if;
      annotation (
        Documentation(info="<html>
<p>
This component consists of a <b>universal joint</b> at frame_a and
a <b>spherical joint</b> at frame_b that are connected together with
a <b>rigid rod</b>, see default animation figure (the arrows are not
part of the default animation):
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/UniversalSpherical.png\" ALT=\"model Joints.UniversalSpherical\">
</p>

<p>
This joint aggregation has no mass and no inertia and introduces the constraint
that the distance between the origin of frame_a and the origin of frame_b is constant
(= Frames.length(rRod_ia)). The universal joint is defined in the following way:
</p>

<ul>
<li> The rotation <b>axis</b> of revolute joint <b>1</b> is along parameter
     vector n1_a which is fixed in frame_a.</li>
<li> The rotation <b>axis</b> of revolute joint <b>2</b> is perpendicular to
     axis 1 and to the line connecting the universal and the spherical joint.</li>
</ul>
<p>
The definition of axis 2 of the universal joint is performed according
to the most often occurring case. In a future release, axis 2 might
be explicitly definable via a parameter. However, the treatment is much more
complicated and the number of operations is considerably higher,
if axis 2 is not orthogonal to axis 1 and to the connecting rod.
</p>
<p>
Note, there is a <b>singularity</b> when axis 1 and the connecting rod are parallel
to other. Therefore, if possible n1_a should be selected in such a way that it
is perpendicular to rRod_ia in the initial configuration (i.e., the
distance to the singularity is as large as possible).
</p>
<p>
An additional <b>frame_ia</b> is present. It is <b>fixed</b> in the connecting
<b>rod</b> at the origin of <b>frame_a</b>. The placement of frame_ia on the rod
is implicitly defined by the universal joint (frame_a and frame_ia coincide
when the angles of the two revolute joints of the universal joint are zero)
and by parameter vector <b>rRod_ia</b>, the position vector
from the origin of frame_a to the origin of frame_b, resolved in frame_<b>ia</b>.
</p>
<p>
The easiest way to define the parameters of this joint is by moving the
MultiBody system in a <b>reference configuration</b> where <b>all frames</b>
of all components are <b>parallel</b> to other (alternatively,
at least frame_a and frame_ia of the UniversalSpherical joint
should be parallel to other when defining an instance of this
component). Since frame_a and frame_ia are parallel to other,
vector <b>rRod_ia</b> from frame_a to frame_b resolved in frame_<b>ia</b> can be resolved
in frame_<b>a</b> (or the <b>world frame</b>, if all frames are parallel to other).
</p>
<p>
This joint aggregation can be used in cases where
in reality a rod with spherical joints at end are present.
Such a system has an additional degree of freedom to rotate
the rod along its axis. In practice this rotation is usually
of no interest and is mathematically removed by replacing one
of the spherical joints by a universal joint. Still, in most
cases the Joints.SphericalSpherical joint aggregation can be used instead
of the UniversalSpherical joint
since the rod is animated and its mass properties are approximated by
a point mass in the middle of the rod. The SphericalSpherical joint
has the advantage that it does not have a singular configuration.
</p>
<p>
In the public interface of the UniversalSpherical joint, the following
(final) <b>parameters</b> are provided:
</p>
<pre>
  <b>parameter</b> Real rodLength(unit=\"m\")  \"Length of rod\";
  <b>parameter</b> Real eRod_ia[3] \"Unit vector along rod, resolved in frame_ia\";
  <b>parameter</b> Real e2_ia  [3] \"Unit vector along axis 2, resolved in frame_ia\";
</pre>
<p>
This allows a more convenient definition of data which is related to the rod.
For example, if a box shall be connected at frame_ia directing from
the origin of frame_a to the middle of the rod, this might be defined as:
</p>
<pre>
    Modelica.Mechanics.MultiBody.Joints.UniversalSpherical jointUS(rRod_ia={1.2, 1, 0.2});
    Modelica.Mechanics.MultiBody.Visualizers.FixedShape    shape(shapeType       = \"box\",
                                              lengthDirection = jointUS.eRod_ia,
                                              widthDirection  = jointUS.e2_ia,
                                              length          = jointUS.rodLength/2,
                                              width           = jointUS.rodLength/10);
  <b>equation</b>
    <b>connect</b>(jointUS.frame_ia, shape.frame_a);
</pre>
</html>"),     Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Text(
              extent={{-150,-50},{150,-90}},
              lineColor={0,0,255},
              textString="%name"),
            Ellipse(
              extent={{-100,-40},{-19,40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{-90,-30},{-29,29}},
              lineColor={160,160,164},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-60,41},{-9,-44}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-60,40},{-60,-40}},
              color={0,0,0},
              thickness=0.5),
            Ellipse(
              extent={{-83,-17},{-34,21}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{-74,-12},{-40,15}},
              lineColor={160,160,164},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-72,-20},{-89,3},{-69,25},{-45,27},{-72,-20}},
              pattern=LinePattern.None,
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,255}),
            Line(
              points={{-60,40},{-60,-10}},
              color={0,0,0},
              thickness=0.5),
            Line(
              points={{-49,20},{-69,-15}},
              color={0,0,0},
              thickness=0.5),
            Ellipse(
              extent={{44,14},{73,-14}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{20,-40},{100,40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{30,-30},{90,30}},
              lineColor={192,192,192},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-22,45},{40,-43}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{46,14},{75,-14}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Rectangle(
              extent={{-36,-8},{48,8}},
              lineColor={0,0,0},
              pattern=LinePattern.None,
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={192,192,192}),
            Text(
              extent={{-105,118},{-67,86}},
              lineColor={128,128,128},
              textString="ia"),
            Text(
              extent={{-24,95},{167,65}},
              lineColor={0,0,0},
              textString="%rRod_ia"),
            Line(
              points={{-40,101},{-40,60},{-60,1}},
              color={128,128,128},
              thickness=0.5)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{-60,-70},{46,-70}}, color={0,0,255}),
            Polygon(
              points={{60,-70},{45,-64},{45,-76},{60,-70}},
              lineColor={0,0,255},
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-56,-71},{56,-90}},
              textString="rRod",
              lineColor={0,0,255}),
            Ellipse(
              extent={{-100,-40},{-19,40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{-90,-30},{-29,29}},
              lineColor={160,160,164},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-60,41},{-19,-41}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-60,40},{-60,-40}},
              color={0,0,0},
              thickness=0.5),
            Ellipse(
              extent={{-83,-17},{-34,21}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{-74,-12},{-40,15}},
              lineColor={160,160,164},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-72,-20},{-89,3},{-69,25},{-45,27},{-72,-20}},
              pattern=LinePattern.None,
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,255}),
            Line(
              points={{-60,40},{-60,-10}},
              color={0,0,0},
              thickness=0.5),
            Line(
              points={{-49,20},{-69,-15}},
              color={0,0,0},
              thickness=0.5),
            Polygon(points={{7,-1},{-5,2},{-5,-4},{7,-1}}, lineColor={0,0,255}),
            Line(points={{-50,19},{-30,57}}, color={0,0,255}),
            Text(
              extent={{-34,78},{8,62}},
              lineColor={0,0,0},
              textString="e2"),
            Polygon(points={{-25,64},{-33,56},{-27,53},{-25,64}}, lineColor={0,0,
                  255}),
            Line(points={{-60,41},{-60,65}}, color={0,0,255}),
            Polygon(points={{-60,75},{-64,63},{-56,63},{-60,75}}, lineColor={0,0,
                  255}),
            Text(
              extent={{-93,82},{-64,62}},
              lineColor={0,0,0},
              textString="n1"),
            Line(points={{-60,-40},{-60,-72}}, color={0,0,255}),
            Ellipse(
              extent={{20,-40},{100,40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={192,192,192}),
            Ellipse(
              extent={{30,-30},{90,30}},
              lineColor={192,192,192},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-22,45},{40,-43}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{45,14},{74,-14}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-36,-8},{48,8}},
              lineColor={0,0,0},
              pattern=LinePattern.None,
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={192,192,192}),
            Text(
              extent={{-31,-7},{0,-28}},
              lineColor={0,0,0},
              textString="eRod"),
            Line(points={{-60,0},{-5,0}}, color={0,0,255}),
            Polygon(points={{7,0},{-5,3},{-5,-3},{7,0}}, lineColor={0,0,255}),
            Line(points={{60,-1},{60,-72}}, color={0,0,255}),
            Line(
              points={{-40,100},{-40,70},{-60,0}},
              color={128,128,128},
              thickness=0.5),
            Text(
              extent={{-23,30},{26,10}},
              textString=" eRod*e2 = 0;  n1*e2 = 0",
              lineColor={0,0,255})}));
    end UniversalSpherical;

    model GearConstraint "Ideal 3-dim. gearbox (arbitrary shaft directions)"
      extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;
      Interfaces.Frame_a bearing "Coordinate system fixed in the bearing"
       annotation (Placement(transformation(
            origin={0,-100},
            extent={{-16,-16},{16,16}},
            rotation=90)));

      parameter Real ratio(start=2) "Gear speed ratio";

      parameter Modelica_Mechanics_MultiBody.Types.Axis n_a={1,0,0}
        "Axis of rotation of shaft a (same coordinates in frame_a, frame_b, bearing)";
      parameter Modelica_Mechanics_MultiBody.Types.Axis n_b={1,0,0}
        "Axis of rotation of shaft b (same coordinates in frame_a, frame_b, bearing)";

      parameter Modelica_SIunits.Position r_a[3]={0,0,0}
        "Vector from frame bearing to frame_a resolved in bearing";
      parameter Modelica_SIunits.Position r_b[3]={0,0,0}
        "Vector from frame bearing to frame_b resolved in bearing";
      parameter StateSelect stateSelect=StateSelect.default
        "Priority to use joint coordinates (phi_a, phi_b, w_a, w_b) as states" annotation(Dialog(tab="Advanced"));

      Modelica_SIunits.Angle phi_b(start=0, stateSelect=stateSelect)
        "Relative rotation angle of revolute joint at frame_b";
      Modelica_SIunits.AngularVelocity w_b(start=0, stateSelect=stateSelect)
        "First derivative of angle phi_b (relative angular velocity b)";
      Modelica_SIunits.AngularAcceleration a_b(start=0)
        "Second derivative of angle phi_b (relative angular acceleration b)";

      Modelica_Mechanics_MultiBody.Joints.Revolute actuatedRevolute_a(
        useAxisFlange=true,
        n=n_a,
        animation=false) annotation (Placement(transformation(extent={{-40,-10},
                {-60,10}}, rotation=0)));
      Modelica_Mechanics_MultiBody.Joints.Revolute actuatedRevolute_b(
        useAxisFlange=true,
        n=n_b,
        animation=false) annotation (Placement(transformation(extent={{40,-10},
                {60,10}}, rotation=0)));
      Modelica_Mechanics_Rotational.Components.IdealGear idealGear(
                                                        ratio=ratio)
        annotation (Placement(transformation(extent={{-10,30},{10,50}}, rotation=
                0)));
      Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation1(animation=
           false, r=r_b) annotation (Placement(transformation(extent={{10,-10},
                {30,10}}, rotation=0)));
      Modelica_Mechanics_MultiBody.Parts.FixedTranslation fixedTranslation2(animation=
           false, r=r_a) annotation (Placement(transformation(
            origin={-20,0},
            extent={{-10,-10},{10,10}},
            rotation=180)));
    equation
      assert(cardinality(bearing) > 0,
        "Connector bearing of component is not connected");

      phi_b = actuatedRevolute_b.phi;
      w_b = der(phi_b);
      a_b = der(w_b);

      connect(actuatedRevolute_a.axis, idealGear.flange_a)
        annotation (Line(points={{-50,10},{-50,40},{-10,40}}, color={0,0,0}));
      connect(idealGear.flange_b, actuatedRevolute_b.axis)
        annotation (Line(points={{10,40},{50,40},{50,10}}, color={0,0,0}));
      connect(actuatedRevolute_a.frame_a,fixedTranslation2. frame_b) annotation (Line(
          points={{-40,0},{-35,0},{-30,0}},
          color={95,95,95},
          thickness=0.5));
      connect(fixedTranslation2.frame_a, bearing) annotation (Line(
          points={{-10,0},{-4,0},{0,0},{0,-100}},
          color={95,95,95},
          thickness=0.5));
      connect(fixedTranslation1.frame_a, bearing)
        annotation (Line(
          points={{10,0},{0,0},{0,-100}},
          color={95,95,95},
          thickness=0.5));
      connect(fixedTranslation1.frame_b, actuatedRevolute_b.frame_a)
        annotation (Line(
          points={{30,0},{40,0}},
          color={95,95,95},
          thickness=0.5));
      connect(frame_a, actuatedRevolute_a.frame_b)
        annotation (Line(
          points={{-100,0},{-80,0},{-80,0},{-60,0}},
          color={95,95,95},
          thickness=0.5));
      connect(actuatedRevolute_b.frame_b, frame_b)
        annotation (Line(
          points={{60,0},{80,0},{80,0},{100,0}},
          color={95,95,95},
          thickness=0.5));
      annotation (
        Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}), graphics={
          Text(origin=  {0,-20},
            lineColor=  {0,0,255},
            extent=  {{-150,135},{150,175}},
            textString=  "%name"),
          Text(origin=  {0,12},
            extent=  {{-150,-94},{150,-64}},
            textString=  "%ratio"),
          Rectangle(origin=  {-35,60},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.HorizontalCylinder,
            extent=  {{-15,-40},{15,40}}),
          Rectangle(origin=  {-35,0},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.HorizontalCylinder,
            extent=  {{-15,-21},{15,21}}),
          Line(points=  {{-80,20},{-60,20}}),
          Line(points=  {{-80,-20},{-60,-20}}),
          Line(points=  {{-70,-20},{-70,-86}}),
          Line(points=  {{0,40},{0,-100}}),
          Line(points=  {{-10,40},{10,40}}),
          Line(points=  {{-10,80},{10,80}}),
          Line(points=  {{60,-20},{80,-20}}),
          Line(points=  {{60,20},{80,20}}),
          Line(points=  {{70,-20},{70,-86}}),
          Rectangle(origin=  {-75,0},
            lineColor=  {64,64,64},
            fillColor=  {191,191,191},
            fillPattern=  FillPattern.HorizontalCylinder,
            extent=  {{-25,-10},{25,10}}),
          Rectangle(origin=  {75,0},
            lineColor=  {64,64,64},
            fillColor=  {191,191,191},
            fillPattern=  FillPattern.HorizontalCylinder,
            extent=  {{-25,-10},{25,10}}),
          Rectangle(origin=  {-35,-19},
            fillColor=  {153,153,153},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-2},{15,2}}),
          Rectangle(origin=  {-35,-8},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {-35,19},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-2},{15,2}}),
          Rectangle(origin=  {-35,8},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {0,60},
            lineColor=  {64,64,64},
            fillColor=  {191,191,191},
            fillPattern=  FillPattern.HorizontalCylinder,
            extent=  {{-20,-10},{20,10}}),
          Rectangle(origin=  {-35,98},
            fillColor=  {153,153,153},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-2},{15,2}}),
          Rectangle(origin=  {-35,87},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {-35,50},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-4},{15,4}}),
          Rectangle(origin=  {-35,22},
            fillColor=  {102,102,102},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-2},{15,2}}),
          Rectangle(origin=  {-35,33},
            fillColor=  {153,153,153},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {-35,70},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-4},{15,4}}),
          Rectangle(origin=  {35,60},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.HorizontalCylinder,
            extent=  {{-15,-21},{15,21}}),
          Rectangle(origin=  {35,41},
            fillColor=  {153,153,153},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-2},{15,2}}),
          Rectangle(origin=  {35,52},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {35,79},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-2},{15,2}}),
          Rectangle(origin=  {35,68},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {35,0},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.HorizontalCylinder,
            extent=  {{-15,-40},{15,40}}),
          Rectangle(origin=  {35,38},
            fillColor=  {153,153,153},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-2},{15,2}}),
          Rectangle(origin=  {35,27},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {35,-10},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-4},{15,4}}),
          Rectangle(origin=  {35,-27},
            fillColor=  {153,153,153},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {35,10},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-4},{15,4}}),
          Rectangle(origin=  {-35,40},
            fillColor=  {255,255,255},
            extent=  {{-15,-61},{15,60}}),
          Rectangle(origin=  {35,21},
            fillColor=  {255,255,255},
            extent=  {{-15,-61},{15,60}}),
          Line(points=  {{70,-86},{-70,-86}})}),
        Documentation(info="<html>
<p>This ideal massless joint provides a gear constraint between
frames <code>frame_a</code> and <code>frame_b</code>. The axes of rotation
of <code>frame_a</code> and <code>frame_b</code> may be arbitrary.</p>
<p><b>Reference</b><br>
<span style=\"font-variant:small-caps\">Schweiger</span>, Christian ;
<span style=\"font-variant:small-caps\">Otter</span>, Martin:
<a href=\"https://www.modelica.org/events/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf\">Modelling
3D Mechanical Effects of 1-dim. Powertrains</a>. In: <i>Proceedings of the 3rd International
Modelica Conference</i>. Link&ouml;ping : The Modelica Association and Link&ouml;ping University,
November 3-4, 2003, pp. 149-158</p>
</html>"));
    end GearConstraint;

      model RollingWheel
      "Joint (no mass, no inertia) that describes an ideal rolling wheel (rolling on the plane z=0)"

      import Modelica_Mechanics_MultiBody.Frames;

        Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a
        "Frame fixed in wheel center point. x-Axis: upwards, y-axis: along wheel axis"
        annotation (Placement(transformation(extent={{-16,-16},{16,16}})));

      parameter Modelica_SIunits.Radius wheelRadius "Wheel radius";
        parameter StateSelect stateSelect=StateSelect.always
        "Priority to use generalized coordinates as states"   annotation(HideResult=true,Evaluate=true);

      Modelica_SIunits.Position x(start=0, stateSelect=stateSelect)
        "x-coordinate of wheel axis";

      Modelica_SIunits.Position y(start=0, stateSelect=stateSelect)
        "y-coordinate of wheel axis";
      Modelica_SIunits.Position z;

      Modelica_SIunits.Angle angles[3](start={0,0,0}, each stateSelect=
            stateSelect)
        "Angles to rotate world-frame in to frame_a around z-, y-, x-axis"
        annotation (Dialog(group="Initialization", showStartAttribute=true));

      Modelica_SIunits.AngularVelocity der_angles[3](start={0,0,0}, each
          stateSelect=stateSelect) "Derivative of angles"
        annotation (Dialog(group="Initialization", showStartAttribute=true));

      Modelica_SIunits.Position r_road_0[3]
        "Position vector from world frame to contact point on road, resolved in world frame";

        // Contact force
      Modelica_SIunits.Force f_wheel_0[3]
        "Contact force acting on wheel, resolved in world frame";
      Modelica_SIunits.Force f_n
        "Contact force acting on wheel in normal direction";
      Modelica_SIunits.Force f_lat
        "Contact force acting on wheel in lateral direction";
      Modelica_SIunits.Force f_long
        "Contact force acting on wheel in longitudinal direction";
      Modelica_SIunits.Position err
        "|r_road_0 - frame_a.r_0| - wheelRadius (must be zero; used for checking)";
    protected
         Real e_axis_0[3]
        "Unit vector along wheel axis, resolved in world frame";
      Modelica_SIunits.Position delta_0[3](start={0,0,-wheelRadius})
        "Distance vector from wheel center to contact point";

         // Coordinate system at contact point
         Real e_n_0[3]
        "Unit vector in normal direction of road at contact point, resolved in world frame";
         Real e_lat_0[3]
        "Unit vector in lateral direction of wheel at contact point, resolved in world frame";
         Real e_long_0[3]
        "Unit vector in longitudinal direction of wheel at contact point, resolved in world frame";

         // Road description
      Modelica_SIunits.Position s "Road surface parameter 1";
      Modelica_SIunits.Position w "Road surface parameter 2";
         Real e_s_0[3]
        "Road heading at (s,w), resolved in world frame (unit vector)";

         // Slip velocities
      Modelica_SIunits.Velocity v_0[3]
        "Velocity of wheel center, resolved in world frame";
      Modelica_SIunits.AngularVelocity w_0[3]
        "Angular velocity of wheel, resolved in world frame";

      Modelica_SIunits.Velocity vContact_0[3]
        "Velocity of wheel contact point, resolved in world frame";

         // Utility vectors
         Real aux[3];

      equation
         // frame_a.R is computed from generalized coordinates
         Connections.root(frame_a.R);
         frame_a.r_0 = {x,y,z};
         der_angles  = der(angles);
         frame_a.R = Frames.axesRotations({3,2,1}, angles, der_angles);

         // Road description
         r_road_0 = {s,w,0};
         e_n_0    = {0,0,1};
         e_s_0    = {1,0,0};

         // Coordinate system at contact point (e_long_0, e_lat_0, e_n_0)
         e_axis_0  = Frames.resolve1(frame_a.R, {0,1,0});
         aux       = cross(e_n_0, e_axis_0);
         e_long_0 = aux / Modelica_Math.Vectors.length(aux);
         e_lat_0  = cross(e_long_0, e_n_0);

         // Determine point on road where the wheel is in contact with the road
         delta_0 = r_road_0 - frame_a.r_0;
         0 = delta_0*e_axis_0;
         0 = delta_0*e_long_0;

         // One holonomic positional constraint equation (no penetration in to the ground)
         0 = wheelRadius - delta_0*cross(e_long_0, e_axis_0);

         // only for testing
         err = Modelica_Math.Vectors.length(delta_0) - wheelRadius;

         // Slip velocities
         v_0 = der(frame_a.r_0);
         w_0 = Frames.angularVelocity1(frame_a.R);
         vContact_0 = v_0 + cross(w_0, delta_0);

         // Two non-holonomic constraint equations on velocity level (ideal rolling, no slippage)
         0 = vContact_0*e_long_0;
         0 = vContact_0*e_lat_0;

         // Contact force
         f_wheel_0 = f_n*e_n_0 + f_lat*e_lat_0 + f_long*e_long_0;

         // Force and torque balance at the wheel center
         zeros(3) = frame_a.f + Frames.resolve2(frame_a.R, f_wheel_0);
         zeros(3) = frame_a.t + Frames.resolve2(frame_a.R, cross(delta_0, f_wheel_0));

         // Guard against singularity
         assert(abs(e_n_0*e_axis_0) < 0.99, "Wheel lays nearly on the ground (which is a singularity)");
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,-80},{100,-100}},
                lineColor={0,0,0},
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-154,124},{146,84}},
                lineColor={0,0,255},
                textString="%name"),
              Ellipse(
                extent={{-80,80},{80,-80}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}));
      end RollingWheel;

      model RollingWheelSet
      "Joint (no mass, no inertia) that describes an ideal rolling wheel set (two ideal rolling wheels connected together by an axis)"
       Modelica_Mechanics_MultiBody.Interfaces.Frame_a frameMiddle
        "Frame fixed in middle of axis connecting both wheels (y-axis: along wheel axis, z-Axis: upwards)"
        annotation (Placement(transformation(extent={{-16,16},{16,-16}}),
            iconTransformation(extent={{-16,-16},{16,16}})));

        parameter Boolean animation=true
        "= true, if animation of wheel set shall be enabled";

      parameter Modelica_SIunits.Radius wheelRadius "Radius of one wheel";
      parameter Modelica_SIunits.Distance wheelDistance
        "Distance between the two wheels";

        parameter StateSelect stateSelect = StateSelect.default
        "Priority to use the generalized coordinates as states";

        Modelica_SIunits.Position x(start=0, stateSelect=stateSelect)
        "x coordinate for center between wheels";
        Modelica_SIunits.Position y(start=0, stateSelect=stateSelect)
        "y coordinate for center between wheels";
        Modelica_SIunits.Angle phi(start=0, stateSelect=stateSelect)
        "Orientation angle of wheel axis along z-axis";
        Modelica_SIunits.Angle theta1(start=0, stateSelect=stateSelect)
        "Angle of wheel 1";
        Modelica_SIunits.Angle theta2(start=0, stateSelect=stateSelect)
        "Angle of wheel 2";
        Modelica_SIunits.AngularVelocity der_theta1(start=0, stateSelect=stateSelect)
        "Derivative of theta 1";
        Modelica_SIunits.AngularVelocity der_theta2(start=0, stateSelect=stateSelect)
        "Derivative of theta 2";

        Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame1
        "Frame fixed in center point of left wheel (y-axis: along wheel axis, z-Axis: upwards)"
        annotation (Placement(transformation(extent={{-96,16},{-64,-16}}),
            iconTransformation(extent={{-96,16},{-64,-16}})));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame2
        "Frame fixed in center point of right wheel (y-axis: along wheel axis, z-Axis: upwards)"
        annotation (Placement(transformation(extent={{64,16},{96,-16}})));
        Modelica_Mechanics_MultiBody.Parts.Fixed fixed(r={0,0,wheelRadius},
          animation=animation) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={0,-90})));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation rod1(r={0,
            wheelDistance/2,0}, animation=animation)
        annotation (Placement(transformation(extent={{-8,-10},{-28,10}})));
        Modelica_Mechanics_MultiBody.Joints.Prismatic prismatic1(animation=
            animation) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={0,-66})));
        Modelica_Mechanics_MultiBody.Joints.Prismatic prismatic2(n={0,1,0},
          animation=animation) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=180,
            origin={-24,-50})));
        Modelica_Mechanics_MultiBody.Joints.Revolute revolute(animation=
            animation) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={0,-22})));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation rod2(r={0,-
            wheelDistance/2,0}, animation=animation)
        annotation (Placement(transformation(extent={{12,-10},{32,10}})));
        Modelica_Mechanics_MultiBody.Joints.Revolute revolute1(
        n={0,1,0},
        useAxisFlange=true,
        animation=animation)
        annotation (Placement(transformation(extent={{-34,-10},{-54,10}})));
        Modelica_Mechanics_MultiBody.Joints.Revolute revolute2(
        n={0,1,0},
        useAxisFlange=true,
        animation=animation)
        annotation (Placement(transformation(extent={{40,-10},{60,10}})));
        Modelica_Mechanics_MultiBody.Joints.Internal.RollingConstraintVerticalWheel
        rolling1(radius=wheelRadius)
        annotation (Placement(transformation(extent={{-70,-60},{-50,-40}})));
        Modelica_Mechanics_MultiBody.Joints.Internal.RollingConstraintVerticalWheel
        rolling2(radius=wheelRadius, lateralSlidingConstraint=false)
        annotation (Placement(transformation(extent={{54,-60},{74,-40}})));
        Modelica_Mechanics_Rotational.Interfaces.Flange_a axis1
        "1-dim. rotational flange that drives the joint"
          annotation (Placement(transformation(extent={{-110,90},{-90,110}})));
        Modelica_Mechanics_Rotational.Interfaces.Flange_a axis2
        "1-dim. rotational flange that drives the joint"
          annotation (Placement(transformation(extent={{90,90},{110,110}})));
        Modelica_Mechanics_MultiBody.Parts.Mounting1D mounting1D
        annotation (Placement(transformation(extent={{-10,38},{10,58}})));
        Modelica_Mechanics_Rotational.Interfaces.Flange_b support
        "Support of 1D axes"   annotation (Placement(transformation(extent={{-10,70},
                {10,90}}),       iconTransformation(extent={{-10,70},{10,90}})));
      equation
        prismatic1.s  = x;
        prismatic2.s  = y;
        revolute.phi  = phi;
        revolute1.phi = theta1;
        revolute2.phi = theta2;
        der_theta1 = der(theta1);
        der_theta2 = der(theta2);

        connect(revolute.frame_b, frameMiddle) annotation (Line(
            points={{0,-12},{0,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(rod1.frame_a, frameMiddle) annotation (Line(
            points={{-8,0},{0,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(rod2.frame_a, frameMiddle) annotation (Line(
            points={{12,0},{0,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(rod1.frame_b, revolute1.frame_a) annotation (Line(
            points={{-28,0},{-34,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(revolute1.frame_b, frame1) annotation (Line(
            points={{-54,0},{-80,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(revolute2.frame_a, rod2.frame_b) annotation (Line(
            points={{40,0},{32,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(revolute2.frame_b, frame2) annotation (Line(
            points={{60,0},{80,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(prismatic1.frame_a, fixed.frame_b) annotation (Line(
            points={{0,-76},{0,-80}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(prismatic1.frame_b, prismatic2.frame_a) annotation (Line(
            points={{0,-56},{0,-50},{-14,-50}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(prismatic2.frame_b, revolute.frame_a) annotation (Line(
            points={{-34,-50},{-40,-50},{-40,-36},{0,-36},{0,-32}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(rolling1.frame_a, revolute1.frame_b) annotation (Line(
            points={{-60,-48},{-60,0},{-54,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(rolling2.frame_a, revolute2.frame_b) annotation (Line(
            points={{64,-48},{64,0},{60,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(revolute1.axis, axis1) annotation (Line(
            points={{-44,10},{-44,100},{-100,100}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(revolute2.axis, axis2) annotation (Line(
            points={{50,10},{50,100},{100,100}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(frameMiddle, mounting1D.frame_a) annotation (Line(
            points={{0,0},{0,38}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(mounting1D.flange_b, support) annotation (Line(
            points={{10,48},{16,48},{16,80},{0,80}},
            color={0,0,0},
            smooth=Smooth.None));
        annotation (defaultComponentName="wheelSet",Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,-80},{100,-100}},
                lineColor={0,0,0},
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-146,-98},{154,-138}},
                textString="%name",
                lineColor={0,0,255}),
              Ellipse(
                extent={{42,80},{118,-80}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-62,2},{64,-6}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-118,80},{-42,-80}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{86,24},{64,24},{64,10},{56,10}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{86,-24},{64,-24},{64,-12},{56,-12}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-96,100},{-80,100},{-80,4}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{100,100},{80,100},{80,-2}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{0,72},{0,40},{-20,40},{-20,2}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{0,40},{20,40},{20,2}},
                color={0,0,0},
                smooth=Smooth.None)}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Line(
                points={{-68,24},{-68,52}},
                color={0,0,255},
                smooth=Smooth.None),
              Polygon(
                points={{-68,70},{-74,52},{-62,52},{-68,70}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-56,62},{-38,50}},
                lineColor={0,0,255},
                textString="x"),
              Line(
                points={{-62,30},{-94,30}},
                color={0,0,255},
                smooth=Smooth.None),
              Polygon(
                points={{-90,36},{-90,24},{-108,30},{-90,36}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-114,50},{-96,38}},
                lineColor={0,0,255},
                textString="y")}));
      end RollingWheelSet;

    package Assemblies
      "Components that aggregate several joints for analytic loop handling"
      extends Modelica_Icons.Package;

      model JointUPS
        "Universal - prismatic - spherical joint aggregation (no constraints, no potential states)"

        import Modelica_Mechanics_MultiBody.Types;
        extends Interfaces.PartialTwoFramesDoubleSize;
        Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_ia
          "Coordinate system at origin of frame_a fixed at prismatic joint"
          annotation (Placement(transformation(
              origin={-80,100},
              extent={{-8,-8},{8,8}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_ib
          "Coordinate system at origin of frame_b fixed at prismatic joint"
          annotation (Placement(transformation(
              origin={80,100},
              extent={{-8,8},{8,-8}},
              rotation=270)));
        Modelica_Mechanics_Translational.Interfaces.Flange_a axis
          "1-dim. translational flange that drives the prismatic joint"
          annotation (Placement(transformation(extent={{45,95},{35,105}},
                rotation=0)));
        Modelica_Mechanics_Translational.Interfaces.Flange_b bearing
          "1-dim. translational flange of the drive bearing of the prismatic joint"
          annotation (Placement(transformation(extent={{-35,95},{-45,105}},
                rotation=0)));

        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        parameter Boolean showUniversalAxes=true
          "= true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)";
        parameter Modelica_Mechanics_MultiBody.Types.Axis n1_a={0,0,1}
          "Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to line from universal to spherical joint)"
          annotation (Evaluate=true);
        parameter Modelica_SIunits.Position nAxis_ia[3]={1,0,0}
          "Axis vector along line from origin of frame_a to origin of frame_b, resolved in frame_ia"
          annotation (Evaluate=true);
        parameter Modelica_SIunits.Position s_offset=0
          "Relative distance offset (distance between frame_a and frame_b = s(t) + s_offset)";
        parameter Modelica_SIunits.Diameter sphereDiameter=world.defaultJointLength
          "Diameter of spheres representing the spherical joints" annotation (
            Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color sphereColor=Types.Defaults.JointColor
          "Color of spheres representing the spherical joints"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        parameter Modelica_SIunits.Diameter axisDiameter=sphereDiameter/Types.Defaults.JointRodDiameterFraction
          "Diameter of cylinder on the connecting line from frame_a to frame_b"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color axisColor=Types.Defaults.SensorColor
          "Color of cylinder on the connecting line from frame_a to frame_b"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
        parameter Modelica_SIunits.Distance cylinderLength=world.defaultJointLength
          "Length of cylinders representing the two universal joint axes"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true and showUniversalAxes",
            enable=animation and showUniversalAxes));
        parameter Modelica_SIunits.Distance cylinderDiameter=world.defaultJointWidth
          "Diameter of cylinders representing the two universal joint axes"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true and showUniversalAxes",
            enable=animation and showUniversalAxes));
       input Types.Color cylinderColor=Types.Defaults.JointColor
          "Color of cylinders representing the two universal joint axes" annotation (
            Dialog(colorSelector=true, tab="Animation", group="if animation = true and showUniversalAxes",
                  enable=animation and showUniversalAxes));

        parameter Boolean checkTotalPower=false
          "= true, if total power flowing into this component shall be determined (must be zero)"
          annotation (Dialog(tab="Advanced"));
        final parameter Real eAxis_ia[3](each final unit="1")=Modelica_Math.Vectors.normalizeWithAssert(nAxis_ia)
          "Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia";
        final parameter Real e2_ia[3](each final unit="1")=Modelica_Math.Vectors.normalizeWithAssert(
                                                       cross(n1_a, eAxis_ia))
          "Unit vector in direction of second rotation axis of universal joint, resolved in frame_ia";
        final parameter Real e3_ia[3](each final unit="1")=cross(eAxis_ia, e2_ia)
          "Unit vector perpendicular to eAxis_ia and e2_ia, resolved in frame_ia";
        Modelica_SIunits.Position s
          "Relative distance between frame_a and frame_b along axis nAxis = s + s_offset";
        Modelica_SIunits.Force f
          "= axis.f (driving force in the axis; = -bearing.f)";
        Modelica_SIunits.Length axisLength
          "Distance between frame_a and frame_b";
        Modelica_SIunits.Power totalPower
          "Total power flowing into this element, if checkTotalPower=true (otherwise dummy)";

      protected
        Modelica_SIunits.Force f_c_a[3] "frame_ia.f resolved in frame_a";
        Modelica_SIunits.Torque t_cd_a[3]
          "frame_ia.t + frame_ib.t resolved in frame_a";
        Modelica_SIunits.Force f_bd_a[3]
          "frame_b.f + frame_ib.f resolved in frame_a";
        Modelica_SIunits.Position rAxis_0[3]
          "Position vector from origin of frame_a to origin of frame_b resolved in world frame";
        Modelica_SIunits.Position rAxis_a[3]
          "Position vector from origin of frame_a to origin of frame_b resolved in frame_a";
        Real eAxis_a[3](each final unit="1")
          "Unit vector in direction of rAxis_a, resolved in frame_a";
        Real e2_a[3](each final unit="1")
          "Unit vector in direction of second rotation axis of universal joint, resolved in frame_a";
        Real e3_a[3](each final unit="1")
          "Unit vector perpendicular to eAxis_a and e2_a, resolved in frame_a";
        Real n2_a[3](each final unit="1")
          "Vector in direction of second rotation axis of universal joint, resolved in frame_a";
        Real length2_n2_a(unit="1") "Square of length of vector n2_a";
        Real length_n2_a(unit="1") "Length of vector n2_a";
        Real der_rAxis_a_L[3](each unit="1/s") "= der(rAxis_a)/axisLength";
        Modelica_SIunits.AngularVelocity w_rel_ia1[3];
        Frames.Orientation R_ia1_a;
        Frames.Orientation R_ia2_a;
        Frames.Orientation R_ia_a "Rotation from frame_a to frame_ia";
        // Real T_ia_a[3, 3] "Transformation matrix from frame_a to frame_ia";

        Visualizers.Advanced.Shape axisCylinder(
          shapeType="cylinder",
          color=axisColor,
          specularCoefficient=specularCoefficient,
          length=axisLength,
          width=axisDiameter,
          height=axisDiameter,
          lengthDirection=eAxis_ia,
          widthDirection=e2_ia,
          r=frame_ia.r_0,
          R=frame_ia.R) if world.enableAnimation and animation;
        Visualizers.Advanced.Shape sphericalShape_b(
          shapeType="sphere",
          color=sphereColor,
          specularCoefficient=specularCoefficient,
          length=sphereDiameter,
          width=sphereDiameter,
          height=sphereDiameter,
          lengthDirection={1,0,0},
          widthDirection={0,1,0},
          r_shape={-0.5,0,0}*sphereDiameter,
          r=frame_b.r_0,
          R=frame_b.R) if world.enableAnimation and animation;
        Visualizers.Advanced.Shape sphericalShape_a(
          shapeType="sphere",
          color=sphereColor,
          specularCoefficient=specularCoefficient,
          length=sphereDiameter,
          width=sphereDiameter,
          height=sphereDiameter,
          lengthDirection={1,0,0},
          widthDirection={0,1,0},
          r_shape={-0.5,0,0}*sphereDiameter,
          r=frame_a.r_0,
          R=frame_a.R) if world.enableAnimation and animation;
        Visualizers.Advanced.Shape universalShape1(
          shapeType="cylinder",
          color=cylinderColor,
          specularCoefficient=specularCoefficient,
          length=cylinderLength,
          width=cylinderDiameter,
          height=cylinderDiameter,
          lengthDirection=n1_a,
          widthDirection={0,1,0},
          r_shape=-n1_a*(cylinderLength/2),
          r=frame_a.r_0,
          R=frame_a.R) if world.enableAnimation and animation and showUniversalAxes;
        Visualizers.Advanced.Shape universalShape2(
          shapeType="cylinder",
          color=cylinderColor,
          specularCoefficient=specularCoefficient,
          length=cylinderLength,
          width=cylinderDiameter,
          height=cylinderDiameter,
          lengthDirection=e2_ia,
          widthDirection={0,1,0},
          r_shape=-e2_ia*(cylinderLength/2),
          r=frame_ia.r_0,
          R=frame_ia.R) if world.enableAnimation and animation and showUniversalAxes;
      equation
        Connections.branch(frame_a.R, frame_ia.R);
        Connections.branch(frame_ia.R, frame_ib.R);

        // Translational flanges
        axisLength = s + s_offset;
        bearing.s = 0;
        axis.s = s;
        axis.f = f;

        // Position vector rAxis from frame_a to frame_b
        rAxis_0 = frame_b.r_0 - frame_a.r_0;
        rAxis_a = Frames.resolve2(frame_a.R, rAxis_0);

        /* Determine relative Rotation R_rel_c from frame_a to frame_ia
     and absolute rotation of frame_a.R.
  */
        axisLength = sqrt(rAxis_0*rAxis_0);
        assert(axisLength > 1.0e-15, "
Distance between frame_a and frame_b of a JointUPS joint
became zero. This is not allowed. If this occurs during
initialization, the initial conditions are probably wrong.");

        eAxis_a = rAxis_a/axisLength;
        n2_a = cross(n1_a, eAxis_a);
        length2_n2_a = n2_a*n2_a;
        assert(noEvent(length2_n2_a > 1.e-10), "
A Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUPS joint (consisting of
a universal, prismatic and spherical joint) is in the singular
configuration of the universal joint. This means that axis 1 of
the universal joint defined via parameter \"n1_a\" is parallel to vector
\"eAxis_ia\" that is directed from the origin of frame_a to the
origin of frame_b. You may try to use another \"n1_a\" vector.
");     length_n2_a = sqrt(length2_n2_a);
        e2_a = n2_a/length_n2_a;
        e3_a = cross(eAxis_a, e2_a);

        /* The statements below are an efficient implementation of the
     original equations:
       T_ia_a = [eAxis_ia, e2_ia, e3_ia]*transpose([eAxis_a, e2_a, e3_a]);
       R_ia_a = Frames.from_T(T_ia_a,
                     Frames.TransformationMatrices.angularVelocity2(T_ia_a, der(T_ia_a)));
   To perform this, the rotation is split into two parts:
     R_ia_a : Rotation object from frame_a to frame_ia
     R_ia1_a: Rotation object from frame_a to frame_ia1
                (frame that is fixed in frame_ia such that x-axis
                is along the rod axis)
                T = transpose([eAxis_a, e2_a, e3_a]; w = w_rel_ia1
     R_ia2_a: Fixed rotation object from frame_ia1 to frame_ia
                T = [eAxis_a, e2_ia, e3_ia]; w = zeros(3)

   The difficult part is to compute w_rel_ia1:
      w_rel_ia1 = [  e3_a*der(e2_a);
                    -e3_a*der(eAxis_a);
                     e2_a*der(eAxis_a)]
   der(eAxis_a) is directly given, since eAxis_a is a function
   of translational quantities only.
      der(eAxis_a) = (der(rAxis_a) - eAxis_a*(eAxis_a*der(rAxis_a)))/axisLength
      der(n2_a)    = cross(n1_a, der(eAxis_a))
      der(e2_a)    = (der(n2_a) - e2_a*(e2_a*der(n2_a)))/length_n2_a
   Inserting these equations in w_rel_ia1 results in:
      e3_a*der(eAxis_a) = e3_a*der(rAxis_a)/axisLength       // e3_a*eAxis_a = 0
      e2_a*der(eAxis_a) = e2_a*der(rAxis_a)/axisLength       // e2_a*eAxis_a = 0
      e3_a*der(e2_a)    = e3_a*der(n2_a)/lenght_n2_a       // e3_a*e2_a = 0
                        = e3_a*cross(n1_a, der(eAxis_a))/length_n2_a
                        = e3_a*cross(n1_a, der(rAxis_a) - eAxis_a*(eAxis_a*der(rAxis_a)))/(length_n2_a*axisLength)
                        = e3_a*cross(n1_a, der(rAxis_a))/(length_n2_a*axisLength)
   Furthermore, we have:
     rAxis_a      = resolve2(frame_a.R, rAxis_0);
     der(rAxis_a) = resolve2(frame_a.R, der(rAxis_0)) - cross(frame_a.R.w, rAxis_a));
*/
        der_rAxis_a_L = (Frames.resolve2(frame_a.R, der(rAxis_0)) - cross(frame_a.
           R.w, rAxis_a))/axisLength;
        w_rel_ia1 = {e3_a*cross(n1_a, der_rAxis_a_L)/length_n2_a,-e3_a*
          der_rAxis_a_L,e2_a*der_rAxis_a_L};
        R_ia1_a = Frames.from_T(transpose([eAxis_a, e2_a, e3_a]), w_rel_ia1);
        R_ia2_a = Frames.from_T([eAxis_ia, e2_ia, e3_ia], zeros(3));
        R_ia_a = Frames.absoluteRotation(R_ia1_a, R_ia2_a);
        /*
  T_ia_a = [eAxis_ia, e2_ia, e3_ia]*transpose([eAxis_a, e2_a, e3_a]);
  R_ia_a = Frames.from_T(T_ia_a, Frames.TransformationMatrices.angularVelocity2
    (T_ia_a, der(T_ia_a)));
*/

        // Compute kinematic quantities of frame_ia and frame_ib
        frame_ia.r_0 = frame_a.r_0;
        frame_ib.r_0 = frame_b.r_0;
        frame_ia.R = Frames.absoluteRotation(frame_a.R, R_ia_a);
        frame_ib.R = frame_ia.R;

        /* In the following formulas f_a, f_b, f_ia, f_ib, t_a, t_b, t_ia, t_ib are
     the forces and torques at frame_a, frame_b, frame_ia, frame_ib respectively,
     resolved in frame_a. eAxis, e2, e3 are the unit vectors resolved in frame_a.
     Torque balance at the rod around the origin of frame_a:
       0 = t_a + t_ia + t_ib + cross(rAxis, (f_b+f_ib))
     with
         rAxis = axisLength*eAxis
         f_bd  = f_b + f_ib
         f_bd  = f*eAxis + f_bd[2]*e2 + f_bd[3]*e3
     follows:
         0 = t_a + t_ia + axisLength*(f_bd[2]*e_z - f_bd[3]*e_y)
     The projection of t_a with respect to universal joint axes vanishes:
       e1*t_a = 0
       e2*t_a = 0
     Therefore:
        0 = e1*(t_ia + t_ib) + axisLength*f_bd[2]*(e1*e3)
        0 = e2*(t_ia + t_ib) - axisLength*f_bd[3]
     or
        f_bd = f*eAxis - e2*(e1*(t_ia+t_ib))/(axisLength*(e1*e3)) +
                e3*(e2*(t_ia+t_ib))/axisLength
     Force balance:
        0 = f_a + f_bd + f_ia
  */
        f_c_a = Frames.resolve1(R_ia_a, frame_ia.f);
        t_cd_a = Frames.resolve1(R_ia_a, frame_ia.t + frame_ib.t);
        f_bd_a = -eAxis_a*f - e2_a*((n1_a*t_cd_a)/(axisLength*(n1_a*e3_a))) +
          e3_a*((e2_a*t_cd_a)/axisLength);
        zeros(3) = frame_b.f + Frames.resolveRelative(frame_ib.f, frame_ib.R,
          frame_b.R) - Frames.resolveRelative(f_bd_a, frame_a.R, frame_b.R);
        zeros(3) = frame_b.t;
        zeros(3) = frame_a.f + f_c_a + f_bd_a;
        zeros(3) = frame_a.t + t_cd_a + cross(rAxis_a, f_bd_a);

        // Measure power for test purposes
        if checkTotalPower then
          totalPower = frame_a.f*Frames.resolve2(frame_a.R, der(frame_a.r_0)) +
            frame_b.f*Frames.resolve2(frame_b.R, der(frame_b.r_0)) + frame_ia.f*
            Frames.resolve2(frame_ia.R, der(frame_ia.r_0)) + frame_ib.f*
            Frames.resolve2(frame_ib.R, der(frame_ib.r_0)) + frame_a.t*
            Frames.angularVelocity2(frame_a.R) + frame_b.t*
            Frames.angularVelocity2(frame_b.R) + frame_ia.t*
            Frames.angularVelocity2(frame_ia.R) + frame_ib.t*
            Frames.angularVelocity2(frame_ib.R) + axis.f*der(axis.s) + bearing.f*
            der(bearing.s);
        else
          totalPower = 0;
        end if;
        annotation (
          Documentation(info="<html>
<p>
This component consists of a <b>universal</b> joint at frame_a,
a <b>spherical</b> joint at frame_b and a <b>prismatic</b> joint along the
line connecting the origin of frame_a and the origin of frame_b,
see the default animation in the following figure (the axes vectors
are not part of the default animation):
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/JointUPS.png\" ALT=\"model Joints.Assemblies.JointUPS\">
</p>

<p>
This joint aggregation has no mass and no inertia and
introduces neither constraints nor potential state variables.
It is especially useful to build up more complicated force elements
where the mass and/or inertia of the force element shall be taken
into account.
</p>
<p>
The universal joint is defined in the following way:
</p>
<ul>
<li> The rotation <b>axis</b> of revolute joint <b>1</b> is along parameter
     vector n1_a which is fixed in frame_a.</li>
<li> The rotation <b>axis</b> of revolute joint <b>2</b> is perpendicular to
     axis 1 and to the line connecting the universal and the spherical joint.</li>
</ul>
<p>
The definition of axis 2 of the universal joint is performed according
to the most often occurring case. In a future release, axis 2 might
be explicitly definable via a parameter. However, the treatment is much more
complicated and the number of operations is considerably higher,
if axis 2 is not orthogonal to axis 1 and to the connecting rod.
</p>
<p>
Note, there is a <b>singularity</b> when axis 1 and the connecting line are parallel
to each other. Therefore, if possible n1_a should be selected in such a way that it
is perpendicular to nAxis_ia in the initial configuration (i.e., the
distance to the singularity is as large as possible).
</p>
<p>
An additional <b>frame_ia</b> is present. It is <b>fixed</b> on the line
connecting the universal and the spherical joint at the
origin of <b>frame_a</b>. The placement of frame_ia on this line
is implicitly defined by the universal joint (frame_a and frame_ia coincide
when the angles of the two revolute joints of the universal joint are zero)
and by parameter vector <b>nAxis_ia</b>, an axis vector directed
along the line from the origin of frame_a to the spherical joint,
resolved in frame_<b>ia</b>.
</p>
<p>
An additional <b>frame_ib</b> is present. It is <b>fixed</b> in the line
connecting the prismatic and the spherical joint at the
origin of <b>frame_b</b>.
It is always parallel to <b>frame_ia</b>.
</p>
<p>
Note, this joint aggregation can be used in cases where
in reality a rod with spherical joints at each end are present.
Such a system has an additional degree of freedom to rotate
the rod along its axis. In practice this rotation is usually
of no interest and is mathematically removed by replacing one
of the spherical joints by a universal joint.
</p>
<p>
The easiest way to define the parameters of this joint is by moving the
MultiBody system in a <b>reference configuration</b> where <b>all frames</b>
of all components are <b>parallel</b> to each other (alternatively,
at least frame_a, frame_ia and frame_ib of the JointUSP joint
should be parallel to each other when defining an instance of this
component).
</p>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              initialScale=0.2), graphics={
              Text(
                extent={{-140,-50},{140,-75}},
                lineColor={0,0,255},
                textString="%name"),
              Ellipse(
                extent={{-100,-40},{-19,40}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-90,-30},{-29,29}},
                lineColor={160,160,164},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-60,41},{-9,-44}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-60,40},{-60,-40}},
                color={0,0,0},
                thickness=0.5),
              Ellipse(
                extent={{-83,-17},{-34,21}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-74,-12},{-40,15}},
                lineColor={160,160,164},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-72,-20},{-89,3},{-69,25},{-45,27},{-72,-20}},
                pattern=LinePattern.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(
                points={{-60,40},{-60,-10}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-49,20},{-69,-15}},
                color={0,0,0},
                thickness=0.5),
              Ellipse(
                extent={{44,14},{73,-14}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{20,-40},{100,40}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{30,-30},{90,30}},
                lineColor={192,192,192},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-22,45},{40,-43}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{45,14},{74,-14}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Text(
                extent={{-98,84},{-60,65}},
                lineColor={128,128,128},
                textString="ia"),
              Line(
                points={{-40,0},{-40,90},{-80,90},{-80,97}},
                color={95,95,95},
                thickness=0.5),
              Text(
                extent={{61,86},{109,64}},
                lineColor={128,128,128},
                textString="ib"),
              Rectangle(
                extent={{-35,-13},{-6,14}},
                pattern=LinePattern.None,
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{-35,14},{-6,18}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{-6,-7},{46,6}},
                pattern=LinePattern.None,
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{-6,6},{46,10}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(points={{-6,-13},{-6,18}}, color={0,0,0}),
              Line(
                points={{60,-1},{60,90},{80,90},{80,97}},
                color={95,95,95},
                thickness=0.5),
              Line(
                points={{60,90},{40,90},{40,95}},
                color={95,95,95},
                thickness=0.5),
              Line(points={{-30,70},{10,70}}, color={0,0,0}),
              Polygon(
                points={{30,70},{10,76},{10,63},{30,70}},
                lineColor={128,128,128},
                fillColor={128,128,128},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-40,90},{-40,90},{-40,95}},
                color={95,95,95},
                thickness=0.5)}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              initialScale=0.2), graphics={
              Line(points={{-60,-70},{46,-70}}, color={0,0,255}),
              Polygon(
                points={{60,-70},{45,-64},{45,-76},{60,-70}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-62,-73},{65,-90}},
                textString="rAxis",
                lineColor={0,0,255}),
              Ellipse(
                extent={{-100,-40},{-19,40}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-90,-30},{-29,29}},
                lineColor={160,160,164},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-60,41},{-19,-41}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-60,40},{-60,-40}},
                color={0,0,0},
                thickness=0.5),
              Ellipse(
                extent={{-83,-17},{-34,21}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-74,-12},{-40,15}},
                lineColor={160,160,164},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-72,-20},{-89,3},{-69,25},{-45,27},{-72,-20}},
                pattern=LinePattern.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(
                points={{-60,40},{-60,-10}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-49,20},{-69,-15}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-40,0},{-40,90},{-80,90},{-80,99}},
                color={95,95,95},
                thickness=0.5),
              Polygon(points={{7,-1},{-5,2},{-5,-4},{7,-1}}, lineColor={0,0,255}),
              Line(points={{-50,19},{-30,57}}, color={0,0,255}),
              Text(
                extent={{-24,74},{7,53}},
                lineColor={0,0,0},
                textString="e2"),
              Polygon(points={{-25,64},{-33,56},{-27,53},{-25,64}}, lineColor={0,
                    0,255}),
              Line(points={{-60,41},{-60,65}}, color={0,0,255}),
              Polygon(points={{-60,75},{-64,63},{-56,63},{-60,75}}, lineColor={0,
                    0,255}),
              Text(
                extent={{-96,82},{-65,61}},
                lineColor={0,0,0},
                textString="n1"),
              Line(points={{-60,-40},{-60,-72}}, color={0,0,255}),
              Ellipse(
                extent={{20,-40},{100,40}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{30,-30},{90,30}},
                lineColor={192,192,192},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-22,45},{40,-43}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{45,14},{74,-14}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={128,128,128}),
              Line(points={{60,0},{60,-74}}, color={0,0,255}),
              Rectangle(
                extent={{-35,14},{-6,18}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{-35,-13},{-6,14}},
                pattern=LinePattern.None,
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{-6,6},{46,10}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{-6,-7},{46,6}},
                pattern=LinePattern.None,
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(points={{-6,-13},{-6,18}}, color={0,0,0}),
              Text(
                extent={{-40,-2},{-1,-16}},
                lineColor={0,0,0},
                textString="nAxis"),
              Line(points={{-61,1},{-2,1}}, color={0,0,255}),
              Polygon(points={{10,1},{-2,4},{-2,-2},{10,1}}, lineColor={0,0,255}),
              Line(
                points={{60,-1},{60,90},{80,90},{80,99}},
                color={95,95,95},
                thickness=0.5),
              Text(
                extent={{-24,117},{-9,102}},
                textString="f",
                lineColor={0,0,255}),
              Polygon(
                points={{-26,103},{-36,100},{-26,97},{-26,103}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{26,103},{36,100},{26,97},{26,103}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Line(points={{14,100},{36,100}}, color={0,0,255}),
              Text(
                extent={{12,116},{27,101}},
                textString="f",
                lineColor={0,0,255}),
              Polygon(
                points={{30,93},{40,90},{30,87},{30,93}},
                lineColor={128,128,128},
                fillColor={128,128,128},
                fillPattern=FillPattern.Solid),
              Line(points={{-40,90},{40,90}}, color={128,128,128}),
              Line(points={{-25,100},{-10,100}}, color={0,0,255}),
              Text(
                extent={{-18,90},{19,77}},
                lineColor={128,128,128},
                textString="s"),
              Line(
                points={{60,90},{40,90},{40,98}},
                color={95,95,95},
                thickness=0.5),
              Line(
                points={{-40,90},{-40,96},{-40,98}},
                color={135,135,135},
                thickness=0.5)}));
      end JointUPS;

      model JointUSR
        "Universal - spherical - revolute joint aggregation (no constraints, no potential states)"

        import Modelica_Mechanics_MultiBody.Types;

        extends Interfaces.PartialTwoFramesDoubleSize;
        Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_ia
          "Coordinate system at origin of frame_a fixed at connecting rod of universal and spherical joint"
          annotation (Placement(transformation(
              origin={-80,100},
              extent={{-8,-8},{8,8}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_ib
          "Coordinate system at origin of frame_b fixed at connecting rod of spherical and revolute joint"
          annotation (Placement(transformation(
              origin={80,100},
              extent={{-8,8},{8,-8}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_im
          "Coordinate system at origin of spherical joint fixed at connecting rod of spherical and revolute joint"
          annotation (Placement(transformation(
              origin={0,100},
              extent={{8,-8},{-8,8}},
              rotation=270)));
        Modelica_Mechanics_Rotational.Interfaces.Flange_a axis
          "1-dim. rotational flange that drives the revolute joint"
          annotation (Placement(transformation(extent={{105,85},{95,75}},
                rotation=0)));
        Modelica_Mechanics_Rotational.Interfaces.Flange_b bearing
          "1-dim. rotational flange of the drive bearing of the revolute joint"
          annotation (Placement(transformation(extent={{95,45},{105,35}},
                rotation=0)));

        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        parameter Boolean showUniversalAxes=true
          "= true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)";
        parameter Modelica_Mechanics_MultiBody.Types.Axis n1_a={0,0,1}
          "Axis 1 of universal joint fixed and resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod 1)"
          annotation (Evaluate=true);
        parameter Modelica_Mechanics_MultiBody.Types.Axis n_b={0,0,1}
          "Axis of revolute joint fixed and resolved in frame_b"
          annotation (Evaluate=true);
        parameter Modelica_SIunits.Position rRod1_ia[3]={1,0,0}
          "Vector from origin of frame_a to spherical joint, resolved in frame_ia"
          annotation (Evaluate=true);
        parameter Modelica_SIunits.Position rRod2_ib[3]={-1,0,0}
          "Vector from origin of frame_ib to spherical joint, resolved in frame_ib";
        parameter Cv.NonSIunits.Angle_deg phi_offset=0
          "Relative angle offset of revolute joint (angle = phi(t) + from_deg(phi_offset))";
        parameter Cv.NonSIunits.Angle_deg phi_guess=0
          "Select the configuration such that at initial time |phi(t0) - from_deg(phi_guess)| is minimal";
        parameter Modelica_SIunits.Diameter sphereDiameter=world.defaultJointLength
          "Diameter of the spheres representing the universal and the spherical joint"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color sphereColor=Types.Defaults.JointColor
          "Color of the spheres representing the universal and the spherical joint"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        parameter Modelica_SIunits.Diameter rod1Diameter=sphereDiameter/Types.Defaults.JointRodDiameterFraction
          "Diameter of rod 1 connecting the universal and the spherical joint"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color rod1Color=Types.Defaults.RodColor
          "Color of rod 1 connecting the universal and the spherical joint"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));

        parameter Modelica_SIunits.Diameter rod2Diameter=rod1Diameter
          "Diameter of rod 2 connecting the revolute and the spherical joint"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color rod2Color=rod1Color
          "Color of rod 2 connecting the revolute and the spherical joint"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        parameter Modelica_SIunits.Diameter revoluteDiameter=world.defaultJointWidth
          "Diameter of cylinder representing the revolute joint" annotation (
            Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter Modelica_SIunits.Distance revoluteLength=world.defaultJointLength
          "Length of cylinder representing the revolute joint" annotation (
            Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color revoluteColor=Types.Defaults.JointColor
          "Color of cylinder representing the revolute joint"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
        parameter Modelica_SIunits.Distance cylinderLength=world.defaultJointLength
          "Length of cylinders representing the two universal joint axes"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true and showUniversalAxes",
            enable=animation and showUniversalAxes));
        parameter Modelica_SIunits.Distance cylinderDiameter=world.defaultJointWidth
          "Diameter of cylinders representing the two universal joint axes"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true and showUniversalAxes",
            enable=animation and showUniversalAxes));
        input Types.Color cylinderColor=Types.Defaults.JointColor
          "Color of cylinders representing the two universal joint axes" annotation (
            Dialog(colorSelector=true, tab="Animation", group="if animation = true and showUniversalAxes",
                  enable=animation and showUniversalAxes));
        parameter Boolean checkTotalPower=false
          "= true, if total power flowing into this component shall be determined (must be zero)"
          annotation (Dialog(tab="Advanced"));
        final parameter Real eRod1_ia[3](each final unit="1")=rod1.eRod_ia
          "Unit vector from origin of frame_a to origin of spherical joint, resolved in frame_ia";
        final parameter Real e2_ia[3](each final unit="1")=rod1.e2_ia
          "Unit vector in direction of axis 2 of universal joint, resolved in frame_ia";
        final parameter Modelica_SIunits.Distance rod1Length=rod1.rodLength
          "Length of rod 1 (= distance between universal and spherical joint)";
        Modelica_SIunits.Power totalPower
          "Total power flowing into this element, if checkTotalPower=true (otherwise dummy)";
        Modelica_SIunits.Position aux
          "Denominator used to compute force in rod connecting universal and spherical joint";
        Modelica_SIunits.Force f_rod
          "Constraint force in direction of the rod (positive, if rod is pressed)";

        Modelica_Mechanics_MultiBody.Joints.Internal.RevoluteWithLengthConstraint
          revolute(
          animation=animation,
          lengthConstraint=rod1Length,
          n=n_b,
          phi_offset=phi_offset,
          phi_guess=phi_guess,
          cylinderDiameter=revoluteDiameter,
          cylinderLength=revoluteLength,
          cylinderColor=revoluteColor,
          specularCoefficient=specularCoefficient) annotation (Placement(
              transformation(extent={{75,-20},{35,20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.UniversalSpherical rod1(
          animation=animation,
          showUniversalAxes=showUniversalAxes,
          rRod_ia=rRod1_ia,
          n1_a=n1_a,
          sphereDiameter=sphereDiameter,
          sphereColor=sphereColor,
          rodWidth=rod1Diameter,
          rodHeight=rod1Diameter,
          rodColor=rod1Color,
          cylinderLength=cylinderLength,
          cylinderDiameter=cylinderDiameter,
          cylinderColor=cylinderColor,
          specularCoefficient=specularCoefficient,
          kinematicConstraint=false,
          constraintResidue=rod1.f_rod - f_rod) annotation (Placement(
              transformation(extent={{-92,-20},{-52,20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation rod2(
          animation=animation,
          width=rod2Diameter,
          height=rod2Diameter,
          color=rod2Color,
          specularCoefficient=specularCoefficient,
          r=rRod2_ib) annotation (Placement(transformation(extent={{15,-20},{-25,
                  20}}, rotation=0)));
        Sensors.RelativePosition relativePosition(resolveInFrame=Types.ResolveInFrameAB.frame_a)
          annotation (Placement(transformation(extent={{60,-70},{40,-90}},
                rotation=0)));
        Modelica_Blocks.Sources.Constant position_b[3](k=rRod2_ib)
          annotation (Placement(transformation(extent={{-20,-50},{0,-30}},
                rotation=0)));
      equation
       // Connections.root(frame_ib.R);

        /* Compute the unknown force in the rod of the rod1 joint
     by a torque balance at the revolute joint:
       0 = revolute.frame_b.t + frame_ib.t + frame_im.t + cross(rRod2_ib, frame_im.f)
           + cross(r_ib, -rod1.f_b_a1)
           + cross(r_ib, Frames.resolve2(rod1.R_rel, rod1.f_rod*rod1.eRod1_ia))
     The condition is that the projection of the torque in the revolute
     joint along the axis of the revolute joint is equal to the driving
     axis torque in the flange:
       -revolute.tau = revolute.e*frame_b.t
     Therefore, we have
        tau = e*(frame_ib.t  + frame_im.t + cross(rRod2_ib, frame_im.f)
              + cross(rRod2_ib, -rod1.f_b_a1))
              + e*cross(rRod2_ib, Frames.resolve2(rod1.R_rel, rod1.f_rod*rod1.eRod_a))
            = e*(frame_ib.t + frame_im.t + cross(rRod2_ib, frame_im.f)
              + cross(rRod2_ib, -rod.f_b_a1))
              + rod1.f_rod*e*cross(rRod2_ib, Frames.resolve2(rod1.R_rel, rod1.eRod_a))
     Solving this equation for f_rod results in
       f_rod = (-tau - e*(frame_ib.t + frame_im.t + cross(rRod2_ib, frame_im.f)
               + cross(rRod2_ib, -rod1.f_b_a1)))
               / (cross(e,rRod2_ib)*Frames.resolve2(rod1.R_rel, rod1.eRod_a))
     Additionally, a guard against division by zero is introduced

     f_rod is passed to component JointsUSR.rod1 via variable "constraintResidue" in the Advanced menu
  */
        aux = cross(revolute.e, rRod2_ib)*Frames.resolveRelative(rod1.eRod_a,
          rod1.frame_a.R, rod1.frame_b.R);
        f_rod = (-revolute.tau - revolute.e*(frame_ib.t + frame_im.t + cross(
          rRod2_ib, frame_im.f) - cross(rRod2_ib, Frames.resolveRelative(rod1.
          f_b_a1, rod1.frame_a.R, rod1.frame_b.R))))/noEvent(if abs(aux) < 1.e-10 then
                1.e-10 else aux);

        // Measure power for test purposes
        if checkTotalPower then
          totalPower = frame_a.f*Frames.resolve2(frame_a.R, der(frame_a.r_0)) +
            frame_b.f*Frames.resolve2(frame_b.R, der(frame_b.r_0)) + frame_ia.f*
            Frames.resolve2(frame_ia.R, der(frame_ia.r_0)) + frame_ib.f*
            Frames.resolve2(frame_ib.R, der(frame_ib.r_0)) + frame_im.f*
            Frames.resolve2(frame_im.R, der(frame_im.r_0)) + frame_a.t*
            Frames.angularVelocity2(frame_a.R) + frame_b.t*
            Frames.angularVelocity2(frame_b.R) + frame_ia.t*
            Frames.angularVelocity2(frame_ia.R) + frame_ib.t*
            Frames.angularVelocity2(frame_ib.R) + frame_im.t*
            Frames.angularVelocity2(frame_im.R) + axis.tau*der(axis.phi) +
            bearing.tau*der(bearing.phi);
        else
          totalPower = 0;
        end if;

        connect(revolute.frame_b, rod2.frame_a) annotation (Line(
            points={{35,0},{15,0}},
            color={95,95,95},
            thickness=0.5));
        connect(rod2.frame_b, rod1.frame_b) annotation (Line(
            points={{-25,0},{-52,0}},
            color={95,95,95},
            thickness=0.5));
        connect(revolute.frame_a, frame_b) annotation (Line(
            points={{75,0},{100,0}},
            color={95,95,95},
            thickness=0.5));
        connect(rod2.frame_a, frame_ib) annotation (Line(
            points={{15,0},{26,0},{26,70},{80,70},{80,100}},
            color={95,95,95},
            thickness=0.5));
        connect(rod1.frame_a, frame_a) annotation (Line(
            points={{-92,0},{-100,0}},
            color={95,95,95},
            thickness=0.5));
        connect(relativePosition.frame_b, frame_a)
                                                 annotation (Line(
            points={{40,-80},{-96,-80},{-96,0},{-100,0}},
            color={95,95,95},
            pattern=LinePattern.Dot));
        connect(relativePosition.frame_a, frame_b)
                                                 annotation (Line(
            points={{60,-80},{96,-80},{96,0},{100,0}},
            color={95,95,95},
            pattern=LinePattern.Dot));
        connect(position_b.y, revolute.position_b)       annotation (Line(
            points={{1,-40},{20,-40},{20,-12},{31,-12}},
            color={0,0,127}));
        connect(rod2.frame_b, frame_im) annotation (Line(
            points={{-25,0},{-40,0},{-40,80},{0,80},{0,100}},
            color={95,95,95},
            thickness=0.5));
        connect(rod1.frame_ia, frame_ia) annotation (Line(
            points={{-80,20},{-80,100}},
            color={95,95,95},
            thickness=0.5));
        connect(revolute.axis, axis) annotation (Line(points={{55,20},{55,60},{90,
                60},{90,80},{100,80}}, color={0,0,0}));
        connect(relativePosition.r_rel, revolute.position_a) annotation (Line(
            points={{50,-69},{50,-40},{90,-40},{90,-12},{79,-12}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(revolute.bearing, bearing) annotation (Line(
            points={{67,20},{67,40},{100,40}},
            color={0,0,0},
            smooth=Smooth.None));
        annotation (
          Documentation(info="<html>
<p>
This component consists of a <b>universal</b> joint at frame_a, a <b>revolute</b>
joint at frame_b and a <b>spherical</b> joint which is connected via <b>rod1</b>
to the universal and via <b>rod2</b> to the revolute joint, see the default
animation in the following figure (the axes vectors are not part of the
default animation):
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/JointUSR.png\" ALT=\"model Joints.Assemblies.JointUSR\">
</p>

<p>
This joint aggregation has no mass and no inertia and
introduces neither constraints nor potential state variables.
It should be used in kinematic loops whenever possible since
the non-linear system of equations introduced by this joint aggregation
is solved <b>analytically</b> (i.e., a solution is always computed, if a
unique solution exists).
</p>
<p>
The universal joint is defined in the following way:
</p>
<ul>
<li> The rotation <b>axis</b> of revolute joint <b>1</b> is along parameter
     vector n1_a which is fixed in frame_a.</li>
<li> The rotation <b>axis</b> of revolute joint <b>2</b> is perpendicular to
     axis 1 and to the line connecting the universal and the spherical joint
     (= rod 1).</li>
</ul>
<p>
The definition of axis 2 of the universal joint is performed according
to the most often occurring case. In a future release, axis 2 might
be explicitly definable via a parameter. However, the treatment is much more
complicated and the number of operations is considerably higher,
if axis 2 is not orthogonal to axis 1 and to the connecting rod.
</p>
<p>
Note, there is a <b>singularity</b> when axis 1 and the connecting rod are parallel
to each other. Therefore, if possible n1_a should be selected in such a way that it
is perpendicular to rRod1_ia in the initial configuration (i.e., the
distance to the singularity is as large as possible).
</p>
<p>
The rest of this joint aggregation is defined by the following parameters:
</p>
<ul>
<li> The position of the spherical joint with respect to the universal
     joint is defined by vector <b>rRod1_ia</b>. This vector is directed from
     frame_a to the spherical joint and is resolved in frame_ia
     (it is most simple to select frame_ia such that it is parallel to
     frame_a in the reference or initial configuration).</li>
<li> The position of the spherical joint with respect to the revolute
     joint is defined by vector <b>rRod2_ib</b>. This vector is directed from
     the inner frame of the revolute joint (frame_ib or revolute.frame_a)
     to the spherical joint and is resolved in frame_ib (note, that frame_ib
     and frame_b are parallel to each other).</li>
<li> The axis of rotation of the revolute joint is defined by axis
     vector <b>n_b</b>. It is fixed and resolved in frame_b.</li>
<li> When specifying this joint aggregation with the definitions above, <b>two</b>
     different <b>configurations</b> are possible. Via parameter <b>phi_guess</b>
     a guess value for revolute.phi(t0) at the initial time t0 is given. The configuration is selected that is closest to phi_guess (|revolute.phi - phi_guess| is minimal).</li>
</ul>
<p>
An additional <b>frame_ia</b> is present. It is <b>fixed</b> in the rod
connecting the universal and the spherical joint at the
origin of <b>frame_a</b>. The placement of frame_ia on the rod
is implicitly defined by the universal joint (frame_a and frame_ia coincide
when the angles of the two revolute joints of the universal joint are zero)
and by parameter vector <b>rRod1_ia</b>, the position vector
from the origin of frame_a to the spherical joint, resolved in frame_<b>ia</b>.
</p>
<p>
An additional <b>frame_ib</b> is present. It is <b>fixed</b> in the rod
connecting the revolute and the spherical joint at the side of the revolute
joint that is connected to this rod (= rod2.frame_a = revolute.frame_a).
</p>
<p>
An additional <b>frame_im</b> is present. It is <b>fixed</b> in the rod
connecting the revolute and the spherical joint at the side of the spherical
joint that is connected to this rod (= rod2.frame_b).
It is always parallel to <b>frame_ib</b>.
</p>
<p>
The easiest way to define the parameters of this joint is by moving the
MultiBody system in a <b>reference configuration</b> where <b>all frames</b>
of all components are <b>parallel</b> to each other (alternatively,
at least frame_a and frame_ia of the JointUSR joint
should be parallel to each other when defining an instance of this
component).
</p>
<p>
In the public interface of the JointUSR joint, the following
(final) <b>parameters</b> are provided:
</p>
<pre>
  <b>parameter</b> Real rod1Length(unit=\"m\")  \"Length of rod 1\";
  <b>parameter</b> Real eRod1_ia[3] \"Unit vector along rod 1, resolved in frame_ia\";
  <b>parameter</b> Real e2_ia  [3]  \"Unit vector along axis 2, resolved in frame_ia\";
</pre>
<p>
This allows a more convenient definition of data which is related to rod 1.
For example, if a box shall be connected at frame_ia directing from
the origin of frame_a to the middle of rod 1, this might be defined as:
</p>
<pre>
    Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUSP jointUSR(rRod1_ia={1.2, 1, 0.2});
    Modelica.Mechanics.MultiBody.Visualizers.FixedShape     shape(shapeType       = \"box\",
                                               lengthDirection = jointUSR.eRod1_ia,
                                               widthDirection  = jointUSR.e2_ia,
                                               length          = jointUSR.rod1Length/2,
                                               width           = jointUSR.rod1Length/10);
  <b>equation</b>
    <b>connect</b>(jointUSP.frame_ia, shape.frame_a);
</pre>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              initialScale=0.2), graphics={
              Text(
                extent={{-140,-41},{140,-66}},
                lineColor={0,0,255},
                textString="%name"),
              Ellipse(
                extent={{-100,-30},{-40,30}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-93,-22},{-48,23}},
                lineColor={160,160,164},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-70,40},{-39,-33}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-70,28},{-70,-30}},
                color={0,0,0},
                thickness=0.5),
              Ellipse(
                extent={{-89,-18},{-48,18}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-84,-12},{-53,13}},
                lineColor={160,160,164},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-81,-17},{-92,-1},{-83,16},{-57,24},{-81,-17}},
                pattern=LinePattern.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(
                points={{-70,30},{-70,-10}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-61,16},{-79,-15}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-50,0},{-50,80},{-80,80},{-80,100}},
                color={95,95,95},
                thickness=0.5),
              Ellipse(
                extent={{-40,-30},{20,30}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-33,-22},{12,23}},
                lineColor={192,192,192},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-44,31},{-14,-30}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-23,10},{-3,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{19,6},{61,-6}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-50,5},{-21,-5}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{60,-30},{76,30}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{85,-30},{100,30}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{76,10},{85,-10}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Rectangle(extent={{60,30},{76,-30}}, lineColor={0,0,0}),
              Rectangle(extent={{85,30},{100,-30}}, lineColor={0,0,0}),
              Text(
                extent={{40,109},{77,91}},
                lineColor={128,128,128},
                textString="ib"),
              Text(
                extent={{-124,109},{-95,92}},
                lineColor={128,128,128},
                textString="ia"),
              Line(
                points={{60,30},{60,80},{80,80},{80,100}},
                color={95,95,95},
                thickness=0.5),
              Text(
                extent={{-43,108},{-10,92}},
                lineColor={128,128,128},
                textString="im"),
              Line(
                points={{19,6},{19,80},{0,80},{0,100}},
                color={95,95,95},
                thickness=0.5),
              Line(
                points={{80,80},{101,80}},
                color={128,128,128},
                thickness=0.5),
              Line(
                points={{90,30},{90,40},{95,40}},
                color={95,95,95},
                thickness=0.5)}));
      end JointUSR;

      model JointUSP
        "Universal - spherical - prismatic joint aggregation (no constraints, no potential states)"

        import Modelica_Mechanics_MultiBody.Types;

        extends Interfaces.PartialTwoFramesDoubleSize;
        Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_ia
          "Coordinate system at origin of frame_a fixed at connecting rod of universal and spherical joint"
          annotation (Placement(transformation(
              origin={-80,100},
              extent={{-8,-8},{8,8}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_ib
          "Coordinate system at origin of frame_b fixed at connecting rod of spherical and prismatic joint"
          annotation (Placement(transformation(
              origin={80,100},
              extent={{-8,8},{8,-8}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_im
          "Coordinate system at origin of spherical joint fixed at connecting rod of spherical and prismatic joint"
          annotation (Placement(transformation(
              origin={0,100},
              extent={{8,-8},{-8,8}},
              rotation=270)));
        Modelica_Mechanics_Translational.Interfaces.Flange_a axis
          "1-dim. translational flange that drives the prismatic joint"
          annotation (Placement(transformation(extent={{95,75},{105,85}},
                rotation=0)));
        Modelica_Mechanics_Translational.Interfaces.Flange_b bearing
          "1-dim. translational flange of the drive bearing of the prismatic joint"
          annotation (Placement(transformation(extent={{105,35},{95,45}},
                rotation=0)));

        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        parameter Boolean showUniversalAxes=true
          "= true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)";
        parameter Modelica_Mechanics_MultiBody.Types.Axis n1_a={0,0,1}
          "Axis 1 of universal joint fixed and resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod 1)"
          annotation (Evaluate=true);
        parameter Modelica_Mechanics_MultiBody.Types.Axis n_b={-1,0,0}
          "Axis of prismatic joint fixed and resolved in frame_b"
          annotation (Evaluate=true);
        parameter Modelica_SIunits.Position rRod1_ia[3]={1,0,0}
          "Vector from origin of frame_a to spherical joint, resolved in frame_ia"
          annotation (Evaluate=true);
        parameter Modelica_SIunits.Position rRod2_ib[3]={-1,0,0}
          "Vector from origin of frame_ib to spherical joint, resolved in frame_ib (frame_ib is parallel to frame_b)"
          annotation (Evaluate=true);
        parameter Modelica_SIunits.Position s_offset=0
          "Relative distance offset of prismatic joint (distance between the prismatic joint frames = s(t) + s_offset)";
        parameter Modelica_SIunits.Position s_guess=0
          "Select the configuration such that at initial time |s(t0)-s_guess| is minimal";
        parameter Modelica_SIunits.Diameter sphereDiameter=world.defaultJointLength
          "Diameter of the spheres representing the universal and the spherical joint"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color sphereColor=Types.Defaults.JointColor
          "Color of the spheres representing the universal and the spherical joint"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        parameter Modelica_SIunits.Diameter rod1Diameter=sphereDiameter/Types.Defaults.JointRodDiameterFraction
          "Diameter of rod 1 connecting the universal and the spherical joint"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color rod1Color=Types.Defaults.RodColor
          "Color of rod 1 connecting the universal and the spherical joint"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        parameter Modelica_SIunits.Diameter rod2Diameter=rod1Diameter
          "Diameter of rod 2 connecting the prismatic and the spherical joint"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color rod2Color=rod1Color
          "Color of rod 2 connecting the prismatic and the spherical joint"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        parameter Types.Axis boxWidthDirection={0,1,0}
          "Vector in width direction of prismatic joint, resolved in frame_b"
          annotation (Evaluate=true, Dialog(tab="Animation", group=
                "if animation = true", enable=animation));
        parameter Modelica_SIunits.Distance boxWidth=world.defaultJointWidth
          "Width of prismatic joint box" annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter Modelica_SIunits.Distance boxHeight=boxWidth
          "Height of prismatic joint box" annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color boxColor=sphereColor "Color of prismatic joint box"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
        parameter Modelica_SIunits.Distance cylinderLength=world.defaultJointLength
          "Length of cylinders representing the two universal joint axes"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true and showUniversalAxes",
            enable=animation and showUniversalAxes));
        parameter Modelica_SIunits.Distance cylinderDiameter=world.defaultJointWidth
          "Diameter of cylinders representing the two universal joint axes"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true and showUniversalAxes",
            enable=animation and showUniversalAxes));
        input Types.Color cylinderColor=Types.Defaults.JointColor
          "Color of cylinders representing the two universal joint axes" annotation (
            Dialog(colorSelector=true, tab="Animation", group="if animation = true and showUniversalAxes",
                  enable=animation and showUniversalAxes));
        parameter Boolean checkTotalPower=false
          "= true, if total power flowing into this component shall be determined (must be zero)"
          annotation (Dialog(tab="Advanced"));
        final parameter Real eRod1_ia[3](each final unit="1")=rod1.eRod_ia
          "Unit vector from origin of frame_a to origin of spherical joint, resolved in frame_ia";
        final parameter Real e2_ia[3](each final unit="1")=rod1.e2_ia
          "Unit vector in direction of axis 2 of universal joint, resolved in frame_ia";
        final parameter Modelica_SIunits.Distance rod1Length=rod1.rodLength
          "Length of rod 1 (= distance between universal and spherical joint)";
        Modelica_SIunits.Force f_rod
          "Constraint force in direction of the rod (positive, if rod is pressed)";
        Modelica_SIunits.Power totalPower
          "Total power flowing into this element, if checkTotalPower=true (otherwise dummy)";

        Modelica_Mechanics_MultiBody.Joints.Internal.PrismaticWithLengthConstraint
          prismatic(
          animation=animation,
          length=rod1.rodLength,
          n=n_b,
          s_offset=s_offset,
          s_guess=s_guess,
          boxWidthDirection=boxWidthDirection,
          boxWidth=boxWidth,
          boxHeight=boxHeight,
          boxColor=boxColor,
          specularCoefficient=specularCoefficient) annotation (Placement(
              transformation(extent={{76,-20},{36,20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.UniversalSpherical rod1(
          animation=animation,
          showUniversalAxes=showUniversalAxes,
          rRod_ia=rRod1_ia,
          n1_a=n1_a,
          sphereDiameter=sphereDiameter,
          sphereColor=sphereColor,
          rodWidth=rod1Diameter,
          rodHeight=rod1Diameter,
          rodColor=rod1Color,
          specularCoefficient=specularCoefficient,
          cylinderLength=cylinderLength,
          cylinderDiameter=cylinderDiameter,
          cylinderColor=cylinderColor,
          kinematicConstraint=false,
          constraintResidue=rod1.f_rod - f_rod) annotation (Placement(
              transformation(extent={{-92,-20},{-52,20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation rod2(
          animation=animation,
          r=rRod2_ib,
          width=rod2Diameter,
          height=rod2Diameter,
          specularCoefficient=specularCoefficient,
          color=rod2Color) annotation (Placement(transformation(extent={{0,20},
                  {-40,-20}}, rotation=0)));
        Sensors.RelativePosition relativePosition(resolveInFrame=Types.ResolveInFrameAB.frame_a)
          annotation (Placement(transformation(extent={{50,-70},{30,-90}},
                rotation=0)));
        Modelica_Blocks.Sources.Constant position_b[3](k=rRod2_ib)
          annotation (Placement(transformation(extent={{-20,-60},{0,-40}},
                rotation=0)));
      protected
        Real aux
          "Denominator used to compute force in rod connecting universal and spherical joint";
      equation
        /* Compute the unknown force in rod1 connecting the universal and
     the spherical joint by a force balance at the prismatic joint
        0 = -prismatic.frame_b.f + frame_ib.f + frame_im.f - rod1.frame_b.f
     The force at rod1.frame_b is split into two parts:
        rod1.frame_b.f = Frames.resolve2(rod1.R_rel, rod1.f_b_a1 - rod1.f_rod*rod1.eRod_a)
     where rod1.f_rod is the unknown force in rod1.
     The condition is that the projection of the force in the prismatic
     joint along the axis of its translation axis is equal to the driving
     axis force in the flange:
       -prismatic.f = prismatic.e*prismatic.frame_b.f
     Therefore, we have with e=prismatic.e and f=prismatic.f
       -f = e*(frame_ib.f + frame_im.f
               - Frames.resolve2(rod1.R_rel, rod1.f_b_a1 - rod1.f_rod*rod1.eRod_a))
          = e*(frame_ib.f + frame_im.f - Frames.resolve2(rod1.R_rel, rod1.f_b_a1)
              + rod1.f_rod*Frames.resolve2(rod1.R_rel, rod1.eRod_a))
     Solving this equation for f_rod results in
       rod1.f_rod = -(f+e*(frame_ib.f + frame_im.f - Frames.resolve2(rod1.R_rel, rod1.f_b_a1)))
                   /(e*Frames.resolve2(rod1.R_rel, rod1.eRod_a))
     Additionally, a guard against division by zero is introduced
  */
        aux = prismatic.e*Frames.resolveRelative(rod1.eRod_a, rod1.frame_a.R,
          rod1.frame_b.R);
        f_rod = (-prismatic.f - prismatic.e*(frame_ib.f + frame_im.f -
          Frames.resolveRelative(rod1.f_b_a1, rod1.frame_a.R, rod1.frame_b.R)))/
          noEvent(if abs(aux) < 1.e-10 then 1.e-10 else aux);
        // Measure power for test purposes
        if checkTotalPower then
          totalPower = frame_a.f*Frames.resolve2(frame_a.R, der(frame_a.r_0)) +
            frame_b.f*Frames.resolve2(frame_b.R, der(frame_b.r_0)) + frame_ia.f*
            Frames.resolve2(frame_ia.R, der(frame_ia.r_0)) + frame_ib.f*
            Frames.resolve2(frame_ib.R, der(frame_ib.r_0)) + frame_im.f*
            Frames.resolve2(frame_im.R, der(frame_im.r_0)) + frame_a.t*
            Frames.angularVelocity2(frame_a.R) + frame_b.t*
            Frames.angularVelocity2(frame_b.R) + frame_ia.t*
            Frames.angularVelocity2(frame_ia.R) + frame_ib.t*
            Frames.angularVelocity2(frame_ib.R) + frame_im.t*
            Frames.angularVelocity2(frame_im.R) + axis.f*der(axis.s) + bearing.f*
            der(bearing.s);
        else
          totalPower = 0;
        end if;

        connect(prismatic.frame_b, rod2.frame_a) annotation (Line(
            points={{36,0},{0,0}},
            color={95,95,95},
            thickness=0.5));
        connect(rod2.frame_b, rod1.frame_b) annotation (Line(
            points={{-40,0},{-52,0}},
            color={0,0,0},
            thickness=0.5));
        connect(prismatic.frame_a, frame_b) annotation (Line(
            points={{76,0},{100,0}},
            color={95,95,95},
            thickness=0.5));
        connect(rod2.frame_a, frame_ib) annotation (Line(
            points={{0,0},{7,0},{7,70},{80,70},{80,100}},
            color={95,95,95},
            thickness=0.5));
        connect(rod1.frame_a, frame_a) annotation (Line(
            points={{-92,0},{-100,0}},
            color={95,95,95},
            thickness=0.5));
        connect(relativePosition.frame_b, frame_a)
                                                 annotation (Line(
            points={{30,-80},{-97,-80},{-97,0},{-100,0}},
            color={95,95,95},
            pattern=LinePattern.Dot));
        connect(relativePosition.frame_a, frame_b)
                                                 annotation (Line(
            points={{50,-80},{95,-80},{95,0},{100,0}},
            color={95,95,95},
            pattern=LinePattern.Dot));
        connect(rod2.frame_b, frame_im) annotation (Line(
            points={{-40,0},{-46,0},{-46,80},{0,80},{0,100}},
            color={95,95,95},
            thickness=0.5));
        connect(rod1.frame_ia, frame_ia) annotation (Line(
            points={{-80,20},{-80,100}},
            color={95,95,95},
            thickness=0.5));
        connect(position_b.y, prismatic.position_b)       annotation (Line(
            points={{1,-50},{10,-50},{10,-12},{32,-12}},
            color={0,0,127}));
        connect(prismatic.axis, axis) annotation (Line(points={{40,14},{40,56},{
                90,56},{90,80},{100,80}}, color={0,191,0}));
        connect(prismatic.bearing, bearing)
          annotation (Line(points={{64,14},{64,40},{100,40}}, color={0,191,0}));
        connect(relativePosition.r_rel, prismatic.position_a)
                                                            annotation (Line(
            points={{40,-69},{40,-50},{90,-50},{90,-12},{80,-12}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (
          Documentation(info="<html>
<p>
This component consists of a <b>universal</b> joint at frame_a, a <b>prismatic</b>
joint at frame_b and a <b>spherical</b> joint which is connected via <b>rod1</b>
to the universal and via <b>rod2</b> to the prismatic joint, see the default
animation in the following figure (the axes vectors are not part of the
default animation):
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/JointUSP.png\" ALT=\"model Joints.Assemblies.JointUSP\">
</p>

<p>
This joint aggregation has no mass and no inertia and
introduces neither constraints nor potential state variables.
It should be used in kinematic loops whenever possible since
the non-linear system of equations introduced by this joint aggregation
is solved <b>analytically</b> (i.e., a solution is always computed, if a
unique solution exists).
</p>
<p>
The universal joint is defined in the following way:
</p>
<ul>
<li> The rotation <b>axis</b> of revolute joint <b>1</b> is along parameter
     vector n1_a which is fixed in frame_a.</li>
<li> The rotation <b>axis</b> of revolute joint <b>2</b> is perpendicular to
     axis 1 and to the line connecting the universal and the spherical joint
     (= rod 1).</li>
</ul>
<p>
The definition of axis 2 of the universal joint is performed according
to the most often occurring case. In a future release, axis 2 might
be explicitly definable via a parameter. However, the treatment is much more
complicated and the number of operations is considerably higher,
if axis 2 is not orthogonal to axis 1 and to the connecting rod.
</p>
<p>
Note, there is a <b>singularity</b> when axis 1 and the connecting rod are parallel
to each other. Therefore, if possible n1_a should be selected in such a way that it
is perpendicular to rRod1_ia in the initial configuration (i.e., the
distance to the singularity is as large as possible).
</p>
<p>
The rest of this joint aggregation is defined by the following parameters:
</p>
<ul>
<li> The position of the spherical joint with respect to the universal
     joint is defined by vector <b>rRod1_ia</b>. This vector is directed from
     frame_a to the spherical joint and is resolved in frame_ia
     (it is most simple to select frame_ia such that it is parallel to
     frame_a in the reference or initial configuration).</li>
<li> The position of the spherical joint with respect to the prismatic
     joint is defined by vector <b>rRod2_ib</b>. This vector is directed from
     the inner frame of the prismatic joint (frame_ib or prismatic.frame_a)
     to the spherical joint and is resolved in frame_ib (note, that frame_ib
     and frame_b are parallel to each other).</li>
<li> The axis of translation of the prismatic joint is defined by axis
     vector <b>n_b</b>. It is fixed and resolved in frame_b.</li>
<li> The two frames of the prismatic joint, i.e., frame_b and frame_ib,
     are parallel to each other.
     The distance between the origins of these two frames along axis n_b
     is equal to \"prismatic.s(t) + s_offset\", where \"prismatic.s(t)\" is
     a time varying variable and \"s_offset\" is a fixed, constant offset
     parameter.</li>
<li> When specifying this joint aggregation with the definitions above, <b>two</b>
     different <b>configurations</b> are possible. Via parameter <b>s_guess</b>
     a guess value for prismatic.s(t0) at the initial time t0 is given. The configuration
     is selected that is closest to s_guess (|prismatic.s - s_guess| is minimal).</li>
</ul>
<p>
An additional <b>frame_ia</b> is present. It is <b>fixed</b> in the rod
connecting the universal and the spherical joint at the
origin of <b>frame_a</b>. The placement of frame_ia on the rod
is implicitly defined by the universal joint (frame_a and frame_ia coincide
when the angles of the two revolute joints of the universal joint are zero)
and by parameter vector <b>rRod1_ia</b>, the position vector
from the origin of frame_a to the spherical joint, resolved in frame_<b>ia</b>.
</p>
<p>
An additional <b>frame_ib</b> is present. It is <b>fixed</b> in the rod
connecting the prismatic and the spherical joint at the side of the prismatic
joint that is connected to this rod (= rod2.frame_a = prismatic.frame_a).
It is always parallel to <b>frame_b</b>.
</p>
<p>
An additional <b>frame_im</b> is present. It is <b>fixed</b> in the rod
connecting the prismatic and the spherical joint at the side of the spherical
joint that is connected to this rod (= rod2.frame_b).
It is always parallel to <b>frame_b</b>.
</p>
<p>
The easiest way to define the parameters of this joint is by moving the
MultiBody system in a <b>reference configuration</b> where <b>all frames</b>
of all components are <b>parallel</b> to each other (alternatively,
at least frame_a and frame_ia of the JointUSP joint
should be parallel to each other when defining an instance of this
component).
</p>
<p>
In the public interface of the JointUSP joint, the following
(final) <b>parameters</b> are provided:
</p>
<pre>
  <b>parameter</b> Real rod1Length(unit=\"m\")  \"Length of rod 1\";
  <b>parameter</b> Real eRod1_ia[3] \"Unit vector along rod 1, resolved in frame_ia\";
  <b>parameter</b> Real e2_ia  [3]  \"Unit vector along axis 2, resolved in frame_ia\";
</pre>
<p>
This allows a more convenient definition of data which is related to rod 1.
For example, if a box shall be connected at frame_ia directing from
the origin of frame_a to the middle of rod 1, this might be defined as:
</p>
<pre>
    Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUSP jointUSP(rRod1_ia={1.2, 1, 0.2});
    Modelica.Mechanics.MultiBody.Visualizers.FixedShape     shape(shapeType       = \"box\",
                                               lengthDirection = jointUSP.eRod1_ia,
                                               widthDirection  = jointUSP.e2_ia,
                                               length          = jointUSP.rod1Length/2,
                                               width           = jointUSP.rod1Length/10);
  <b>equation</b>
    <b>connect</b>(jointUSP.frame_ia, shape.frame_a);
</pre>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              initialScale=0.2), graphics={
              Rectangle(
                extent={{50,20},{80,-20}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{80,30},{100,-30}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-140,-45},{140,-70}},
                lineColor={0,0,255},
                textString="%name"),
              Ellipse(
                extent={{-100,-30},{-40,30}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-93,-22},{-48,23}},
                lineColor={160,160,164},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-70,40},{-39,-33}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-70,28},{-70,-30}},
                color={0,0,0},
                thickness=0.5),
              Ellipse(
                extent={{-89,-18},{-48,18}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-84,-12},{-53,13}},
                lineColor={160,160,164},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-81,-17},{-92,-1},{-83,16},{-57,24},{-81,-17}},
                pattern=LinePattern.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(
                points={{-70,30},{-70,-10}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-61,16},{-79,-15}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-50,0},{-50,80},{-80,80},{-80,100}},
                color={95,95,95},
                thickness=0.5),
              Ellipse(
                extent={{-40,-30},{20,30}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-33,-22},{12,23}},
                lineColor={192,192,192},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-44,31},{-14,-30}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-23,10},{-3,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{19,6},{50,-6}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-50,5},{-21,-5}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Text(
                extent={{37,109},{68,90}},
                lineColor={128,128,128},
                textString="ib"),
              Text(
                extent={{-124,110},{-93,90}},
                lineColor={128,128,128},
                textString="ia"),
              Line(
                points={{50,6},{50,80},{80,80},{80,100}},
                color={95,95,95},
                thickness=0.5),
              Text(
                extent={{-44,111},{-8,91}},
                lineColor={128,128,128},
                textString="im"),
              Line(
                points={{19,6},{19,80},{0,80},{0,100}},
                color={95,95,95},
                thickness=0.5),
              Rectangle(
                extent={{80,24},{100,30}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{50,14},{80,20}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(
                points={{95,80},{79,80}},
                color={135,135,135},
                thickness=0.5),
              Line(
                points={{95,40},{90,40},{90,30}},
                color={135,135,135},
                thickness=0.5)}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              initialScale=0.2), graphics={
              Line(
                points={{-78,30},{-50,30}},
                color={128,128,128},
                arrow={Arrow.None,Arrow.Filled}),
              Text(
                extent={{-76,39},{-49,32}},
                lineColor={128,128,128},
                textString="rRod1_ia"),
              Text(
                extent={{-27,40},{0,33}},
                lineColor={128,128,128},
                textString="rRod2_ib"),
              Line(
                points={{3,30},{-43,30}},
                color={128,128,128},
                arrow={Arrow.None,Arrow.Filled})}));
      end JointUSP;

      model JointSSR
        "Spherical - spherical - revolute joint aggregation with mass (no constraints, no potential states)"

        import Modelica_Mechanics_MultiBody.Types;

        extends Interfaces.PartialTwoFramesDoubleSize;
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_ib
          "Coordinate system at origin of frame_b fixed at connecting rod of spherical and revolute joint"
          annotation (Placement(transformation(
              origin={80,100},
              extent={{-8,8},{8,-8}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_im
          "Coordinate system at origin of spherical joint in the middle fixed at connecting rod of spherical and revolute joint"
          annotation (Placement(transformation(
              origin={0,100},
              extent={{8,-8},{-8,8}},
              rotation=270)));
        Modelica_Mechanics_Rotational.Interfaces.Flange_a axis
          "1-dim. rotational flange that drives the revolute joint"
          annotation (Placement(transformation(extent={{105,85},{95,75}},
                rotation=0)));
        Modelica_Mechanics_Rotational.Interfaces.Flange_b bearing
          "1-dim. rotational flange of the drive bearing of the revolute joint"
          annotation (Placement(transformation(extent={{95,45},{105,35}},
                rotation=0)));

        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        parameter Boolean showMass=true
          "= true, if point mass on rod 1 shall be shown (provided animation = true and rod1Mass > 0)";
        parameter Modelica_SIunits.Length rod1Length(min=Modelica_Constants.eps,
            start=1) "Distance between the origins of the two spherical joints";
        parameter Modelica_SIunits.Mass rod1Mass(min=0) = 0
          "Mass of rod 1 (= point mass located in middle of rod connecting the two spherical joints)";
        parameter Modelica_Mechanics_MultiBody.Types.Axis n_b={0,0,1}
          "Axis of revolute joint fixed and resolved in frame_b";
        parameter Modelica_SIunits.Position rRod2_ib[3]={1,0,0}
          "Vector from origin of frame_ib to spherical joint in the middle, resolved in frame_ib";
        parameter Cv.NonSIunits.Angle_deg phi_offset=0
          "Relative angle offset of revolute joint (angle = phi(t) + from_deg(phi_offset))";
        parameter Cv.NonSIunits.Angle_deg phi_guess=0
          "Select the configuration such that at initial time |phi(t0) - from_deg(phi_guess)| is minimal";
        parameter Modelica_SIunits.Diameter sphereDiameter=world.defaultJointLength
          "Diameter of the spheres representing the two spherical joints"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color sphereColor=Types.Defaults.JointColor
          "Color of the spheres representing the two spherical joints"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        parameter Modelica_SIunits.Diameter rod1Diameter=sphereDiameter/Types.Defaults.JointRodDiameterFraction
          "Diameter of rod 1 connecting the two spherical joints" annotation (
            Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color rod1Color=Types.Defaults.RodColor
          "Color of rod 1 connecting the two spherical joint"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        parameter Modelica_SIunits.Diameter rod2Diameter=rod1Diameter
          "Diameter of rod 2 connecting the revolute joint and spherical joint 2"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color rod2Color=rod1Color
          "Color of rod 2 connecting the revolute joint and spherical joint 2"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        parameter Modelica_SIunits.Diameter revoluteDiameter=world.defaultJointWidth
          "Diameter of cylinder representing the revolute joint" annotation (
            Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter Modelica_SIunits.Distance revoluteLength=world.defaultJointLength
          "Length of cylinder representing the revolute joint" annotation (
            Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color revoluteColor=Types.Defaults.JointColor
          "Color of cylinder representing the revolute joint"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
        parameter Boolean checkTotalPower=false
          "= true, if total power flowing into this component shall be determined (must be zero)"
          annotation (Dialog(tab="Advanced"));
        Modelica_SIunits.Position aux
          "Denominator used to compute force in rod connecting universal and spherical joint";
        Modelica_SIunits.Force f_rod
          "Constraint force in direction of the rod (positive, if rod is pressed)";
        Modelica_SIunits.Power totalPower
          "Total power flowing into this element, if checkTotalPower=true (otherwise dummy)";

        Modelica_Mechanics_MultiBody.Joints.Internal.RevoluteWithLengthConstraint
          revolute(
          animation=animation,
          lengthConstraint=rod1Length,
          n=n_b,
          phi_offset=phi_offset,
          phi_guess=phi_guess,
          cylinderDiameter=revoluteDiameter,
          cylinderLength=revoluteLength,
          cylinderColor=revoluteColor,
          specularCoefficient=specularCoefficient) annotation (Placement(
              transformation(extent={{75,-20},{35,20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.SphericalSpherical rod1(
          animation=animation,
          showMass=showMass,
          m=rod1Mass,
          rodLength=rod1Length,
          rodDiameter=rod1Diameter,
          sphereDiameter=sphereDiameter,
          rodColor=rod1Color,
          specularCoefficient=specularCoefficient,
          kinematicConstraint=false,
          sphereColor=sphereColor,
          constraintResidue=rod1.f_rod - f_rod) annotation (Placement(
              transformation(extent={{-89,-20},{-49,20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation rod2(
          animation=animation,
          width=rod2Diameter,
          height=rod2Diameter,
          color=rod2Color,
          specularCoefficient=specularCoefficient,
          r=rRod2_ib) annotation (Placement(transformation(extent={{15,-20},{-25,
                  20}}, rotation=0)));
        Sensors.RelativePosition relativePosition(resolveInFrame=Types.ResolveInFrameAB.frame_a)
          annotation (Placement(transformation(extent={{60,-70},{40,-90}},
                rotation=0)));
        Modelica_Blocks.Sources.Constant position_b[3](k=rRod2_ib)
          annotation (Placement(transformation(extent={{-20,-50},{0,-30}},
                rotation=0)));
      equation
        /* Compute the unknown force in the rod of the rod1 joint
     by a torque balance at the revolute joint:
       0 = frame_b.t + frame_ib.t + frame_im.t + cross(rRod2_ib, frame_im.f)
           + cross(rRod2_ib, -rod1.f_b_a1)
           + cross(rRod2_ib, Frames.resolve2(rod1.R_rel, rod1.f_rod*rod1.eRod_a))
     The condition is that the projection of the torque in the revolute
     joint along the axis of the revolute joint is equal to the driving
     axis torque in the flange:
       -revolute.tau = revolute.e*frame_b.t
     Therefore, we have with e=revolute.e and tau=revolute.tau
        tau = e*(frame_ib.t  + frame_im.t + cross(rRod2_ib, frame_im.f)
              + cross(rRod2_ib, -rod1.f_b_a1))
              + e*cross(rRod2_ib, Frames.resolve2(rod1.R_rel, rod1.f_rod*rod1.eRod_a))
            = e*(frame_ib.t + frame_im.t + cross(rRod2_ib, frame_im.f)
              + cross(rRod2_ib, -rod.f_b_a1))
              + rod1.f_rod*e*cross(rRod2_ib, Frames.resolve2(rod1.R_rel, rod1.eRod_a))
     Solving this equation for f_rod results in
       rod1.f_rod = (tau - e*(frame_ib.t + frame_im.t + cross(rRod2_ib, frame_im.f)
                   + cross(rRod2_ib, -rod1.f_b_a1)))
                   / (cross(e,rRod2_ib)*Frames.resolve2(rod1.R_rel, rod1.eRod_a))
     Additionally, a guard against division by zero is introduced
  */

        aux = cross(revolute.e, rRod2_ib)*Frames.resolveRelative(rod1.eRod_a,
          rod1.frame_a.R, rod1.frame_b.R);
        f_rod = (-revolute.tau - revolute.e*(frame_ib.t + frame_im.t + cross(
          rRod2_ib, frame_im.f) - cross(rRod2_ib, Frames.resolveRelative(rod1.
          f_b_a1, rod1.frame_a.R, rod1.frame_b.R))))/noEvent(if abs(aux) < 1.e-10 then
                1.e-10 else aux);

        // Measure power for test purposes
        if checkTotalPower then
          totalPower = frame_a.f*Frames.resolve2(frame_a.R, der(frame_a.r_0)) +
            frame_b.f*Frames.resolve2(frame_b.R, der(frame_b.r_0)) + frame_ib.f*
            Frames.resolve2(frame_ib.R, der(frame_ib.r_0)) + frame_im.f*
            Frames.resolve2(frame_im.R, der(frame_im.r_0)) + frame_a.t*
            Frames.angularVelocity2(frame_a.R) + frame_b.t*
            Frames.angularVelocity2(frame_b.R) + frame_ib.t*
            Frames.angularVelocity2(frame_ib.R) + frame_im.t*
            Frames.angularVelocity2(frame_im.R) + axis.tau*der(axis.phi) +
            bearing.tau*der(bearing.phi) + (-rod1Mass)*(der(rod1.v_CM_0) -
            world.gravityAcceleration(rod1.r_CM_0))*rod1.v_CM_0;
        else
          totalPower = 0;
        end if;

        connect(revolute.frame_b, rod2.frame_a) annotation (Line(
            points={{35,0},{15,0}},
            color={95,95,95},
            thickness=0.5));
        connect(rod2.frame_b, rod1.frame_b) annotation (Line(
            points={{-25,0},{-49,0}},
            color={95,95,95},
            thickness=0.5));
        connect(revolute.frame_a, frame_b) annotation (Line(
            points={{75,0},{100,0}},
            color={95,95,95},
            thickness=0.5));
        connect(rod2.frame_a, frame_ib) annotation (Line(
            points={{15,0},{26,0},{26,70},{80,70},{80,100}},
            color={95,95,95},
            thickness=0.5));
        connect(rod1.frame_a, frame_a) annotation (Line(
            points={{-89,0},{-100,0}},
            color={95,95,95},
            thickness=0.5));
        connect(relativePosition.frame_b, frame_a)
                                                 annotation (Line(
            points={{40,-80},{-95,-80},{-95,0},{-100,0}},
            color={95,95,95},
            pattern=LinePattern.Dot));
        connect(relativePosition.frame_a, frame_b)
                                                 annotation (Line(
            points={{60,-80},{96,-80},{96,0},{100,0}},
            color={95,95,95},
            pattern=LinePattern.Dot));
        connect(position_b.y, revolute.position_b)       annotation (Line(
            points={{1,-40},{20,-40},{20,-12},{31,-12}},
            color={0,0,127}));
        connect(revolute.axis, axis) annotation (Line(points={{55,20},{55,60},{90,
                60},{90,80},{100,80}}, color={0,0,0}));
        connect(rod2.frame_b, frame_im) annotation (Line(
            points={{-25,0},{-35,0},{-35,60},{0,60},{0,100}},
            color={95,95,95},
            thickness=0.5));
        connect(relativePosition.r_rel, revolute.position_a)
                                                           annotation (Line(
            points={{50,-69},{50,-50},{90,-50},{90,-12},{79,-12}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(revolute.bearing, bearing) annotation (Line(
            points={{67,20},{67,40},{100,40}},
            color={0,0,0},
            smooth=Smooth.None));
        annotation (
          Documentation(info="<html>
<p>
This component consists of a <b>spherical</b> joint 1 at frame_a, a <b>revolute</b>
joint at frame_b and a <b>spherical</b> joint 2 which is connected via rod 1
to the spherical joint 1 and via rod 2 to the revolute joint, see the default
animation in the following figure (the axes vectors are not part of the
default animation):
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/JointSSR.png\" ALT=\"model Joints.Assemblies.JointSSR\">
</p>

<p>
Besides an optional point mass in the middle of rod 1,
this joint aggregation has no mass and no inertia,
and introduces neither constraints nor potential state variables.
It should be used in kinematic loops whenever possible since
the non-linear system of equations introduced by this joint aggregation
is solved <b>analytically</b> (i.e., a solution is always computed, if a
unique solution exists).
</p>
<p>
An additional <b>frame_ib</b> is present. It is <b>fixed</b> in rod 2
connecting the revolute and the spherical joint at the side of the revolute
joint that is connected to this rod (= rod2.frame_a = revolute.frame_a).
</p>
<p>
An additional <b>frame_im</b> is present. It is <b>fixed</b> in rod 2
connecting the revolute and the spherical joint at the side of spherical
joint 2 that is connected to this rod (= rod2.frame_b).
It is always parallel to <b>frame_ib</b>.
</p>
<p>
The easiest way to define the parameters of this joint is by moving the
MultiBody system in a <b>reference configuration</b> where <b>all frames</b>
of all components are <b>parallel</b> to each other (alternatively,
at least frame_b and frame_ib of the JointSSR joint
should be parallel to each other when defining an instance of this
component).
</p>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              initialScale=0.2), graphics={
              Text(
                extent={{-141,-41},{139,-66}},
                lineColor={0,0,255},
                textString="%name"),
              Ellipse(
                extent={{-100,-30},{-40,30}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-93,-22},{-48,23}},
                lineColor={160,160,164},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-63,33},{-39,-33}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-40,-30},{20,30}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-33,-22},{12,23}},
                lineColor={192,192,192},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-44,31},{-19,-30}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-23,10},{-3,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{19,6},{61,-6}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{60,-30},{76,30}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{85,-30},{100,30}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{76,10},{85,-10}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Rectangle(extent={{60,30},{76,-30}}, lineColor={0,0,0}),
              Rectangle(extent={{85,30},{100,-30}}, lineColor={0,0,0}),
              Text(
                extent={{88,112},{127,92}},
                lineColor={128,128,128},
                textString="ib"),
              Ellipse(
                extent={{-80,11},{-60,-9}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-62,6},{-21,-5}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Line(
                points={{80,80},{100,80}},
                color={95,95,95},
                thickness=0.5),
              Line(
                points={{19,6},{19,80},{0,80},{0,100}},
                color={95,95,95},
                thickness=0.5),
              Text(
                extent={{-47,111},{-8,92}},
                lineColor={128,128,128},
                textString="im"),
              Line(
                points={{68,30},{68,80},{80,80},{80,98}},
                color={95,95,95},
                thickness=0.5),
              Line(
                points={{90,30},{90,40},{95,40}},
                color={95,95,95},
                thickness=0.5)}));
      end JointSSR;

      model JointSSP
        "Spherical - spherical - prismatic joint aggregation with mass (no constraints, no potential states)"

        import Modelica_Mechanics_MultiBody.Types;

        extends Interfaces.PartialTwoFramesDoubleSize;
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_ib
          "Coordinate system at origin of frame_b fixed at connecting rod of spherical and prismatic joint"
          annotation (Placement(transformation(
              origin={80,100},
              extent={{-8,8},{8,-8}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_im
          "Coordinate system at origin of spherical joint in the middle fixed at connecting rod of spherical and prismatic joint"
          annotation (Placement(transformation(
              origin={0,100},
              extent={{8,-8},{-8,8}},
              rotation=270)));
        Modelica_Mechanics_Translational.Interfaces.Flange_a axis
          "1-dim. translational flange that drives the prismatic joint"
          annotation (Placement(transformation(extent={{95,75},{105,85}},
                rotation=0)));
        Modelica_Mechanics_Translational.Interfaces.Flange_b bearing
          "1-dim. translational flange of the drive bearing of the prismatic joint"
          annotation (Placement(transformation(extent={{105,35},{95,45}},
                rotation=0)));

        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        parameter Boolean showMass=true
          "= true, if point mass on rod 1 shall be shown (provided animation = true and rod1Mass > 0)";
        parameter Modelica_SIunits.Length rod1Length(min=Modelica_Constants.eps,
            start=1) "Distance between the origins of the two spherical joints";
        parameter Modelica_SIunits.Mass rod1Mass(min=0) = 0
          "Mass of rod 1 (= point mass located in middle of rod connecting the two spherical joints)";
        parameter Modelica_Mechanics_MultiBody.Types.Axis n_b={0,0,1}
          "Axis of prismatic joint fixed and resolved in frame_b";
        parameter Modelica_SIunits.Position rRod2_ib[3]={1,0,0}
          "Vector from origin of frame_ib to spherical joint in the middle, resolved in frame_ib";
        parameter Modelica_SIunits.Position s_offset=0
          "Relative distance offset of prismatic joint (distance between frame_b and frame_ib = s(t) + s_offset)";
        parameter Modelica_SIunits.Position s_guess=0
          "Select the configuration such that at initial time |s(t0)-s_guess| is minimal";

        parameter Modelica_SIunits.Diameter sphereDiameter=world.defaultJointLength
          "Diameter of the spheres representing the two spherical joints"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color sphereColor=Types.Defaults.JointColor
          "Color of the spheres representing the two spherical joints"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        parameter Modelica_SIunits.Diameter rod1Diameter=sphereDiameter/Types.Defaults.JointRodDiameterFraction
          "Diameter of rod 1 connecting the two spherical joints" annotation (
            Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color rod1Color=Types.Defaults.RodColor
          "Color of rod 1 connecting the two spherical joint"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));

        parameter Modelica_SIunits.Diameter rod2Diameter=rod1Diameter
          "Diameter of rod 2 connecting the revolute joint and spherical joint 2"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color rod2Color=rod1Color
          "Color of rod 2 connecting the revolute joint and spherical joint 2"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));

        parameter Types.Axis boxWidthDirection={0,1,0}
          "Vector in width direction of prismatic joint box, resolved in frame_b"
          annotation (Evaluate=true, Dialog(tab="Animation", group=
                "if animation = true", enable=animation));
        parameter Modelica_SIunits.Distance boxWidth=world.defaultJointWidth
          "Width of prismatic joint box" annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter Modelica_SIunits.Distance boxHeight=boxWidth
          "Height of prismatic joint box" annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color boxColor=Types.Defaults.JointColor
          "Color of prismatic joint box"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
        parameter Boolean checkTotalPower=false
          "= true, if total power flowing into this component shall be determined (must be zero)"
          annotation (Dialog(tab="Advanced"));
        Real aux
          "Denominator used to compute force in rod connecting universal and spherical joint";
        Modelica_SIunits.Force f_rod
          "Constraint force in direction of the rod (positive, if rod is pressed)";
        Modelica_SIunits.Power totalPower
          "Total power flowing into this element, if checkTotalPower=true (otherwise dummy)";

        Modelica_Mechanics_MultiBody.Joints.Internal.PrismaticWithLengthConstraint
          prismatic(
          animation=animation,
          length=rod1Length,
          n=n_b,
          s_offset=s_offset,
          s_guess=s_guess,
          boxWidthDirection=boxWidthDirection,
          boxWidth=boxWidth,
          boxHeight=boxHeight,
          specularCoefficient=specularCoefficient,
          boxColor=boxColor) annotation (Placement(transformation(extent={{75,-20},
                  {35,20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Joints.SphericalSpherical rod1(
          animation=animation,
          showMass=showMass,
          m=rod1Mass,
          rodLength=rod1Length,
          rodDiameter=rod1Diameter,
          sphereDiameter=sphereDiameter,
          rodColor=rod1Color,
          kinematicConstraint=false,
          specularCoefficient=specularCoefficient,
          sphereColor=sphereColor,
          constraintResidue=rod1.f_rod - f_rod) annotation (Placement(
              transformation(extent={{-89,-20},{-49,20}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Parts.FixedTranslation rod2(
          animation=animation,
          width=rod2Diameter,
          height=rod2Diameter,
          specularCoefficient=specularCoefficient,
          color=rod2Color,
          r=rRod2_ib) annotation (Placement(transformation(extent={{15,-20},{-25,
                  20}}, rotation=0)));
        Sensors.RelativePosition relativePosition(resolveInFrame=Types.ResolveInFrameAB.frame_a)
          annotation (Placement(transformation(extent={{60,-70},{40,-90}},
                rotation=0)));
        Modelica_Blocks.Sources.Constant position_b[3](k=rRod2_ib)
          annotation (Placement(transformation(extent={{-20,-50},{0,-30}},
                rotation=0)));
      equation
        /* Compute the unknown force in the rod of the rod1 joint
     by a force balance:
       0 = frame_b.f + frame_ib.f + frame_im.f +
           Frames.resolve2(rod1.R_rel, rod1.f_rod*rod1.eRod_a)
     The condition is that the projection of the force in the prismatic
     joint along the axis of the prismatic joint is equal to the driving
     axis force in the flange:
       -prismatic.f = prismatic.e*frame_b.f
     Therefore, we have with e=prismatic.e and f=prismatic.f
        f = e*(frame_ib.f + frame_im.f +
               Frames.resolve2(rod1.R_rel, rod1.f_rod*rod1.eRod_a))
          = e*(frame_ib.f + frame_im.f +
               rod1.f_rod*Frames.resolve2(rod1.R_rel, rod1.eRod_a))
     Solving this equation for f_rod results in
       rod1.f_rod = (f - e*(frame_ib.f + frame_im.f))
                    / (e*Frames.resolve2(rod1.R_rel, rod1.eRod_a))
     Additionally, a guard against division by zero is introduced
  */
        aux = prismatic.e*Frames.resolveRelative(rod1.eRod_a, rod1.frame_a.R,
          rod1.frame_b.R);
        f_rod = (-prismatic.f - prismatic.e*(frame_ib.f + frame_im.f))/
          noEvent(if abs(aux) < 1.e-10 then 1.e-10 else aux);

        // Measure power for test purposes
        if checkTotalPower then
          totalPower = frame_a.f*Frames.resolve2(frame_a.R, der(frame_a.r_0)) +
            frame_b.f*Frames.resolve2(frame_b.R, der(frame_b.r_0)) + frame_ib.f*
            Frames.resolve2(frame_ib.R, der(frame_ib.r_0)) + frame_im.f*
            Frames.resolve2(frame_im.R, der(frame_im.r_0)) + frame_a.t*
            Frames.angularVelocity2(frame_a.R) + frame_b.t*
            Frames.angularVelocity2(frame_b.R) + frame_ib.t*
            Frames.angularVelocity2(frame_ib.R) + frame_im.t*
            Frames.angularVelocity2(frame_im.R) + axis.f*der(axis.s) + bearing.f*
            der(bearing.s) + (-rod1Mass)*(der(rod1.v_CM_0) -
            world.gravityAcceleration(rod1.r_CM_0))*rod1.v_CM_0;
        else
          totalPower = 0;
        end if;

        connect(prismatic.frame_b, rod2.frame_a) annotation (Line(
            points={{35,0},{15,0}},
            color={95,95,95},
            thickness=0.5));
        connect(rod2.frame_b, rod1.frame_b) annotation (Line(
            points={{-25,0},{-49,0}},
            color={95,95,95},
            thickness=0.5));
        connect(prismatic.frame_a, frame_b) annotation (Line(
            points={{75,0},{100,0}},
            color={95,95,95},
            thickness=0.5));
        connect(rod2.frame_a, frame_ib) annotation (Line(
            points={{15,0},{26,0},{26,70},{80,70},{80,100}},
            color={95,95,95},
            thickness=0.5));
        connect(rod1.frame_a, frame_a) annotation (Line(
            points={{-89,0},{-100,0}},
            color={95,95,95},
            thickness=0.5));
        connect(relativePosition.frame_b, frame_a)
                                                 annotation (Line(
            points={{40,-80},{-95,-80},{-95,0},{-100,0}},
            color={95,95,95},
            pattern=LinePattern.Dot));
        connect(relativePosition.frame_a, frame_b)
                                                 annotation (Line(
            points={{60,-80},{96,-80},{96,0},{100,0}},
            color={95,95,95},
            pattern=LinePattern.Dot));
        connect(position_b.y, prismatic.position_b)       annotation (Line(
            points={{1,-40},{20,-40},{20,-12},{31,-12}},
            color={0,0,127}));
        connect(prismatic.axis, axis) annotation (Line(points={{39,14},{40,14},{
                40,60},{90,60},{90,80},{100,80}}, color={0,0,0}));
        connect(prismatic.bearing, bearing)
          annotation (Line(points={{63,14},{63,40},{100,40}}, color={0,0,0}));
        connect(rod2.frame_b, frame_im) annotation (Line(
            points={{-25,0},{-35,0},{-35,60},{0,60},{0,100}},
            color={95,95,95},
            thickness=0.5));
        connect(relativePosition.r_rel, prismatic.position_a)
                                                            annotation (Line(
            points={{50,-69},{50,-50},{90,-50},{90,-12},{79,-12}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (
          Documentation(info="<html>
<p>
This component consists of a <b>spherical</b> joint 1 at frame_a, a <b>prismatic</b>
joint at frame_b and a <b>spherical</b> joint 2 which is connected via rod 1
to the spherical joint 1 and via rod 2 to the prismatic joint, see the default
animation in the following figure (the axes vectors are not part of the
default animation):
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/JointSSP.png\" ALT=\"model Joints.Assemblies.JointSSP\">
</p>

<p>
Besides an optional point mass in the middle of rod 1,
this joint aggregation has no mass and no inertia,
and introduces neither constraints nor potential state variables.
It should be used in kinematic loops whenever possible since
the non-linear system of equations introduced by this joint aggregation
is solved <b>analytically</b> (i.e., a solution is always computed, if a
unique solution exists).
</p>
<p>
An additional <b>frame_ib</b> is present. It is <b>fixed</b> in rod 2
connecting the prismatic and the spherical joint at the side of the prismatic
joint that is connected to this rod (= rod2.frame_a = prismatic.frame_a).
</p>
<p>
An additional <b>frame_im</b> is present. It is <b>fixed</b> in rod 2
connecting the prismatic and the spherical joint at the side of spherical
joint 2 that is connected to this rod (= rod2.frame_b).
It is always parallel to <b>frame_ib</b>.
</p>
<p>
The easiest way to define the parameters of this joint is by moving the
MultiBody system in a <b>reference configuration</b> where <b>all frames</b>
of all components are <b>parallel</b> to each other (alternatively,
at least frame_b and frame_ib of the JointSSP joint
should be parallel to each other when defining an instance of this
component).
</p>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              initialScale=0.2), graphics={
              Text(
                extent={{-140,-40},{140,-65}},
                lineColor={0,0,255},
                textString="%name"),
              Ellipse(
                extent={{-100,-30},{-40,30}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-93,-22},{-48,23}},
                lineColor={160,160,164},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-63,33},{-39,-33}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-40,-30},{20,30}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-33,-22},{12,23}},
                lineColor={192,192,192},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-44,31},{-19,-30}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-23,10},{-3,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{19,6},{61,-6}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Text(
                extent={{89,115},{132,92}},
                lineColor={128,128,128},
                textString="ib"),
              Ellipse(
                extent={{-80,11},{-60,-9}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-62,6},{-21,-5}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Line(
                points={{19,6},{19,80},{0,80},{0,100}},
                color={95,95,95},
                thickness=0.5),
              Text(
                extent={{-49,114},{-11,92}},
                lineColor={128,128,128},
                textString="im"),
              Rectangle(
                extent={{50,20},{80,-20}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{80,30},{100,-30}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{50,14},{80,20}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{80,24},{100,30}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(
                points={{50,6},{50,80},{80,80},{80,100}},
                color={95,95,95},
                thickness=0.5),
              Line(
                points={{101,80},{80,80}},
                color={95,95,95},
                thickness=0.5),
              Line(
                points={{99,40},{90,40},{90,30}},
                color={95,95,95},
                thickness=0.5)}));
      end JointSSP;

      model JointRRR
        "Planar revolute - revolute - revolute joint aggregation (no constraints, no potential states)"

        import Modelica_Mechanics_MultiBody.Types;
        import Modelica_SIunits.Conversions.to_unit1;

        extends Interfaces.PartialTwoFramesDoubleSize;

        Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_ia
          "Coordinate system at origin of frame_a fixed at connecting rod of left and middle revolute joint"
          annotation (Placement(transformation(
              origin={-80,100},
              extent={{-8,-8},{8,8}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_ib
          "Coordinate system at origin of frame_b fixed at connecting rod of middle and right revolute joint"
          annotation (Placement(transformation(
              origin={80,100},
              extent={{-8,8},{8,-8}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_im
          "Coordinate system at origin of revolute joint in the middle fixed at connecting rod of middle and right revolute joint"
          annotation (Placement(transformation(
              origin={0,100},
              extent={{8,-8},{-8,8}},
              rotation=270)));
        Modelica_Mechanics_Rotational.Interfaces.Flange_a axis
          "1-dim. rotational flange that drives the right revolute joint at frame_b"
          annotation (Placement(transformation(extent={{105,85},{95,75}},
                rotation=0)));
        Modelica_Mechanics_Rotational.Interfaces.Flange_b bearing
          "1-dim. rotational flange of the drive bearing of the right revolute joint at frame_b"
          annotation (Placement(transformation(extent={{95,45},{105,35}},
                rotation=0)));

        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        parameter Modelica_Mechanics_MultiBody.Types.Axis n_a={0,0,1}
          "Axes of revolute joints resolved in frame_a (all axes are parallel to each other)"
          annotation (Evaluate=true);
        final parameter Real n_b[3](each final unit="1",each fixed=false, start = {0,0,1})
          "Axis of revolute joint fixed and resolved in frame_b"
          annotation (Evaluate=true);
        parameter Modelica_SIunits.Position rRod1_ia[3]={1,0,0}
          "Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia"
          annotation (Evaluate=true);
        parameter Modelica_SIunits.Position rRod2_ib[3]={-1,0,0}
          "Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib";
        parameter Cv.NonSIunits.Angle_deg phi_offset=0
          "Relative angle offset of revolute joint at frame_b (angle = phi(t) + from_deg(phi_offset))";
        parameter Cv.NonSIunits.Angle_deg phi_guess=0
          "Select the configuration such that at initial time |phi(t0) - from_deg(phi_guess)| is minimal";
        parameter Modelica_SIunits.Distance cylinderLength=world.defaultJointLength
          "Length of cylinders representing the revolute joints" annotation (
            Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter Modelica_SIunits.Distance cylinderDiameter=world.defaultJointWidth
          "Diameter of cylinders representing the revolute joints" annotation (
            Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color cylinderColor=Types.Defaults.JointColor
          "Color of cylinders representing the revolute joints"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        parameter Modelica_SIunits.Diameter rodDiameter=1.1*cylinderDiameter
          "Diameter of the two rods connecting the revolute joints" annotation (
           Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color rodColor=Types.Defaults.RodColor
          "Color of the two rods connecting the revolute joint"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));

        parameter Boolean checkTotalPower=false
          "= true, if total power flowing into this component shall be determined (must be zero)"
          annotation (Dialog(tab="Advanced"));
        final parameter Real e_a[3](each final unit="1")=Modelica_Math.Vectors.normalizeWithAssert(
                                                     n_a)
          "Unit vector along axes of rotations, resolved in frame_a";
        final parameter Real e_ia[3](each final unit="1")=jointUSR.e2_ia
          "Unit vector along axes of rotations, resolved in frame_ia";
        final parameter Real e_b[3](each final unit="1")=jointUSR.revolute.e
          "Unit vector along axes of rotations, resolved in frame_b, frame_ib and frame_im";
        Modelica_SIunits.Power totalPower=jointUSR.totalPower
          "Total power flowing into this element, if checkTotalPower=true (otherwise dummy)";

        JointUSR jointUSR(
          animation=false,
          n1_a=n_a,
          n_b=n_b,
          phi_offset=phi_offset,
          rRod2_ib=rRod2_ib,
          showUniversalAxes=false,
          rRod1_ia=rRod1_ia,
          checkTotalPower=checkTotalPower,
          phi_guess=phi_guess) annotation (Placement(transformation(extent={{-30,
                  -20},{10,20}}, rotation=0)));

      protected
       Visualizers.Advanced.Shape shape_rev1(
          shapeType="cylinder",
          color=cylinderColor,
          specularCoefficient=specularCoefficient,
          length=cylinderLength,
          width=cylinderDiameter,
          height=cylinderDiameter,
          lengthDirection=e_a,
          widthDirection={0,1,0},
          r_shape=-e_a*(cylinderLength/2),
          r=frame_a.r_0,
          R=frame_a.R) if world.enableAnimation and animation;
        Visualizers.Advanced.Shape shape_rev2(
          shapeType="cylinder",
          color=cylinderColor,
          specularCoefficient=specularCoefficient,
          length=cylinderLength,
          width=cylinderDiameter,
          height=cylinderDiameter,
          lengthDirection=e_b,
          widthDirection={0,1,0},
          r_shape=-e_b*(cylinderLength/2),
          r=frame_im.r_0,
          R=frame_im.R) if world.enableAnimation and animation;
        Visualizers.Advanced.Shape shape_rev3(
          shapeType="cylinder",
          color=cylinderColor,
          specularCoefficient=specularCoefficient,
          length=cylinderLength,
          width=cylinderDiameter,
          height=cylinderDiameter,
          lengthDirection=e_b,
          widthDirection={0,1,0},
          r_shape=-e_b*(cylinderLength/2),
          r=frame_b.r_0,
          R=frame_b.R) if world.enableAnimation and animation;
        Visualizers.Advanced.Shape shape_rod1(
          shapeType="cylinder",
          color=rodColor,
          specularCoefficient=specularCoefficient,
          length=Modelica_Math.Vectors.length(
                               rRod1_ia),
          width=rodDiameter,
          height=rodDiameter,
          lengthDirection = to_unit1(rRod1_ia),
          widthDirection=e_ia,
          r=frame_ia.r_0,
          R=frame_ia.R) if world.enableAnimation and animation;
        Visualizers.Advanced.Shape shape_rod2(
          shapeType="cylinder",
          color=rodColor,
          specularCoefficient=specularCoefficient,
          length=Modelica_Math.Vectors.length(
                               rRod2_ib),
          width=rodDiameter,
          height=rodDiameter,
          lengthDirection = to_unit1(rRod2_ib),
          widthDirection=e_b,
          r=frame_ib.r_0,
          R=frame_ib.R) if world.enableAnimation and animation;
      initial equation
        n_b = Frames.resolve2(frame_b.R, Frames.resolve1(frame_a.R, n_a));

      equation
        connect(jointUSR.frame_a, frame_a)
          annotation (Line(
            points={{-30,0},{-100,0}},
            color={95,95,95},
            thickness=0.5));
        connect(jointUSR.frame_b, frame_b)
          annotation (Line(
            points={{10,0},{100,0}},
            color={95,95,95},
            thickness=0.5));
        connect(jointUSR.frame_ia, frame_ia) annotation (Line(
            points={{-26,20},{-26,70},{-80,70},{-80,100}},
            color={95,95,95},
            thickness=0.5));
        connect(jointUSR.frame_im, frame_im) annotation (Line(
            points={{-10,20},{-10,70},{0,70},{0,100}},
            color={95,95,95},
            thickness=0.5));
        connect(jointUSR.frame_ib, frame_ib) annotation (Line(
            points={{6,20},{6,50},{80,50},{80,100}},
            color={95,95,95},
            thickness=0.5));
        connect(jointUSR.axis, axis)
          annotation (Line(points={{10,16},{86,16},{86,80},{100,80}}, color={0,0,
                0}));
        connect(jointUSR.bearing, bearing)
          annotation (Line(points={{10,8},{94,8},{94,40},{100,40}}, color={0,0,0}));
        annotation (
          Documentation(info="<html>
<p>
This component consists of <b>3 revolute</b> joints with parallel
axes of rotation that are connected together by two rods, see the default
animation in the following figure (the axes vectors are not part of the
default animation):
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/JointRRR.png\" ALT=\"model Joints.Assemblies.JointRRR\">
</p>

<p>
This joint aggregation introduces neither constraints nor state variables and
should therefore be used in kinematic loops whenever possible to
avoid non-linear systems of equations. It is only meaningful to
use this component in <b>planar loops</b>. Basically, the position
and orientation of the 3 revolute joints as well as of frame_ia, frame_ib, and
frame_im are calculated by solving analytically a non-linear equation,
given the position and orientation at frame_a and at frame_b.
</p>
<p>
Connector <b>frame_a</b> is the \"left\" side of the first revolute joint
whereas <b>frame_ia</b> is the \"right side of this revolute joint, fixed in rod 1.
Connector <b>frame_b</b> is the \"right\" side of the third revolute joint
whereas <b>frame_ib</b> is the \"left\" side of this revolute joint, fixed in rod 2.
Finally, connector <b>frame_im</b> is the connector at the \"right\" side
of the revolute joint in the middle, fixed in rod 2.
</p>
<p>
The easiest way to define the parameters of this joint is by moving the
MultiBody system in a <b>reference configuration</b> where <b>all frames</b>
of all components are <b>parallel</b> to each other (alternatively,
at least frame_a, frame_ia, frame_im, frame_ib, frame_b of the JointRRR joint
should be parallel to each other when defining an instance of this
component).
</p>
<p>
Basically, the JointRRR model consists internally of a universal -
spherical - revolute joint aggregation (= JointUSR). In a planar
loop this will behave as if 3 revolute joints with parallel axes
are connected by rigid rods.
</p>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              initialScale=0.2), graphics={
              Rectangle(
                extent={{-90,90},{90,-90}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-140,-55},{140,-80}},
                lineColor={0,0,255},
                textString="%name"),
              Text(
                extent={{36,114},{71,92}},
                lineColor={128,128,128},
                textString="ib"),
              Text(
                extent={{-126,115},{-87,90}},
                lineColor={128,128,128},
                textString="ia"),
              Ellipse(
                extent={{-100,25},{-50,-25}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-85,10},{-65,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{50,25},{100,-25}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{65,10},{85,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-26,80},{24,30}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-10,66},{10,46}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-71,9},{-24,45},{-19,39},{-66,3},{-71,9}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{54,12},{5,47},{10,52},{59,18},{54,12}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{100,-4},{83,-4},{84,3},{100,3},{100,-4}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Line(
                points={{80,24},{80,80},{80,80},{80,100}},
                color={95,95,95},
                thickness=0.5),
              Text(
                extent={{-128,-29},{136,-47}},
                lineColor={0,0,0},
                textString="n_a=%n_a"),
              Line(
                points={{0,57},{0,86},{0,86},{0,100}},
                color={95,95,95},
                thickness=0.5),
              Text(
                extent={{-46,114},{-7,91}},
                lineColor={128,128,128},
                textString="im"),
              Line(
                points={{-80,100},{-80,8}},
                color={95,95,95},
                thickness=0.5),
              Line(
                points={{80,80},{101,80}},
                color={95,95,95},
                thickness=0.5),
              Line(
                points={{100,40},{93,40},{93,3}},
                color={95,95,95},
                thickness=0.5)}));
      end JointRRR;

      model JointRRP
        "Planar revolute - revolute - prismatic joint aggregation (no constraints, no potential states)"

        import Modelica_Mechanics_MultiBody.Types;
        import Modelica_SIunits.Conversions.to_unit1;

        extends Interfaces.PartialTwoFramesDoubleSize;
        Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_ia
          "Coordinate system at origin of frame_a fixed at connecting rod of revolute joints"
          annotation (Placement(transformation(
              origin={-80,100},
              extent={{-8,-8},{8,8}},
              rotation=90)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_ib
          "Coordinate system at origin of frame_b fixed at connecting rod of revolute and prismatic joint"
          annotation (Placement(transformation(
              origin={80,100},
              extent={{-8,8},{8,-8}},
              rotation=270)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_im
          "Coordinate system at origin of revolute joint in the middle fixed at connecting rod of revolute and prismatic joint"
          annotation (Placement(transformation(
              origin={0,100},
              extent={{8,-8},{-8,8}},
              rotation=270)));
        Modelica_Mechanics_Translational.Interfaces.Flange_a axis
          "1-dim. translational flange that drives the prismatic joint"
          annotation (Placement(transformation(extent={{95,75},{105,85}},
                rotation=0)));
        Modelica_Mechanics_Translational.Interfaces.Flange_b bearing
          "1-dim. translational flange of the drive bearing of the prismatic joint"
          annotation (Placement(transformation(extent={{105,35},{95,45}},
                rotation=0)));

        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        parameter Modelica_Mechanics_MultiBody.Types.Axis n_a={0,0,1}
          "Axes of the two revolute joints resolved in frame_a (both axes are parallel to each other)"
          annotation (Evaluate=true);
        parameter Modelica_Mechanics_MultiBody.Types.Axis n_b={-1,0,0}
          "Axis of prismatic joint fixed and resolved in frame_b (must be orthogonal to revolute joint axes)"
          annotation (Evaluate=true);
        parameter Modelica_SIunits.Position rRod1_ia[3]={1,0,0}
          "Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia"
          annotation (Evaluate=true);
        parameter Modelica_SIunits.Position rRod2_ib[3]={-1,0,0}
          "Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib (frame_ib is parallel to frame_b)";
        parameter Modelica_SIunits.Position s_offset=0
          "Relative distance offset of prismatic joint (distance between the prismatic joint frames = s(t) + s_offset)";
        parameter Modelica_SIunits.Position s_guess=0
          "Select the configuration such that at initial time |s(t0)-s_guess| is minimal";
        parameter Modelica_SIunits.Distance cylinderLength=world.defaultJointLength
          "Length of cylinders representing the revolute joints" annotation (
            Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter Modelica_SIunits.Distance cylinderDiameter=world.defaultJointWidth
          "Diameter of cylinders representing the revolute joints" annotation (
            Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color cylinderColor=Types.Defaults.JointColor
          "Color of cylinders representing the revolute joints"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        parameter Types.Axis boxWidthDirection={0,1,0}
          "Vector in width direction of prismatic joint, resolved in frame_b"
          annotation (Evaluate=true, Dialog(tab="Animation", group=
                "if animation = true", enable=animation));
        parameter Modelica_SIunits.Distance boxWidth=world.defaultJointWidth
          "Width of prismatic joint box" annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter Modelica_SIunits.Distance boxHeight=boxWidth
          "Height of prismatic joint box" annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color boxColor=cylinderColor "Color of prismatic joint box"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        parameter Modelica_SIunits.Diameter rodDiameter=1.1*cylinderDiameter
          "Diameter of the two rods connecting the joints" annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color rodColor=Types.Defaults.RodColor
          "Color of the two rods connecting the joints"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
        parameter Boolean checkTotalPower=false
          "= true, if total power flowing into this component shall be determined (must be zero)"
          annotation (Dialog(tab="Advanced"));
        final parameter Real e_a[3](each final unit="1")=Modelica_Math.Vectors.normalizeWithAssert(
                                                     n_a)
          "Unit vector along axes of rotations, resolved in frame_a";
        final parameter Real e_ia[3](each final unit="1")=jointUSP.e2_ia
          "Unit vector along axes of rotations, resolved in frame_ia";
        final parameter Real e_im[3](each final unit="1", each fixed=false)
          "Unit vector along axes of rotations, resolved in frame_im";
        final parameter Real e_b[3](each final unit="1")=jointUSP.prismatic.e
          "Unit vector along axes of translation of the prismatic joint, resolved in frame_b and frame_ib";
        Modelica_SIunits.Power totalPower=jointUSP.totalPower
          "Total power flowing into this element, if checkTotalPower=true (otherwise dummy)";

        JointUSP jointUSP(
          animation=false,
          showUniversalAxes=false,
          n1_a=n_a,
          n_b=n_b,
          s_offset=s_offset,
          s_guess=s_guess,
          rRod1_ia=rRod1_ia,
          rRod2_ib=rRod2_ib,
          checkTotalPower=checkTotalPower) annotation (Placement(transformation(
                extent={{-30,-20},{10,20}}, rotation=0)));

      protected
        Visualizers.Advanced.Shape shape_rev1(
          shapeType="cylinder",
          color=cylinderColor,
          specularCoefficient=specularCoefficient,
          length=cylinderLength,
          width=cylinderDiameter,
          height=cylinderDiameter,
          lengthDirection=e_a,
          widthDirection={0,1,0},
          r_shape=-e_a*(cylinderLength/2),
          r=frame_a.r_0,
          R=frame_a.R) if world.enableAnimation and animation;
        Visualizers.Advanced.Shape shape_rev2(
          shapeType="cylinder",
          color=cylinderColor,
          specularCoefficient=specularCoefficient,
          length=cylinderLength,
          width=cylinderDiameter,
          height=cylinderDiameter,
          lengthDirection=e_im,
          widthDirection={0,1,0},
          r_shape=-e_im*(cylinderLength/2),
          r=frame_im.r_0,
          R=frame_im.R) if world.enableAnimation and animation;
        Visualizers.Advanced.Shape shape_prism(
          shapeType="box",
          color=boxColor,
          specularCoefficient=specularCoefficient,
          length=jointUSP.prismatic.distance,
          width=boxWidth,
          height=boxHeight,
          lengthDirection=e_b,
          widthDirection=e_im,
          r=frame_b.r_0,
          R=frame_b.R) if world.enableAnimation and animation;
        Visualizers.Advanced.Shape shape_rod1(
          shapeType="cylinder",
          color=rodColor,
          specularCoefficient=specularCoefficient,
          length=Modelica_Math.Vectors.length(
                               rRod1_ia),
          width=rodDiameter,
          height=rodDiameter,
          lengthDirection = to_unit1(rRod1_ia),
          widthDirection=e_ia,
          r=frame_ia.r_0,
          R=frame_ia.R) if world.enableAnimation and animation;
        Visualizers.Advanced.Shape shape_rod2(
          shapeType="cylinder",
          color=rodColor,
          specularCoefficient=specularCoefficient,
          length=Modelica_Math.Vectors.length(
                               rRod2_ib),
          width=rodDiameter,
          height=rodDiameter,
          lengthDirection = to_unit1(rRod2_ib),
          widthDirection=e_b,
          r=frame_ib.r_0,
          R=frame_ib.R) if world.enableAnimation and animation;
      initial equation
        e_im = Frames.resolve2(frame_im.R, Frames.resolve1(frame_a.R, e_a));

      equation
        connect(jointUSP.frame_a, frame_a)
          annotation (Line(
            points={{-30,0},{-100,0}},
            color={95,95,95},
            thickness=0.5));
        connect(jointUSP.frame_b, frame_b)
          annotation (Line(
            points={{10,0},{100,0}},
            color={95,95,95},
            thickness=0.5));
        connect(jointUSP.frame_ia, frame_ia) annotation (Line(
            points={{-26,20},{-26,70},{-80,70},{-80,100}},
            color={95,95,95},
            thickness=0.5));
        connect(jointUSP.frame_im, frame_im) annotation (Line(
            points={{-10,20},{-10,70},{0,70},{0,100}},
            color={95,95,95},
            thickness=0.5));
        connect(jointUSP.frame_ib, frame_ib) annotation (Line(
            points={{6,20},{6,50},{80,50},{80,100}},
            color={95,95,95},
            thickness=0.5));
        connect(jointUSP.axis, axis)
          annotation (Line(points={{10,16},{86,16},{86,80},{100,80}}, color={0,0,
                0}));
        connect(jointUSP.bearing, bearing)
          annotation (Line(points={{10,8},{94,8},{94,40},{100,40}}, color={0,0,0}));
        annotation (
          Documentation(info="<html>
<p>
This component consists of <b>2 revolute</b> joints with parallel
axes of rotation that and a <b>prismatic</b> joint with a translational
axis that is orthogonal to the revolute joint axes, see the default
animation in the following figure (the axes vectors are not part of the
default animation):
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/JointRRP.png\" ALT=\"model Joints.Assemblies.JointRRP\">
</p>

<p>
This joint aggregation introduces neither constraints nor state variables and
should therefore be used in kinematic loops whenever possible to
avoid non-linear systems of equations. It is only meaningful to
use this component in <b>planar loops</b>. Basically, the position
and orientation of the 3 joints as well as of frame_ia, frame_ib, and
frame_im are calculated by solving analytically a non-linear equation,
given the position and orientation at frame_a and at frame_b.
</p>
<p>
Connector <b>frame_a</b> is the \"left\" side of the first revolute joint
whereas <b>frame_ia</b> is the \"right side of this revolute joint, fixed in rod 1.
Connector <b>frame_b</b> is the \"right\" side of the prismatic joint
whereas <b>frame_ib</b> is the \"left\" side of this prismatic joint, fixed in rod 2.
Finally, connector <b>frame_im</b> is the connector at the \"right\" side
of the revolute joint in the middle, fixed in rod 2. The frames
frame_b, frame_ib, frame_im are always parallel to each other.
</p>
<p>
The easiest way to define the parameters of this joint is by moving the
MultiBody system in a <b>reference configuration</b> where <b>all frames</b>
of all components are <b>parallel</b> to each other (alternatively,
at least frame_a, frame_ia, frame_im, frame_ib, frame_b of the JointRRP joint
should be parallel to each other when defining an instance of this
component).
</p>
<p>
Basically, the JointRRP model consists internally of a universal -
spherical - prismatic joint aggregation (= JointUSP). In a planar
loop this will behave as if 2 revolute joints with parallel axes
and 1 prismatic joint are connected by rigid rods.
</p>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              initialScale=0.2), graphics={
              Rectangle(
                extent={{-90,90},{90,-90}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-139,-53},{141,-78}},
                lineColor={0,0,255},
                textString="%name"),
              Text(
                extent={{26,124},{68,93}},
                lineColor={128,128,128},
                textString="ib"),
              Text(
                extent={{-134,128},{-94,94}},
                lineColor={128,128,128},
                textString="ia"),
              Ellipse(
                extent={{-100,25},{-50,-25}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-85,10},{-65,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-26,80},{24,30}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-10,66},{10,46}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-71,9},{-24,45},{-19,39},{-66,3},{-71,9}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{54,5},{5,47},{8,53},{58,11},{54,5}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-128,-29},{139,-47}},
                lineColor={0,0,0},
                textString="n_a=%n_a"),
              Line(
                points={{0,57},{0,86},{0,86},{0,100}},
                color={95,95,95},
                thickness=0.5),
              Text(
                extent={{-55,126},{-15,92}},
                lineColor={128,128,128},
                textString="im"),
              Line(
                points={{-80,100},{-80,8}},
                color={95,95,95},
                thickness=0.5),
              Line(
                points={{80,80},{101,80}},
                color={95,95,95},
                thickness=0.5),
              Line(
                points={{100,40},{93,40},{93,3}},
                color={95,95,95},
                thickness=0.5),
              Rectangle(
                extent={{80,15},{100,21}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{53,5},{80,11}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{53,5},{80,-15}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{80,15},{100,-21}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(
                points={{80,100},{80,80},{57,11}},
                color={95,95,95},
                thickness=0.5)}));
      end JointRRP;
      annotation ( Documentation(info="<HTML>
<p>
The joints in this package are mainly designed to be used
in <b>kinematic loop</b> structures. Every component consists of
<b>3 elementary joints</b>. These joints are combined in such a
way that the kinematics of the 3 joints between frame_a and
frame_b are computed from the movement of frame_a and frame_b,
i.e., there are <b>no constraints</b> between frame_a and frame_b.
This requires to solve a <b>non-linear system of equations</b> which
is performed <b>analytically</b> (i.e., when a mathematical
solution exists, it is computed efficiently and reliably).
A detailed description how to use these joints is provided in
<a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling\">MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling</a>.
</p>
<p>
The assembly joints in this package are named <b>JointXYZ</b> where
<b>XYZ</b> are the first letters of the elementary joints used in the
component, in particular:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td valign=\"top\"><b>P</b></td><td valign=\"top\">Prismatic joint</td></tr>
  <tr><td valign=\"top\"><b>R</b></td><td valign=\"top\">Revolute joint</td></tr>
  <tr><td valign=\"top\"><b>S</b></td><td valign=\"top\">Spherical joint</td></tr>
  <tr><td valign=\"top\"><b>U</b></td><td valign=\"top\">Universal joint</td></tr>
</table>
<p>
For example, JointUSR is an assembly joint consisting
of a universal, a spherical and a revolute joint.
</p>
<p> This package contains the following models:
</p>
<h4>Content</h4>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><b><i>Model</i></b></th><th><b><i>Description</i></b></th></tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUPS\">JointUPS</a></td>
      <td valign=\"top\"> Universal - prismatic - spherical joint aggregation<br>
     <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/JointUPS.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUSR\">JointUSR</a></td>
      <td valign=\"top\"> Universal - spherical - revolute joint aggregation<br>
     <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/JointUSR.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUSP\">JointUSP</a></td>
      <td valign=\"top\"> Universal - spherical - prismatic joint aggregation<br>
     <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/JointUSP.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies.JointSSR\">JointSSR</a></td>
      <td valign=\"top\"> Spherical - spherical - revolute joint aggregation
           with an optional mass point at the rod connecting
           the two spherical joints<br>
     <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/JointSSR.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies.JointSSP\">JointSSP</a></td>
      <td valign=\"top\"> Spherical - spherical - prismatic joint aggregation
           with an optional mass point at the rod connecting
           the two spherical joints<br>
     <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/JointSSP.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies.JointRRR\">JointRRR</a></td>
      <td valign=\"top\"> Revolute - revolute - revolute joint aggregation for planar loops<br>
     <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/JointRRR.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies.JointRRP\">JointRRP</a></td>
      <td valign=\"top\"> Revolute - revolute - prismatic joint aggregation for planar loops<br>
     <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/JointRRP.png\">
      </td>
  </tr>
</table>
<p>
Note, no component of this package has potential states, since the
components are designed in such a way that the generalized coordinates
of the used elementary joints are computed from the frame_a and frame_b
coordinates. Still, it is possible to use the components in a
tree structure. In this case states are selected from bodies that are
connected to the frame_a or frame_b side of the component.
In most cases this gives a less efficient solution, as if elementary
joints of package Modelica.Mechanics.MultiBody.Joints would be used directly.
</p>
<p>
The analytic handling of kinematic loops by using joint aggregations
with 6 degrees of freedom as provided in this package, is a <b>new</b>
methodology. It is based on a more general method for solving
non-linear equations of kinematic loops developed by Woernle and
Hiller. An automatic application of this more general method
is difficult, and a manual application is only suited for
specialists in this field. The method introduced here is a
compromise: It can be quite easily applied by an end user, but
for a smaller class of kinematic loops. The method of the \"characteristic
pair of joints\" from Woernle and Hiller is described in:
</p>
<dl>
<dt>Woernle C.:</dt>
<dd><b>Ein systematisches Verfahren zur Aufstellung der geometrischen
    Schliessbedingungen in kinematischen Schleifen mit Anwendung
    bei der R&uuml;ckw&auml;rtstransformation f&uuml;r
    Industrieroboter.</b><br>
    Fortschritt-Berichte VDI, Reihe 18, Nr. 59, Duesseldorf: VDI-Verlag 1988,
    ISBN 3-18-145918-6.<br>&nbsp;</dd>
<dt>Hiller M., and Woernle C.:</dt>
<dd><b>A Systematic Approach for Solving the Inverse Kinematic
    Problem of Robot Manipulators</b>.<br>
    Proceedings 7th World Congress Th. Mach. Mech., Sevilla 1987. </dd>
</dl>
</HTML>"));
    end Assemblies;

    package Constraints "Components that define joints by constraints"
      extends Modelica_Icons.Package;

      model Prismatic
        "Prismatic cut-joint and translational directions may be constrained or released"
        extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;
        import Cv = Modelica_SIunits.Conversions;

        parameter Boolean x_locked=true
          "= true: constraint force in x-direction, resolved in frame_a"
          annotation (Dialog(group="Constraints"),choices(checkBox=true));
        parameter Boolean y_locked=true
          "= true: constraint force in y-direction, resolved in frame_a"
          annotation (Dialog(group="Constraints"),choices(checkBox=true));
        parameter Boolean z_locked=true
          "= true: constraint force in z-direction, resolved in frame_a"
          annotation (Dialog(group="Constraints"),choices(checkBox=true));

        parameter Boolean animation=true
          "= true, if animation shall be enabled (show sphere)";
        parameter Modelica_SIunits.Distance sphereDiameter=world.defaultJointLength
            /3 "Diameter of sphere representing the spherical joint"
          annotation (Dialog(group="if animation = true", enable=animation));
        input Types.Color sphereColor=Types.Defaults.JointColor
          "Color of sphere representing the spherical joint"
            annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
        input Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
            annotation (Dialog(group="if animation = true", enable=animation));

      protected
        Frames.Orientation R_rel
          "Dummy or relative orientation object from frame_a to frame_b";
        Modelica_SIunits.Position r_rel_a[3]
          "Position vector from origin of frame_a to origin of frame_b, resolved in frame_a";
        Modelica_SIunits.InstantaneousPower P;

      public
        Visualizers.Advanced.Shape sphere(
          shapeType="sphere",
          color=sphereColor,
          specularCoefficient=specularCoefficient,
          length=sphereDiameter,
          width=sphereDiameter,
          height=sphereDiameter,
          lengthDirection={1,0,0},
          widthDirection={0,1,0},
          r_shape={-0.5,0,0}*sphereDiameter,
          r=frame_a.r_0,
          R=frame_a.R) if world.enableAnimation and animation;
      equation
        // Determine relative position vector resolved in frame_a
        R_rel = Frames.relativeRotation(frame_a.R, frame_b.R);
        r_rel_a = Frames.resolve2(frame_a.R, frame_b.r_0 - frame_a.r_0);

        // Constraint equations concerning rotations
        ones(3)={R_rel.T[1,1], R_rel.T[2,2], R_rel.T[3,3]};

        // Constraint equations concerning translations
        if x_locked and y_locked and z_locked then
          r_rel_a=zeros(3);
        elseif x_locked and y_locked and not z_locked then
          r_rel_a[1]=0;
          r_rel_a[2]=0;
          frame_a.f[3]=0;
        elseif x_locked and not y_locked and z_locked then
          r_rel_a[1]=0;
          r_rel_a[3]=0;
          frame_a.f[2]=0;
        elseif x_locked and not y_locked and not z_locked then
          r_rel_a[1]=0;
          frame_a.f[2]=0;
          frame_a.f[3]=0;
        elseif not x_locked and y_locked and z_locked then
          r_rel_a[2]=0;
          r_rel_a[3]=0;
          frame_a.f[1]=0;
        elseif not x_locked and y_locked and not z_locked then
          r_rel_a[2]=0;
          frame_a.f[1]=0;
          frame_a.f[3]=0;
        elseif not x_locked and not y_locked and z_locked then
          r_rel_a[3]=0;
          frame_a.f[1]=0;
          frame_a.f[2]=0;
        else
          frame_a.f=zeros(3);
        end if;

        zeros(3) = frame_a.t + Frames.resolve1(R_rel, frame_b.t) + cross(r_rel_a,
          Frames.resolve1(R_rel, frame_b.f));
        zeros(3) = Frames.resolve1(R_rel, frame_b.f) + frame_a.f;
        P = frame_a.t*Frames.angularVelocity2(frame_a.R) + frame_b.t*
          Frames.angularVelocity2(frame_b.R) + frame_b.f*Frames.resolve2(frame_b.R,
          der(frame_b.r_0)) + frame_a.f*Frames.resolve2(frame_a.R, der(frame_a.r_0));

        annotation (
          defaultComponentName="constraint",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: x",
                visible=x_locked and not y_locked and not z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: y",
                visible=not x_locked and y_locked and not z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: z",
                visible=not x_locked and not y_locked and z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: x, y",
                visible=x_locked and y_locked and not z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: x, z",
                visible=x_locked and not y_locked and z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: y, z",
                visible=not x_locked and y_locked and z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: x, y, z",
                visible=x_locked and y_locked and z_locked),
              Rectangle(
                extent={{-100,46},{-30,56}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{-100,-44},{-30,47}},
                pattern=LinePattern.None,
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{-30,24},{100,34}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{-30,-26},{100,24}},
                pattern=LinePattern.None,
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(points={{100,-26},{100,25}}, color={0,0,0}),
              Line(points={{-30,-44},{-30,56}}, color={0,0,0}),
              Text(
                extent={{-150,120},{150,80}},
                lineColor={0,0,255},
                textString="%name"),
              Line(
                points={{-81,-66},{-23,25},{40,-39},{97,71}},
                color={255,0,0},
                thickness=0.5,
                smooth=Smooth.None)}),
          Documentation(info="<html>
<p>This model does not use explicit variables e.g. state variables in order to describe the relative motion of frame_b with respect to frame_a, but defines kinematic constraints between the frame_a and frame_b. The forces and torques at both frames are then evaluated in such a way that the constraints are satisfied.  Sometimes this type of formulation is also called an implicit joint in literature.</p>
<p>As a consequence of the formulation the relative kinematics between frame_a and frame_b cannot be initialized.</p>
<p>In particular in complex multibody systems with closed loops this may help to simplify the system of non-linear equations. Please compare the translation log using the classical joint formulation and the alternative formulation used here in order to check whether this fact applies to the particular system under consideration.</p>
<p>In systems without closed loops the use of this implicit joint does not make sense or may even be disadvantageous.</p>
<p>See the subpackage <a href=\"Modelica://Modelica.Mechanics.MultiBody.Examples.Constraints\">Examples.Constraints</a> for testing the joint. </p>
</html>"));
      end Prismatic;

      model Revolute
        "Revolute cut-joint and translational directions may be constrained or released"
        extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;

        parameter Boolean x_locked=true
          "= true: constraint force in x-direction, resolved in frame_a"
          annotation (Dialog(group="Constraints in translational motion"),choices(checkBox=true));
        parameter Boolean y_locked=true
          "= true: constraint force in y-direction, resolved in frame_a"
          annotation (Dialog(group="Constraints in translational motion"),choices(checkBox=true));
        parameter Boolean z_locked=true
          "= true: constraint force in z-direction, resolved in frame_a"
          annotation (Dialog(group="Constraints in translational motion"),choices(checkBox=true));

        parameter Boolean animation=true
          "= true, if animation shall be enabled (show sphere)";
        parameter Types.Axis n={0,1,0}
          "Axis of rotation resolved in frame_a (= same as in frame_b)"
          annotation (Evaluate=true);

        parameter Modelica_SIunits.Distance sphereDiameter=world.defaultJointLength
            /3 "Diameter of sphere representing the spherical joint"
          annotation (Dialog(group="if animation = true", enable=animation));
        input Types.Color sphereColor=Types.Defaults.JointColor
          "Color of sphere representing the spherical joint"
          annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
        input Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog(group="if animation = true", enable=animation));

      protected
        Frames.Orientation R_rel
          "Dummy or relative orientation object from frame_a to frame_b";
        Modelica_SIunits.Position r_rel_a[3]
          "Position vector from origin of frame_a to origin of frame_b, resolved in frame_a";
        Modelica_SIunits.InstantaneousPower P;
        parameter Real e[3](each final unit="1")=Modelica_Math.Vectors.normalizeWithAssert(
                                             n)
          "Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)";

        parameter Real nnx_a[3](each final unit="1")=if abs(e[1]) > 0.1 then {0,1,0} else (if abs(e[2])
             > 0.1 then {0,0,1} else {1,0,0})
          "Arbitrary vector that is not aligned with rotation axis n"
          annotation (Evaluate=true);
            parameter Real ey_a[3](each final unit="1")=Modelica_Math.Vectors.normalizeWithAssert(
                                                cross(e, nnx_a))
          "Unit vector orthogonal to axis n of revolute joint, resolved in frame_a"
          annotation (Evaluate=true);
        parameter Real ex_a[3](each final unit="1")=cross(ey_a, e)
          "Unit vector orthogonal to axis n of revolute joint and to ey_a, resolved in frame_a";

      public
        Visualizers.Advanced.Shape sphere(
          shapeType="sphere",
          color=sphereColor,
          specularCoefficient=specularCoefficient,
          length=sphereDiameter,
          width=sphereDiameter,
          height=sphereDiameter,
          lengthDirection={1,0,0},
          widthDirection={0,1,0},
          r_shape={-0.5,0,0}*sphereDiameter,
          r=frame_a.r_0,
          R=frame_a.R) if world.enableAnimation and animation;

      equation
        // Determine relative position vector resolved in frame_a
        R_rel = Frames.relativeRotation(frame_a.R, frame_b.R);
        r_rel_a = Frames.resolve2(frame_a.R, frame_b.r_0 - frame_a.r_0);

        // Constraint equations concerning translations
        if x_locked and y_locked and z_locked then
          r_rel_a=zeros(3);
        elseif x_locked and y_locked and not z_locked then
          r_rel_a[1]=0;
          r_rel_a[2]=0;
          frame_a.f[3]=0;
        elseif x_locked and not y_locked and z_locked then
          r_rel_a[1]=0;
          r_rel_a[3]=0;
          frame_a.f[2]=0;
        elseif x_locked and not y_locked and not z_locked then
          r_rel_a[1]=0;
          frame_a.f[2]=0;
          frame_a.f[3]=0;
        elseif not x_locked and y_locked and z_locked then
          r_rel_a[2]=0;
          r_rel_a[3]=0;
          frame_a.f[1]=0;
        elseif not x_locked and y_locked and not z_locked then
          r_rel_a[2]=0;
          frame_a.f[1]=0;
          frame_a.f[3]=0;
        elseif not x_locked and not y_locked and z_locked then
          r_rel_a[3]=0;
          frame_a.f[1]=0;
          frame_a.f[2]=0;
        else
          frame_a.f=zeros(3);
        end if;

        // Constraint equations concerning rotations
        0 = ex_a*R_rel.T*e;
        0 = ey_a*R_rel.T*e;
        frame_a.t*n=0;

        zeros(3) = frame_a.f + Frames.resolve1(R_rel, frame_b.f);
        zeros(3) = frame_a.t + Frames.resolve1(R_rel, frame_b.t) - cross(r_rel_a,
          frame_a.f);
        P = frame_a.t*Frames.angularVelocity2(frame_a.R) + frame_b.t*
          Frames.angularVelocity2(frame_b.R) + Frames.resolve1(frame_b.R, frame_b.f)
          *der(frame_b.r_0) + Frames.resolve1(frame_a.R, frame_a.f)*der(frame_a.r_0);

          annotation ( defaultComponentName="constraint",
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-63,-63},{53,-93}},
                lineColor={0,0,0},
                textString="n=%n",
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,-60},{-30,60}},
                lineColor={64,64,64},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={255,255,255},
                radius=10),
              Rectangle(
                extent={{30,-60},{100,60}},
                lineColor={64,64,64},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={255,255,255},
                radius=10),
              Rectangle(extent={{-100,60},{-30,-60}}, lineColor={64,64,64}, radius=10),
              Rectangle(extent={{30,60},{100,-60}}, lineColor={64,64,64}, radius=10),
              Text(
                extent={{-90,14},{-54,-11}},
                lineColor={128,128,128},
                textString="a"),
              Text(
                extent={{51,11},{87,-14}},
                lineColor={128,128,128},
                textString="b"),
              Rectangle(
                extent={{-30,11},{30,-10}},
                lineColor={64,64,64},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-81,-66},{-23,25},{40,-39},{97,71}},
                color={255,0,0},
                thickness=0.5,
                smooth=Smooth.None),
              Text(
                extent={{-49,82},{45,59}},
                textString="constraint",
                pattern=LinePattern.None),
              Text(
                extent={{-150,120},{150,80}},
                lineColor={0,0,255},
                textString="%name")}),
            Documentation(info="<html>
<p>This model does not use explicit variables e.g. state variables in order to describe the relative motion of frame_b with respect to frame_a, but defines kinematic constraints between the frame_a and frame_b. The forces and torques at both frames are then evaluated in such a way that the constraints are satisfied. Sometimes this type of formulation is also called an implicit joint in literature.</p>
<p>As a consequence of the formulation the relative kinematics between frame_a and frame_b cannot be initialized.</p>
<p>In particular in complex multibody systems with closed loops this may help to simplify the system of non-linear equations. Please compare the translation log using the classical joint formulation and the alternative formulation used here in order to check whether this fact applies to the particular system under consideration.</p>
<p>In systems without closed loops the use of this implicit joint does not make sense or may even be disadvantageous.</p>
<p>See the subpackage <a href=\"Modelica://Modelica.Mechanics.MultiBody.Examples.Constraints\">Examples.Constraints</a> for testing the joint. </p>
</html>"));
      end Revolute;

      model Spherical
        "Spherical cut joint and translational directions may be constrained or released"
        extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;
        import MBS = Modelica_Mechanics_MultiBody;

        parameter Boolean x_locked=true
          "= true: constraint force in x-direction, resolved in frame_a"
          annotation (Dialog(group="Constraints"), choices(checkBox=true));
        parameter Boolean y_locked=true
          "= true: constraint force in y-direction, resolved in frame_a"
          annotation (Dialog(group="Constraints"), choices(checkBox=true));
        parameter Boolean z_locked=true
          "= true: constraint force in z-direction, resolved in frame_a"
          annotation (Dialog(group="Constraints"), choices(checkBox=true));

        parameter Boolean animation=true
          "= true, if animation shall be enabled (show sphere)"
          annotation (Dialog(group="Animation"));
        parameter Modelica_SIunits.Distance sphereDiameter=world.defaultJointLength /3
          "Diameter of sphere representing the spherical joint"
          annotation (Dialog(group="Animation", enable=animation));
        input MBS.Types.Color sphereColor=MBS.Types.Defaults.JointColor
          "Color of sphere representing the spherical joint"
          annotation (Dialog(colorSelector=true, group="Animation", enable=animation));
        input MBS.Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog(group="Animation", enable=animation));

        Modelica_Mechanics_MultiBody.Visualizers.Advanced.Shape sphere(
          shapeType="sphere",
          color=sphereColor,
          specularCoefficient=specularCoefficient,
          length=sphereDiameter,
          width=sphereDiameter,
          height=sphereDiameter,
          lengthDirection={1,0,0},
          widthDirection={0,1,0},
          r_shape={-0.5,0,0}*sphereDiameter,
          r=frame_a.r_0,
          R=frame_a.R) if world.enableAnimation and animation;
      protected
        MBS.Frames.Orientation R_rel
          "Dummy or relative orientation object from frame_a to frame_b";
        Modelica_SIunits.Position r_rel_a[3]
          "Position vector from origin of frame_a to origin of frame_b, resolved in frame_a";
        Modelica_SIunits.InstantaneousPower P;

      equation
        // Determine relative position vector resolved in frame_a
        R_rel = MBS.Frames.relativeRotation(frame_a.R, frame_b.R);
        r_rel_a = MBS.Frames.resolve2(frame_a.R, frame_b.r_0 - frame_a.r_0);

        // Constraint equations concerning translation
        if x_locked and y_locked and z_locked then
          r_rel_a=zeros(3);
        elseif x_locked and y_locked and not z_locked then
          r_rel_a[1]=0;
          r_rel_a[2]=0;
          frame_a.f[3]=0;
        elseif x_locked and not y_locked and z_locked then
          r_rel_a[1]=0;
          r_rel_a[3]=0;
          frame_a.f[2]=0;
        elseif x_locked and not y_locked and not z_locked then
          r_rel_a[1]=0;
          frame_a.f[2]=0;
          frame_a.f[3]=0;
        elseif not x_locked and y_locked and z_locked then
          r_rel_a[2]=0;
          r_rel_a[3]=0;
          frame_a.f[1]=0;
        elseif not x_locked and y_locked and not z_locked then
          r_rel_a[2]=0;
          frame_a.f[1]=0;
          frame_a.f[3]=0;
        elseif not x_locked and not y_locked and z_locked then
          r_rel_a[3]=0;
          frame_a.f[1]=0;
          frame_a.f[2]=0;
        else
          frame_a.f=zeros(3);
        end if;

        //frame_a.t = zeros(3);
        frame_b.t = zeros(3);
        frame_b.f = -MBS.Frames.resolve2(R_rel, frame_a.f);
        zeros(3) = frame_a.t + MBS.Frames.resolve1(R_rel, frame_b.t) - cross(r_rel_a, frame_a.f);
        P= frame_a.t*MBS.Frames.angularVelocity2(frame_a.R)+frame_b.t*MBS.Frames.angularVelocity2(frame_b.R) + MBS.Frames.resolve1(frame_b.R,frame_b.f)*der(frame_b.r_0)+MBS.Frames.resolve1(frame_a.R,frame_a.f)*der(frame_a.r_0);
        annotation (
          defaultComponentName="constraint",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-150,120},{150,80}},
                lineColor={0,0,255},
                textString="%name"),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: x",
                visible=x_locked and not y_locked and not z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: y",
                visible=not x_locked and y_locked and not z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: z",
                visible=not x_locked and not y_locked and z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: x, y",
                visible=x_locked and y_locked and not z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: x, z",
                visible=x_locked and not y_locked and z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: y, z",
                visible=not x_locked and y_locked and z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: x, y, z",
                visible=x_locked and y_locked and z_locked),
              Ellipse(
                extent={{-66,-70},{74,70}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-45,-50},{55,50}},
                lineColor={128,128,128},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{34,70},{75,-68}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-96,10},{-64,-10}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{27,10},{104,-10}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Ellipse(
                extent={{-20,25},{30,-25}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={160,160,164}),
              Line(
                points={{-81,-66},{-23,25},{40,-39},{97,71}},
                color={255,0,0},
                thickness=0.5,
                smooth=Smooth.None)}),
          Documentation(info="<html>
<p>This model does not use explicit variables e.g. state variables in order to describe the relative motion of frame_b with to respect to frame_a, but defines kinematic constraints between the frame_a and frame_b. The forces and torques at both frames are then evaluated in such a way that the constraints are satisfied. Sometimes this type of formulation is also called an implicit joint in literature.</p>
<p>As a consequence of the formulation the relative kinematics between frame_a and frame_b cannot be initialized.</p>
<p>In particular in complex multibody systems with closed loops this may help to simplify the system of non-linear equations. Please compare the translation log using the classical joint formulation and the alternative formulation used here in order to check whether this fact applies to the particular system under consideration.</p>
<p>In systems without closed loops the use of this implicit joint does not make sense or may even be disadvantageous.</p>
<p>See the subpackage <a href=\"Modelica://Modelica.Mechanics.MultiBody.Examples.Constraints\">Examples.Constraints</a> for testing the joint. </p>
</html>"));
      end Spherical;

      model Universal
        "Universal cut-joint and translational directions may be constrained or released"
        extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;
        import MBS = Modelica_Mechanics_MultiBody;

        parameter MBS.Types.Axis n_a={1,0,0}
          "Axis of revolute joint 1 resolved in frame_a" annotation (Evaluate=true);
        parameter MBS.Types.Axis n_b={0,1,0}
          "Axis of revolute joint 2 resolved in frame_b" annotation (Evaluate=true);

        parameter Boolean x_locked=true
          "= true: constraint force in x-direction, resolved in frame_a"
          annotation (Dialog(group="Constraints in translational motion"), choices(checkBox=true));
        parameter Boolean y_locked=true
          "= true: constraint force in y-direction, resolved in frame_a"
          annotation (Dialog(group="Constraints in translational motion"), choices(checkBox=true));
        parameter Boolean z_locked=true
          "= true: constraint force in z-direction, resolved in frame_a"
          annotation (Dialog(group="Constraints in translational motion"), choices(checkBox=true));

        parameter Boolean animation=true
          "= true, if animation shall be enabled (show sphere)"
          annotation (Dialog(group="Animation"));
        parameter Modelica_SIunits.Distance sphereDiameter=world.defaultJointLength
            /3 "Diameter of sphere representing the spherical joint"
          annotation (Dialog(group="Animation", enable=animation));
        input MBS.Types.Color sphereColor=MBS.Types.Defaults.JointColor
          "Color of sphere representing the spherical joint"
          annotation (Dialog(colorSelector=true, group="Animation", enable=animation));
        input MBS.Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog(group="Animation", enable=animation));
      protected
        MBS.Frames.Orientation R_rel
          "Dummy or relative orientation object from frame_a to frame_b";
        Real w_rel[3];
        Modelica_SIunits.Position r_rel_a[3]
          "Position vector from origin of frame_a to origin of frame_b, resolved in frame_a";

        Modelica_SIunits.InstantaneousPower P;
      equation
        // Determine relative position vector resolved in frame_a
        R_rel = MBS.Frames.relativeRotation(frame_a.R, frame_b.R);
        w_rel = MBS.Frames.angularVelocity1(R_rel);
        r_rel_a = MBS.Frames.resolve2(frame_a.R, frame_b.r_0 - frame_a.r_0);

        // Constraint equations concerning translations
        if x_locked and y_locked and z_locked then
          r_rel_a=zeros(3);
        elseif x_locked and y_locked and not z_locked then
          r_rel_a[1]=0;
          r_rel_a[2]=0;
          frame_a.f[3]=0;
        elseif x_locked and not y_locked and z_locked then
          r_rel_a[1]=0;
          r_rel_a[3]=0;
          frame_a.f[2]=0;
        elseif x_locked and not y_locked and not z_locked then
          r_rel_a[1]=0;
          frame_a.f[2]=0;
          frame_a.f[3]=0;
        elseif not x_locked and y_locked and z_locked then
          r_rel_a[2]=0;
          r_rel_a[3]=0;
          frame_a.f[1]=0;
        elseif not x_locked and y_locked and not z_locked then
          r_rel_a[2]=0;
          frame_a.f[1]=0;
          frame_a.f[3]=0;
        elseif not x_locked and not y_locked and z_locked then
          r_rel_a[3]=0;
          frame_a.f[1]=0;
          frame_a.f[2]=0;
        else
          frame_a.f=zeros(3);
        end if;
        // Constraint equations concerning rotations
        frame_a.t*n_a=0;
        frame_b.t*n_b=0;
        n_b*R_rel.T*n_a=0;
        assert(abs(n_a*n_b) <Modelica_Constants.eps,  "The two axes that constitute the Constraints.Universal joint must be different");

        zeros(3)=frame_a.f + MBS.Frames.resolve1(R_rel, frame_b.f);
        zeros(3) = frame_a.t+MBS.Frames.resolve1(R_rel, frame_b.t)- cross(r_rel_a, frame_a.f);
        P = frame_a.t*MBS.Frames.angularVelocity2(frame_a.R)+frame_b.t*MBS.Frames.angularVelocity2(frame_b.R) + MBS.Frames.resolve1(frame_b.R,frame_b.f)*der(frame_b.r_0)+MBS.Frames.resolve1(frame_a.R,frame_a.f)*der(frame_a.r_0);

        annotation (
          defaultComponentName="constraint",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: x",
                visible=x_locked and not y_locked and not z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: y",
                visible=not x_locked and y_locked and not z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: z",
                visible=not x_locked and not y_locked and z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: x, y",
                visible=x_locked and y_locked and not z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: x, z",
                visible=x_locked and not y_locked and z_locked),
              Text(
                extent={{-100,-70},{100,-100}},
                lineColor={95,95,95},
                textString="lock: y, z",
                visible=not x_locked and y_locked and z_locked),
              Text(
                extent={{-100,-76},{100,-106}},
                lineColor={95,95,95},
                textString="lock: x, y, z",
                visible=x_locked and y_locked and z_locked),
              Rectangle(
                extent={{-96,15},{-61,-15}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={235,235,235}),
              Ellipse(
                extent={{-76,-80},{84,80}},
                lineColor={160,160,164},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-56,-60},{64,60}},
                lineColor={160,160,164},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{16,82},{84,-82}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{60,15},{104,-15}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={235,235,235}),
              Line(
                points={{16,78},{16,-78}},
                color={0,0,0},
                thickness=0.5),
              Ellipse(
                extent={{-48,-40},{84,40}},
                lineColor={160,160,164},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-28,-20},{64,26}},
                lineColor={160,160,164},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-18,-54},{-56,0},{-18,50},{44,52},{-18,-54}},
                pattern=LinePattern.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(
                points={{16,78},{16,-20}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{36,38},{-8,-36}},
                color={0,0,0},
                thickness=0.5),
              Text(
                extent={{-150,120},{150,80}},
                lineColor={0,0,255},
                textString="%name"),
              Line(
                points={{-81,-66},{-23,25},{40,-39},{97,71}},
                color={255,0,0},
                thickness=0.5,
                smooth=Smooth.None)}),
          Documentation(info="<html>
<p>This model does not use explicit variables e.g. state variables in order to describe the relative motion of frame_b with respect to frame_a, but defines kinematic constraints between the frame_a and frame_b. The forces and torques at both frames are then evaluated in such a way that the constraints are satisfied. Sometimes this type of formulation is also called an implicit joint in literature.</p>
<p>As a consequence of the formulation the relative kinematics between frame_a and frame_b cannot be initialized.</p>
<p>In particular in complex multibody systems with closed loops this may help to simplify the system of non-linear equations. Please compare the translation log using the classical joint formulation and the alternative formulation used here in order to check whether this fact applies to the particular system under consideration.</p>
<p>In systems without closed loops the use of this implicit joint does not make sense or may even be disadvantageous.</p>
<p>See the subpackage <a href=\"Modelica://Modelica.Mechanics.MultiBody.Examples.Constraints\">Examples.Constraints</a> for testing the joint. </p>
</html>"));
      end Universal;

      annotation (Documentation(info="<html>
<p>
This package contains <b>constraint components</b>, that is, idealized, massless elements that
constrain the motion between frames by means of kinematic constraints. The constraint
elements are especially aimed to be used for multibody models which contain <b>kinematic loops</b>.
Usually, kinematic loops are automatically handled. However, the performance might be improved
by either solving certain kinds of loops analytically with the help of the components of
subpackage  <a href=\"Modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies\">Assemblies</a>, or
by providing numerically better loop constraint formulations with the help of the components
of this subpackage.
</p>
</html>"));
    end Constraints;

    package Internal
      "Components used for analytic solution of kinematic loops (use only if you know what you are doing)"

      extends Modelica_Icons.InternalPackage;

      model RevoluteWithLengthConstraint
        "Revolute joint where the rotation angle is computed from a length constraint (1 degree-of-freedom, no potential state)"

        extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;
        Modelica_Mechanics_Rotational.Interfaces.Flange_a axis
          "1-dim. rotational flange that drives the joint"
          annotation (Placement(transformation(extent={{10,90},{-10,110}},
                rotation=0)));
        Modelica_Mechanics_Rotational.Interfaces.Flange_b bearing
          "1-dim. rotational flange of the drive bearing"
          annotation (Placement(transformation(extent={{-50,90},{-70,110}},
                rotation=0)));

        Modelica_Blocks.Interfaces.RealInput position_a[3](each final quantity="Length", each final unit="m")
          "Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}},
                rotation=0)));
        Modelica_Blocks.Interfaces.RealInput position_b[3](each final quantity="Length", each final unit="m")
          "Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint"
          annotation (Placement(transformation(extent={{140,-80},{100,-40}},
                rotation=0)));

        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        parameter Modelica_SIunits.Position lengthConstraint(start=1)
          "Fixed length of length constraint";
        parameter Modelica_Mechanics_MultiBody.Types.Axis n={0,0,1}
          "Axis of rotation resolved in frame_a (= same as in frame_b)"
          annotation (Evaluate=true);
        parameter Cv.NonSIunits.Angle_deg phi_offset=0
          "Relative angle offset (angle = phi + from_deg(phi_offset))";
        parameter Cv.NonSIunits.Angle_deg phi_guess=0
          "Select the configuration such that at initial time |phi - from_deg(phi_guess)| is minimal";
        parameter Modelica_SIunits.Distance cylinderLength=world.defaultJointLength
          "Length of cylinder representing the joint axis" annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter Modelica_SIunits.Distance cylinderDiameter=world.defaultJointWidth
          "Diameter of cylinder representing the joint axis" annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color cylinderColor=Types.Defaults.JointColor
          "Color of cylinder representing the joint axis"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));

        final parameter Boolean positiveBranch(fixed=false)
          "Based on phi_guess, selection of one of the two solutions of the non-linear constraint equation";
        final parameter Real e[3](each final unit="1")=Modelica_Math.Vectors.normalizeWithAssert(n)
          "Unit vector in direction of rotation axis, resolved in frame_a";

        Modelica_SIunits.Angle phi "Rotation angle of revolute joint";
        Frames.Orientation R_rel
          "Relative orientation object from frame_a to frame_b";
        Modelica_SIunits.Angle angle
          "= phi + from_deg(phi_offset) (relative rotation angle between frame_a and frame_b)";
        Modelica_SIunits.Torque tau "= axis.tau (driving torque in the axis)";

      protected
        Modelica_SIunits.Position r_a[3]=position_a
          "Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint";
        Modelica_SIunits.Position r_b[3]=position_b
          "Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint";
        Real e_r_a "Projection of r_a on e";
        Real e_r_b "Projection of r_b on e";
        Real A "Coefficient A of equation: A*cos(phi) + B*sin(phi) + C = 0";
        Real B "Coefficient B of equation: A*cos(phi) + B*sin(phi) + C = 0";
        Real C "Coefficient C of equation: A*cos(phi) + B*sin(phi) + C = 0";
        Real k1 "Constant of quadratic equation";
        Real k2 "Constant of quadratic equation";
        Real k1a(start=1);
        Real k1b;
        Real kcos_angle "= k1*cos(angle)";
        Real ksin_angle "= k1*sin(angle)";

        Visualizers.Advanced.Shape cylinder(
          shapeType="cylinder",
          color=cylinderColor,
          specularCoefficient=specularCoefficient,
          length=cylinderLength,
          width=cylinderDiameter,
          height=cylinderDiameter,
          lengthDirection=e,
          widthDirection={0,1,0},
          r_shape=-e*(cylinderLength/2),
          r=frame_a.r_0,
          R=frame_a.R) if world.enableAnimation and animation;

        function selectBranch
          "Determine branch which is closest to initial angle=0"
          extends Modelica_Icons.Function;
          input Modelica_SIunits.Length L "Length of length constraint";
          input Real e[3](each final unit="1")
            "Unit vector along axis of rotation, resolved in frame_a (= same in frame_b)";
          input Modelica_SIunits.Angle angle_guess
            "Select the configuration such that at initial time |angle-angle_guess| is minimal (angle=0: frame_a and frame_b coincide)";
          input Modelica_SIunits.Position r_a[3]
            "Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint";
          input Modelica_SIunits.Position r_b[3]
            "Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint";
          output Boolean positiveBranch "Branch of the initial solution";
        protected
          Real e_r_a "Projection of r_a on e";
          Real e_r_b "Projection of r_b on e";
          Real A "Coefficient A of equation: A*cos(phi) + B*sin(phi) + C = 0";
          Real B "Coefficient B of equation: A*cos(phi) + B*sin(phi) + C = 0";
          Real C "Coefficient C of equation: A*cos(phi) + B*sin(phi) + C = 0";
          Real k1 "Constant of quadratic equation";
          Real k2 "Constant of quadratic equation";
          Real k1a;
          Real k1b;
          Real kcos1 "k1*cos(angle1)";
          Real ksin1 "k1*sin(angle1)";
          Real kcos2 "k2*cos(angle2)";
          Real ksin2 "k2*sin(angle2)";
          Modelica_SIunits.Angle angle1 "solution 1 of nonlinear equation";
          Modelica_SIunits.Angle angle2 "solution 2 of nonlinear equation";
        algorithm
          /* The position vector r_rel from frame_a to frame_b of the length constraint
       element, resolved in frame_b of the revolute joint is given by
       (T_rel is the planar transformation matrix from frame_a to frame_b of
        the revolute joint):
          r_rel = r_b - T_rel*r_a
       The length constraint can therefore be formulated as:
          r_rel*r_rel = L*L
       with
          (r_b - T_rel*r_a)*(r_b - T_rel*r_a)
             = r_b*r_b - 2*r_b*T_rel*r_a + r_a*transpose(T_rel)*T_rel*r_a
             = r_b*r_b + r_a*r_a - 2*r_b*T_rel*r_a
       follows
          (1) 0 = r_a*r_a + r_b*r_b - 2*r_b*T_rel*r_a - L*L
       The vectors r_a, r_b and parameter L are NOT a function of
       the angle of the revolute joint. Since T_rel = T_rel(angle) is a function
       of the unknown angle of the revolute joint, this is a non-linear
       equation in this angle.
          T_rel = [e]*transpose([e]) + (identity(3) - [e]*transpose([e]))*cos(angle)
                  - skew(e)*sin(angle);
       with
          r_b*T_rel*r_a
             = r_b*(e*(e*r_a) + (r_a - e*(e*r_a))*cos(angle) - cross(e,r_a)*sin(angle)
             = (e*r_b)*(e*r_a) + (r_b*r_a - (e*r_b)*(e*r_a))*cos(angle) - r_b*cross(e,r_a)*sin(angle)
       follows for the constraint equation (1)
          (2) 0 = r_a*r_a + r_b*r_b - L*L
                  - 2*(e*r_b)*(e*r_a)
                  - 2*(r_b*r_a - (e*r_b)*(e*r_a))*cos(angle)
                  + 2*r_b*cross(e,r_a)*sin(angle)
       or
          (3) A*cos(angle) + B*sin(angle) + C = 0
       with
              A = -2*(r_b*r_a - (e*r_b)*(e*r_a))
              B = 2*r_b*cross(e,r_a)
              C = r_a*r_a + r_b*r_b - L*L - 2*(e*r_b)*(e*r_a)
       Equation (3) is solved by computing sin(angle) and cos(angle)
       independently from each other. This allows to compute
       angle in the range: -180 deg <= angle <= 180 deg
    */
          e_r_a := e*r_a;
          e_r_b := e*r_b;
          A := -2*(r_b*r_a - e_r_b*e_r_a);
          B := 2*r_b*cross(e, r_a);
          C := r_a*r_a + r_b*r_b - L*L - 2*e_r_b*e_r_a;
          k1 := A*A + B*B;
          k1a :=k1 - C*C;
          assert(k1a > 1.e-10, "
Singular position of loop (either no or two analytic solutions;
the mechanism has lost one-degree-of freedom in this position).
Try first to use another Modelica.Mechanics.MultiBody.Joints.Assemblies.JointXXX component.
In most cases it is best that the joints outside of the JointXXX
component are revolute and NOT prismatic joints. If this also
lead to singular positions, it could be that this kinematic loop
cannot be solved analytically. In this case you have to build
up the loop with basic joints (NO aggregation JointXXX components)
and rely on dynamic state selection, i.e., during simulation
the states will be dynamically selected in such a way that in no
position a degree of freedom is lost.
");       k1b := max(k1a, 1.0e-12);
          k2 := sqrt(k1b);

          kcos1 := -A*C + B*k2;
          ksin1 := -B*C - A*k2;
          angle1 := atan2(ksin1, kcos1);

          kcos2 := -A*C - B*k2;
          ksin2 := -B*C + A*k2;
          angle2 := atan2(ksin2, kcos2);

          if abs(angle1 - angle_guess) <= abs(angle2 - angle_guess) then
            positiveBranch := true;
          else
            positiveBranch := false;
          end if;
        end selectBranch;
      initial equation
        positiveBranch = selectBranch(lengthConstraint, e, Cv.from_deg(phi_offset
           + phi_guess), r_a, r_b);
      equation
        Connections.branch(frame_a.R, frame_b.R);
        axis.tau = tau;
        axis.phi = phi;
        bearing.phi = 0;

        angle = Cv.from_deg(phi_offset) + phi;

        // transform kinematic quantities from frame_a to frame_b
        frame_b.r_0 = frame_a.r_0;

        R_rel = Frames.planarRotation(e, angle, der(angle));
        frame_b.R = Frames.absoluteRotation(frame_a.R, R_rel);

        // Force and torque balance
        zeros(3) = frame_a.f + Frames.resolve1(R_rel, frame_b.f);
        zeros(3) = frame_a.t + Frames.resolve1(R_rel, frame_b.t);

        // Compute rotation angle (details, see function "selectBranch")
        e_r_a = e*r_a;
        e_r_b = e*r_b;
        A = -2*(r_b*r_a - e_r_b*e_r_a);
        B = 2*r_b*cross(e, r_a);
        C = r_a*r_a + r_b*r_b - lengthConstraint*lengthConstraint - 2*e_r_b*e_r_a;
        k1 = A*A + B*B;
        k1a = k1 - C*C;

        assert(k1a > 1.e-10, "
Singular position of loop (either no or two analytic solutions;
the mechanism has lost one-degree-of freedom in this position).
Try first to use another Modelica.Mechanics.MultiBody.Joints.Assemblies.JointXXX component.
In most cases it is best that the joints outside of the JointXXX
component are revolute and NOT prismatic joints. If this also
lead to singular positions, it could be that this kinematic loop
cannot be solved analytically. In this case you have to build
up the loop with basic joints (NO aggregation JointXXX components)
and rely on dynamic state selection, i.e., during simulation
the states will be dynamically selected in such a way that in no
position a degree of freedom is lost.
");

        k1b = Frames.Internal.maxWithoutEvent(k1a, 1.0e-12);
        k2 = sqrt(k1b);
        kcos_angle = -A*C + (if positiveBranch then B else -B)*k2;
        ksin_angle = -B*C + (if positiveBranch then -A else A)*k2;

        angle = Modelica_Math.atan2(ksin_angle, kcos_angle);
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-30,10},{10,-10}},
                lineColor={64,64,64},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,-60},{-30,60}},
                lineColor={64,64,64},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={255,255,255},
                radius=10),
              Rectangle(
                extent={{30,-60},{100,60}},
                lineColor={64,64,64},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={255,255,255},
                radius=10),
              Text(
                extent={{-139,-168},{137,-111}},
                textString="%name",
                lineColor={0,0,255}),
              Rectangle(extent={{-100,60},{-30,-60}}, lineColor={64,64,64}, radius=10),
              Rectangle(extent={{30,60},{100,-60}}, lineColor={64,64,64}, radius=10),
              Text(
                extent={{-142,-108},{147,-69}},
                lineColor={0,0,0},
                textString="n=%n"),
              Line(points={{-60,60},{-60,90}}, color={0,0,0}),
              Line(points={{-20,70},{-60,70}}, color={0,0,0}),
              Line(points={{-20,80},{-20,60}}, color={0,0,0}),
              Line(points={{20,80},{20,60}}, color={0,0,0}),
              Line(points={{20,70},{41,70}}, color={0,0,0}),
              Polygon(
                points={{-9,30},{10,30},{30,50},{-29,50},{-9,30}},
                lineColor={64,64,64},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{10,30},{30,50},{30,-51},{10,-31},{10,30}},
                lineColor={64,64,64},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-10,90},{10,50}},
                lineColor={64,64,64},
                fillPattern=FillPattern.VerticalCylinder,
                fillColor={192,192,192})}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,-60},{-30,60}},
                lineColor={64,64,64},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={255,255,255},
                radius=10),
              Rectangle(
                extent={{-100,-60},{-30,60}},
                lineColor={64,64,64},
                fillPattern=FillPattern.None,
                radius=10),
              Rectangle(
                extent={{-30,10},{10,-10}},
                lineColor={64,64,64},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{30,-60},{100,60}},
                lineColor={64,64,64},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={255,255,255},
                radius=10),
              Rectangle(
                extent={{30,-60},{100,60}},
                lineColor={64,64,64},
                fillPattern=FillPattern.None,
                radius=10),
              Line(points={{-60,60},{-60,96}}, color={0,0,0}),
              Line(points={{-20,70},{-60,70}}, color={0,0,0}),
              Line(points={{-20,80},{-20,60}}, color={0,0,0}),
              Line(points={{20,80},{20,60}}, color={0,0,0}),
              Line(points={{20,70},{41,70}}, color={0,0,0}),
              Polygon(
                points={{-9,30},{10,30},{30,50},{-29,50},{-9,30}},
                lineColor={64,64,64},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{10,30},{30,50},{30,-51},{10,-31},{10,30}},
                lineColor={64,64,64},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-10,50},{10,100}},
                lineColor={64,64,64},
                fillPattern=FillPattern.VerticalCylinder,
                fillColor={192,192,192})}),
          Documentation(info="<html>
<p>
Joint where frame_b rotates around axis n which is fixed in frame_a.
The two frames coincide when \"phi + phi_offset = 0\", where
\"phi_offset\" is a parameter with a zero default
and \"phi\" is the rotation angle.
</p>
<p>
This variant of the revolute joint is designed to work together
with a length constraint in a kinematic loop. This means that the
angle of the revolute joint, phi, is computed such that the
length constraint is fulfilled.
</p>
<p>
<b>Usually, this joint should not be used by a user of the MultiBody
library. It is only provided to built-up the Modelica.Mechanics.MultiBody.Joints.Assemblies.JointXYZ
joints.</b>
</p>

<p>
In releases before version 3.0 of the Modelica Standard Library, it was possible
to activate the torque projection equation (= cut-torque projected to the rotation
axis must be identical to the drive torque of flange axis) via parameter
<b>axisTorqueBalance</b>. This is no longer possible, since otherwise this
model would not be \"balanced\" (= same number of unknowns as equations).
Instead, when using this model in version 3.0 and later versions,
the force in the length constraint component (Joints.SphericalSpherical or
Joints.UniversalSpherical) must be calculated such that the driving torque
in direction of the rotation
axis is (RC shall be the name of the instance of RevoluteWithLenghtConstraint):
</p>
<pre>
    0 = RC.axis.tau + RC.e*RC.frame_b.t;
</pre>
<p>
If this equation is used, usually the force in the length constraint
and the second derivative of the revolute angle will be part of a linear
algebraic system of equations. In some cases it is possible to solve
this system of equations locally, i.e., provide the rod force directly
as function of the revolute constraint torque. In any case, this projection
equation or an equivalent one has to be provided via variable \"constraintResidue\" in the \"Advanced\"
menu of \"Joints.SphericalSpherical\" or \"Joints.UniversalSpherical\".
</p>

</html>"));
      end RevoluteWithLengthConstraint;

      model PrismaticWithLengthConstraint
        "Prismatic joint where the translational distance is computed from a length constraint (1 degree-of-freedom, no potential state)"

        extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;
        Modelica_Mechanics_Translational.Interfaces.Flange_a axis
          "1-dim. translational flange that drives the joint"
          annotation (Placement(transformation(extent={{70,80},{90,60}}, rotation=
                 0)));
        Modelica_Mechanics_Translational.Interfaces.Flange_b bearing
          "1-dim. translational flange of the drive bearing"
          annotation (Placement(transformation(extent={{-30,80},{-50,60}},
                rotation=0)));
        Modelica_Blocks.Interfaces.RealInput position_a[3](each final quantity="Length", each final unit="m")
          "Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of prismatic joint"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}},
                rotation=0)));
        Modelica_Blocks.Interfaces.RealInput position_b[3](each final quantity="Length", each final unit="m")
          "Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of prismatic joint"
          annotation (Placement(transformation(extent={{140,-80},{100,-40}},
                rotation=0)));

        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        parameter Modelica_SIunits.Position length(start=1)
          "Fixed length of length constraint";
        parameter Modelica_Mechanics_MultiBody.Types.Axis n={1,0,0}
          "Axis of translation resolved in frame_a (= same as in frame_b)"
          annotation (Evaluate=true);
        parameter Modelica_SIunits.Position s_offset=0
          "Relative distance offset (distance between frame_a and frame_b = s(t) + s_offset)";
        parameter Modelica_SIunits.Position s_guess=0
          "Select the configuration such that at initial time |s(t0)-s_guess| is minimal";
        parameter Types.Axis boxWidthDirection={0,1,0}
          "Vector in width direction of box, resolved in frame_a"
          annotation (Evaluate=true, Dialog(tab="Animation", group=
                "if animation = true", enable=animation));
        parameter Modelica_SIunits.Distance boxWidth=world.defaultJointWidth
          "Width of prismatic joint box" annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter Modelica_SIunits.Distance boxHeight=boxWidth
          "Height of prismatic joint box" annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color boxColor=Types.Defaults.JointColor
          "Color of prismatic joint box"
          annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
        input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));

        final parameter Boolean positiveBranch(fixed=false)
          "Selection of one of the two solutions of the non-linear constraint equation";
        final parameter Real e[3](each final unit="1")=Modelica_Math.Vectors.normalizeWithAssert(n)
          "Unit vector in direction of translation axis, resolved in frame_a";
        Modelica_SIunits.Position s
          "Relative distance between frame_a and frame_b along axis n = s + s_offset)";
        Modelica_SIunits.Position distance
          "Relative distance between frame_a and frame_b along axis n";
        Modelica_SIunits.Position r_rel_a[3]
          "Position vector from frame_a to frame_b resolved in frame_a";
        Modelica_SIunits.Force f "= axis.f (driving force in the axis)";

      protected
        Modelica_SIunits.Position r_a[3]=position_a
          "Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of prismatic joint";
        Modelica_SIunits.Position r_b[3]=position_b
          "Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of prismatic joint";
        Modelica_SIunits.Position rbra[3] "= rb - ra";
        Real B "Coefficient B of equation: s*s + B*s + C = 0";
        Real C "Coefficient C of equation: s*s + B*s + C = 0";
        Real k1 "Constant of quadratic equation solution";
        Real k2 "Constant of quadratic equation solution";
        Real k1a(start=1);
        Real k1b;

        Visualizers.Advanced.Shape box(
          shapeType="box",
          color=boxColor,
          specularCoefficient=specularCoefficient,
          length=if noEvent(abs(s + s_offset) > 1.e-6) then s + s_offset else 1.e-6,
          width=boxWidth,
          height=boxHeight,
          lengthDirection=e,
          widthDirection=boxWidthDirection,
          r=frame_a.r_0,
          R=frame_a.R) if world.enableAnimation and animation;

        function selectBranch
          "Determine branch which is closest to initial angle=0"
          extends Modelica_Icons.Function;
          input Modelica_SIunits.Length L "Length of length constraint";
          input Real e[3](each final unit="1")
            "Unit vector along axis of translation, resolved in frame_a (= same in frame_b)";
          input Modelica_SIunits.Position d_guess
            "Select the configuration such that at initial time |d-d_guess| is minimal (d: distance between origin of frame_a and origin of frame_b)";
          input Modelica_SIunits.Position r_a[3]
            "Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of prismatic joint";
          input Modelica_SIunits.Position r_b[3]
            "Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of prismatic joint";
          output Boolean positiveBranch "Branch of the initial solution";
        protected
          Modelica_SIunits.Position rbra[3] "= rb - ra";
          Real B "Coefficient B of equation: d*d + B*d + C = 0";
          Real C "Coefficient C of equation: d*d + B*d + C = 0";
          Real k1 "Constant of quadratic equation solution";
          Real k2 "Constant of quadratic equation solution";
          Real k1a;
          Real k1b;
          Real d1 "solution 1 of quadratic equation";
          Real d2 "solution 2 of quadratic equation";
        algorithm
          /* The position vector r_rel from frame_a to frame_b of the length constraint
       element, resolved in frame_b of the prismatic joint (frame_a and frame_b
       of the prismatic joint are parallel to each other) is given by:
          r_rel = d*e + r_b - r_a
       The length constraint can therefore be formulated as:
          r_rel*r_rel = L*L
       with
          (d*e + r_b - r_a)*(d*e + r_b - r_a)
                   = d*d + 2*d*e*(r_b - r_a) + (r_b - r_a)*(r_b - r_a)
       follows
          (1)  0 = d*d + d*2*e*(r_b - r_a) + (r_b - r_a)*(r_b - r_a) - L*L
       The vectors r_a, r_b and parameter L are NOT a function of
       the distance d of the prismatic joint. Therefore, (1) is a quadratic
       equation in the single unknown "d":
          (2) d*d + B*d + C = 0
              with   B = 2*e*(r_b - r_a)
                     C = (r_b - r_a)*(r_b - r_a) - L*L
       The solution is
          (3) d = - B/2 +/- sqrt(B*B/4 - C)
    */
          rbra := r_b - r_a;
          B := 2*(e*rbra);
          C := rbra*rbra - L*L;
          k1 := B/2;
          k1a :=k1*k1 - C;
        assert(noEvent(k1a > 1.e-10), "
Singular position of loop (either no or two analytic solutions;
the mechanism has lost one-degree-of freedom in this position).
Try first to use another Modelica.Mechanics.MultiBody.Joints.Assemblies.JointXXX component.
If this also lead to singular positions, it could be that this
kinematic loop cannot be solved analytically with a fixed state
selection. In this case you have to build up the loop with
basic joints (NO aggregation JointXXX components) and rely on
dynamic state selection, i.e., during simulation the states will
be dynamically selected in such a way that in no position a
degree of freedom is lost.
");       k1b :=max(k1a, 1.0e-12);
          k2 :=sqrt(k1b);
          d1 := -k1 + k2;
          d2 := -k1 - k2;
          if abs(d1 - d_guess) <= abs(d2 - d_guess) then
            positiveBranch := true;
          else
            positiveBranch := false;
          end if;
        end selectBranch;
      initial equation
        positiveBranch = selectBranch(length, e, s_offset + s_guess, r_a, r_b);
      equation
        Connections.branch(frame_a.R, frame_b.R);

        axis.f = f;
        axis.s = s;
        bearing.s = 0;
        distance = s_offset + s;

        // relationships of frame_a and frame_b quantities
        r_rel_a = e*distance;
        frame_b.r_0 = frame_a.r_0 + Frames.resolve1(frame_a.R, r_rel_a);
        frame_b.R = frame_a.R;
        zeros(3) = frame_a.f + frame_b.f;
        zeros(3) = frame_a.t + frame_b.t + cross(r_rel_a, frame_b.f);

        // Compute translational distance (details, see function "selectBranch")
        rbra = r_b - r_a;
        B = 2*(e*rbra);
        C = rbra*rbra - length*length;
        k1 = B/2;
        k1a = k1*k1 - C;
        assert(noEvent(k1a > 1.e-10), "
Singular position of loop (either no or two analytic solutions;
the mechanism has lost one-degree-of freedom in this position).
Try first to use another Modelica.Mechanics.MultiBody.Joints.Assemblies.JointXXX component.
If this also lead to singular positions, it could be that this
kinematic loop cannot be solved analytically with a fixed state
selection. In this case you have to build up the loop with
basic joints (NO aggregation JointXXX components) and rely on
dynamic state selection, i.e., during simulation the states will
be dynamically selected in such a way that in no position a
degree of freedom is lost.
");     k1b = Frames.Internal.maxWithoutEvent(k1a, 1.0e-12);
        k2 = sqrt(k1b);
        distance = -k1 + (if positiveBranch then k2 else -k2);
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-30,-40},{100,30}},
                pattern=LinePattern.None,
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(extent={{-30,40},{100,-40}}, lineColor={0,0,0}),
              Rectangle(
                extent={{-100,-60},{-30,50}},
                pattern=LinePattern.None,
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{-100,50},{-30,60}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{-30,30},{100,40}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Text(
                extent={{-136,-170},{140,-113}},
                textString="%name",
                lineColor={0,0,255}),
              Rectangle(extent={{-100,60},{-30,-60}}, lineColor={0,0,0}),
              Line(points={{100,-40},{100,-60}}, color={0,0,255}),
              Rectangle(
                extent={{100,40},{90,80}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-136,-116},{153,-77}},
                lineColor={0,0,0},
                textString="n=%n")}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-30,-50},{-30,50}}, color={0,0,0}),
              Line(points={{0,-67},{90,-67}}, color={128,128,128}),
              Text(
                extent={{31,-68},{68,-81}},
                lineColor={128,128,128},
                textString="s"),
              Line(points={{-100,-67},{0,-67}}, color={128,128,128}),
              Polygon(
                points={{-39,-64},{-29,-67},{-39,-70},{-39,-64}},
                lineColor={128,128,128},
                fillColor={128,128,128},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-77,-70},{-43,-85}},
                lineColor={128,128,128},
                textString="s_offset"),
              Line(points={{-100,-71},{-100,-51}}, color={128,128,128}),
              Line(points={{-30,-73},{-30,-33}}, color={128,128,128}),
              Line(points={{100,-70},{100,-30}}, color={128,128,128}),
              Polygon(
                points={{90,-64},{100,-67},{90,-70},{90,-64}},
                lineColor={128,128,128},
                fillColor={128,128,128},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,50},{-30,60}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{-100,-60},{-30,50}},
                pattern=LinePattern.None,
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(extent={{-30,40},{100,-40}}, lineColor={0,0,0}),
              Rectangle(
                extent={{-30,-40},{100,30}},
                pattern=LinePattern.None,
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(
                extent={{-30,30},{100,40}},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Rectangle(extent={{-100,60},{-30,-60}}, lineColor={0,0,0}),
              Line(points={{100,-40},{100,-60}}, color={0,0,255}),
              Text(
                extent={{42,91},{57,76}},
                textString="f",
                lineColor={0,0,255}),
              Line(points={{40,75},{70,75}}, color={0,0,255}),
              Polygon(
                points={{-21,78},{-31,75},{-21,72},{-21,78}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-8,75},{-31,75}}, color={0,0,255}),
              Text(
                extent={{-21,90},{-6,75}},
                textString="f",
                lineColor={0,0,255}),
              Polygon(
                points={{60,78},{70,75},{60,72},{60,78}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-30,64},{70,64}}, color={128,128,128}),
              Polygon(
                points={{60,67},{70,64},{60,61},{60,67}},
                lineColor={128,128,128},
                fillColor={128,128,128},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{0,63},{37,50}},
                lineColor={128,128,128},
                textString="s"),
              Rectangle(
                extent={{100,40},{90,80}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<HTML>
<p>
Joint where frame_b is translated along axis n which is fixed in frame_a.
The two frames coincide when \"s + s_offset = 0\", where
\"s_offset\" is a parameter with a zero default
and \"s\" is the relative distance.
</p>
<p>
This variant of the prismatic joint is designed to work together
with a length constraint in a kinematic loop. This means that the
relative distance \"s\" of the joint is computed such that the
length constraint is fulfilled.
</p>
<p>
<b>Usually, this joint should not be used by a user of the MultiBody
library. It is only provided to built-up the Modelica.Mechanics.MultiBody.Joints.Assemblies.JointXYZ
joints.</b>
</p>

<p>
In releases before version 3.0 of the Modelica Standard Library, it was possible
to activate the force projection equation (= cut-force projected to the translation
axis must be identical to the driving force of flange axis) via parameter
<b>axisForceBalance</b>. This is no longer possible, since otherwise this
model would not be \"balanced\" (= same number of unknowns as equations).
Instead, when using this model in version 3.0 and later versions,
the force in the length constraint component (Joints.SphericalSpherical or
Joints.UniversalSpherical) must be calculated such that the driving force
in direction of the translation
axis is (RC shall be the name of the instance of PrismaticWithLenghtConstraint):
</p>
<pre>
    0 = RC.axis.f + RC.e*RC.frame_b.f;
</pre>
<p>
If this equation is used, usually the force in the length constraint
and the second derivative of the prismatic distance will be part of a linear
algebraic system of equations. In some cases it is possible to solve
this system of equations locally, i.e., provide the rod force directly
as function of the prismatic constraint force. In any case, this projection
equation or an equivalent one has to be provided via variable \"constraintResidue\" in the \"Advanced\"
menu of \"Joints.SphericalSpherical\" or \"Joints.UniversalSpherical\".
</p>

</html>"));
      end PrismaticWithLengthConstraint;

       model RollingConstraintVerticalWheel
        "Rolling constraint for wheel that is always perpendicular to x-y plane"
        import Modelica_Mechanics_MultiBody.Frames;

          Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a
          "Frame fixed in wheel center point. x-Axis: upwards, y-axis: along wheel axis"
          annotation (Placement(transformation(extent={{-16,4},{16,36}}),
              iconTransformation(extent={{-16,4},{16,36}})));

        parameter Modelica_SIunits.Radius radius "Wheel radius";

          parameter Boolean lateralSlidingConstraint = true
          "= true, if lateral sliding constraint taken into account, = false if lateral force = 0 (needed to avoid overconstraining if two ideal rolling wheels are connect on one axis)"
                                                                                                              annotation(choices(checkBox=true),HideResult=true,Evaluate=true);

          // Contact force
        Modelica_SIunits.Force f_wheel_0[3]
          "Contact force acting on wheel, resolved in world frame";
        Modelica_SIunits.Force f_lat
          "Contact force acting on wheel in lateral direction";
        Modelica_SIunits.Force f_long
          "Contact force acting on wheel in longitudinal direction";
      protected
           Real e_axis_0[3]
          "Unit vector along wheel axis, resolved in world frame";
        Modelica_SIunits.Position rContact_0[3]
          "Distance vector from wheel center to contact point, resolved in world frame";

           // Coordinate system at contact point
           Real e_n_0[3]
          "Unit vector in normal direction of road at contact point, resolved in world frame";
           Real e_lat_0[3]
          "Unit vector in lateral direction of wheel at contact point, resolved in world frame";
           Real e_long_0[3]
          "Unit vector in longitudinal direction of wheel at contact point, resolved in world frame";

           // Slip velocities
        Modelica_SIunits.Velocity v_0[3]
          "Velocity of wheel center, resolved in world frame";
        Modelica_SIunits.AngularVelocity w_0[3]
          "Angular velocity of wheel, resolved in world frame";

        Modelica_SIunits.Velocity vContact_0[3]
          "Velocity of wheel contact point, resolved in world frame";

           // Utility vectors
           Real aux[3];

       equation
           // Coordinate system at contact point (e_long_0, e_lat_0, e_n_0)
           e_n_0    = {0,0,1};
           e_axis_0 = Frames.resolve1(frame_a.R, {0,1,0});
           aux      = cross(e_n_0, e_axis_0);
           e_long_0 = aux / Modelica_Math.Vectors.length(aux);
           e_lat_0  = cross(e_long_0, e_n_0);

           // Slip velocities
           rContact_0 = {0,0,-radius};
           v_0 = der(frame_a.r_0);
           w_0 = Frames.angularVelocity1(frame_a.R);
           vContact_0 = v_0 + cross(w_0, rContact_0);

           // Two non-holonomic constraint equations on velocity level (ideal rolling, no slippage)
           0 = vContact_0*e_long_0;
           if lateralSlidingConstraint then
              0 = vContact_0*e_lat_0;
              f_wheel_0 = f_lat*e_lat_0 + f_long*e_long_0;
           else
              0 = f_lat;
              f_wheel_0 = f_long*e_long_0;
           end if;

           // Force and torque balance at the wheel center
           zeros(3) = frame_a.f + Frames.resolve2(frame_a.R, f_wheel_0);
           zeros(3) = frame_a.t + Frames.resolve2(frame_a.R, cross(rContact_0, f_wheel_0));
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,-60},{100,-80}},
                  lineColor={0,0,0},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-148,-86},{152,-126}},
                  lineColor={0,0,255},
                  textString="%name"),
                Line(
                  points={{0,-60},{0,4}},
                  color={0,0,0},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dot),
                Line(
                  visible=lateralSlidingConstraint,
                  points={{-98,-30},{-16,-30}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Polygon(
                  visible=lateralSlidingConstraint,
                  points={{-40,-16},{-40,-42},{-6,-30},{-40,-16}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}));
       end RollingConstraintVerticalWheel;

       model InitPosition
        "Internal model to initialize r_rel_a for Joints.FreeMotionScalarInit"
         extends Modelica_Blocks.Icons.Block;

         import SI = Modelica_SIunits;
         import Modelica_Mechanics_MultiBody.Frames;

        input Modelica_SIunits.Position r_a_0[3]
          annotation (HideResult=true, Dialog);
        input Modelica_SIunits.Position r_b_0[3]
          annotation (HideResult=true, Dialog);
         input Frames.Orientation R_a annotation(HideResult=true,Dialog);

         Modelica_Blocks.Interfaces.RealOutput r_rel_a[3](each final quantity="Length", each final unit="m") annotation (Placement(transformation(extent={{100,-10},
                   {120,10}})));

       equation
         r_b_0 = r_a_0 + Frames.resolve1(R_a, {r_rel_a[1], r_rel_a[2], r_rel_a[3]});

         annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                   -100},{100,100}}), graphics), Icon(coordinateSystem(
                preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={Text(
                extent={{-88,16},{82,-12}},
                lineColor={0,0,0},
                textString="r_rel_a")}));
       end InitPosition;

       model InitAngle
        "Internal model to initialize the angels for Joints.FreeMotionScalarInit"
         extends Modelica_Blocks.Icons.Block;

         import SI = Modelica_SIunits;
         import Modelica_Mechanics_MultiBody.Frames;

         parameter Modelica_Mechanics_MultiBody.Types.RotationSequence sequence_start={1,2,3}
          "Sequence of angle rotations";

         Interfaces.Frame_a frame_a
           annotation (Placement(transformation(extent={{-116,-16},{-84,16}})));
         Interfaces.Frame_b frame_b
           annotation (Placement(transformation(extent={{84,-16},{116,16}})));

         Frames.Orientation R_rel
          "Relative orientation object to rotate from frame_a to frame_b"      annotation(HideResult=true);
         Frames.Orientation R_rel_inv
          "Relative orientation object to rotate from frame_b to frame_a"      annotation(HideResult=true);

         Modelica_Blocks.Interfaces.RealOutput angle[3](each final quantity=
              "Angle", each final unit="rad") annotation (Placement(
              transformation(
              extent={{-10,-10},{10,10}},
              rotation=-90,
              origin={0,-110})));
       equation
         Connections.branch(frame_a.R, frame_b.R);
         R_rel = Frames.axesRotations(sequence_start,
                                      {angle[1], angle[2], angle[3]},
                                      {der(angle[1]), der(angle[2]), der(angle[3])});
         if rooted(frame_a.R) then
            R_rel_inv = Frames.nullRotation();
            frame_b.R = Frames.absoluteRotation(frame_a.R, R_rel);
         else
            R_rel_inv = Frames.inverseRotation(R_rel);
            frame_a.R = Frames.absoluteRotation(frame_b.R, R_rel_inv);
         end if;

         frame_a.f = zeros(3);
         frame_a.t = zeros(3);
         frame_b.f = zeros(3);
         frame_b.t = zeros(3);

         annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}),  graphics), Icon(graphics={Text(
                extent={{-84,-58},{86,-86}},
                lineColor={0,0,0},
                textString="angle")}));
       end InitAngle;

       model InitAngularVelocity
        "Internal model to initialize w_rel_b for Joints.FreeMotionScalarInit"
         extends Modelica_Blocks.Icons.Block;

         import SI = Modelica_SIunits;
         import Modelica_Mechanics_MultiBody.Frames;

         input Frames.Orientation R_a annotation(HideResult=true, Dialog);
         input Frames.Orientation R_b annotation(HideResult=true, Dialog);

         Modelica_Blocks.Interfaces.RealOutput w_rel_b[3](each final quantity="AngularVelocity", each final unit="rad/s") annotation (Placement(transformation(extent={{100,-10},
                   {120,10}})));
       equation
        Frames.angularVelocity2(R_b) = Frames.resolve2(R_b,Frames.angularVelocity1(R_a)) + w_rel_b;

         annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                   -100},{100,100}}), graphics), Icon(graphics={Text(
                extent={{-86,16},{84,-12}},
                lineColor={0,0,0},
                textString="w_rel_b")}));
       end InitAngularVelocity;
      annotation (Documentation(info="<HTML>
<p>
The models in this package should not be used by the user.
They are designed to build up other models in the MultiBody library
and some of them cannot be used in an arbitrary way and require
particular knowledge how to set the options in the parameter menu.
Don't use the models of this package.
</p>
</HTML>"));
    end Internal;

    annotation ( Documentation(info="<HTML>
<p>
This package contains <b>joint components</b>,
that is, idealized, massless elements that constrain
the motion between frames. In subpackage <b>Assemblies</b>
aggregation joint components are provided to handle
kinematic loops analytically (this means that non-linear systems
of equations occurring in these joint aggregations are analytically
solved, i.e., robustly and efficiently).
</p>
<h4>Content</h4>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><b><i>Model</i></b></th><th><b><i>Description</i></b></th></tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Prismatic\">Prismatic</a>
      <td valign=\"top\">Prismatic joint and actuated prismatic joint
          (1 translational degree-of-freedom, 2 potential states)<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/Prismatic.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Revolute\">Revolute</a>
 </td>
      <td valign=\"top\">Revolute and actuated revolute joint
          (1 rotational degree-of-freedom, 2 potential states)<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/Revolute.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Cylindrical\">Cylindrical</a></td>
      <td valign=\"top\">Cylindrical joint (2 degrees-of-freedom, 4 potential states)<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/Cylindrical.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Universal\">Universal</a></td>
      <td valign=\"top\">Universal joint (2 degrees-of-freedom, 4 potential states)<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/Universal.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Planar\">Planar</a></td>
      <td valign=\"top\">Planar joint (3 degrees-of-freedom, 6 potential states)<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/Planar.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Spherical\">Spherical</a></td>
      <td valign=\"top\">Spherical joint (3 constraints and no potential states, or 3 degrees-of-freedom and 3 states)<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/Spherical.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.FreeMotion\">FreeMotion</a></td>
      <td valign=\"top\">Free motion joint (6 degrees-of-freedom, 12 potential states)<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/FreeMotion.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.SphericalSpherical\">SphericalSpherical</a></td>
      <td valign=\"top\">Spherical - spherical joint aggregation (1 constraint,
          no potential states) with an optional point mass in the middle<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/SphericalSpherical.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.UniversalSpherical\">UniversalSpherical</a></td>
      <td valign=\"top\">Universal - spherical joint aggregation (1 constraint, no potential states)<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Joints/UniversalSpherical.png\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.GearConstraint\">GearConstraint</a></td>
      <td valign=\"top\">Ideal 3-dim. gearbox (arbitrary shaft directions)
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies\">MultiBody.Joints.Assemblies</a></td>
      <td valign=\"top\"><b>Package</b> of joint aggregations for analytic loop handling.
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Joints.Constraints\">MultiBody.Joints.Constraints</a></td>
      <td valign=\"top\"><b>Package</b> of components that define joints by constraints
      </td>
  </tr>
</table>
</HTML>"),   Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
              {100,100}}), graphics={
          Polygon(
            points={{6,6},{28,-2},{54,80},{32,86},{6,6}},
            lineColor={95,95,95},
            fillPattern=FillPattern.Sphere,
            smooth=Smooth.None,
            fillColor={255,255,255}),
          Polygon(
            points={{-12,-18},{0,-36},{-70,-84},{-82,-66},{-12,-18}},
            lineColor={95,95,95},
            fillPattern=FillPattern.Sphere,
            smooth=Smooth.None,
            fillColor={255,255,255}),
          Ellipse(
            extent={{-12,8},{34,-38}},
            lineColor={95,95,95},
            fillPattern=FillPattern.Sphere,
            fillColor={95,95,95})}));
  end Joints;

  package Parts
    "Rigid components such as bodies with mass and inertia and massless rods"
    extends Modelica_Icons.Package;

    model Fixed "Frame fixed in the world frame at a given position"
      import Modelica_Mechanics_MultiBody.Types;
      import Modelica_SIunits.Conversions.to_unit1;

      Interfaces.Frame_b frame_b "Coordinate system fixed in the world frame"
        annotation (Placement(transformation(extent={{84,-16},{116,16}}, rotation=
               0)));

      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Modelica_SIunits.Position r[3]={0,0,0}
        "Position vector from world frame to frame_b, resolved in world frame";
      parameter Types.ShapeType shapeType="cylinder" "Type of shape" annotation (
         Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Position r_shape[3]={0,0,0}
        "Vector from world frame to shape origin, resolved in world frame"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Types.Axis lengthDirection = to_unit1(r - r_shape)
        "Vector in length direction of shape, resolved in world frame"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Types.Axis widthDirection={0,1,0}
        "Vector in width direction of shape, resolved in world frame"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Length length=Modelica_Math.Vectors.length(r
           - r_shape) "Length of shape" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance width=length/world.defaultWidthFraction
        "Width of shape" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance height=width "Height of shape"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Types.ShapeExtra extra=0.0
        "Additional parameter for cone, pipe etc. (see docu of Visualizers.Advanced.Shape)"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color color=Types.Defaults.RodColor "Color of shape"
                         annotation (Dialog(
          colorSelector=true,
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));

    protected
      outer Modelica_Mechanics_MultiBody.World world;
      Visualizers.Advanced.Shape shape(
        shapeType=shapeType,
        color=color,
        specularCoefficient=specularCoefficient,
        length=length,
        width=width,
        height=height,
        lengthDirection=lengthDirection,
        widthDirection=widthDirection,
        extra=extra,
        r_shape=r_shape,
        r=zeros(3),
        R=Frames.nullRotation()) if world.enableAnimation and animation;
    equation
      Connections.root(frame_b.R);
      frame_b.r_0 = r;
      frame_b.R = Frames.nullRotation();
      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-90,90},{90,-90}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{150,145},{-150,105}},
              textString="%name",
              lineColor={0,0,255}),
            Line(points={{0,100},{0,-100}}, color={0,0,0}),
            Line(points={{0,-80},{-100,-20}}, color={0,0,0}),
            Line(points={{0,-40},{-100,20}}, color={0,0,0}),
            Line(points={{0,0},{-100,60}}, color={0,0,0}),
            Line(points={{0,40},{-100,100}}, color={0,0,0}),
            Line(points={{0,0},{100,0}}, color={0,0,0}),
            Text(
              extent={{-150,-105},{150,-135}},
              lineColor={0,0,0},
              textString="r=%r")}),
        Documentation(info="<html>
<p>
Element consisting of a frame (frame_b) that is fixed in the world
frame at a given position defined by parameter vector <b>r</b>
(vector from origin of world frame to frame_b, resolved in the
world frame).
</p>
<p>
By default, this component is visualized by a cylinder connecting the
world frame and frame_b of this components, as shown in the figure below.
Note, that the visualized world frame on the left side and
Fixed.frame_b on the right side are not part of the
component animation and that the animation may be switched off via parameter
animation = <b>false</b>.
</p>
<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Fixed.png\" ALT=\"Parts.Fixed\">
</p>

</html>"),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{0,100},{0,-100}}, color={0,0,0}),
            Line(points={{0,-80},{-100,-20}}, color={0,0,0}),
            Line(points={{0,-40},{-100,20}}, color={0,0,0}),
            Line(points={{0,0},{-100,60}}, color={0,0,0}),
            Line(points={{0,40},{-100,100}}, color={0,0,0}),
            Line(points={{0,0},{100,0}}, color={0,0,0})}));
    end Fixed;

    model FixedTranslation
      "Fixed translation of frame_b with respect to frame_a"
      import Modelica_Mechanics_MultiBody.Types;
      import Modelica_SIunits.Conversions.to_unit1;

      Interfaces.Frame_a frame_a
        "Coordinate system fixed to the component with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
              rotation=0)));
      Interfaces.Frame_b frame_b
        "Coordinate system fixed to the component with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{84,-16},{116,16}}, rotation=
               0)));

      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Modelica_SIunits.Position r[3](start={0,0,0})
        "Vector from frame_a to frame_b resolved in frame_a";
      parameter Types.ShapeType shapeType="cylinder" "Type of shape" annotation (
         Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Position r_shape[3]={0,0,0}
        "Vector from frame_a to shape origin, resolved in frame_a" annotation (
          Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Types.Axis lengthDirection = to_unit1(r - r_shape)
        "Vector in length direction of shape, resolved in frame_a" annotation (
          Evaluate=true, Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Types.Axis widthDirection={0,1,0}
        "Vector in width direction of shape, resolved in frame_a" annotation (
          Evaluate=true, Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Length length=Modelica_Math.Vectors.length(r
           - r_shape) "Length of shape" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance width=length/world.defaultWidthFraction
        "Width of shape" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance height=width "Height of shape"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Types.ShapeExtra extra=0.0
        "Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape)"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color color=Types.Defaults.RodColor "Color of shape"
                         annotation (Dialog(
          colorSelector=true,
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));

    protected
      outer Modelica_Mechanics_MultiBody.World world;
      Visualizers.Advanced.Shape shape(
        shapeType=shapeType,
        color=color,
        specularCoefficient=specularCoefficient,
        r_shape=r_shape,
        lengthDirection=lengthDirection,
        widthDirection=widthDirection,
        length=length,
        width=width,
        height=height,
        extra=extra,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;
    equation
      Connections.branch(frame_a.R, frame_b.R);
      assert(cardinality(frame_a) > 0 or cardinality(frame_b) > 0,
        "Neither connector frame_a nor frame_b of FixedTranslation object is connected");

      frame_b.r_0 = frame_a.r_0 + Frames.resolve1(frame_a.R, r);
      frame_b.R = frame_a.R;

      /* Force and torque balance */
      zeros(3) = frame_a.f + frame_b.f;
      zeros(3) = frame_a.t + frame_b.t + cross(r, frame_b.f);
      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-99,5},{101,-5}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,85},{150,45}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{150,-50},{-150,-20}},
              lineColor={0,0,0},
              textString="r=%r"),
            Text(
              extent={{-89,38},{-53,13}},
              lineColor={128,128,128},
              textString="a"),
            Text(
              extent={{57,39},{93,14}},
              lineColor={128,128,128},
              textString="b")}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-100,5},{100,-5}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-95,20},{-58,20}},
              color={128,128,128},
              arrow={Arrow.None,Arrow.Filled}),
            Line(
              points={{-94,18},{-94,50}},
              color={128,128,128},
              arrow={Arrow.None,Arrow.Filled}),
            Text(
              extent={{-72,35},{-58,24}},
              lineColor={128,128,128},
              textString="x"),
            Text(
              extent={{-113,57},{-98,45}},
              lineColor={128,128,128},
              textString="y"),
            Line(points={{-100,-4},{-100,-69}}, color={128,128,128}),
            Line(points={{-100,-63},{90,-63}}, color={128,128,128}),
            Text(
              extent={{-22,-39},{16,-63}},
              lineColor={128,128,128},
              textString="r"),
            Polygon(
              points={{88,-59},{88,-68},{100,-63},{88,-59}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{100,-3},{100,-68}}, color={128,128,128}),
            Line(
              points={{69,20},{106,20}},
              color={128,128,128},
              arrow={Arrow.None,Arrow.Filled}),
            Line(
              points={{70,18},{70,50}},
              color={128,128,128},
              arrow={Arrow.None,Arrow.Filled}),
            Text(
              extent={{92,35},{106,24}},
              lineColor={128,128,128},
              textString="x"),
            Text(
              extent={{51,57},{66,45}},
              lineColor={128,128,128},
              textString="y")}),
        Documentation(info="<HTML>
<p>
Component for a <b>fixed translation</b> of frame_b with respect
to frame_a, i.e., the relationship between connectors frame_a and frame_b
remains constant and frame_a is always <b>parallel</b> to frame_b.
</p>
<p>
By default, this component is visualized by a cylinder connecting
frame_a and frame_b, as shown in the figure below. Note, that the
two visualized frames are not part of the component animation and that
the animation may be switched off via parameter animation = <b>false</b>.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/FixedTranslation.png\" ALT=\"Parts.FixedTranslation\">
</p>
</HTML>"));
    end FixedTranslation;

    model FixedRotation
      "Fixed translation followed by a fixed rotation of frame_b with respect to frame_a"

      import Modelica_Mechanics_MultiBody.Frames;
      import Modelica_SIunits.Conversions.to_unit1;

      Interfaces.Frame_a frame_a
        "Coordinate system fixed to the component with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
              rotation=0)));
      Interfaces.Frame_b frame_b
        "Coordinate system fixed to the component with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{84,-16},{116,16}}, rotation=
               0)));

      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Modelica_SIunits.Position r[3]={0,0,0}
        "Vector from frame_a to frame_b resolved in frame_a";
      parameter Modelica_Mechanics_MultiBody.Types.RotationTypes rotationType=Types.RotationTypes.RotationAxis
        "Type of rotation description" annotation (Evaluate=true);
      parameter Modelica_Mechanics_MultiBody.Types.Axis n={1,0,0}
        "Axis of rotation in frame_a (= same as in frame_b)" annotation (
          Evaluate=true, Dialog(group="if rotationType = RotationAxis", enable=
              rotationType == Modelica.Mechanics.MultiBody.Types.RotationTypes.RotationAxis));
      parameter Cv.NonSIunits.Angle_deg angle=0
        "Angle to rotate frame_a around axis n into frame_b" annotation (Dialog(
            group="if rotationType = RotationAxis", enable=rotationType ==
              Modelica.Mechanics.MultiBody.Types.RotationTypes.RotationAxis));

      parameter Modelica_Mechanics_MultiBody.Types.Axis n_x={1,0,0}
        "Vector along x-axis of frame_b resolved in frame_a" annotation (
          Evaluate=true, Dialog(group="if rotationType = TwoAxesVectors",
            enable=rotationType == Modelica.Mechanics.MultiBody.Types.RotationTypes.TwoAxesVectors));
      parameter Modelica_Mechanics_MultiBody.Types.Axis n_y={0,1,0}
        "Vector along y-axis of frame_b resolved in frame_a" annotation (
          Evaluate=true, Dialog(group="if rotationType = TwoAxesVectors",
            enable=rotationType == Modelica.Mechanics.MultiBody.Types.RotationTypes.TwoAxesVectors));

      parameter Modelica_Mechanics_MultiBody.Types.RotationSequence sequence(
        min={1,1,1},
        max={3,3,3})={1,2,3} "Sequence of rotations" annotation (Evaluate=true,
          Dialog(group="if rotationType = PlanarRotationSequence", enable=
              rotationType == Modelica.Mechanics.MultiBody.Types.RotationTypes.PlanarRotationSequence));
      parameter Cv.NonSIunits.Angle_deg angles[3]={0,0,0}
        "Rotation angles around the axes defined in 'sequence'" annotation (
          Dialog(group="if rotationType = PlanarRotationSequence", enable=
              rotationType == Modelica.Mechanics.MultiBody.Types.RotationTypes.PlanarRotationSequence));
      parameter Modelica_Mechanics_MultiBody.Types.ShapeType shapeType=
          "cylinder" "Type of shape" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Position r_shape[3]={0,0,0}
        "Vector from frame_a to shape origin, resolved in frame_a" annotation (
          Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_Mechanics_MultiBody.Types.Axis lengthDirection=to_unit1(
          r - r_shape)
        "Vector in length direction of shape, resolved in frame_a" annotation (
          Evaluate=true, Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_Mechanics_MultiBody.Types.Axis widthDirection={0,1,0}
        "Vector in width direction of shape, resolved in frame_a" annotation (
          Evaluate=true, Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Length length=Modelica_Math.Vectors.length(r
           - r_shape) "Length of shape" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance width=length/world.defaultWidthFraction
        "Width of shape" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance height=width "Height of shape"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_Mechanics_MultiBody.Types.ShapeExtra extra=0.0
        "Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape)"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      /*
  parameter Boolean checkTotalPower=false
    "= true, if total power flowing into this component shall be determined (must be zero)"
    annotation (Dialog(tab="Advanced"));
*/

      input Modelica_Mechanics_MultiBody.Types.Color color=Types.Defaults.RodColor
        "Color of shape" annotation (Dialog(
          colorSelector=true,
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Modelica_Mechanics_MultiBody.Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      final parameter Frames.Orientation R_rel=if rotationType == Types.RotationTypes.RotationAxis
           then Frames.planarRotation(
            Modelica_Math.Vectors.normalizeWithAssert(n),
            Cv.from_deg(angle),
            0) else if rotationType == Types.RotationTypes.TwoAxesVectors then
          Frames.from_nxy(n_x, n_y) else Frames.axesRotations(
            sequence,
            Cv.from_deg(angles),
            zeros(3)) "Fixed rotation object from frame_a to frame_b";
      /*
  SI.Power totalPower
    "Total power flowing into this element, if checkTotalPower=true (otherwise dummy)";
*/
    protected
      outer Modelica_Mechanics_MultiBody.World world;

      /*
  parameter Frames.Orientation R_rel_inv=
      Frames.inverseRotation(R_rel)
*/
      parameter Frames.Orientation R_rel_inv=Frames.from_T(transpose(R_rel.T),
          zeros(3)) "Inverse of R_rel (rotate from frame_b to frame_a)";
      Modelica_Mechanics_MultiBody.Visualizers.Advanced.Shape shape(
        shapeType=shapeType,
        color=color,
        specularCoefficient=specularCoefficient,
        r_shape=r_shape,
        lengthDirection=lengthDirection,
        widthDirection=widthDirection,
        length=length,
        width=width,
        height=height,
        extra=extra,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;

    equation
      Connections.branch(frame_a.R, frame_b.R);
      assert(cardinality(frame_a) > 0 or cardinality(frame_b) > 0,
        "Neither connector frame_a nor frame_b of FixedRotation object is connected");

      /* Relationships between quantities of frame_a and frame_b */
      frame_b.r_0 = frame_a.r_0 + Frames.resolve1(frame_a.R, r);
      if rooted(frame_a.R) then
        frame_b.R = Frames.absoluteRotation(frame_a.R, R_rel);
        zeros(3) = frame_a.f + Frames.resolve1(R_rel, frame_b.f);
        zeros(3) = frame_a.t + Frames.resolve1(R_rel, frame_b.t) - cross(r,
          frame_a.f);
      else
        frame_a.R = Frames.absoluteRotation(frame_b.R, R_rel_inv);
        zeros(3) = frame_b.f + Frames.resolve1(R_rel_inv, frame_a.f);
        zeros(3) = frame_b.t + Frames.resolve1(R_rel_inv, frame_a.t) + cross(
          Frames.resolve1(R_rel_inv, r), frame_b.f);
      end if;

      /*
  if checkTotalPower then
    totalPower = frame_a.f*Frames.resolve2(frame_a.R, der(frame_a.r_0)) +
                 frame_b.f*Frames.resolve2(frame_b.R, der(frame_b.r_0)) +
                 frame_a.t*Frames.angularVelocity2(frame_a.R) +
                 frame_b.t*Frames.angularVelocity2(frame_b.R);
  else
    totalPower = 0;
  end if;
*/
      annotation (
        Documentation(info="<HTML>
<p>
Component for a <b>fixed translation</b> and <b>fixed rotation</b> of frame_b with respect
to frame_a, i.e., the relationship between connectors frame_a and frame_b
remains constant. There are several possibilities to define the
orientation of frame_b with respect to frame_a:
</p>
<ul>
<li><b>Planar rotation</b> along axis 'n' (that is fixed and resolved
    in frame_a) with a fixed angle 'angle'.</li>
<li><b>Vectors n_x</b> and <b>n_y</b> that are directed along the corresponding axes
    direction of frame_b and are resolved in frame_a (if n_y is not
    orthogonal to n_x, the y-axis of frame_b is selected such that it is
    orthogonal to n_x and in the plane of n_x and n_y).</li>
<li><b>Sequence</b> of <b>three planar axes rotations</b>.
    For example, \"sequence = {1,2,3}\" and \"angles = {90, 45, -90}\"
    means to rotate frame_a around the x axis with 90 degrees, around the new
    y axis with 45 degrees and around the new z axis around -90 degrees to
    arrive at frame_b. Note, that sequence={1,2,3}
    is the Cardan angle sequence and sequence = {3,1,3} is the Euler angle
    sequence.</li>
</ul>
<p>
By default, this component is visualized by a cylinder connecting
frame_a and frame_b, as shown in the figure below. In this figure
frame_b is rotated along the z-axis of frame_a with 60 degree. Note, that the
two visualized frames are not part of the component animation and that
the animation may be switched off via parameter animation = <b>false</b>.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/FixedRotation.png\" ALT=\"Parts.FixedRotation\">
</p>
</HTML>",   revisions="<HTML><p><b>Release Notes:</b></p>
<ul>
  <li><i>July 28, 2003</i><br>
         Bug fixed: if rotationType = PlanarRotationSequence, then 'angles'
         was used with unit [rad] instead of [deg].</li>
</ul>
</HTML>"),
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Text(
              extent={{-150,80},{150,120}},
              textString="%name",
              lineColor={0,0,255}),
            Rectangle(
              extent={{-100,5},{100,-4}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{80,20},{129,50}}, color={0,0,0}),
            Line(points={{80,20},{57,59}}, color={0,0,0}),
            Polygon(
              points={{144,60},{117,59},{132,37},{144,60}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{43,80},{46,50},{68,65},{43,80}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,-50},{150,-80}},
              lineColor={0,0,0},
              textString="r=%r"),
            Text(
              extent={{-117,51},{-81,26}},
              lineColor={128,128,128},
              textString="a"),
            Text(
              extent={{84,-24},{120,-49}},
              lineColor={128,128,128},
              textString="b")}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{-100,-1},{-100,-66}}, color={128,128,128}),
            Line(points={{100,0},{100,-65}}, color={128,128,128}),
            Line(points={{-100,-60},{89,-60}}, color={128,128,128}),
            Text(
              extent={{-22,-36},{16,-60}},
              lineColor={128,128,128},
              textString="r"),
            Rectangle(
              extent={{-100,5},{100,-5}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(
              points={{69,29},{97,45}},
              color={128,128,128},
              arrow={Arrow.None,Arrow.Filled}),
            Line(
              points={{70,27},{55,54}},
              color={128,128,128},
              arrow={Arrow.None,Arrow.Filled}),
            Text(
              extent={{95,42},{109,31}},
              lineColor={128,128,128},
              textString="x"),
            Text(
              extent={{42,70},{57,58}},
              lineColor={128,128,128},
              textString="y"),
            Line(
              points={{-95,22},{-58,22}},
              color={128,128,128},
              arrow={Arrow.None,Arrow.Filled}),
            Line(
              points={{-94,20},{-94,52}},
              color={128,128,128},
              arrow={Arrow.None,Arrow.Filled}),
            Text(
              extent={{-72,37},{-58,26}},
              lineColor={128,128,128},
              textString="x"),
            Text(
              extent={{-113,59},{-98,47}},
              lineColor={128,128,128},
              textString="y"),
            Polygon(
              points={{88,-56},{88,-65},{100,-60},{88,-56}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid)}));
    end FixedRotation;

    model Body
      "Rigid body with mass, inertia tensor and one frame connector (12 potential states)"

      import Modelica_Mechanics_MultiBody.Types;
      import Modelica_Mechanics_MultiBody.Frames;
      import Modelica_SIunits.Conversions.to_unit1;

      Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a
        "Coordinate system fixed at body" annotation (Placement(transformation(
              extent={{-116,-16},{-84,16}}, rotation=0)));
      parameter Boolean animation=true
        "= true, if animation shall be enabled (show cylinder and sphere)";
      parameter Modelica_SIunits.Position r_CM[3](start={0,0,0})
        "Vector from frame_a to center of mass, resolved in frame_a";
      parameter Modelica_SIunits.Mass m(min=0, start=1) "Mass of rigid body";
      parameter Modelica_SIunits.Inertia I_11(min=0) = 0.001
        "(1,1) element of inertia tensor" annotation (Dialog(group=
              "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica_SIunits.Inertia I_22(min=0) = 0.001
        "(2,2) element of inertia tensor" annotation (Dialog(group=
              "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica_SIunits.Inertia I_33(min=0) = 0.001
        "(3,3) element of inertia tensor" annotation (Dialog(group=
              "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica_SIunits.Inertia I_21(min=-Modelica_Constants.inf) = 0
        "(2,1) element of inertia tensor" annotation (Dialog(group=
              "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica_SIunits.Inertia I_31(min=-Modelica_Constants.inf) = 0
        "(3,1) element of inertia tensor" annotation (Dialog(group=
              "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica_SIunits.Inertia I_32(min=-Modelica_Constants.inf) = 0
        "(3,2) element of inertia tensor" annotation (Dialog(group=
              "Inertia tensor (resolved in center of mass, parallel to frame_a)"));

      Modelica_SIunits.Position r_0[3](start={0,0,0}, each stateSelect=if
            enforceStates then StateSelect.always else StateSelect.avoid)
        "Position vector from origin of world frame to origin of frame_a"
        annotation (Dialog(tab="Initialization", showStartAttribute=true));
      Modelica_SIunits.Velocity v_0[3](start={0,0,0}, each stateSelect=if
            enforceStates then StateSelect.always else StateSelect.avoid)
        "Absolute velocity of frame_a, resolved in world frame (= der(r_0))"
        annotation (Dialog(tab="Initialization", showStartAttribute=true));
      Modelica_SIunits.Acceleration a_0[3](start={0,0,0})
        "Absolute acceleration of frame_a resolved in world frame (= der(v_0))"
        annotation (Dialog(tab="Initialization", showStartAttribute=true));

      parameter Boolean angles_fixed=false
        "= true, if angles_start are used as initial values, else as guess values"
        annotation (
        Evaluate=true,
        choices(checkBox=true),
        Dialog(tab="Initialization"));
      parameter Modelica_SIunits.Angle angles_start[3]={0,0,0}
        "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b"
        annotation (Dialog(tab="Initialization"));
      parameter Types.RotationSequence sequence_start={1,2,3}
        "Sequence of rotations to rotate frame_a into frame_b at initial time"
        annotation (Evaluate=true, Dialog(tab="Initialization"));

      parameter Boolean w_0_fixed=false
        "= true, if w_0_start are used as initial values, else as guess values"
        annotation (
        Evaluate=true,
        choices(checkBox=true),
        Dialog(tab="Initialization"));
      parameter Modelica_SIunits.AngularVelocity w_0_start[3]={0,0,0}
        "Initial or guess values of angular velocity of frame_a resolved in world frame"
        annotation (Dialog(tab="Initialization"));

      parameter Boolean z_0_fixed=false
        "= true, if z_0_start are used as initial values, else as guess values"
        annotation (
        Evaluate=true,
        choices(checkBox=true),
        Dialog(tab="Initialization"));
      parameter Modelica_SIunits.AngularAcceleration z_0_start[3]={0,0,0}
        "Initial values of angular acceleration z_0 = der(w_0)"
        annotation (Dialog(tab="Initialization"));

      parameter Modelica_SIunits.Diameter sphereDiameter=world.defaultBodyDiameter
        "Diameter of sphere" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color sphereColor=Types.Defaults.BodyColor "Color of sphere"
                          annotation (Dialog(
          colorSelector=true,
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Diameter cylinderDiameter=sphereDiameter/Types.Defaults.BodyCylinderDiameterFraction
        "Diameter of cylinder" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color cylinderColor=sphereColor "Color of cylinder" annotation (
         Dialog(
          colorSelector=true,
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Boolean enforceStates=false
        "= true, if absolute variables of body object shall be used as states (StateSelect.always)"
        annotation (Evaluate=true,Dialog(tab="Advanced"));
      parameter Boolean useQuaternions=true
        "= true, if quaternions shall be used as potential states otherwise use 3 angles as potential states"
        annotation (Evaluate=true,Dialog(tab="Advanced"));
      parameter Types.RotationSequence sequence_angleStates={1,2,3}
        "Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states"
        annotation (Evaluate=true, Dialog(tab="Advanced", enable=not
              useQuaternions));

      final parameter Modelica_SIunits.Inertia I[3,3]=[I_11,I_21,I_31; I_21,
          I_22,I_32; I_31,I_32,I_33] "inertia tensor";
      final parameter Frames.Orientation R_start=
          Frames.axesRotations(
            sequence_start,
            angles_start,
            zeros(3))
        "Orientation object from world frame to frame_a at initial time";
      final parameter Modelica_SIunits.AngularAcceleration z_a_start[3]=
          Frames.resolve2(R_start, z_0_start)
        "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";

      Modelica_SIunits.AngularVelocity w_a[3](
        start=Frames.resolve2(R_start, w_0_start),
        fixed=fill(w_0_fixed, 3),
        each stateSelect=if enforceStates then (if useQuaternions then
            StateSelect.always else StateSelect.never) else StateSelect.avoid)
        "Absolute angular velocity of frame_a resolved in frame_a";
      Modelica_SIunits.AngularAcceleration z_a[3](start=Frames.resolve2(R_start,
            z_0_start), fixed=fill(z_0_fixed, 3))
        "Absolute angular acceleration of frame_a resolved in frame_a";
      Modelica_SIunits.Acceleration g_0[3]
        "Gravity acceleration resolved in world frame";

    protected
      outer Modelica_Mechanics_MultiBody.World world;

      // Declarations for quaternions (dummies, if quaternions are not used)
      parameter Frames.Quaternions.Orientation Q_start=Frames.to_Q(R_start)
        "Quaternion orientation object from world frame to frame_a at initial time";
      Frames.Quaternions.Orientation Q(start=Q_start, each stateSelect=if
            enforceStates then (if useQuaternions then StateSelect.prefer else
            StateSelect.never) else StateSelect.avoid)
        "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";

      // Declaration for 3 angles
      parameter Modelica_SIunits.Angle phi_start[3]=if sequence_start[1] ==
          sequence_angleStates[1] and sequence_start[2] == sequence_angleStates[
          2] and sequence_start[3] == sequence_angleStates[3] then angles_start
           else Frames.axesRotationsAngles(R_start, sequence_angleStates)
        "Potential angle states at initial time";
      Modelica_SIunits.Angle phi[3](start=phi_start, each stateSelect=if
            enforceStates then (if useQuaternions then StateSelect.never else
            StateSelect.always) else StateSelect.avoid)
        "Dummy or 3 angles to rotate world frame into frame_a of body";
      Modelica_SIunits.AngularVelocity phi_d[3](each stateSelect=if
            enforceStates then (if useQuaternions then StateSelect.never else
            StateSelect.always) else StateSelect.avoid) "= der(phi)";
      Modelica_SIunits.AngularAcceleration phi_dd[3] "= der(phi_d)";

      // Declarations for animation
      Visualizers.Advanced.Shape cylinder(
        shapeType="cylinder",
        color=cylinderColor,
        specularCoefficient=specularCoefficient,
        length=if Modelica_Math.Vectors.length(r_CM) > sphereDiameter/2 then
            Modelica_Math.Vectors.length(r_CM) - (if cylinderDiameter > 1.1*
            sphereDiameter then sphereDiameter/2 else 0) else 0,
        width=cylinderDiameter,
        height=cylinderDiameter,
        lengthDirection = to_unit1(r_CM),
        widthDirection={0,1,0},
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;
      Visualizers.Advanced.Shape sphere(
        shapeType="sphere",
        color=sphereColor,
        specularCoefficient=specularCoefficient,
        length=sphereDiameter,
        width=sphereDiameter,
        height=sphereDiameter,
        lengthDirection={1,0,0},
        widthDirection={0,1,0},
        r_shape=r_CM - {1,0,0}*sphereDiameter/2,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation and sphereDiameter >
        0;
    initial equation
      if angles_fixed then
        // Initialize positional variables
        if not Connections.isRoot(frame_a.R) then
          // frame_a.R is computed somewhere else
          zeros(3) = Frames.Orientation.equalityConstraint(frame_a.R, R_start);
        elseif useQuaternions then
          // frame_a.R is computed from quaternions Q
          zeros(3) = Frames.Quaternions.Orientation.equalityConstraint(Q, Q_start);
        else
          // frame_a.R is computed from the 3 angles 'phi'
          phi = phi_start;
        end if;
      end if;

    equation
      if enforceStates then
        Connections.root(frame_a.R);
      else
        Connections.potentialRoot(frame_a.R);
      end if;
      r_0 = frame_a.r_0;

      if not Connections.isRoot(frame_a.R) then
        // Body does not have states
        // Dummies
        Q = {0,0,0,1};
        phi = zeros(3);
        phi_d = zeros(3);
        phi_dd = zeros(3);
      elseif useQuaternions then
        // Use Quaternions as states (with dynamic state selection)
        frame_a.R = Frames.from_Q(Q, Frames.Quaternions.angularVelocity2(Q, der(Q)));
        {0} = Frames.Quaternions.orientationConstraint(Q);

        // Dummies
        phi = zeros(3);
        phi_d = zeros(3);
        phi_dd = zeros(3);
      else
        // Use Cardan angles as states
        phi_d = der(phi);
        phi_dd = der(phi_d);
        frame_a.R = Frames.axesRotations(
            sequence_angleStates,
            phi,
            phi_d);

        // Dummies
        Q = {0,0,0,1};
      end if;

      // gravity acceleration at center of mass resolved in world frame
      g_0 = world.gravityAcceleration(frame_a.r_0 + Frames.resolve1(frame_a.R,
        r_CM));

      // translational kinematic differential equations
      v_0 = der(frame_a.r_0);
      a_0 = der(v_0);

      // rotational kinematic differential equations
      w_a = Frames.angularVelocity2(frame_a.R);
      z_a = der(w_a);

      /* Newton/Euler equations with respect to center of mass
            a_CM = a_a + cross(z_a, r_CM) + cross(w_a, cross(w_a, r_CM));
            f_CM = m*(a_CM - g_a);
            t_CM = I*z_a + cross(w_a, I*w_a);
       frame_a.f = f_CM
       frame_a.t = t_CM + cross(r_CM, f_CM);
    Inserting the first three equations in the last two results in:
  */
      frame_a.f = m*(Frames.resolve2(frame_a.R, a_0 - g_0) + cross(z_a, r_CM) +
        cross(w_a, cross(w_a, r_CM)));
      frame_a.t = I*z_a + cross(w_a, I*w_a) + cross(r_CM, frame_a.f);
      annotation (Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-100,30},{-3,-31}},
              lineColor={0,24,48},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={0,127,255},
              radius=10),
            Text(
              extent={{150,-100},{-150,-70}},
              lineColor={0,0,0},
              textString="m=%m"),
            Text(
              extent={{-150,110},{150,70}},
              textString="%name",
              lineColor={0,0,255}),
            Ellipse(
              extent={{-20,60},{100,-60}},
              lineColor={0,24,48},
              fillPattern=FillPattern.Sphere,
              fillColor={0,127,255})}), Documentation(info="<HTML>
<p>
<b>Rigid body</b> with mass and inertia tensor.
All parameter vectors have to be resolved in frame_a.
The <b>inertia tensor</b> has to be defined with respect to a
coordinate system that is parallel to frame_a with the
origin at the center of mass of the body.
</p>
<p>
By default, this component is visualized by a <b>cylinder</b> located
between frame_a and the center of mass and by a <b>sphere</b> that has
its center at the center of mass. If the cylinder length is smaller as
the radius of the sphere, e.g., since frame_a is located at the
center of mass, the cylinder is not displayed. Note, that
the animation may be switched off via parameter animation = <b>false</b>.
</p>
<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Body.png\" ALT=\"Parts.Body\">
</p>

<p>
<b>States of Body Components</b>
</p>
<p>
Every body has potential states. If possible a tool will select
the states of joints and not the states of bodies because this is
usually the most efficient choice. In this case the position, orientation,
velocity and angular velocity of frame_a of the body will be computed
by the component that is connected to frame_a. However, if a body is moving
freely in space, variables of the body have to be used as states. The potential
states of the body are:
</p>
<ul>
<li> The <b>position vector</b> frame_a.r_0 from the origin of the
     world frame to the origin of frame_a of the body, resolved in
     the world frame and the <b>absolute velocity</b> v_0 of the origin of
     frame_a, resolved in the world frame (= der(frame_a.r_0)).
</li>
<li> If parameter <b>useQuaternions</b> in the \"Advanced\" menu
     is <b>true</b> (this is the default), then <b>4 quaternions</b>
     are potential states. Additionally, the coordinates of the
     absolute angular velocity vector of the
     body are 3 potential states.<br>
     If <b>useQuaternions</b> in the \"Advanced\" menu
     is <b>false</b>, then <b>3 angles</b> and the derivatives of
     these angles are potential states. The orientation of frame_a
     is computed by rotating the world frame along the axes defined
     in parameter vector \"sequence_angleStates\" (default = {1,2,3}, i.e.,
     the Cardan angle sequence) around the angles used as potential states.
     For example, the default is to rotate the x-axis of the world frame
     around angles[1], the new y-axis around angles[2] and the new z-axis
     around angles[3], arriving at frame_a.
 </li>
</ul>
<p>
The quaternions have the slight disadvantage that there is a
non-linear constraint equation between the 4 quaternions.
Therefore, at least one non-linear equation has to be solved
during simulation. A tool might, however, analytically solve this
simple constraint equation. Using the 3 angles as states has the
disadvantage that there is a singular configuration in which a
division by zero will occur. If it is possible to determine in advance
for an application class that this singular configuration is outside
of the operating region, the 3 angles might be used as potential
states by setting <b>useQuaternions</b> = <b>false</b>.
</p>
<p>
In text books about 3-dimensional mechanics often 3 angles and the
angular velocity are used as states. This is not the case here, since
3 angles and their derivatives are used as potential states
(if useQuaternions = false). The reason
is that for real-time simulation the discretization formula of the
integrator might be \"inlined\" and solved together with the body equations.
By appropriate symbolic transformation the performance is
drastically increased if angles and their
derivatives are used as states, instead of angles and the angular
velocity.
</p>
<p>
Whether or not variables of the body are used as states is usually
automatically selected by the Modelica translator. If parameter
<b>enforceStates</b> is set to <b>true</b> in the \"Advanced\" menu,
then body variables are forced to be used as states according
to the setting of parameters \"useQuaternions\" and
\"sequence_angleStates\".
</p>
</HTML>"));
    end Body;

    model BodyShape
      "Rigid body with mass, inertia tensor, different shapes for animation, and two frame connectors (12 potential states)"

      import Modelica_Mechanics_MultiBody.Types;
      import Modelica_SIunits.Conversions.to_unit1;

      Interfaces.Frame_a frame_a
        "Coordinate system fixed to the component with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
              rotation=0)));
      Interfaces.Frame_b frame_b
        "Coordinate system fixed to the component with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{84,-16},{116,16}}, rotation=
               0)));

      parameter Boolean animation=true
        "= true, if animation shall be enabled (show shape between frame_a and frame_b and optionally a sphere at the center of mass)";
      parameter Boolean animateSphere=true
        "= true, if mass shall be animated as sphere provided animation=true";
      parameter Modelica_SIunits.Position r[3](start={0,0,0})
        "Vector from frame_a to frame_b resolved in frame_a";
      parameter Modelica_SIunits.Position r_CM[3](start={0,0,0})
        "Vector from frame_a to center of mass, resolved in frame_a";
      parameter Modelica_SIunits.Mass m(min=0, start=1) "Mass of rigid body";
      parameter Modelica_SIunits.Inertia I_11(min=0) = 0.001
        "(1,1) element of inertia tensor" annotation (Dialog(group=
              "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica_SIunits.Inertia I_22(min=0) = 0.001
        "(2,2) element of inertia tensor" annotation (Dialog(group=
              "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica_SIunits.Inertia I_33(min=0) = 0.001
        "(3,3) element of inertia tensor" annotation (Dialog(group=
              "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica_SIunits.Inertia I_21(min=-Modelica_Constants.inf) = 0
        "(2,1) element of inertia tensor" annotation (Dialog(group=
              "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica_SIunits.Inertia I_31(min=-Modelica_Constants.inf) = 0
        "(3,1) element of inertia tensor" annotation (Dialog(group=
              "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica_SIunits.Inertia I_32(min=-Modelica_Constants.inf) = 0
        "(3,2) element of inertia tensor" annotation (Dialog(group=
              "Inertia tensor (resolved in center of mass, parallel to frame_a)"));

      Modelica_SIunits.Position r_0[3](start={0,0,0}, each stateSelect=if
            enforceStates then StateSelect.always else StateSelect.avoid)
        "Position vector from origin of world frame to origin of frame_a"
        annotation (Dialog(tab="Initialization", showStartAttribute=true));
      Modelica_SIunits.Velocity v_0[3](start={0,0,0}, each stateSelect=if
            enforceStates then StateSelect.always else StateSelect.avoid)
        "Absolute velocity of frame_a, resolved in world frame (= der(r_0))"
        annotation (Dialog(tab="Initialization", showStartAttribute=true));
      Modelica_SIunits.Acceleration a_0[3](start={0,0,0})
        "Absolute acceleration of frame_a resolved in world frame (= der(v_0))"
        annotation (Dialog(tab="Initialization", showStartAttribute=true));

      parameter Boolean angles_fixed=false
        "= true, if angles_start are used as initial values, else as guess values"
        annotation (
        Evaluate=true,
        choices(checkBox=true),
        Dialog(tab="Initialization"));
      parameter Modelica_SIunits.Angle angles_start[3]={0,0,0}
        "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b"
        annotation (Dialog(tab="Initialization"));
      parameter Types.RotationSequence sequence_start={1,2,3}
        "Sequence of rotations to rotate frame_a into frame_b at initial time"
        annotation (Evaluate=true, Dialog(tab="Initialization"));

      parameter Boolean w_0_fixed=false
        "= true, if w_0_start are used as initial values, else as guess values"
        annotation (
        Evaluate=true,
        choices(checkBox=true),
        Dialog(tab="Initialization"));
      parameter Modelica_SIunits.AngularVelocity w_0_start[3]={0,0,0}
        "Initial or guess values of angular velocity of frame_a resolved in world frame"
        annotation (Dialog(tab="Initialization"));

      parameter Boolean z_0_fixed=false
        "= true, if z_0_start are used as initial values, else as guess values"
        annotation (
        Evaluate=true,
        choices(checkBox=true),
        Dialog(tab="Initialization"));
      parameter Modelica_SIunits.AngularAcceleration z_0_start[3]={0,0,0}
        "Initial values of angular acceleration z_0 = der(w_0)"
        annotation (Dialog(tab="Initialization"));

      parameter Types.ShapeType shapeType="cylinder" "Type of shape" annotation (
         Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Position r_shape[3]={0,0,0}
        "Vector from frame_a to shape origin, resolved in frame_a" annotation (
          Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Types.Axis lengthDirection = to_unit1(r - r_shape)
        "Vector in length direction of shape, resolved in frame_a" annotation (
          Evaluate=true, Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Types.Axis widthDirection={0,1,0}
        "Vector in width direction of shape, resolved in frame_a" annotation (
          Evaluate=true, Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Length length=Modelica_Math.Vectors.length(r
           - r_shape) "Length of shape" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance width=length/world.defaultWidthFraction
        "Width of shape" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance height=width "Height of shape"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Types.ShapeExtra extra=0.0
        "Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape)"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color color=Types.Defaults.BodyColor "Color of shape"
                         annotation (Dialog(
          colorSelector=true,
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Diameter sphereDiameter=2*width
        "Diameter of sphere" annotation (Dialog(
          tab="Animation",
          group="if animation = true and animateSphere = true",
          enable=animation and animateSphere));
      input Types.Color sphereColor=color "Color of sphere of mass" annotation (
          Dialog(
          colorSelector=true,
          tab="Animation",
          group="if animation = true and animateSphere = true",
          enable=animation and animateSphere));
      input Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Boolean enforceStates=false
        "= true, if absolute variables of body object shall be used as states (StateSelect.always)"
        annotation (Dialog(tab="Advanced"));
      parameter Boolean useQuaternions=true
        "= true, if quaternions shall be used as potential states otherwise use 3 angles as potential states"
        annotation (Dialog(tab="Advanced"));
      parameter Types.RotationSequence sequence_angleStates={1,2,3}
        "Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states"
        annotation (Evaluate=true, Dialog(tab="Advanced", enable=not
              useQuaternions));

      FixedTranslation frameTranslation(r=r, animation=false) annotation (
          Placement(transformation(extent={{-20,-20},{20,20}}, rotation=0)));
      Body body(
        r_CM=r_CM,
        m=m,
        I_11=I_11,
        I_22=I_22,
        I_33=I_33,
        I_21=I_21,
        I_31=I_31,
        I_32=I_32,
        animation=false,
        sequence_start=sequence_start,
        angles_fixed=angles_fixed,
        angles_start=angles_start,
        w_0_fixed=w_0_fixed,
        w_0_start=w_0_start,
        z_0_fixed=z_0_fixed,
        z_0_start=z_0_start,
        useQuaternions=useQuaternions,
        sequence_angleStates=sequence_angleStates,
        enforceStates=false) annotation (Placement(transformation(extent={{-27.3333,
                -70.3333},{13,-30}}, rotation=0)));
    protected
      outer Modelica_Mechanics_MultiBody.World world;
      Visualizers.Advanced.Shape shape1(
        shapeType=shapeType,
        color=color,
        specularCoefficient=specularCoefficient,
        length=length,
        width=width,
        height=height,
        lengthDirection=lengthDirection,
        widthDirection=widthDirection,
        r_shape=r_shape,
        extra=extra,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;
      Visualizers.Advanced.Shape shape2(
        shapeType="sphere",
        color=sphereColor,
        specularCoefficient=specularCoefficient,
        length=sphereDiameter,
        width=sphereDiameter,
        height=sphereDiameter,
        lengthDirection={1,0,0},
        widthDirection={0,1,0},
        r_shape=r_CM - {1,0,0}*sphereDiameter/2,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation and animateSphere;
    equation
      r_0 = frame_a.r_0;
      v_0 = der(r_0);
      a_0 = der(v_0);
      connect(frame_a, frameTranslation.frame_a) annotation (Line(
          points={{-100,0},{-20,0}},
          color={95,95,95},
          thickness=0.5));
      connect(frame_b, frameTranslation.frame_b) annotation (Line(
          points={{100,0},{20,0}},
          color={95,95,95},
          thickness=0.5));
      connect(frame_a, body.frame_a) annotation (Line(
          points={{-100,0},{-60,0},{-60,-50.1666},{-27.3333,-50.1666}},
          color={95,95,95},
          thickness=0.5));
      annotation (
        Documentation(info="<HTML>
<p>
<b>Rigid body</b> with mass and inertia tensor and <b>two frame connectors</b>.
All parameter vectors have to be resolved in frame_a.
The <b>inertia tensor</b> has to be defined with respect to a
coordinate system that is parallel to frame_a with the
origin at the center of mass of the body. The coordinate system <b>frame_b</b>
is always parallel to <b>frame_a</b>.
</p>
<p>
By default, this component is visualized by any <b>shape</b> that can be
defined with Modelica.Mechanics.MultiBody.Visualizers.FixedShape. This shape is placed
between frame_a and frame_b (default: length(shape) = Frames.length(r)).
Additionally a <b>sphere</b> may be visualized that has
its center at the center of mass.
Note, that
the animation may be switched off via parameter animation = <b>false</b>.
</p>
<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/BodyShape.png\" ALT=\"Parts.BodyShape\">
</p>

<p>
The following shapes can be defined via parameter <b>shapeType</b>,
e.g., shapeType=\"cone\":
</p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/FixedShape.png\" ALT=\"Visualizers.FixedShape\">
<p>
A BodyShape component has potential states. For details of these
states and of the \"Advanced\" menu parameters, see model
<a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.Body\">MultiBody.Parts.Body</a>.
</p>
</html>"),
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Text(
              extent={{-150,110},{150,70}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{-150,-100},{150,-70}},
              lineColor={0,0,0},
              textString="r=%r"),
            Rectangle(
              extent={{-100,31},{101,-30}},
              lineColor={0,24,48},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={0,127,255},
              radius=10),
            Ellipse(
              extent={{-60,60},{60,-60}},
              lineColor={0,24,48},
              fillPattern=FillPattern.Sphere,
              fillColor={0,127,255}),
            Text(
              extent={{-50,24},{55,-27}},
              lineColor={0,0,0},
              textString="%m"),
            Text(
              extent={{55,12},{91,-13}},
              lineColor={0,0,0},
              textString="b"),
            Text(
              extent={{-92,13},{-56,-12}},
              lineColor={0,0,0},
              textString="a")}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{-100,9},{-100,43}}, color={128,128,128}),
            Line(points={{100,0},{100,44}}, color={128,128,128}),
            Line(points={{-100,40},{90,40}}, color={135,135,135}),
            Polygon(
              points={{90,44},{90,36},{100,40},{90,44}},
              lineColor={128,128,128},
              fillColor={128,128,128},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-22,68},{20,40}},
              lineColor={128,128,128},
              textString="r"),
            Line(points={{-100,-10},{-100,-90}}, color={128,128,128}),
            Line(points={{-100,-84},{-10,-84}}, color={128,128,128}),
            Polygon(
              points={{-10,-80},{-10,-88},{0,-84},{-10,-80}},
              lineColor={128,128,128},
              fillColor={128,128,128},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-82,-66},{-56,-84}},
              lineColor={128,128,128},
              textString="r_CM"),
            Line(points={{0,-46},{0,-90}}, color={128,128,128})}));
    end BodyShape;

    model BodyBox
      "Rigid body with box shape. Mass and animation properties are computed from box data and density (12 potential states)"

      import Modelica_Mechanics_MultiBody.Types;
      import Modelica_Math.Vectors.normalizeWithAssert;
      import Modelica_SIunits.Conversions.to_unit1;

      Interfaces.Frame_a frame_a
        "Coordinate system fixed to the component with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
              rotation=0)));
      Interfaces.Frame_b frame_b
        "Coordinate system fixed to the component with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{84,-16},{116,16}}, rotation=
               0)));
      parameter Boolean animation=true
        "= true, if animation shall be enabled (show box between frame_a and frame_b)";
      parameter Modelica_SIunits.Position r[3](start={0.1,0,0})
        "Vector from frame_a to frame_b resolved in frame_a";
      parameter Modelica_SIunits.Position r_shape[3]={0,0,0}
        "Vector from frame_a to box origin, resolved in frame_a";
      parameter Modelica_Mechanics_MultiBody.Types.Axis lengthDirection=to_unit1(
          r - r_shape) "Vector in length direction of box, resolved in frame_a"
        annotation (Evaluate=true);
      parameter Modelica_Mechanics_MultiBody.Types.Axis widthDirection={0,1,0}
        "Vector in width direction of box, resolved in frame_a"
        annotation (Evaluate=true);
      parameter Modelica_SIunits.Length length=Modelica_Math.Vectors.length(r
           - r_shape) "Length of box";
      parameter Modelica_SIunits.Distance width=length/world.defaultWidthFraction
        "Width of box";
      parameter Modelica_SIunits.Distance height=width "Height of box";
      parameter Modelica_SIunits.Distance innerWidth=0
        "Width of inner box surface (0 <= innerWidth <= width)";
      parameter Modelica_SIunits.Distance innerHeight=innerWidth
        "Height of inner box surface (0 <= innerHeight <= height)";
      parameter Modelica_SIunits.Density density=7700
        "Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)";
      input Modelica_Mechanics_MultiBody.Types.Color color=Types.Defaults.BodyColor
        "Color of box" annotation (Dialog(colorSelector=true, enable=animation));
      input Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(enable=animation));

      Modelica_SIunits.Position r_0[3](start={0,0,0}, each stateSelect=if
            enforceStates then StateSelect.always else StateSelect.avoid)
        "Position vector from origin of world frame to origin of frame_a"
        annotation (Dialog(tab="Initialization", showStartAttribute=true));
      Modelica_SIunits.Velocity v_0[3](start={0,0,0}, each stateSelect=if
            enforceStates then StateSelect.always else StateSelect.avoid)
        "Absolute velocity of frame_a, resolved in world frame (= der(r_0))"
        annotation (Dialog(tab="Initialization", showStartAttribute=true));
      Modelica_SIunits.Acceleration a_0[3](start={0,0,0})
        "Absolute acceleration of frame_a resolved in world frame (= der(v_0))"
        annotation (Dialog(tab="Initialization", showStartAttribute=true));

      parameter Boolean angles_fixed=false
        "= true, if angles_start are used as initial values, else as guess values"
        annotation (
        Evaluate=true,
        choices(checkBox=true),
        Dialog(tab="Initialization"));
      parameter Modelica_SIunits.Angle angles_start[3]={0,0,0}
        "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b"
        annotation (Dialog(tab="Initialization"));
      parameter Types.RotationSequence sequence_start={1,2,3}
        "Sequence of rotations to rotate frame_a into frame_b at initial time"
        annotation (Evaluate=true, Dialog(tab="Initialization"));

      parameter Boolean w_0_fixed=false
        "= true, if w_0_start are used as initial values, else as guess values"
        annotation (
        Evaluate=true,
        choices(checkBox=true),
        Dialog(tab="Initialization"));
      parameter Modelica_SIunits.AngularVelocity w_0_start[3]={0,0,0}
        "Initial or guess values of angular velocity of frame_a resolved in world frame"
        annotation (Dialog(tab="Initialization"));

      parameter Boolean z_0_fixed=false
        "= true, if z_0_start are used as initial values, else as guess values"
        annotation (
        Evaluate=true,
        choices(checkBox=true),
        Dialog(tab="Initialization"));
      parameter Modelica_SIunits.AngularAcceleration z_0_start[3]={0,0,0}
        "Initial values of angular acceleration z_0 = der(w_0)"
        annotation (Dialog(tab="Initialization"));

      parameter Boolean enforceStates=false
        "= true, if absolute variables of body object shall be used as states (StateSelect.always)"
        annotation (Dialog(tab="Advanced"));
      parameter Boolean useQuaternions=true
        "= true, if quaternions shall be used as potential states otherwise use 3 angles as potential states"
        annotation (Dialog(tab="Advanced"));
      parameter Types.RotationSequence sequence_angleStates={1,2,3}
        "Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states"
        annotation (Evaluate=true, Dialog(tab="Advanced", enable=not
              useQuaternions));

      final parameter Modelica_SIunits.Mass mo(min=0) = density*length*width*
        height "Mass of box without hole";
      final parameter Modelica_SIunits.Mass mi(min=0) = density*length*
        innerWidth*innerHeight "Mass of hole of box";
      final parameter Modelica_SIunits.Mass m(min=0) = mo - mi "Mass of box";
      final parameter Frames.Orientation R=Frames.from_nxy(r, widthDirection)
        "Orientation object from frame_a to coordinates system spanned by r and widthDirection";
      final parameter Modelica_SIunits.Position r_CM[3]=r_shape +
          normalizeWithAssert(lengthDirection)*length/2
        "Position vector from origin of frame_a to center of mass, resolved in frame_a";
      final parameter Modelica_SIunits.Inertia I[3,3]=Frames.resolveDyade1(R,
          diagonal({mo*(width*width + height*height) - mi*(innerWidth*
          innerWidth + innerHeight*innerHeight),mo*(length*length + height*
          height) - mi*(length*length + innerHeight*innerHeight),mo*(length*
          length + width*width) - mi*(length*length + innerWidth*innerWidth)}/
          12))
        "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
      Body body(
        animation=false,
        r_CM=r_CM,
        m=m,
        I_11=I[1, 1],
        I_22=I[2, 2],
        I_33=I[3, 3],
        I_21=I[2, 1],
        I_31=I[3, 1],
        I_32=I[3, 2],
        sequence_start=sequence_start,
        angles_fixed=angles_fixed,
        angles_start=angles_start,
        w_0_fixed=w_0_fixed,
        w_0_start=w_0_start,
        z_0_fixed=z_0_fixed,
        z_0_start=z_0_start,
        useQuaternions=useQuaternions,
        sequence_angleStates=sequence_angleStates,
        enforceStates=false) annotation (Placement(transformation(extent={{-30,-80},
                {10,-40}}, rotation=0)));
      FixedTranslation frameTranslation(
        r=r,
        animation=animation,
        shapeType="box",
        r_shape=r_shape,
        lengthDirection=lengthDirection,
        widthDirection=widthDirection,
        length=length,
        width=width,
        height=height,
        color=color,
        specularCoefficient=specularCoefficient) annotation (Placement(
            transformation(extent={{-30,-20},{10,20}}, rotation=0)));

    protected
      outer Modelica_Mechanics_MultiBody.World world;
    equation
      r_0 = frame_a.r_0;
      v_0 = der(r_0);
      a_0 = der(v_0);

      assert(innerWidth <= width,
        "parameter innerWidth is greater than parameter width");
      assert(innerHeight <= height,
        "parameter innerHeight is greater than parameter height");
      connect(frameTranslation.frame_a, frame_a) annotation (Line(
          points={{-30,0},{-100,0}},
          color={95,95,95},
          thickness=0.5));
      connect(frameTranslation.frame_b, frame_b) annotation (Line(
          points={{10,0},{100,0}},
          color={95,95,95},
          thickness=0.5));
      connect(frame_a, body.frame_a) annotation (Line(
          points={{-100,0},{-70,0},{-70,-60},{-30,-60}},
          color={95,95,95},
          thickness=0.5));
      annotation (Documentation(info="<HTML>
<p>
<b>Rigid body</b> with <b>box</b> shape.
The mass properties of the body (mass, center of mass,
inertia tensor) are computed
from the box data. Optionally, the box may be hollow.
The (outer) box shape is by default used in the animation.
The hollow part is not shown in the animation.
The two connector frames <b>frame_a</b> and <b>frame_b</b>
are always parallel to each other. Example of component
animation (note, that
the animation may be switched off via parameter animation = <b>false</b>):
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/BodyBox.png\" ALT=\"Parts.BodyBox\">
</p>

<p>
A BodyBox component has potential states. For details of these
states and of the \"Advanced\" menu parameters, see model
<a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.Body\">MultiBody.Parts.Body</a>.</p>
</html>"),   Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Polygon(
              points={{100,40},{100,-30},{90,-40},{90,30},{100,40}},
              lineColor={0,95,191},
              fillColor={0,95,191},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-100,30},{90,-40}},
              lineColor={0,127,255},
              pattern=LinePattern.None,
              fillColor={0,127,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-100,30},{-90,40},{100,40},{90,30},{-100,30}},
              lineColor={0,95,191},
              fillColor={0,95,191},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,90},{150,50}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{150,-80},{-150,-50}},
              lineColor={0,0,0},
              textString="r=%r"),
            Text(
              extent={{52,8},{88,-17}},
              lineColor={0,0,0},
              textString="b"),
            Text(
              extent={{-87,12},{-51,-13}},
              lineColor={0,0,0},
              textString="a")}));
    end BodyBox;

    model BodyCylinder
      "Rigid body with cylinder shape. Mass and animation properties are computed from cylinder data and density (12 potential states)"

      import NonSI = Modelica_SIunits.Conversions.NonSIunits;
      import Modelica_Mechanics_MultiBody.Types;
      import Modelica_Math.Vectors.normalizeWithAssert;
      import Modelica_SIunits.Conversions.to_unit1;

      Interfaces.Frame_a frame_a
        "Coordinate system fixed to the component with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
              rotation=0)));
      Interfaces.Frame_b frame_b
        "Coordinate system fixed to the component with one cut-force and cut-torque"
        annotation (Placement(transformation(extent={{84,-16},{116,16}}, rotation=
               0)));
      parameter Boolean animation=true
        "= true, if animation shall be enabled (show cylinder between frame_a and frame_b)";
      parameter Modelica_SIunits.Position r[3](start={0.1,0,0})
        "Vector from frame_a to frame_b, resolved in frame_a";
      parameter Modelica_SIunits.Position r_shape[3]={0,0,0}
        "Vector from frame_a to cylinder origin, resolved in frame_a";
      parameter Modelica_Mechanics_MultiBody.Types.Axis lengthDirection=to_unit1(
          r - r_shape)
        "Vector in length direction of cylinder, resolved in frame_a"
        annotation (Evaluate=true);
      parameter Modelica_SIunits.Length length=Modelica_Math.Vectors.length(r
           - r_shape) "Length of cylinder";
      parameter Modelica_SIunits.Distance diameter=length/world.defaultWidthFraction
        "Diameter of cylinder";
      parameter Modelica_SIunits.Distance innerDiameter=0
        "Inner diameter of cylinder (0 <= innerDiameter <= Diameter)";
      parameter Modelica_SIunits.Density density=7700
        "Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)";
      input Modelica_Mechanics_MultiBody.Types.Color color=Types.Defaults.BodyColor
        "Color of cylinder"
        annotation (Dialog(colorSelector=true, enable=animation));
      input Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(enable=animation));

      Modelica_SIunits.Position r_0[3](start={0,0,0}, each stateSelect=if
            enforceStates then StateSelect.always else StateSelect.avoid)
        "Position vector from origin of world frame to origin of frame_a"
        annotation (Dialog(tab="Initialization", showStartAttribute=true));
      Modelica_SIunits.Velocity v_0[3](start={0,0,0}, each stateSelect=if
            enforceStates then StateSelect.always else StateSelect.avoid)
        "Absolute velocity of frame_a, resolved in world frame (= der(r_0))"
        annotation (Dialog(tab="Initialization", showStartAttribute=true));
      Modelica_SIunits.Acceleration a_0[3](start={0,0,0})
        "Absolute acceleration of frame_a resolved in world frame (= der(v_0))"
        annotation (Dialog(tab="Initialization", showStartAttribute=true));

      parameter Boolean angles_fixed=false
        "= true, if angles_start are used as initial values, else as guess values"
        annotation (
        Evaluate=true,
        choices(checkBox=true),
        Dialog(tab="Initialization"));
      parameter Modelica_SIunits.Angle angles_start[3]={0,0,0}
        "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b"
        annotation (Dialog(tab="Initialization"));
      parameter Types.RotationSequence sequence_start={1,2,3}
        "Sequence of rotations to rotate frame_a into frame_b at initial time"
        annotation (Evaluate=true, Dialog(tab="Initialization"));

      parameter Boolean w_0_fixed=false
        "= true, if w_0_start are used as initial values, else as guess values"
        annotation (
        Evaluate=true,
        choices(checkBox=true),
        Dialog(tab="Initialization"));
      parameter Modelica_SIunits.AngularVelocity w_0_start[3]={0,0,0}
        "Initial or guess values of angular velocity of frame_a resolved in world frame"
        annotation (Dialog(tab="Initialization"));

      parameter Boolean z_0_fixed=false
        "= true, if z_0_start are used as initial values, else as guess values"
        annotation (
        Evaluate=true,
        choices(checkBox=true),
        Dialog(tab="Initialization"));
      parameter Modelica_SIunits.AngularAcceleration z_0_start[3]={0,0,0}
        "Initial values of angular acceleration z_0 = der(w_0)"
        annotation (Dialog(tab="Initialization"));

      parameter Boolean enforceStates=false
        "= true, if absolute variables of body object shall be used as states (StateSelect.always)"
        annotation (Dialog(tab="Advanced"));
      parameter Boolean useQuaternions=true
        "= true, if quaternions shall be used as potential states otherwise use 3 angles as potential states"
        annotation (Dialog(tab="Advanced"));
      parameter Types.RotationSequence sequence_angleStates={1,2,3}
        "Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states"
        annotation (Evaluate=true, Dialog(tab="Advanced", enable=not
              useQuaternions));

      constant Real pi=Modelica_Constants.pi;
      final parameter Modelica_SIunits.Distance radius=diameter/2
        "Radius of cylinder";
      final parameter Modelica_SIunits.Distance innerRadius=innerDiameter/2
        "Inner-Radius of cylinder";
      final parameter Modelica_SIunits.Mass mo(min=0) = density*pi*length*
        radius*radius "Mass of cylinder without hole";
      final parameter Modelica_SIunits.Mass mi(min=0) = density*pi*length*
        innerRadius*innerRadius "Mass of hole of cylinder";
      final parameter Modelica_SIunits.Inertia I22=(mo*(length*length + 3*
          radius*radius) - mi*(length*length + 3*innerRadius*innerRadius))/12
        "Inertia with respect to axis through center of mass, perpendicular to cylinder axis";
      final parameter Modelica_SIunits.Mass m(min=0) = mo - mi
        "Mass of cylinder";
      final parameter Frames.Orientation R=Frames.from_nxy(r, {0,1,0})
        "Orientation object from frame_a to frame spanned by cylinder axis and axis perpendicular to cylinder axis";
      final parameter Modelica_SIunits.Position r_CM[3]=r_shape +
          normalizeWithAssert(lengthDirection)*length/2
        "Position vector from frame_a to center of mass, resolved in frame_a";
      final parameter Modelica_SIunits.Inertia I[3,3]=Frames.resolveDyade1(R,
          diagonal({(mo*radius*radius - mi*innerRadius*innerRadius)/2,I22,I22}))
        "Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a";

      Body body(
        r_CM=r_CM,
        m=m,
        I_11=I[1, 1],
        I_22=I[2, 2],
        I_33=I[3, 3],
        I_21=I[2, 1],
        I_31=I[3, 1],
        I_32=I[3, 2],
        animation=false,
        sequence_start=sequence_start,
        angles_fixed=angles_fixed,
        angles_start=angles_start,
        w_0_fixed=w_0_fixed,
        w_0_start=w_0_start,
        z_0_fixed=z_0_fixed,
        z_0_start=z_0_start,
        useQuaternions=useQuaternions,
        sequence_angleStates=sequence_angleStates,
        enforceStates=false) annotation (Placement(transformation(extent={{-30,-80},
                {10,-40}}, rotation=0)));
      FixedTranslation frameTranslation(
        r=r,
        animation=animation,
        shapeType="pipecylinder",
        r_shape=r_shape,
        lengthDirection=lengthDirection,
        length=length,
        width=diameter,
        height=diameter,
        extra=innerDiameter/diameter,
        color=color,
        specularCoefficient=specularCoefficient,
        widthDirection={0,1,0}) annotation (Placement(transformation(extent={{-30,
                -20},{10,20}}, rotation=0)));

    protected
      outer Modelica_Mechanics_MultiBody.World world;
    equation
      r_0 = frame_a.r_0;
      v_0 = der(r_0);
      a_0 = der(v_0);

      assert(innerDiameter < diameter,
        "parameter innerDiameter is greater than parameter diameter");
      connect(frameTranslation.frame_a, frame_a) annotation (Line(
          points={{-30,0},{-100,0}},
          color={95,95,95},
          thickness=0.5));
      connect(frameTranslation.frame_b, frame_b) annotation (Line(
          points={{10,0},{100,0}},
          color={95,95,95},
          thickness=0.5));
      connect(frame_a, body.frame_a) annotation (Line(
          points={{-100,0},{-70,0},{-70,-60},{-30,-60}},
          color={95,95,95},
          thickness=0.5));
      annotation (Documentation(info="<HTML>
<p>
<b>Rigid body</b> with <b>cylinder</b> shape.
The mass properties of the body (mass, center of mass,
inertia tensor) are computed
from the cylinder data. Optionally, the cylinder may be hollow.
The cylinder shape is by default used in the animation.
The two connector frames <b>frame_a</b> and <b>frame_b</b>
are always parallel to each other. Example of component
animation (note, that
the animation may be switched off via parameter animation = <b>false</b>):
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/BodyCylinder.png\" ALT=\"Parts.BodyCylinder\">
</p>

<p>
A BodyCylinder component has potential states. For details of these
states and of the \"Advanced\" menu parameters, see model
<a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.Body\">MultiBody.Parts.Body</a>.</html>"),
          Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Text(
              extent={{-150,90},{150,50}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{150,-80},{-150,-50}},
              lineColor={0,0,0},
              textString="r=%r"),
            Rectangle(
              extent={{-100,40},{100,-40}},
              lineColor={0,24,48},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={0,127,255},
              radius=10),
            Text(
              extent={{-87,13},{-51,-12}},
              lineColor={0,0,0},
              textString="a"),
            Text(
              extent={{51,12},{87,-13}},
              lineColor={0,0,0},
              textString="b")}));
    end BodyCylinder;

    model PointMass
      "Rigid body where body rotation and inertia tensor is neglected (6 potential states)"

      import Modelica_Mechanics_MultiBody.Types;
      Interfaces.Frame_a frame_a
        "Coordinate system fixed at center of mass point" annotation (Placement(
            transformation(extent={{-16,-16},{16,16}}, rotation=0)));
      parameter Boolean animation=true
        "= true, if animation shall be enabled (show sphere)";
      parameter Modelica_SIunits.Mass m(min=0) "Mass of mass point";
      input Modelica_SIunits.Diameter sphereDiameter=world.defaultBodyDiameter
        "Diameter of sphere" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color sphereColor=Types.Defaults.BodyColor "Color of sphere"
                          annotation (Dialog(
          colorSelector=true,
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter StateSelect stateSelect=StateSelect.avoid
        "Priority to use frame_a.r_0, v_0 (= der(frame_a.r_0)) as states"
        annotation (Dialog(tab="Advanced"));

      Modelica_SIunits.Position r_0[3](start={0,0,0}, each stateSelect=
            stateSelect)
        "Position vector from origin of world frame to origin of frame_a, resolved in world frame"
        annotation (Dialog(group="Initialization", showStartAttribute=true));
      Modelica_SIunits.Velocity v_0[3](start={0,0,0}, each stateSelect=
            stateSelect)
        "Absolute velocity of frame_a, resolved in world frame (= der(r_0))"
        annotation (Dialog(group="Initialization", showStartAttribute=true));
      Modelica_SIunits.Acceleration a_0[3](start={0,0,0})
        "Absolute acceleration of frame_a resolved in world frame (= der(v_0))"
        annotation (Dialog(group="Initialization", showStartAttribute=true));

    protected
      outer Modelica_Mechanics_MultiBody.World world;

      // Declarations for animation
      Visualizers.Advanced.Shape sphere(
        shapeType="sphere",
        color=sphereColor,
        specularCoefficient=specularCoefficient,
        length=sphereDiameter,
        width=sphereDiameter,
        height=sphereDiameter,
        lengthDirection={1,0,0},
        widthDirection={0,1,0},
        r_shape=-{1,0,0}*sphereDiameter/2,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;
    equation
      // If any possible, do not use the connector as root
      Connections.potentialRoot(frame_a.R, 10000);

      if Connections.isRoot(frame_a.R) then
        assert(cardinality(frame_a) == 0, "
A Modelica.Mechanics.MultiBody.Parts.PointMass model is connected in
a way, so that no equations are present to compute frame_a.R
(the orientation object in the connector). Setting frame_a.R to
an arbitrary value in the PointMass model, might lead to a wrong
overall model, depending on how the PointMass model is used.
   You can avoid this message, by providing equations that
compute the orientation object, e.g., by using the
Modelica.Mechanics.MultiBody.Joints.FreeMotion joint.
   If a PointMass model is not connected at all, the
orientation object is set to a unit rotation. But this is
the only case where this is done.
");     frame_a.R = Frames.nullRotation();
      else
        frame_a.t = zeros(3);
      end if;

      // Newton equation: f = m*(a-g)
      r_0 = frame_a.r_0;
      v_0 = der(r_0);
      a_0 = der(v_0);
      frame_a.f = m*Frames.resolve2(frame_a.R, a_0 - world.gravityAcceleration(
        r_0));
      annotation (Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Text(
              extent={{150,-90},{-150,-60}},
              lineColor={0,0,0},
              textString="m=%m"),
            Text(
              extent={{-150,100},{150,60}},
              textString="%name",
              lineColor={0,0,255}),
            Ellipse(
              extent={{-50,50},{50,-50}},
              lineColor={0,24,48},
              fillPattern=FillPattern.Sphere,
              fillColor={0,127,255})}), Documentation(info="<HTML>
<p>
<b>Rigid body</b> where the inertia tensor is neglected.
This body is
solely defined by its mass.
By default, this component is visualized by a <b>sphere</b> that has
its center at frame_a. Note, that
the animation may be switched off via parameter animation = <b>false</b>.
</p>

<p>
Every PointMass has potential states. If possible a tool will select
the states of joints and not the states of PointMass because this is
usually the most efficient choice. In this case the position and
velocity of frame_a of the body will be computed
by the component that is connected to frame_a. However, if a PointMass is moving
freely in space, variables of the PointMass have to be used as states. The potential
states are: The <b>position vector</b> frame_a.r_0 from the origin of the
world frame to the origin of frame_a of the body, resolved in
the world frame and the <b>absolute velocity</b> v_0 of the origin of
frame_a, resolved in the world frame (= der(frame_a.r_0)).
</p>

<p>
Whether or not variables of the body are used as states is usually
automatically selected by the Modelica translator. If parameter
<b>enforceStates</b> is set to <b>true</b> in the \"Advanced\" menu,
then PointMass variables frame_a.r_0 and der(frame_a.r_0)
are forced to be used as states.
</p>
</HTML>"));
    end PointMass;

    model Mounting1D
      "Propagate 1-dim. support torque to 3-dim. system (provided world.driveTrainMechanics3D=true)"
      parameter Modelica_SIunits.Angle phi0=0 "Fixed offset angle of housing";
      parameter Modelica_Mechanics_MultiBody.Types.Axis n={1,0,0}
        "Axis of rotation = axis of support torque (resolved in frame_a)";

      Modelica_Mechanics_Rotational.Interfaces.Flange_b flange_b
        "(right) flange fixed in housing" annotation (Placement(transformation(
              extent={{110,10},{90,-10}}, rotation=0)));
      Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a if world.driveTrainMechanics3D
        "Frame in which housing is fixed (connector is removed, if world.driveTrainMechanics3D=false)"
        annotation (Placement(transformation(
            origin={0,-100},
            extent={{-20,-20},{20,20}},
            rotation=90)));
    protected
      outer Modelica_Mechanics_MultiBody.World world;

      encapsulated model Housing
        import Modelica =
               M_S_L;
        import Modelica_SIunits;
        import M_S_L;
        input Modelica_SIunits.Torque t[3];
        M_S_L.Mechanics.MultiBody.Interfaces.Frame_a frame_a annotation (
            Placement(transformation(extent={{-116,-16},{-84,16}}, rotation=0)));
      equation
        frame_a.f = zeros(3);
        frame_a.t = t;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Text(
                    extent={{-150,110},{150,150}},
                    lineColor={0,0,255},
                    textString="%name")}));
      end Housing;
      Housing housing(t=-n*flange_b.tau) if world.driveTrainMechanics3D
        annotation (Placement(transformation(extent={{20,-60},{40,-40}}, rotation=
               0)));
    equation
      flange_b.phi = phi0;
      connect(housing.frame_a, frame_a) annotation (Line(
          points={{20,-50},{0,-50},{0,-100}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                {100,100}}), graphics={
            Rectangle(
              extent={{-80,-60},{80,-100}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,60},{150,20}},
              lineColor={0,0,255},
              textString="%name"),
            Line(points={{80,-60},{40,-100}}, color={0,0,0}),
            Line(points={{40,-60},{0,-100}}, color={0,0,0}),
            Line(points={{0,-60},{-40,-100}}, color={0,0,0}),
            Line(points={{-40,-60},{-80,-100}}, color={0,0,0}),
            Line(points={{0,-60},{0,0}}, color={0,0,0}),
            Line(points={{0,0},{90,0}}, color={0,0,0})}), Documentation(info="<html>
<p>This component is used to acquire support torques from a 1-dim.-rotational
mechanical system (e.g., components from Modelica.Mechanics.Rotational)
and to propagate them to a carrier body.</p>
<p>The 1-dim. support torque at <code>flange_b</code> is transformed into 3-dim. space under
consideration of the rotation axis, parameter <code>n</code>, which has to be given in the
local coordinate system of <code>frame_a</code>.</p>
<p>All components of a 1-dim.-rotational mechanical system that are connected to <b>a</b> common
<b>Mounting1D</b> element need to have the same axis of rotation
along parameter vector <code>n</code>. This means that, e.g., bevel
gears where the axis of rotation of <code>flange_a</code> and
<code>flange_b</code> are different cannot be described properly by
connecting to the <b>Mounting1D</b> component. In this case, a combination of several
<b>Mounting1D</b> components or the component <b>BevelGear1D</b> should be used.</p>
<p><b>Reference</b><br>
<span style=\"font-variant:small-caps\">Schweiger</span>, Christian ;
<span style=\"font-variant:small-caps\">Otter</span>, Martin:
<a href=\"https://www.modelica.org/events/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf\">Modelling
3D Mechanical Effects of 1-dim. Powertrains</a>. In: <i>Proceedings of the 3rd International
Modelica Conference</i>. Link&ouml;ping : The Modelica Association and Link&ouml;ping University,
November 3-4, 2003, pp. 149-158</p>
</html>"));
    end Mounting1D;

    model Rotor1D
      "1D inertia attachable on 3-dim. bodies (3D dynamic effects are taken into account if world.driveTrainMechanics3D=true)"

      parameter Boolean animation=true
        "= true, if animation shall be enabled (show rotor as cylinder)";
      parameter Modelica_SIunits.Inertia J(min=0, start=1)
        "Moment of inertia of rotor around its axis of rotation";
      parameter Modelica_Mechanics_MultiBody.Types.Axis n={1,0,0}
        "Axis of rotation resolved in frame_a";
      parameter Modelica_SIunits.Position r_center[3]=zeros(3)
        "Position vector from origin of frame_a to center of cylinder"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance cylinderLength=2*world.defaultJointLength
        "Length of cylinder representing the rotor" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_SIunits.Distance cylinderDiameter=2*world.defaultJointWidth
        "Diameter of cylinder representing the rotor" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Modelica_Mechanics_MultiBody.Types.Color cylinderColor=Types.Defaults.RodColor
        "Color of cylinder representing the rotor" annotation (Dialog(
          colorSelector=true,
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Modelica_Mechanics_MultiBody.Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter StateSelect stateSelect=StateSelect.default
        "Priority to use rotor angle (phi) and rotor speed (w) as states"
        annotation (Dialog(tab="Advanced"));
      parameter Boolean exact=true
        "= true, if exact calculations; false if influence of bearing on rotor acceleration is neglected to avoid an algebraic loop"
        annotation (Dialog(tab="Advanced"));

      Modelica_SIunits.Angle phi(start=0, stateSelect=stateSelect)
        "Rotation angle of rotor with respect to frame_a (= flange_a.phi = flange_b.phi)";
      Modelica_SIunits.AngularVelocity w(start=0, stateSelect=stateSelect)
        "Angular velocity of rotor with respect to frame_a";
      Modelica_SIunits.AngularAcceleration a(start=0)
        "Angular acceleration of rotor with respect to frame_a";

      Modelica_Mechanics_Rotational.Interfaces.Flange_a flange_a
        "(left) driving flange (flange axis directed INTO cut plane)" annotation (
         Placement(transformation(extent={{-110,-10},{-90,10}}, rotation=0)));
      Modelica_Mechanics_Rotational.Interfaces.Flange_b flange_b
        "(right) driven flange (flange axis directed OUT OF cut plane)"
        annotation (Placement(transformation(extent={{90,-10},{110,10}}, rotation=
               0)));
      Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a if world.driveTrainMechanics3D
        "Frame in which rotor housing is fixed (connector is removed, if world.driveTrainMechanics3D=false)"
        annotation (Placement(transformation(
            origin={0,-100},
            extent={{-20,-20},{20,20}},
            rotation=90)));

      encapsulated model RotorWith3DEffects
        "1D inertia attachable on 3-dim. bodies (3D dynamic effects are taken into account)"
        import Modelica_SIunits;
        import Modelica_Math;
        import Modelica_Mechanics_Rotational;
        import M_S_L;

        import Modelica =
               M_S_L;
        import Modelica_Mechanics_MultiBody.Frames;
        import Modelica_Mechanics_MultiBody.Types;
        import SI = Modelica_SIunits;
        import Cv = Modelica_SIunits.Conversions;

        parameter Boolean animation=true
          "= true, if animation shall be enabled (show rotor as cylinder)";
        parameter Modelica_SIunits.Inertia J(min=0) = 1
          "Moment of inertia of rotor around its axis of rotation";
        parameter Types.Axis n={1,0,0} "Axis of rotation resolved in frame_a";
        parameter Modelica_SIunits.Position r_center[3]=zeros(3)
          "Position vector from origin of frame_a to center of cylinder"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter Modelica_SIunits.Distance cylinderLength=2*world.defaultJointLength
          "Length of cylinder representing the rotor" annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter Modelica_SIunits.Distance cylinderDiameter=2*world.defaultJointWidth
          "Diameter of cylinder representing the rotor" annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.Color cylinderColor=M_S_L.Mechanics.MultiBody.Types.Defaults.RodColor
          "Color of cylinder representing the rotor" annotation (Dialog(
            colorSelector=true,
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter StateSelect stateSelect=StateSelect.default
          "Priority to use rotor angle (phi) and rotor speed (w) as states"
          annotation (Dialog(tab="Advanced"));
        parameter Boolean exact=true
          "= true, if exact calculations; false if influence of bearing on rotor acceleration is neglected to avoid an algebraic loop"
          annotation (Dialog(tab="Advanced"));

        Modelica_SIunits.AngularVelocity w_a[3]
          "Angular velocity of frame_a, resolved in frame_a";
        Modelica_SIunits.Angle phi(start=0, final stateSelect=stateSelect)
          "Rotation angle of rotor with respect to frame_a (= flange_a.phi = flange_b.phi)"
          annotation (Dialog(showStartAttribute=true));

        Modelica_SIunits.AngularVelocity w(start=0, stateSelect=stateSelect)
          "Angular velocity of rotor with respect to frame_a"
          annotation (Dialog(showStartAttribute=true));
        Modelica_SIunits.AngularAcceleration a(start=0)
          "Angular acceleration of rotor with respect to frame_a"
          annotation (Dialog(showStartAttribute=true));

        Modelica_Mechanics_Rotational.Interfaces.Flange_a flange_a
          "(left) driving flange (flange axis directed INTO cut plane)"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}},
                rotation=0)));
        Modelica_Mechanics_Rotational.Interfaces.Flange_b flange_b
          "(right) driven flange (flange axis directed OUT OF cut plane)"
          annotation (Placement(transformation(extent={{90,-10},{110,10}},
                rotation=0)));
        M_S_L.Mechanics.MultiBody.Interfaces.Frame_a frame_a
          "Frame in which rotor housing is fixed" annotation (Placement(
              transformation(
              origin={0,-100},
              extent={{-20,-20},{20,20}},
              rotation=90)));

      protected
        outer M_S_L.Mechanics.MultiBody.World world;
        parameter Real e[3](each final unit="1")=
          Modelica_Math.Vectors.normalizeWithAssert(n)
          "Unit vector in direction of rotor axis, resolved in frame_a";
        parameter Modelica_SIunits.Inertia nJ[3]=J*e;
        M_S_L.Mechanics.MultiBody.Visualizers.Advanced.Shape cylinder(
          shapeType="cylinder",
          color=cylinderColor,
          specularCoefficient=specularCoefficient,
          length=cylinderLength,
          width=cylinderDiameter,
          height=cylinderDiameter,
          lengthDirection=n,
          widthDirection={0,1,0},
          extra=1,
          r_shape=r_center - e*(cylinderLength/2),
          r=frame_a.r_0,
          R=Frames.absoluteRotation(frame_a.R, Frames.planarRotation(
                    e,
                    phi,
                    0))) if
                          world.enableAnimation and animation;
      equation
        phi = flange_a.phi;
        phi = flange_b.phi;
        w = der(phi);
        a = der(w);

        w_a =M_S_L.Mechanics.MultiBody.Frames.angularVelocity2(frame_a.R);
        if exact then
          J*a = flange_a.tau + flange_b.tau - nJ*der(w_a);
        else
          J*a = flange_a.tau + flange_b.tau;
        end if;

        /* Reaction torque:
        t = n*(J*a - flange_a.tau - flange_b.tau) + cross(w_a, nJ*w)

     Since
        J*a = flange_a.tau + flange_b.tau - nJ*der(w_a);

     the reaction torque can be simplified to
        t = n*(- nJ*der(w_a)) + cross(w_a, nJ*w)

  */
        frame_a.f = zeros(3);
        frame_a.t = cross(w_a, nJ*w) - e*(nJ*der(w_a));
        annotation (Documentation(info="<html>
<p>
This component is used to model the gyroscopic torques exerted by a 1-dim.
inertia (so called <i>rotor</i>) on its 3-dim. carrier body. Gyroscopic torques
appear, if the vector of the carrier body's angular velocity is not parallel
to the vector of the rotor's axis. The axis of rotation of the rotor is defined by
the parameter <code>n</code>, which has to be given in the local coordinate system
of <code>frame_a</code>. The default animation of this component is
shown in the figure below.</p>

<p>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Parts/Rotor1D.png\" ALT=\"model Parts.Rotor1D\">
</p>

<p>This component is a replacement for
<a href=\"modelica://Modelica.Mechanics.Rotational.Components.Inertia\">Modelica.Mechanics.Rotational.Components.Inertia</a>
for the case, that a 1-dim.-rotational mechanical system should be attached with a 3-dim.
carrier body.</p>
<p>The Boolean parameter <code>exact</code> was introduced due to performance
reasons. If <code>exact</code> is set to <b>false</b>, the influence of the carrier body
motion on the angular velocity of the rotor is neglected. This influence is usually
negligible if the 1-dim.-rotational mechanical system accelerates much faster as the base body (this is,
e.g., the case in vehicle powertrains). The essential advantage is
that an algebraic loop is removed since then there is only an
action on acceleration level from the powertrain to the base body
but not vice versa.</p>
<p><b>Reference</b><br>
<span style=\"font-variant:small-caps\">Schweiger</span>, Christian ;
<span style=\"font-variant:small-caps\">Otter</span>, Martin:
<a href=\"https://www.modelica.org/events/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf\">Modelling
3D Mechanical Effects of 1-dim. Powertrains</a>. In: <i>Proceedings of the 3rd International
Modelica Conference</i>. Link&ouml;ping : The Modelica Association and Link&ouml;ping University,
November 3-4, 2003, pp. 149-158</p>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Line(points={{-80,-25},{-60,-25}}, color={0,0,0}),
              Line(points={{60,-25},{80,-25}}, color={0,0,0}),
              Line(points={{-70,-25},{-70,-70}}, color={0,0,0}),
              Line(points={{70,-25},{70,-70}}, color={0,0,0}),
              Line(points={{-80,25},{-60,25}}, color={0,0,0}),
              Line(points={{60,25},{80,25}}, color={0,0,0}),
              Line(points={{-70,45},{-70,25}}, color={0,0,0}),
              Line(points={{70,45},{70,25}}, color={0,0,0}),
              Line(points={{-70,-70},{70,-70}}, color={0,0,0}),
              Rectangle(
                extent={{-50,50},{50,-50}},
                lineColor={64,64,64},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={255,255,255},
                radius=10),
              Rectangle(
                extent={{-50,50},{50,-50}},
                lineColor={64,64,64},
                fillPattern=FillPattern.None,
                radius=10),
              Rectangle(
                extent={{-100,10},{-50,-10}},
                lineColor={64,64,64},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{50,10},{100,-10}},
                lineColor={64,64,64},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Text(
                extent={{-148,112},{152,72}},
                textString="%name=%J",
                lineColor={0,0,255}),
              Line(points={{0,-70},{0,-100}}, color={0,0,0})}));
      end RotorWith3DEffects;

    protected
      outer Modelica_Mechanics_MultiBody.World world;
      parameter Real e[3](each final unit="1")=
        Modelica_Math.Vectors.normalizeWithAssert(n)
        "Unit vector in direction of rotor axis, resolved in frame_a";
      Modelica_Mechanics_MultiBody.Visualizers.Advanced.Shape cylinder(
        shapeType="cylinder",
        color=cylinderColor,
        specularCoefficient=specularCoefficient,
        length=cylinderLength,
        width=cylinderDiameter,
        height=cylinderDiameter,
        lengthDirection=n,
        widthDirection={0,1,0},
        extra=1,
        r_shape=r_center - e*(cylinderLength/2),
        r=zeros(3),
        R=Frames.planarRotation(
                e,
                phi,
                0)) if world.enableAnimation and animation and not world.driveTrainMechanics3D;

      Modelica_Mechanics_Rotational.Components.Inertia inertia(J=J, stateSelect=
            StateSelect.never) if not world.driveTrainMechanics3D annotation (
          Placement(transformation(extent={{-20,-20},{20,20}}, rotation=0)));
      RotorWith3DEffects rotorWith3DEffects(
        animation=animation,
        J=J,
        n=n,
        r_center=r_center,
        cylinderLength=cylinderLength,
        cylinderDiameter=cylinderDiameter,
        cylinderColor=cylinderColor,
        specularCoefficient=specularCoefficient,
        exact=exact,
        stateSelect=StateSelect.never) if world.driveTrainMechanics3D annotation (
         Placement(transformation(extent={{-20,-80},{20,-40}}, rotation=0)));
    equation
      phi = flange_a.phi;
      w = der(phi);
      a = der(w);

      connect(inertia.flange_a, flange_a) annotation (Line(
          points={{-20,0},{-100,0}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(inertia.flange_b, flange_b) annotation (Line(
          points={{20,0},{100,0}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(rotorWith3DEffects.flange_b, flange_b) annotation (Line(
          points={{20,-60},{60,-60},{60,0},{100,0}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(rotorWith3DEffects.flange_a, flange_a) annotation (Line(
          points={{-20,-60},{-60,-60},{-60,0},{-100,0}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(rotorWith3DEffects.frame_a, frame_a) annotation (Line(
          points={{0,-80},{0,-100}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      annotation (Documentation(info="<html>
<p>This component is used to model the gyroscopic torques exerted by a 1-dim.
inertia (so called <i>rotor</i>) on its 3-dim. carrier body. Gyroscopic torques
appear, if the vector of the carrier body's angular velocity is not parallel
to the vector of the rotor's axis. The axis of rotation of the rotor is defined by
the parameter <code>n</code>, which has to be given in the local coordinate system
of <code>frame_a</code>. The default animation of this component is
shown in the figure below.</p>
<p>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Parts/Rotor1D.png\" ALT=\"model Parts.Rotor1D\">
</p>
<p>This component is a replacement for
<a href=\"modelica://Modelica.Mechanics.Rotational.Components.Inertia\">Modelica.Mechanics.Rotational.Components.Inertia</a>
for the case, that a 1-dim.-rotational mechanical system should be attached with a 3-dim.
carrier body.</p>
<p>The Boolean parameter <code>exact</code> was introduced due to performance
reasons. If <code>exact</code> is set to <b>false</b>, the influence of the carrier body
motion on the angular velocity of the rotor is neglected. This influence is usually
negligible if the 1-dim.-rotational mechanical system accelerates much faster as the base body (this is,
e.g., the case in vehicle powertrains). The essential advantage is
that an algebraic loop is removed since then there is only an
action on acceleration level from the powertrain to the base body
but not vice versa.</p>
<p><b>Reference</b><br>
<span style=\"font-variant:small-caps\">Schweiger</span>, Christian ;
<span style=\"font-variant:small-caps\">Otter</span>, Martin:
<a href=\"https://www.modelica.org/events/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf\">Modelling
3D Mechanical Effects of 1-dim. Powertrains</a>. In: <i>Proceedings of the 3rd International
Modelica Conference</i>. Link&ouml;ping : The Modelica Association and Link&ouml;ping University,
November 3-4, 2003, pp. 149-158</p>
</html>"),   Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                {100,100}}), graphics={
            Line(points={{-80,-25},{-60,-25}}, color={0,0,0}),
            Line(points={{60,-25},{80,-25}}, color={0,0,0}),
            Line(points={{-70,-25},{-70,-70}}, color={0,0,0}),
            Line(points={{70,-25},{70,-70}}, color={0,0,0}),
            Line(points={{-80,25},{-60,25}}, color={0,0,0}),
            Line(points={{60,25},{80,25}}, color={0,0,0}),
            Line(points={{-70,45},{-70,25}}, color={0,0,0}),
            Line(points={{70,45},{70,25}}, color={0,0,0}),
            Line(points={{-70,-70},{70,-70}}, color={0,0,0}),
            Rectangle(
              extent={{-50,50},{50,-50}},
              lineColor={64,64,64},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={255,255,255},
              radius=10),
            Rectangle(
              extent={{-50,50},{50,-50}},
              lineColor={64,64,64},
              fillPattern=FillPattern.None,
              radius=10),
            Rectangle(
              extent={{-100,10},{-50,-10}},
              lineColor={64,64,64},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={192,192,192}),
            Rectangle(
              extent={{50,10},{100,-10}},
              lineColor={64,64,64},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={192,192,192}),
            Text(
              extent={{-150,125},{150,85}},
              lineColor={0,0,255},
              textString="%name"),
            Line(points={{0,-70},{0,-100}}, color={0,0,0}),
            Text(
              extent={{-150,80},{150,50}},
              lineColor={0,0,0},
              textString="%J")}));
    end Rotor1D;

    model BevelGear1D
      "1D gearbox with arbitrary shaft directions and 3-dim. bearing frame (3D dynamic effects are taken into account provided world.driveTrainMechanics3D=true)"
      extends Modelica_Mechanics_Rotational.Interfaces.PartialTwoFlanges;

      parameter Real ratio(start=1) "Gear speed ratio";
      parameter Modelica_Mechanics_MultiBody.Types.Axis n_a={1,0,0}
        "Axis of rotation of flange_a, resolved in frame_a";
      parameter Modelica_Mechanics_MultiBody.Types.Axis n_b={1,0,0}
        "Axis of rotation of flange_b, resolved in frame_a";

      Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a if world.driveTrainMechanics3D
        "Bearing frame" annotation (Placement(transformation(
            origin={0,-100},
            extent={{-20,-20},{20,20}},
            rotation=90)));

    protected
      outer World world;
      parameter Real e_a[3](each final unit="1")=
        Modelica_Math.Vectors.normalizeWithAssert(n_a)
        "Unit vector in direction of flange_a rotation axis";
      parameter Real e_b[3](each final unit="1")=
        Modelica_Math.Vectors.normalizeWithAssert(n_b)
        "Unit vector in direction of flange_b rotation axis";
      encapsulated model Housing
        import Modelica =
               M_S_L;
        import Modelica_SIunits;
        import M_S_L;
        input Modelica_SIunits.Torque t[3];
        M_S_L.Mechanics.MultiBody.Interfaces.Frame_a frame_a annotation (
            Placement(transformation(extent={{-116,-16},{-84,16}}, rotation=0)));
      equation
        frame_a.f = zeros(3);
        frame_a.t = t;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Text(
                    extent={{-150,110},{150,150}},
                    lineColor={0,0,255},
                    textString="%name")}));
      end Housing;
      Housing housing(t=-flange_a.tau*e_a - flange_b.tau*e_b) if world.driveTrainMechanics3D
        annotation (Placement(transformation(extent={{20,-60},{40,-40}}, rotation=
               0)));

    equation
      flange_a.phi = ratio*flange_b.phi;
      0 = ratio*flange_a.tau + flange_b.tau;
      connect(housing.frame_a, frame_a) annotation (Line(
          points={{20,-50},{0,-50},{0,-100}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      annotation (
        Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}, initialScale = 0.1), graphics = {
          Text(origin=  {0,-40},
            lineColor=  {0,0,255},
            extent=  {{-150,150},{150,180}},
            textString=  "%name=%ratio"),
          Text(origin=  {0,-10},
            extent=  {{-150,-66},{150,-36}},
            textString=  "%name=%ratio"),
          Rectangle(origin=  {-35,60},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.HorizontalCylinder,
            extent=  {{-15,-40},{15,40}}),
          Rectangle(origin=  {-35,0},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.HorizontalCylinder,
            extent=  {{-15,-21},{15,21}}),
          Line(points=  {{-80,20},{-60,20}}),
          Line(points=  {{-80,-20},{-60,-20}}),
          Line(points=  {{-70,-20},{-70,-86}}),
          Line(points=  {{0,40},{0,-100}}),
          Line(points=  {{-10,40},{10,40}}),
          Line(points=  {{-10,80},{10,80}}),
          Line(points=  {{60,-20},{80,-20}}),
          Line(points=  {{60,20},{80,20}}),
          Line(points=  {{70,-20},{70,-86}}),
          Line(points=  {{70,-86},{-70,-86}}),
          Rectangle(origin=  {-75,0},
            lineColor=  {64,64,64},
            fillColor=  {191,191,191},
            fillPattern=  FillPattern.HorizontalCylinder,
            extent=  {{-25,-10},{25,10}}),
          Rectangle(origin=  {75,0},
            lineColor=  {64,64,64},
            fillColor=  {191,191,191},
            fillPattern=  FillPattern.HorizontalCylinder,
            extent=  {{-25,-10},{25,10}}),
          Rectangle(origin=  {-35,-19},
            fillColor=  {153,153,153},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-2},{15,2}}),
          Rectangle(origin=  {-35,-8},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {-35,19},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-2},{15,2}}),
          Rectangle(origin=  {-35,8},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {0,60},
            lineColor=  {64,64,64},
            fillColor=  {191,191,191},
            fillPattern=  FillPattern.HorizontalCylinder,
            extent=  {{-20,-10},{20,10}}),
          Rectangle(origin=  {-35,98},
            fillColor=  {153,153,153},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-2},{15,2}}),
          Rectangle(origin=  {-35,87},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {-35,50},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-4},{15,4}}),
          Rectangle(origin=  {-35,22},
            fillColor=  {102,102,102},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-2},{15,2}}),
          Rectangle(origin=  {-35,33},
            fillColor=  {153,153,153},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {-35,70},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-4},{15,4}}),
          Rectangle(origin=  {35,60},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.HorizontalCylinder,
            extent=  {{-15,-21},{15,21}}),
          Rectangle(origin=  {35,41},
            fillColor=  {153,153,153},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-2},{15,2}}),
          Rectangle(origin=  {35,52},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {35,79},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-2},{15,2}}),
          Rectangle(origin=  {35,68},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {35,0},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.HorizontalCylinder,
            extent=  {{-15,-40},{15,40}}),
          Rectangle(origin=  {35,38},
            fillColor=  {153,153,153},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-2},{15,2}}),
          Rectangle(origin=  {35,27},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {35,-10},
            fillColor=  {204,204,204},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-4},{15,4}}),
          Rectangle(origin=  {35,-38},
            fillColor=  {102,102,102},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-2},{15,2}}),
          Rectangle(origin=  {35,-27},
            fillColor=  {153,153,153},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-3},{15,3}}),
          Rectangle(origin=  {35,10},
            fillColor=  {255,255,255},
            fillPattern=  FillPattern.Solid,
            extent=  {{-15,-4},{15,4}}),
          Rectangle(origin=  {-35,40},
            fillColor=  {255,255,255},
            extent=  {{-15,-61},{15,60}}),
          Rectangle(origin=  {35,21},
            fillColor=  {255,255,255},
            extent=  {{-15,-61},{15,60}})}),
        Documentation(
            info="<html>
<p>This component is used to model a 1-dim. gearbox
with non-parallel axes (defined by parameters <code>n_a</code>, <code>n_b</code>).
A 3-dim. <code>bearing</code> frame is necessary to reflect the
correct support torque, as the axes of rotation of <code>flange_a</code> and
<code>flange_b</code> and the direction of the support torque vector
are different in general.</p>
<p>Note: The name BevelGear1D is kept only for simplicity. Regardless,
this component could be used to model any kind of gearbox with non-parallel axes.</p>
<p><b>Reference</b><br>
<span style=\"font-variant:small-caps\">Schweiger</span>, Christian ;
<span style=\"font-variant:small-caps\">Otter</span>, Martin:
<a href=\"https://www.modelica.org/events/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf\">Modelling
3D Mechanical Effects of 1-dim. Powertrains</a>. In: <i>Proceedings of the 3rd International
Modelica Conference</i>. Link&ouml;ping : The Modelica Association and Link&ouml;ping University,
November 3-4, 2003, pp. 149-158</p>
</html>"));
    end BevelGear1D;

    model RollingWheel
      "Ideal rolling wheel on flat surface z=0 (5 positional, 3 velocity degrees of freedom)"

      parameter Boolean animation=true
        "= true, if animation of wheel shall be enabled";

      parameter Modelica_SIunits.Radius wheelRadius "Radius of wheel";
      parameter Modelica_SIunits.Mass wheelMass "Mass of wheel";
      parameter Modelica_SIunits.Inertia wheel_I_axis
        "Inertia along the wheel axis";
      parameter Modelica_SIunits.Inertia wheel_I_long
        "Inertia perpendicular to the wheel axis";
      parameter StateSelect stateSelect=StateSelect.always
        "Priority to use generalized coordinates as states"
        annotation (HideResult=true, Evaluate=true);

      Modelica_SIunits.Position x(
        start=0,
        fixed=true,
        stateSelect=stateSelect) "x-coordinate of wheel axis";

      Modelica_SIunits.Position y(
        start=0,
        fixed=true,
        stateSelect=stateSelect) "y-coordinate of wheel axis";

      Modelica_SIunits.Angle angles[3](
        start={0,0,0},
        each fixed=true,
        each stateSelect=stateSelect)
        "Angles to rotate world-frame in to frame_a around z-, y-, x-axis"
        annotation (Dialog(group="Initialization", showStartAttribute=true));

      Modelica_SIunits.AngularVelocity der_angles[3](
        start={0,0,0},
        each fixed=true,
        each stateSelect=stateSelect) "Derivative of angles"
        annotation (Dialog(group="Initialization", showStartAttribute=true));

      parameter Modelica_SIunits.Distance width=0.035 "Width of wheel"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Real hollowFraction=0.8
        "1.0: Completely hollow, 0.0: rigid cylinder" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_Mechanics_MultiBody.Types.Color wheelColor={30,30,30}
        "Color of wheel" annotation (Dialog(
          colorSelector=true,
          tab="Animation",
          group="if animation = true",
          enable=animation));

      Modelica_Mechanics_MultiBody.Parts.Body body(
        final r_CM={0,0,0},
        final m=wheelMass,
        final I_11=wheel_I_long,
        final I_22=wheel_I_axis,
        final I_33=wheel_I_long,
        final I_21=0,
        final I_31=0,
        final I_32=0,
        animation=false)
        annotation (Placement(transformation(extent={{20,-10},{40,10}})));

      Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a
        "Frame fixed in wheel center point (y-axis: along wheel axis, z-axis: upwards)"
        annotation (Placement(transformation(extent={{-16,-16},{16,16}})));
      Modelica_Mechanics_MultiBody.Joints.RollingWheel rollingWheel(wheelRadius=
           wheelRadius, stateSelect=StateSelect.avoid)
        annotation (Placement(transformation(extent={{-60,-60},{-40,-40}})));
      Modelica_Mechanics_MultiBody.Visualizers.FixedShape fixedShape(
        final animation=animation,
        final r_shape={0,-width,0},
        final lengthDirection={0,1,0},
        final widthDirection={1,0,0},
        final length=2*width,
        final width=2*wheelRadius,
        final height=2*wheelRadius,
        final color=wheelColor,
        final extra=hollowFraction,
        final shapeType="pipe") if animation
        annotation (Placement(transformation(extent={{20,20},{40,40}})));

    equation
      rollingWheel.x = x;
      rollingWheel.y = y;
      rollingWheel.angles = angles;
      rollingWheel.der_angles = der_angles;

      connect(body.frame_a, frame_a) annotation (Line(
          points={{20,0},{0,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(rollingWheel.frame_a, frame_a) annotation (Line(
          points={{-50,-50},{-25,-50},{-25,0},{0,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(fixedShape.frame_a, frame_a) annotation (Line(
          points={{20,30},{0,30},{0,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      annotation (defaultComponentName="wheel", Icon(coordinateSystem(
              preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics=
             {
            Rectangle(
              extent={{-100,-80},{100,-100}},
              lineColor={0,0,0},
              fillColor={175,175,175},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-80,80},{80,-80}},
              lineColor={0,0,0},
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,125},{150,85}},
              textString="%name",
              lineColor={0,0,255})}));
    end RollingWheel;

    model RollingWheelSet
      "Ideal rolling wheel set consisting of two ideal rolling wheels connected together by an axis"
      Modelica_Mechanics_MultiBody.Interfaces.Frame_a frameMiddle
        "Frame fixed in middle of axis connecting both wheels (y-axis: along wheel axis, z-axis: upwards)"
        annotation (Placement(transformation(extent={{-16,16},{16,-16}}),
            iconTransformation(extent={{-16,-16},{16,16}})));

      parameter Boolean animation=true
        "= true, if animation of wheel set shall be enabled";

      parameter Modelica_SIunits.Radius wheelRadius "Radius of one wheel";
      parameter Modelica_SIunits.Mass wheelMass "Mass of one wheel";
      parameter Modelica_SIunits.Inertia wheel_I_axis
        "Inertia along one wheel axis";
      parameter Modelica_SIunits.Inertia wheel_I_long
        "Inertia perpendicular to one wheel axis";
      parameter Modelica_SIunits.Distance wheelDistance
        "Distance between the two wheels";
      parameter StateSelect stateSelect=StateSelect.always
        "Priority to use the generalized coordinates as states";

      Modelica_SIunits.Position x(
        start=0,
        fixed=true,
        stateSelect=stateSelect) "x coordinate of center between wheels";
      Modelica_SIunits.Position y(
        start=0,
        fixed=true,
        stateSelect=stateSelect) "y coordinate of center between wheels";
      Modelica_SIunits.Angle phi(
        start=0,
        fixed=true,
        stateSelect=stateSelect) "Orientation angle of wheel axis along z-axis";
      Modelica_SIunits.Angle theta1(
        start=0,
        fixed=true,
        stateSelect=stateSelect) "Angle of wheel 1";
      Modelica_SIunits.Angle theta2(
        start=0,
        fixed=true,
        stateSelect=stateSelect) "Angle of wheel 2";
      Modelica_SIunits.AngularVelocity der_theta1(
        start=0,
        fixed=true,
        stateSelect=stateSelect) "Derivative of theta 1";
      Modelica_SIunits.AngularVelocity der_theta2(
        start=0,
        fixed=true,
        stateSelect=stateSelect) "Derivative of theta 2";

      parameter Modelica_SIunits.Distance wheelWidth=0.01 "Width of one wheel"
        annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Real hollowFraction=0.8
        "1.0: Completely hollow, 0.0: rigid cylinder" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      parameter Modelica_Mechanics_MultiBody.Types.Color wheelColor={30,30,30}
        "Color of wheels" annotation (Dialog(
          colorSelector=true,
          tab="Animation",
          group="if animation = true",
          enable=animation));

      Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame1
        "Frame fixed in center point of left wheel (y-axis: along wheel axis, z-axis: upwards)"
        annotation (Placement(transformation(extent={{-96,16},{-64,-16}}),
            iconTransformation(extent={{-96,16},{-64,-16}})));
      Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame2
        "Frame fixed in center point of right wheel (y-axis: along wheel axis, z-axis: upwards)"
        annotation (Placement(transformation(extent={{64,16},{96,-16}})));
      Modelica_Mechanics_MultiBody.Parts.Body body2(
        final r_CM={0,0,0},
        final I_21=0,
        final I_31=0,
        final I_32=0,
        animation=false,
        final m=wheelMass,
        final I_11=wheel_I_long,
        final I_22=wheel_I_axis,
        final I_33=wheel_I_long) annotation (Placement(transformation(
            extent={{10,-10},{-10,10}},
            rotation=-90,
            origin={60,30})));
      Modelica_Mechanics_MultiBody.Visualizers.FixedShape shape2(
        final animation=animation,
        final lengthDirection={0,1,0},
        final widthDirection={1,0,0},
        final color=wheelColor,
        final extra=hollowFraction,
        final shapeType="pipe",
        final r_shape={0,-wheelWidth,0},
        final length=2*wheelWidth,
        final width=2*wheelRadius,
        final height=2*wheelRadius) if animation annotation (Placement(
            transformation(
            extent={{10,-10},{-10,10}},
            rotation=90,
            origin={60,-38})));
      Modelica_Mechanics_MultiBody.Parts.Body body1(
        final r_CM={0,0,0},
        final I_21=0,
        final I_31=0,
        final I_32=0,
        animation=false,
        final m=wheelMass,
        final I_11=wheel_I_long,
        final I_22=wheel_I_axis,
        final I_33=wheel_I_long) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={-60,30})));
      Modelica_Mechanics_MultiBody.Visualizers.FixedShape shape1(
        final animation=animation,
        final lengthDirection={0,1,0},
        final widthDirection={1,0,0},
        final color=wheelColor,
        final extra=hollowFraction,
        final shapeType="pipe",
        final r_shape={0,-wheelWidth,0},
        final length=2*wheelWidth,
        final width=2*wheelRadius,
        final height=2*wheelRadius) if animation annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=-90,
            origin={-60,-40})));
      Modelica_Mechanics_Rotational.Interfaces.Flange_a axis1
        "1-dim. rotational flange that drives the left wheel"
        annotation (Placement(transformation(extent={{-110,90},{-90,110}})));
      Modelica_Mechanics_Rotational.Interfaces.Flange_a axis2
        "1-dim. rotational flange that drives the right wheel"
        annotation (Placement(transformation(extent={{90,90},{110,110}})));
      Modelica_Mechanics_MultiBody.Joints.RollingWheelSet wheelSetJoint(
        animation=false,
        wheelRadius=wheelRadius,
        wheelDistance=wheelDistance,
        stateSelect=StateSelect.default,
        x(fixed=false),
        y(fixed=false),
        phi(fixed=false),
        theta1(fixed=false),
        theta2(fixed=false),
        der_theta1(fixed=false),
        der_theta2(fixed=false))
        annotation (Placement(transformation(extent={{-10,-42},{10,-22}})));
      Modelica_Mechanics_Rotational.Interfaces.Flange_b support
        "Support of 1D axes" annotation (Placement(transformation(extent={{-10,70},
                {10,90}}), iconTransformation(extent={{-10,72},{10,92}})));
    equation
      wheelSetJoint.x = x;
      wheelSetJoint.y = y;
      wheelSetJoint.phi = phi;
      wheelSetJoint.theta1 = theta1;
      wheelSetJoint.theta2 = theta2;
      der_theta1 = der(theta1);
      der_theta2 = der(theta2);

      connect(body2.frame_a, frame2) annotation (Line(
          points={{60,20},{60,0},{80,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(body1.frame_a, frame1) annotation (Line(
          points={{-60,20},{-60,0},{-80,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(shape1.frame_a, frame1) annotation (Line(
          points={{-60,-30},{-60,0},{-80,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(shape2.frame_a, frame2) annotation (Line(
          points={{60,-28},{60,0},{80,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(wheelSetJoint.frame2, frame2) annotation (Line(
          points={{8,-32},{40,-32},{40,0},{80,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(wheelSetJoint.frame1, frame1) annotation (Line(
          points={{-8,-32},{-40,-32},{-40,0},{-80,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(wheelSetJoint.axis1, axis1) annotation (Line(
          points={{-10,-22},{-20,-22},{-20,50},{-80,50},{-80,100},{-100,100}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(wheelSetJoint.axis2, axis2) annotation (Line(
          points={{10,-22},{24,-22},{24,50},{80,50},{80,100},{100,100}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(wheelSetJoint.support, support) annotation (Line(
          points={{0,-24},{0,-14},{16,-14},{16,58},{0,58},{0,80}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(wheelSetJoint.frameMiddle, frameMiddle) annotation (Line(
          points={{0,-32},{-4,-32},{-4,0},{0,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      annotation (
        defaultComponentName="wheelSet",
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,-80},{100,-100}},
              lineColor={0,0,0},
              fillColor={175,175,175},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,-105},{150,-145}},
              textString="%name",
              lineColor={0,0,255}),
            Ellipse(
              extent={{42,80},{118,-80}},
              lineColor={0,0,0},
              fillColor={215,215,215},
              fillPattern=FillPattern.Sphere),
            Rectangle(
              extent={{-62,2},{64,-6}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-118,80},{-42,-80}},
              lineColor={0,0,0},
              fillColor={215,215,215},
              fillPattern=FillPattern.Sphere),
            Line(
              points={{86,24},{64,24},{64,10},{56,10}},
              color={0,0,0},
              smooth=Smooth.None),
            Line(
              points={{86,-24},{64,-24},{64,-12},{56,-12}},
              color={0,0,0},
              smooth=Smooth.None),
            Line(
              points={{-96,100},{-80,100},{-80,4}},
              color={0,0,0},
              smooth=Smooth.None),
            Line(
              points={{100,100},{80,100},{80,-2}},
              color={0,0,0},
              smooth=Smooth.None),
            Line(
              points={{0,72},{0,40},{-20,40},{-20,2}},
              color={0,0,0},
              smooth=Smooth.None),
            Line(
              points={{0,40},{20,40},{20,2}},
              color={0,0,0},
              smooth=Smooth.None)}),
        Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                100,100}}), graphics={Line(
                points={{0,-106},{0,-78}},
                color={0,0,255},
                smooth=Smooth.None),Polygon(
                points={{0,-60},{-6,-78},{6,-78},{0,-60}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),Text(
                extent={{12,-68},{30,-80}},
                lineColor={0,0,255},
                textString="x"),Line(
                points={{6,-100},{-26,-100}},
                color={0,0,255},
                smooth=Smooth.None),Polygon(
                points={{-22,-94},{-22,-106},{-40,-100},{-22,-94}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),Text(
                extent={{-46,-80},{-28,-92}},
                lineColor={0,0,255},
                textString="y")}),
        Documentation(info="<html>
<p>
Two wheels are connected by an axis and can rotate around this axis.
The wheels are rolling on the x-y plane. The coordinate system attached
to the center of the wheel axis (frameMiddle) is constrained so that it
is always parallel to the x-y plane. If all generalized coordinates are zero,
frameMiddle is parallel to the world frame.
</p>
</html>"));
    end RollingWheelSet;
    annotation (Documentation(info="<HTML>
<p>
Package <b>Parts</b> contains <b>rigid components</b> of a
multi-body system. These components may be used to build up
more complicated structures. For example, a part may be built up of
a \"Body\" and of several \"FixedTranslation\" components.
</p>
<h4>Content</h4>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><b><i>Model</i></b></th><th><b><i>Description</i></b></th></tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.Fixed\">Fixed</a></td>
      <td valign=\"top\">Frame fixed in world frame at a given position.
          It is visualized with a shape, see <b>shapeType</b> below
         (the frames on the two
          sides do not belong to the component):<br>&nbsp;<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Fixed.png\" ALT=\"model Parts.Fixed\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.FixedTranslation\">FixedTranslation</a></td>
      <td valign=\"top\">Fixed translation of frame_b with respect to frame_a.
          It is visualized with a shape, see <b>shapeType</b> below
          (the frames on the two sides do not belong to the component):<br>&nbsp;<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/FixedTranslation.png\" ALT=\"model Parts.FixedTranslation\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.FixedRotation\">FixedRotation</a></td>
      <td valign=\"top\">Fixed translation and fixed rotation of frame_b with respect to frame_a
          It is visualized with a shape, see <b>shapeType</b>  below
          (the frames on the two sides do not belong to the component):<br>&nbsp;<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/FixedRotation.png\" ALT=\"model Parts.FixedRotation\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.Body\">Body</a></td>
      <td valign=\"top\">Rigid body with mass, inertia tensor and one frame connector.
          It is visualized with a cylinder and a sphere at the
          center of mass:<br>&nbsp;<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Body.png\" ALT=\"model Parts.Body\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.BodyShape\">BodyShape</a></td>
      <td valign=\"top\">Rigid body with mass, inertia tensor, different shapes
          (see <b>shapeType</b> below)
          for animation, and two frame connectors:<br>&nbsp;<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/BodyShape.png\" ALT=\"model Parts.BodyShape\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.Fixed\">Fixed BodyBox</a></td>
      <td valign=\"top\">Rigid body with box shape (mass and animation properties are computed
          from box data and from density):<br>&nbsp;<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/BodyBox.png\" ALT=\"model Parts.BodyBox\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.BodyCylinder\">BodyCylinder</a></td>
      <td valign=\"top\">Rigid body with cylinder shape (mass and animation properties
          are computed from cylinder data and from density):<br>&nbsp;<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/BodyCylinder.png\" ALT=\"model Parts.BodyCylinder\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.PointMass\">PointMass</a></td>
      <td valign=\"top\">Rigid body where inertia tensor and rotation is neglected:<br>&nbsp;<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Parts/PointMass.png\" ALT=\"model Parts.PointMass\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.Mounting1D\">Mounting1D</a></td>
      <td valign=\"top\"> Propagate 1-dim. support torque to 3-dim. system
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.Rotor1D\">Rotor1D</a></td>
      <td valign=\"top\">1D inertia attachable on 3-dim. bodies (without neglecting dynamic effects)<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Parts/Rotor1D.png\" ALT=\"model Parts.Rotor1D\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.BevelGear1D\">BevelGear1D</a></td>
      <td valign=\"top\">1D gearbox with arbitrary shaft directions (3D bearing frame)
      </td>
  </tr>
</table>
<p>
Components <b>Fixed</b>, <b>FixedTranslation</b>, <b>FixedRotation</b>
and <b>BodyShape</b> are visualized according to parameter
<b>shapeType</b>, that may have the following values (e.g., shapeType = \"box\"): <br>&nbsp;<br>
</p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/FixedShape.png\" ALT=\"model Visualizers.FixedShape\">
<p>
All the details of the visualization shape parameters are
given in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.FixedShape\">Visualizers.FixedShape</a>
</p>
<p>
Colors in all animation parts are defined via parameter <b>color</b>.
This is an Integer vector with 3 elements, {r, g, b}, and specifies the
color of the shape. {r,g,b} are the \"red\", \"green\" and \"blue\" color parts,
given in the ranges 0 .. 255, respectively. The predefined type
<b>MultiBody.Types.Color</b> contains a menu
definition of the colors used in the MultiBody library
(this will be replaced by a color editor).
</p>
</html>"),   Icon(graphics={Rectangle(
            extent={{-80,28},{2,-16}},
            lineColor={95,95,95},
            fillPattern=FillPattern.HorizontalCylinder,
            fillColor={215,215,215},
            radius=10), Ellipse(
            extent={{-8,52},{86,-42}},
            lineColor={95,95,95},
            fillPattern=FillPattern.Sphere,
            fillColor={215,215,215})}));
  end Parts;

  package Sensors "Sensors to measure variables"
    extends Modelica_Icons.SensorsPackage;

    model AbsoluteSensor
      "Measure absolute kinematic quantities of frame connector"

      Modelica_Blocks.Interfaces.RealOutput r[3](each final quantity="Length",
          each final unit="m") if get_r
        "Absolute position vector frame_a.r_0 resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(
            origin={-100,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));
      Modelica_Blocks.Interfaces.RealOutput v[3](each final quantity="Velocity",
          each final unit="m/s") if get_v "Absolute velocity vector"
        annotation (Placement(transformation(
            origin={-60,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));
      Modelica_Blocks.Interfaces.RealOutput a[3](each final quantity=
            "Acceleration", each final unit="m/s2") if get_a
        "Absolute acceleration vector" annotation (Placement(transformation(
            origin={-20,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));
      Modelica_Blocks.Interfaces.RealOutput angles[3](
        each final quantity="Angle",
        each final unit="rad",
        each displayUnit="deg") if get_angles
        "Angles to rotate world frame into frame_a via 'sequence'" annotation (
          Placement(transformation(
            origin={20,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));
      Modelica_Blocks.Interfaces.RealOutput w[3](each final quantity=
            "AngularVelocity", each final unit="1/s") if get_w
        "Absolute angular velocity vector" annotation (Placement(transformation(
            origin={60,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));
      Modelica_Blocks.Interfaces.RealOutput z[3](each final quantity=
            "AngularAcceleration", each final unit="1/s2") if get_z
        "Absolute angular acceleration vector" annotation (Placement(
            transformation(
            origin={100,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));

      extends
        Modelica_Mechanics_MultiBody.Sensors.Internal.PartialAbsoluteSensor;

      Interfaces.Frame_resolve frame_resolve if resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve
        "If resolveInFrame = Types.ResolveInFrameA.frame_resolve, the output signals are resolved in this frame"
         annotation (Placement(transformation(
              extent={{84,-16},{116,16}}),iconTransformation(extent={{84,-16},{116,
                16}})));

      parameter Boolean animation=true
        "= true, if animation shall be enabled (show arrow)";
      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameA resolveInFrame=Types.ResolveInFrameA.frame_a
        "Frame in which vectors are resolved (world, frame_a, or frame_resolve)";
      parameter Boolean get_r=false
        "= true, to measure the absolute position vector of the origin of frame_a"
        annotation(HideResult=true, choices(checkBox=true));
      parameter Boolean get_v=false
        "= true, to measure the absolute velocity of the origin of frame_a"
        annotation(HideResult=true, choices(checkBox=true));
      parameter Boolean get_a=false
        "= true, to measure the absolute acceleration of the origin of frame_a"
        annotation(HideResult=true, choices(checkBox=true));
      parameter Boolean get_w=false
        "= true, to measure the absolute angular velocity of frame_a"
        annotation(HideResult=true, choices(checkBox=true));
      parameter Boolean get_z=false
        "= true, to measure the absolute angular acceleration of frame_a"
        annotation(HideResult=true, choices(checkBox=true));
      parameter Boolean get_angles=false
        "= true, to measure the 3 rotation angles"
        annotation(HideResult=true, choices(checkBox=true), Dialog(group="3 angles to rotate the world frame into frame_a along the axes defined in \"sequence\""));
      parameter Types.RotationSequence sequence(
        min={1,1,1},
        max={3,3,3}) = {1,2,3}
        "If get_angles=true: Angles are returned to rotate world frame around axes sequence[1], sequence[2] and finally sequence[3] into frame_a"
        annotation (HideResult=true,Evaluate=true, Dialog(group="3 angles to rotate the world frame into frame_a along the axes defined in \"sequence\"", enable=get_angles));
      parameter Modelica_SIunits.Angle guessAngle1=0
        "If get_angles=true: Select angles[1] such that abs(angles[1] - guessAngle1) is a minimum"
        annotation (HideResult=true, Dialog(group=
              "3 angles to rotate the world frame into frame_a along the axes defined in \"sequence\"",
            enable=get_angles));

      input Modelica_SIunits.Diameter arrowDiameter=world.defaultArrowDiameter
        "Diameter of absolute arrow from world frame to frame_a" annotation (
          Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color arrowColor=Types.Defaults.SensorColor
        "Color of absolute arrow from world frame to frame_b"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));

    protected
      AbsolutePosition position(resolveInFrame=resolveInFrame) if get_r
        annotation (Placement(transformation(extent={{10,10},{-10,30}},
            rotation=90,
            origin={-80,-60})));

    protected
      AbsoluteVelocity velocity(resolveInFrame=resolveInFrame) if get_v
                                                               annotation (
          Placement(transformation(
            extent={{10,-10},{-10,10}},
            rotation=90,
            origin={-60,-60})));
      Modelica_Mechanics_MultiBody.Sensors.AbsoluteAngles absoluteAngles(sequence=
            sequence, guessAngle1=guessAngle1) if get_angles annotation (
          Placement(transformation(
            extent={{-10,10},{10,-10}},
            rotation=-90,
            origin={20,-60})));
      AbsoluteAngularVelocity angularVelocity(resolveInFrame=resolveInFrame) if get_w
        annotation (Placement(transformation(extent={{-10,-10},{10,-30}},
            rotation=-90,
            origin={70,-60})));

    protected
      Modelica_Blocks.Continuous.Der der1[3] if get_a annotation (Placement(
            transformation(
            extent={{-6,-6},{6,6}},
            rotation=-90,
            origin={-20,-34})));
    protected
      Modelica_Blocks.Continuous.Der der2[3] if get_z annotation (Placement(
            transformation(
            extent={{-6,-6},{6,6}},
            rotation=-90,
            origin={100,-46})));

    protected
      Modelica_Mechanics_MultiBody.Sensors.TransformAbsoluteVector transformVector_a(
          frame_r_in=Types.ResolveInFrameA.world, frame_r_out=resolveInFrame) if
           get_a
        annotation (Placement(transformation(extent={{-10,-70},{-30,-50}})));
      Modelica_Mechanics_MultiBody.Sensors.TransformAbsoluteVector transformVector_z(
          frame_r_in=Types.ResolveInFrameA.world, frame_r_out=resolveInFrame) if
           get_z
        annotation (Placement(transformation(extent={{90,-80},{110,-60}})));

    protected
      outer Modelica_Mechanics_MultiBody.World world;

      Modelica_Mechanics_MultiBody.Visualizers.Advanced.Arrow arrow(
        r_head=frame_a.r_0,
        diameter=arrowDiameter,
        color=arrowColor,
        specularCoefficient) if world.enableAnimation and animation;

    protected
      AbsoluteVelocity absoluteVelocity(resolveInFrame=Types.ResolveInFrameA.world) if                         get_a
        annotation (Placement(transformation(
            extent={{10,-10},{-10,10}},
            rotation=90,
            origin={-20,-12})));
      AbsoluteAngularVelocity absoluteAngularVelocity(resolveInFrame=Types.ResolveInFrameA.world) if
           get_z
        annotation (Placement(transformation(extent={{40,-10},{60,10}},
            rotation=0)));
      Internal.ZeroForceAndTorque zeroForce1
        annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
      Internal.ZeroForceAndTorque zeroForce2 if resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve
        annotation (Placement(transformation(extent={{80,20},{60,40}})));
    equation
      connect(zeroForce1.frame_a, frame_a)
                                      annotation (Line(
          points={{-60,30},{-80,30},{-80,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(absoluteAngles.angles, angles) annotation (Line(
          points={{20,-71},{20,-90},{20,-90},{20,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(angularVelocity.frame_a, frame_a)         annotation (Line(
          points={{50,-50},{50,-40},{20,-40},{20,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(angularVelocity.w, w)                 annotation (Line(
          points={{50,-71},{50,-94},{60,-94},{60,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(frame_resolve, position.frame_resolve)         annotation (Line(
          points={{100,0},{114,0},{114,-90},{-80,-90},{-80,-60},{-89.9,-60}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(frame_resolve,zeroForce2. frame_a) annotation (Line(
          points={{100,0},{90,0},{90,30},{80,30}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(angularVelocity.frame_resolve, frame_resolve)         annotation (
          Line(
          points={{60.1,-60},{66,-60},{66,-90},{114,-90},{114,0},{100,0}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(transformVector_a.frame_a, frame_a) annotation (Line(
          points={{-10,-60},{0,-60},{0,-40},{20,-40},{20,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(transformVector_a.frame_resolve, frame_resolve)      annotation (Line(
          points={{-30,-59.9},{-40,-59.9},{-40,-90},{114,-90},{114,0},{100,0}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(transformVector_a.r_out, a)          annotation (Line(
          points={{-20,-71},{-20,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(der2.y, transformVector_z.r_in)     annotation (Line(
          points={{100,-52.6},{100,-58}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(transformVector_z.r_out, z)         annotation (Line(
          points={{100,-81},{100,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(transformVector_z.frame_a, frame_a)     annotation (Line(
          points={{90,-70},{80,-70},{80,-40},{20,-40},{20,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(transformVector_z.frame_resolve, frame_resolve)     annotation (Line(
          points={{110,-69.9},{110,-70},{114,-70},{114,0},{100,0}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(frame_a, position.frame_a)         annotation (Line(
          points={{-100,0},{-80,0},{-80,-40},{-100,-40},{-100,-50}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(absoluteAngles.frame_a, frame_a) annotation (Line(
          points={{20,-50},{20,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(position.r, r)         annotation (Line(
          points={{-100,-71},{-100,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(velocity.frame_a, frame_a) annotation (Line(
          points={{-60,-50},{-60,-40},{-80,-40},{-80,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(velocity.frame_resolve, frame_resolve) annotation (Line(
          points={{-50,-60},{-40,-60},{-40,-90},{114,-90},{114,0},{100,0}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(velocity.v, v) annotation (Line(
          points={{-60,-71},{-60,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(der1.y, transformVector_a.r_in) annotation (Line(
          points={{-20,-40.6},{-20,-48}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(absoluteVelocity.v, der1.u) annotation (Line(
          points={{-20,-23},{-20,-26.8}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(absoluteVelocity.frame_a, frame_a) annotation (Line(
          points={{-20,-2},{-20,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(absoluteAngularVelocity.frame_a, frame_a) annotation (Line(
          points={{40,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(absoluteAngularVelocity.w, der2.u) annotation (Line(
          points={{61,0},{80,0},{80,-30},{100,-30},{100,-38.8}},
          color={0,0,127},
          smooth=Smooth.None));
      annotation (                         Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                -100},{100,100}}), graphics={
            Line(
              visible=get_r,
              points={{-84,0},{-84,-60},{-100,-60},{-100,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Line(
              visible=get_a,
              points={{-20,-67},{-20,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Line(
              visible=get_w,
              points={{60,-36},{60,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Line(
              visible=get_z,
              points={{86,0},{86,-60},{100,-60},{100,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Line(
              visible=get_v,
              points={{-60,-36},{-60,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Line(
              visible=get_angles,
              points={{20,-67},{20,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Line(
              points={{95,0},{95,0},{70,0}},
              color={0,0,0},
              pattern=LinePattern.Dot,
              smooth=Smooth.None),
            Text(
              extent={{-132,76},{129,124}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              visible=get_r,
              extent={{-130,-74},{-95,-90}},
              lineColor={0,0,0},
              textString="r"),
            Text(
              visible=get_v,
              extent={{-95,-74},{-60,-90}},
              lineColor={0,0,0},
              textString="v"),
            Text(
              visible=get_a,
              extent={{-55,-74},{-20,-90}},
              lineColor={0,0,0},
              textString="a"),
            Text(
              visible=get_angles,
              extent={{-71,-35},{96,-54}},
              lineColor={0,0,0},
              textString="angles"),
            Text(
              visible=get_w,
              extent={{59,-68},{105,-85}},
              lineColor={0,0,0},
              textString="w"),
            Text(
              visible=get_z,
              extent={{107,-68},{153,-84}},
              lineColor={0,0,0},
              textString="z"),
            Text(
              extent={{60,52},{191,27}},
              lineColor={95,95,95},
              textString="resolve")}),
        Documentation(info="<html>
<p>
Absolute kinematic quantities of frame_a are
determined and provided at the conditional output signal connectors.
For example, if parameter \"get_r = <b>true</b>\", the connector
\"r\" is enabled and contains the absolute vector from the world frame
to the origin of frame_a. The following quantities can be provided
as output signals:
</p>

<ol>
<li> Absolute position vector (= r) </li>
<li> Absolute velocity vector (= v)</li>
<li> Absolute acceleration vector (= a)</li>
<li> Three angles to rotate world frame into frame_a (= angles)</li>
<li> Absolute angular velocity vector (= w)</li>
<li> Absolute angular acceleration vector (= z)</li>
</ol>

<p>
Via parameter <b>resolveInFrame</b> it is defined, in which frame
a vector is resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>resolveInFrame =<br>Types.ResolveInFrameA.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve vectors in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve vectors in frame_a</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve vectors in frame_resolve</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameA.frame_resolve, the conditional connector
\"frame_resolve\" is enabled and the vectors are resolved in the frame, to
which frame_resolve is connected. Note, if this connector is enabled, it must
be connected.
</p>

<p>
In the following figure the animation of an AbsoluteSensor
component is shown. The light blue coordinate system is
frame_a and the yellow arrow is the animated sensor.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Sensors/AbsoluteSensor.png\">
</p>

<p>
Velocity, acceleration, angular velocity and angular acceleration are
determined by differentiating them in the world frame and then transforming
them in to the frame defined by <b>resolveInFrame</b>.
</p>
<p>
For example, if resolveInFrame = <b>Types.ResolveInFrameA.frame_a</b>, then
</p>
<pre>
   v0 = <b>der</b>(frame_a.r0);
   v  = resolve2(frame_a.R, v0);
</pre>
<p>
is returned, i.e., the derivative of the absolute distance from the
world frame to the origin of frame_a, resolved in frame_a.
</p>

<p>
The cut-force and the cut-torque in frame_resolve are
always zero, whether frame_resolve is connected or not.
</p>

<p>
If <b>get_angles</b> = <b>true</b>, the 3 angles to rotate the world
frame into frame_a along the axes defined by parameter <b>sequence</b>
are returned. For example, if sequence = {3,1,2} then the world frame is
rotated around angles[1] along the z-axis, afterwards it is rotated
around angles[2] along the x-axis, and finally it is rotated around
angles[3] along the y-axis and is then identical to frame_a.
The 3 angles are returned in the range
</p>
<pre>
    -<font face=\"Symbol\">p</font> &lt;= angles[i] &lt;= <font face=\"Symbol\">p</font>
</pre>
<p>
There are <b>two solutions</b> for \"angles[1]\" in this range.
Via parameter <b>guessAngle1</b> (default = 0) the
returned solution is selected such that |angles[1] - guessAngle1| is
minimal. The absolute transformation matrix of frame_a
may be in a singular configuration with respect to \"sequence\", i.e.,
there is an infinite number of angle values leading to the same absolute
transformation matrix. In this case, the returned solution is
selected by setting angles[1] = guessAngle1. Then angles[2]
and angles[3] can be uniquely determined in the above range.
</p>
<p>
The parameter <b>sequence</b> has the restriction that
only values 1,2,3 can be used and that sequence[1] &ne; sequence[2]
and sequence[2] &ne; sequence[3]. Often used values are:
</p>
<pre>
  sequence = <b>{1,2,3}</b>  // Cardan or Tait-Bryan angle sequence
           = <b>{3,1,3}</b>  // Euler angle sequence
           = <b>{3,2,1}</b>
</pre>
</html>"));
    end AbsoluteSensor;

    model RelativeSensor
      "Measure relative kinematic quantities between two frame connectors"

      extends
        Modelica_Mechanics_MultiBody.Sensors.Internal.PartialRelativeSensor;

      Interfaces.Frame_resolve frame_resolve if resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve or
        resolveInFrameAfterDifferentiation == Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve
        "If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the output signals are resolved in this frame"
         annotation (Placement(transformation(
              extent={{84,64},{116,96}}), iconTransformation(extent={{84,64},{116,
                96}})));

      parameter Boolean animation=true
        "= true, if animation shall be enabled (show arrow)";
      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB resolveInFrame=Types.ResolveInFrameAB.frame_a
        "Frame in which vectors are resolved before differentiation (world, frame_a, frame_b, or frame_resolve)";
      parameter Boolean get_r_rel=false
        "= true, to measure the relative position vector from the origin of frame_a to frame_b"
        annotation(HideResult=true, choices(checkBox=true));
      parameter Boolean get_v_rel=false
        "= true, to measure the relative velocity of the origin of frame_b with respect to frame_a"
        annotation(HideResult=true, choices(checkBox=true));
      parameter Boolean get_a_rel=false
        "= true, to measure the relative acceleration of the origin of frame_b with respect to frame_a"
        annotation(HideResult=true, choices(checkBox=true));
      parameter Boolean get_w_rel=false
        "= true, to measure the relative angular velocity of frame_b with respect to frame_a"
        annotation(HideResult=true, choices(checkBox=true));
      parameter Boolean get_z_rel=false
        "= true, to measure the relative angular acceleration of frame_b with respect to frame_a"
        annotation(HideResult=true, choices(checkBox=true));
      parameter Boolean get_angles=false
        "= true, to measure the 3 rotation angles"
        annotation(HideResult=true, choices(checkBox=true), Dialog(group="3 angles to rotate frame_a into frame_b along the axes defined in \"sequence\""));
      parameter Types.RotationSequence sequence(
        min={1,1,1},
        max={3,3,3}) = {1,2,3}
        "If get_angles=true: Angles are returned to rotate frame_a around axes sequence[1], sequence[2] and finally sequence[3] into frame_b"
        annotation (HideResult=true,Evaluate=true, Dialog(group="3 angles to rotate frame_a into frame_b along the axes defined in \"sequence\"", enable=get_angles));
      parameter Modelica_SIunits.Angle guessAngle1=0
        "If get_angles=true: Select angles[1] such that abs(angles[1] - guessAngle1) is a minimum"
        annotation (HideResult=true, Dialog(group=
              "3 angles to rotate frame_a into frame_b along the axes defined in \"sequence\"",
            enable=get_angles));

      input Modelica_SIunits.Diameter arrowDiameter=world.defaultArrowDiameter
        "Diameter of relative arrow from frame_a to frame_b" annotation (Dialog(
          tab="Animation",
          group="if animation = true",
          enable=animation));
      input Types.Color arrowColor=Types.Defaults.SensorColor
        "Color of relative arrow from frame_a to frame_b"
        annotation (Dialog(colorSelector=true, tab="Animation", group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));

      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB resolveInFrameAfterDifferentiation=
          resolveInFrame
        "Frame in which vectors are resolved after differentiation (world, frame_a, frame_b, or frame_resolve)"
        annotation (Dialog(
          tab="Advanced",
          group="if get_v_rel or get_a_rel or get_z_rel",
          enable=get_v_rel or get_a_rel or get_z_rel));

      Modelica_Blocks.Interfaces.RealOutput r_rel[3](each final quantity=
            "Length", each final unit="m") if get_r_rel
        "Relative position vector frame_b.r_0 - frame_a.r_0 resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(
            origin={-100,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));
      Modelica_Blocks.Interfaces.RealOutput v_rel[3](each final quantity=
            "Velocity", each final unit="m/s") if get_v_rel
        "Relative velocity vector" annotation (Placement(transformation(
            origin={-60,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));
      Modelica_Blocks.Interfaces.RealOutput a_rel[3](each final quantity=
            "Acceleration", each final unit="m/s2") if get_a_rel
        "Relative acceleration vector" annotation (Placement(transformation(
            origin={-20,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));
      Modelica_Blocks.Interfaces.RealOutput angles[3](
        each final quantity="Angle",
        each final unit="rad",
        each displayUnit="deg") if get_angles
        "Angles to rotate frame_a into frame_b via 'sequence'" annotation (
          Placement(transformation(
            origin={20,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));
      Modelica_Blocks.Interfaces.RealOutput w_rel[3](each final quantity=
            "AngularVelocity", each final unit="1/s") if get_w_rel
        "Relative angular velocity vector" annotation (Placement(transformation(
            origin={60,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));
      Modelica_Blocks.Interfaces.RealOutput z_rel[3](each final quantity=
            "AngularAcceleration", each final unit="1/s2") if get_z_rel
        "Relative angular acceleration vector" annotation (Placement(
            transformation(
            origin={100,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));

    protected
      RelativePosition relativePosition(resolveInFrame=resolveInFrame) if
                                                    get_r_rel or get_v_rel or get_a_rel
        annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));

    protected
      Modelica_Blocks.Continuous.Der der1[3] if get_v_rel or get_a_rel
        annotation (Placement(transformation(
            extent={{-10,-10},{0,0}},
            rotation=-90,
            origin={-55,-30})));
      Modelica_Blocks.Continuous.Der der2[3] if get_a_rel annotation (Placement(
            transformation(
            extent={{0,0},{10,10}},
            rotation=-90,
            origin={-25,-40})));
      Modelica_Mechanics_MultiBody.Sensors.RelativeAngles relativeAngles(sequence=
            sequence, guessAngle1=guessAngle1) if get_angles
        annotation (Placement(transformation(extent={{10,-25},{30,-5}})));
      RelativeAngularVelocity relativeAngularVelocity(resolveInFrame=resolveInFrame) if
                                                                  get_w_rel or get_z_rel
        annotation (Placement(transformation(extent={{50,-40},{70,-20}})));

    protected
      Modelica_Blocks.Continuous.Der der3[3] if get_z_rel annotation (Placement(
            transformation(
            extent={{-10,-10},{0,0}},
            rotation=-90,
            origin={105,-60})));
      Internal.ZeroForceAndTorque zeroForce1
        annotation (Placement(transformation(extent={{-81,40},{-61,60}})));
      Internal.ZeroForceAndTorque zeroForce2
        annotation (Placement(transformation(extent={{70,20},{50,40}})));
      Internal.ZeroForceAndTorque zeroForce3 if resolveInFrame ==
        Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve
        annotation (Placement(transformation(extent={{70,50},{50,70}})));

    protected
      Modelica_Mechanics_MultiBody.Sensors.TransformRelativeVector transformVector_v_rel(
          frame_r_in=resolveInFrame, frame_r_out=
            resolveInFrameAfterDifferentiation) if get_v_rel
        annotation (Placement(transformation(extent={{-70,-64},{-50,-44}})));
      Modelica_Mechanics_MultiBody.Sensors.TransformRelativeVector transformVector_a_rel(
          frame_r_in=resolveInFrame, frame_r_out=
            resolveInFrameAfterDifferentiation) if get_a_rel
        annotation (Placement(transformation(extent={{-30,-80},{-10,-60}})));
      Modelica_Mechanics_MultiBody.Sensors.TransformRelativeVector transformVector_z_rel(
          frame_r_in=resolveInFrame, frame_r_out=
            resolveInFrameAfterDifferentiation) if get_z_rel
        annotation (Placement(transformation(extent={{90,-95},{110,-75}})));

    protected
      outer Modelica_Mechanics_MultiBody.World world;

      Modelica_Mechanics_MultiBody.Visualizers.Advanced.Arrow arrow(
        r=frame_a.r_0,
        r_head=frame_b.r_0 - frame_a.r_0,
        diameter=arrowDiameter,
        color=arrowColor,
        specularCoefficient) if world.enableAnimation and animation;
    equation
      connect(relativePosition.frame_a, frame_a) annotation (Line(
          points={{-80,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(relativePosition.frame_b, frame_b) annotation (Line(
          points={{-60,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(relativePosition.r_rel, r_rel) annotation (Line(
          points={{-70,-11},{-70,-15},{-80,-15},{-80,-80},{-100,-80},{-100,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(zeroForce1.frame_a, frame_a)
                                      annotation (Line(
          points={{-81,50},{-90,50},{-90,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(zeroForce2.frame_a, frame_b)
                                      annotation (Line(
          points={{70,30},{90,30},{90,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(relativePosition.r_rel, der1.u) annotation (Line(
          points={{-70,-11},{-70,-15},{-60,-15},{-60,-19}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(der2.u, der1.y) annotation (Line(
          points={{-20,-39},{-20,-35},{-60,-35},{-60,-30.5}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(relativeAngles.frame_a, frame_a) annotation (Line(
          points={{10,-15},{0,-15},{0,30},{-90,30},{-90,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(relativeAngles.frame_b, frame_b) annotation (Line(
          points={{30,-15},{40,-15},{40,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(relativeAngles.angles, angles) annotation (Line(
          points={{20,-26},{20,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(relativeAngularVelocity.frame_b, frame_b) annotation (Line(
          points={{70,-30},{80,-30},{80,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(relativeAngularVelocity.frame_a, frame_a) annotation (Line(
          points={{50,-30},{0,-30},{0,30},{-90,30},{-90,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(relativeAngularVelocity.w_rel, w_rel) annotation (Line(
          points={{60,-41},{60,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(relativeAngularVelocity.w_rel, der3.u) annotation (Line(
          points={{60,-41},{60,-43},{100,-43},{100,-49}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(der1.y, transformVector_v_rel.r_in)
                                            annotation (Line(
          points={{-60,-30.5},{-60,-42}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(transformVector_v_rel.r_out, v_rel)
                                            annotation (Line(
          points={{-60,-65},{-60,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(transformVector_v_rel.frame_a, frame_a)
                                                annotation (Line(
          points={{-70,-54},{-90,-54},{-90,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(transformVector_v_rel.frame_b, frame_b)
                                                annotation (Line(
          points={{-50,-54},{-36,-54},{-36,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(transformVector_v_rel.frame_resolve, frame_resolve)
                                                            annotation (Line(
          points={{-50,-45.9},{-47,-45.9},{-47,-47},{-42,-47},{-42,80},{100,80}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(frame_resolve, relativePosition.frame_resolve) annotation (Line(
          points={{100,80},{-50,80},{-50,8.1},{-60,8.1}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(frame_resolve, zeroForce3.frame_a) annotation (Line(
          points={{100,80},{80,80},{80,60},{70,60}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(relativeAngularVelocity.frame_resolve, frame_resolve) annotation (
          Line(
          points={{70,-21.9},{77,-21.9},{77,80},{100,80}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(der2.y, transformVector_a_rel.r_in)  annotation (Line(
          points={{-20,-50.5},{-20,-58}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(transformVector_a_rel.frame_a, frame_a)  annotation (Line(
          points={{-30,-70},{-90,-70},{-90,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(transformVector_a_rel.frame_b, frame_b)  annotation (Line(
          points={{-10,-70},{6,-70},{6,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(transformVector_a_rel.frame_resolve, frame_resolve)  annotation (Line(
          points={{-10,-61.9},{-10,80},{100,80}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(transformVector_a_rel.r_out, a_rel)  annotation (Line(
          points={{-20,-81},{-20,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(der3.y, transformVector_z_rel.r_in) annotation (Line(
          points={{100,-60.5},{100,-73}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(transformVector_z_rel.r_out, z_rel) annotation (Line(
          points={{100,-96},{100,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(transformVector_z_rel.frame_a, frame_a) annotation (Line(
          points={{90,-85},{-90,-85},{-90,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(transformVector_z_rel.frame_b, frame_b) annotation (Line(
          points={{110,-85},{119,-85},{119,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(transformVector_z_rel.frame_resolve, frame_resolve) annotation (Line(
          points={{110,-76.9},{116,-76.9},{116,80},{100,80}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      annotation (   Icon(coordinateSystem(preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
            Line(
              visible=get_r_rel,
              points={{-84,0},{-84,-60},{-100,-60},{-100,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Line(
              visible=get_a_rel,
              points={{-20,-67},{-20,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Line(
              visible=get_w_rel,
              points={{60,-36},{60,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Line(
              visible=get_z_rel,
              points={{86,0},{86,-60},{100,-60},{100,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Line(
              visible=get_v_rel,
              points={{-60,-36},{-60,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Line(
              visible=get_angles,
              points={{20,-67},{20,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Text(
              extent={{-132,90},{129,138}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              visible=get_r_rel,
              extent={{-130,-74},{-95,-90}},
              lineColor={0,0,0},
              textString="r"),
            Text(
              visible=get_v_rel,
              extent={{-95,-74},{-60,-90}},
              lineColor={0,0,0},
              textString="v"),
            Text(
              visible=get_a_rel,
              extent={{-55,-74},{-20,-90}},
              lineColor={0,0,0},
              textString="a"),
            Text(
              visible=get_angles,
              extent={{-71,-35},{96,-54}},
              lineColor={0,0,0},
              textString="angles"),
            Text(
              visible=get_w_rel,
              extent={{63,-73},{103,-90}},
              lineColor={0,0,0},
              textString="w"),
            Text(
              visible=get_z_rel,
              extent={{103,-71},{149,-87}},
              lineColor={0,0,0},
              textString="z")}),
        Documentation(info="<html>
<p>
Relative kinematic quantities between frame_a and frame_b are
determined and provided at the conditional output signal connectors.
For example, if parameter \"get_r_rel = <b>true</b>\", the connector
\"r_rel\" is enabled and contains the relative vector from
frame_a to frame_b. The following quantities can be provided
as output signals:
</p>

<ol>
<li> Relative position vector (= r_rel) </li>
<li> Relative velocity vector (= v_rel)</li>
<li> Relative acceleration vector (= a_rel)</li>
<li> Three angles to rotate frame_a into frame_b (= angles)</li>
<li> Relative angular velocity vector (= w_rel)</li>
<li> Relative angular acceleration vector (= z_rel)</li>
</ol>

<p>
Via parameter <b>resolveInFrame</b> it is defined, in which frame
a vector is resolved (before differentiation):
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>resolveInFrame =<br>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve vectors in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve vectors in frame_a</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve vectors in frame_b</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve vectors in frame_resolve</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the conditional connector
\"frame_resolve\" is enabled and the vectors are resolved in the frame, to
which frame_resolve is connected. Note, if this connector is enabled, it must
be connected.
</p>

<p>
In the following figure the animation of a RelativeSensor
component is shown. The light blue coordinate system is
frame_a, the dark blue coordinate system is frame_b, and
the yellow arrow is the animated sensor.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Sensors/RelativeSensor.png\">
</p>

<p>
Note, derivatives
of relative kinematic quantities are always performed with
respect to the frame, in which the vector to be differentiated
is resolved. After differentiation, it is possible via parameter
<b>resolveInFrameAfterDifferentiation</b> (in the \"Advanced\" menu)
to resolve the differentiated
vector in another frame.
</p>
<p>
For example, if resolveInFrame = <b>Types.ResolveInFrameAB.frame_b</b>, then
</p>

<pre>
   r_rel = resolve2(frame_b.R, frame_b.r_0 - frame_a.r0);
   v_rel = <b>der</b>(r_rel);
</pre>

<p>
is returned (r_rel = resolve2(frame_b.R, frame_b.r_0 - frame_a.r0)), i.e.,
the derivative of the relative distance from frame_a to frame_b,
resolved in frame_b. If
<b>resolveInFrameAfterDifferentiation</b> = Types.ResolveInFrameAB.world, then
v_rel is additionally transformed to:
</p>

<pre>
   v_rel = resolve1(frame_b.R, <b>der</b>(r_rel))
</pre>

<p>
The cut-force and the cut-torque in frame_resolve are
always zero, whether frame_resolve is connected or not.
</p>

<p>
If <b>get_angles</b> = <b>true</b>, the 3 angles to rotate frame_a
into frame_b along the axes defined by parameter <b>sequence</b>
are returned. For example, if sequence = {3,1,2} then frame_a is
rotated around angles[1] along the z-axis, afterwards it is rotated
around angles[2] along the x-axis, and finally it is rotated around
angles[3] along the y-axis and is then identical to frame_b.
The 3 angles are returned in the range
</p>
<pre>
    -<font face=\"Symbol\">p</font> &lt;= angles[i] &lt;= <font face=\"Symbol\">p</font>
</pre>
<p>
There are <b>two solutions</b> for \"angles[1]\" in this range.
Via parameter <b>guessAngle1</b> (default = 0) the
returned solution is selected such that |angles[1] - guessAngle1| is
minimal. The relative transformation matrix between frame_a and
frame_b may be in a singular configuration with respect to \"sequence\", i.e.,
there is an infinite number of angle values leading to the same relative
transformation matrix. In this case, the returned solution is
selected by setting angles[1] = guessAngle1. Then angles[2]
and angles[3] can be uniquely determined in the above range.
</p>
<p>
The parameter <b>sequence</b> has the restriction that
only values 1,2,3 can be used and that sequence[1] &ne; sequence[2]
and sequence[2] &ne; sequence[3]. Often used values are:
</p>
<pre>
  sequence = <b>{1,2,3}</b>  // Cardan or Tait-Bryan angle sequence
           = <b>{3,1,3}</b>  // Euler angle sequence
           = <b>{3,2,1}</b>
</pre>
</html>"));
    end RelativeSensor;

    model AbsolutePosition
      "Measure absolute position vector of the origin of a frame connector"
      extends Internal.PartialAbsoluteSensor;
      Modelica_Blocks.Interfaces.RealOutput r[3](each final quantity="Length",
          each final unit="m")
        "Absolute position vector resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=0,
            origin={110,0})));

      Modelica_Mechanics_MultiBody.Interfaces.Frame_resolve frame_resolve if
        resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve
        "Coordinate system in which output vector r is optionally resolved"
        annotation (Placement(transformation(
            extent={{-16,-16},{16,16}},
            rotation=-90,
            origin={0,-100}), iconTransformation(
            extent={{-16,-16},{16,16}},
            rotation=-90,
            origin={0,-101})));

      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameA resolveInFrame=Types.ResolveInFrameA.frame_a
        "Frame in which output vector r shall be resolved (world, frame_a, or frame_resolve)";

    protected
      Internal.BasicAbsolutePosition position(resolveInFrame=resolveInFrame)
        annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      Modelica_Mechanics_MultiBody.Interfaces.ZeroPosition zeroPosition if not (
        resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve)
        annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

    equation
      connect(position.frame_resolve, frame_resolve)         annotation (Line(
          points={{0,-10},{0,-100}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, position.frame_resolve)
        annotation (Line(
          points={{20,-30},{0,-30},{0,-10}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(position.r, r) annotation (Line(
          points={{11,0},{110,0}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(position.frame_a, frame_a) annotation (Line(
          points={{-10,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      annotation ( Icon(coordinateSystem(
              preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
            Line(
              points={{70,0},{100,0}},
              color={0,0,127},
              smooth=Smooth.None),
            Text(
              extent={{-127,95},{134,143}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{62,46},{146,16}},
              lineColor={0,0,0},
              textString="r"),
            Text(
              extent={{15,-67},{146,-92}},
              lineColor={95,95,95},
              textString="resolve"),
            Line(
              points={{0,-96},{0,-96},{0,-70},{0,-70}},
              color={0,0,0},
              smooth=Smooth.None,
              pattern=LinePattern.Dot)}),
        Documentation(info="<html>
<p>
The absolute position vector of the origin of frame_a is
determined and provided at the output signal connector <b>r</b>.
</p>

<p>
Via parameter <b>resolveInFrame</b> it is defined, in which frame
the position vector is resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>resolveInFrame =<br>Types.ResolveInFrameA.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve vector in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve vector in frame_a</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve vector in frame_resolve</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameA.frame_resolve, the conditional connector
\"frame_resolve\" is enabled and r is resolved in the frame, to
which frame_resolve is connected. Note, if this connector is enabled, it must
be connected.
</p>

<p>
Example: If resolveInFrame = Types.ResolveInFrameA.frame_a, the output vector is
computed as:
</p>

<pre>
    r = MultiBody.Frames.resolve2(frame_a.R, frame_b.r_0);
</pre>
</html>"));
    end AbsolutePosition;

    model AbsoluteVelocity
      "Measure absolute velocity vector of origin of frame connector"
      extends Internal.PartialAbsoluteSensor;
      Modelica_Blocks.Interfaces.RealOutput v[3](each final quantity="Velocity",
          each final unit="m/s")
        "Absolute velocity vector resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=0,
            origin={110,0})));

      Modelica_Mechanics_MultiBody.Interfaces.Frame_resolve frame_resolve if
        resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve
        "Coordinate system in which output vector v is optionally resolved"
        annotation (Placement(transformation(
            extent={{-16,-16},{16,16}},
            rotation=-90,
            origin={0,-100}), iconTransformation(
            extent={{-16,-16},{16,16}},
            rotation=-90,
            origin={0,-100})));

      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameA resolveInFrame=Types.ResolveInFrameA.frame_a
        "Frame in which output vector v shall be resolved (world, frame_a, or frame_resolve)";

    protected
      Internal.BasicAbsolutePosition position(resolveInFrame=Types.ResolveInFrameA.world)
        annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
      Modelica_Blocks.Continuous.Der der1[3] annotation (Placement(
            transformation(
            extent={{-20,-20},{0,0}},
            rotation=0,
            origin={10,10})));
      Modelica_Mechanics_MultiBody.Sensors.TransformAbsoluteVector tansformAbsoluteVector(
          frame_r_in=Types.ResolveInFrameA.world, frame_r_out=resolveInFrame)
        annotation (Placement(transformation(
            extent={{10,-10},{-10,10}},
            rotation=90,
            origin={50,0})));
      Modelica_Mechanics_MultiBody.Interfaces.ZeroPosition zeroPosition
        annotation (Placement(transformation(extent={{-60,-60},{-80,-40}})));
      Modelica_Mechanics_MultiBody.Interfaces.ZeroPosition zeroPosition1 if not (
        resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve)
        annotation (Placement(transformation(extent={{60,-60},{80,-40}})));
    equation
      connect(position.r, der1.u) annotation (Line(
          points={{-39,0},{-12,0}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(position.frame_a, frame_a) annotation (Line(
          points={{-60,0},{-80,0},{-80,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(der1.y, tansformAbsoluteVector.r_in) annotation (Line(
          points={{11,0},{38,0}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(tansformAbsoluteVector.r_out, v) annotation (Line(
          points={{61,0},{110,0}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, position.frame_resolve) annotation (Line(
          points={{-60,-50},{-50,-50},{-50,-10}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(tansformAbsoluteVector.frame_a, frame_a) annotation (Line(
          points={{50,10},{50,20},{-70,20},{-70,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(tansformAbsoluteVector.frame_resolve, zeroPosition1.frame_resolve)
        annotation (Line(
          points={{49.9,-10},{50,-10},{50,-50},{60,-50}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(tansformAbsoluteVector.frame_resolve, frame_resolve) annotation (Line(
          points={{49.9,-10},{50,-10},{50,-50},{0,-50},{0,-100}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      annotation (                                                 Icon(coordinateSystem(
              preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
            Line(
              points={{70,0},{100,0}},
              color={0,0,127},
              smooth=Smooth.None),
            Text(
              extent={{-130,72},{131,120}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{58,48},{142,18}},
              lineColor={0,0,0},
              textString="v"),
            Text(
              extent={{15,-67},{146,-92}},
              lineColor={95,95,95},
              textString="resolve"),
            Line(
              points={{0,-70},{0,-95}},
              color={95,95,95},
              smooth=Smooth.None,
              pattern=LinePattern.Dot)}),
        Documentation(info="<html>
<p>
The absolute velocity vector of the origin of frame_a is
determined and provided at the output signal connector <b>v</b>.
</p>

<p>
Via parameter <b>resolveInFrame</b> it is defined, in which frame
the velocity vector is resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>resolveInFrame =<br>Types.ResolveInFrameA.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve vector in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve vector in frame_a</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve vector in frame_resolve</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameA.frame_resolve, the conditional connector
\"frame_resolve\" is enabled and v is resolved in the frame, to
which frame_resolve is connected. Note, if this connector is enabled, it must
be connected.
</p>

<p>
Example: If resolveInFrame = Types.ResolveInFrameA.frame_a, the output vector is
computed as:
</p>

<pre>
    v0 = der(frame_a.r_0);
    v  = MultiBody.Frames.resolve2(frame_a.R, v0);
</pre>

</html>"));
    end AbsoluteVelocity;

    model AbsoluteAngles
      "Measure absolute angles between frame connector and the world frame"
      extends Modelica_Icons.RotationalSensor;
      Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a
        "Coordinate system a from which the angles shall be determined"
        annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
              rotation=0)));

      Modelica_Blocks.Interfaces.RealOutput angles[3](
        each final quantity="Angle",
        each final unit="rad",
        each displayUnit="deg")
        "Angles to rotate world frame into frame_a via 'sequence'"
        annotation (Placement(transformation(
            origin={110,0},
            extent={{-10,-10},{10,10}},
            rotation=0)));
      parameter Types.RotationSequence sequence(
        min={1,1,1},
        max={3,3,3})={1,2,3}
        "Angles are returned to rotate world frame around axes sequence[1], sequence[2] and finally sequence[3] into frame_a"
        annotation (Evaluate=true);
      parameter Modelica_SIunits.Angle guessAngle1=0
        "Select angles[1] such that abs(angles[1] - guessAngle1) is a minimum";

    equation
      frame_a.f = zeros(3);
      frame_a.t = zeros(3);
      angles = Frames.axesRotationsAngles(
            frame_a.R,
            sequence,
            guessAngle1);
      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                -100},{100,100}}), graphics={
            Text(
              extent={{-108,43},{-72,18}},
              lineColor={128,128,128},
              textString="a"),
            Line(
              points={{-70,0},{-96,0},{-96,0}},
              color={0,0,0},
              smooth=Smooth.None),
            Text(
              extent={{-132,76},{129,124}},
              textString="%name",
              lineColor={0,0,255}),
            Line(
              points={{70,0},{100,0}},
              color={0,0,127},
              smooth=Smooth.None),
            Text(
              extent={{62,-22},{172,-44}},
              lineColor={0,0,0},
              textString="angles")}),      Documentation(info="<html>
<p>
This model determines the 3 angles to rotate the world frame
into frame_a along the axes defined by parameter <b>sequence</b>.
For example, if sequence = {3,1,2} then the world frame is
rotated around angles[1] along the z-axis, afterwards it is rotated
around angles[2] along the x-axis, and finally it is rotated around
angles[3] along the y-axis and is then identical to frame_a.
The 3 angles are returned in the range
</p>
<pre>
    -<font face=\"Symbol\">p</font> &lt;= angles[i] &lt;= <font face=\"Symbol\">p</font>
</pre>
<p>
There are <b>two solutions</b> for \"angles[1]\" in this range.
Via parameter <b>guessAngle1</b> (default = 0) the
returned solution is selected such that |angles[1] - guessAngle1| is
minimal. The transformation matrix between the world frame and
frame_a may be in a singular configuration with respect to \"sequence\", i.e.,
there is an infinite number of angle values leading to the same relative
transformation matrix. In this case, the returned solution is
selected by setting angles[1] = guessAngle1. Then angles[2]
and angles[3] can be uniquely determined in the above range.
</p>
<p>
The parameter <b>sequence</b> has the restriction that
only values 1,2,3 can be used and that sequence[1] &ne; sequence[2]
and sequence[2] &ne; sequence[3]. Often used values are:
</p>
<pre>
  sequence = <b>{1,2,3}</b>  // Cardan or Tait-Bryan angle sequence
           = <b>{3,1,3}</b>  // Euler angle sequence
           = <b>{3,2,1}</b>
</pre>
</html>"));
    end AbsoluteAngles;

    model AbsoluteAngularVelocity
      "Measure absolute angular velocity of frame connector"
      extends Internal.PartialAbsoluteSensor;
      Modelica_Blocks.Interfaces.RealOutput w[3](each final quantity=
            "AngularVelocity", each final unit="rad/s")
        "Absolute angular velocity vector of frame_a with respect to world frame, resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=0,
            origin={110,0})));

      Modelica_Mechanics_MultiBody.Interfaces.Frame_resolve frame_resolve if
        resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve
        "Coordinate system in which w is optionally resolved" annotation (
          Placement(transformation(
            extent={{-16,-16},{16,16}},
            rotation=-90,
            origin={0,-100}), iconTransformation(
            extent={{-16,-16},{16,16}},
            rotation=-90,
            origin={0,-101})));

      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameA resolveInFrame=Types.ResolveInFrameA.frame_a
        "Frame in which output vector w shall be resolved (world, frame_a, or frame_resolve)";

    protected
      Internal.BasicAbsoluteAngularVelocity angularVelocity(resolveInFrame=
            resolveInFrame)
        annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
      Modelica_Mechanics_MultiBody.Interfaces.ZeroPosition zeroPosition if not (
        resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve)
        annotation (Placement(transformation(extent={{40,-40},{60,-20}})));

    equation
      connect(angularVelocity.frame_resolve, frame_resolve)  annotation (Line(
          points={{0,-10},{0,-100}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, angularVelocity.frame_resolve)
        annotation (Line(
          points={{40,-30},{0,-30},{0,-10}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(angularVelocity.w, w) annotation (Line(
          points={{11,0},{110,0}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(angularVelocity.frame_a, frame_a) annotation (Line(
          points={{-10,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      annotation (              Icon(coordinateSystem(
              preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
            Line(
              points={{70,0},{100,0}},
              color={0,0,127},
              smooth=Smooth.None),
            Text(
              extent={{-127,77},{134,125}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{66,48},{150,18}},
              lineColor={0,0,0},
              textString="w"),
            Line(
              points={{0,-70},{0,-96}},
              color={95,95,95},
              smooth=Smooth.None,
              pattern=LinePattern.Dot),
            Text(
              extent={{15,-67},{146,-92}},
              lineColor={95,95,95},
              textString="resolve")}),
        Documentation(info="<html>
<p>
The absolute angular velocity of frame_a with respect to the
world frame is
determined and provided at the output signal connector <b>w</b>.
</p>

<p>
Via parameter <b>resolveInFrame</b> it is defined, in which frame
the angular velocity is resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>resolveInFrame =<br>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve vector in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve vector in frame_a</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve vector in frame_resolve</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameA.frame_resolve, the conditional connector
\"frame_resolve\" is enabled and w is resolved in the frame, to
which frame_resolve is connected. Note, if this connector is enabled, it must
be connected.
</p>

<p>
Example: If resolveInFrame = Types.ResolveInFrameA.frame_a, the output vector is
computed as:
</p>

<pre>
    w = MultiBody.Frames.angularVelocity2(frame_a.R);
</pre>

</html>"));
    end AbsoluteAngularVelocity;

    model RelativePosition
      "Measure relative position vector between the origins of two frame connectors"
      extends Internal.PartialRelativeSensor;
      Modelica_Blocks.Interfaces.RealOutput r_rel[3]
        "Relative position vector resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=-90,
            origin={0,-110})));

      Modelica_Mechanics_MultiBody.Interfaces.Frame_resolve frame_resolve if
        resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve
        "Coordinate system in which r_rel is optionally resolved" annotation (
          Placement(transformation(extent={{84,64},{116,96}}),
            iconTransformation(extent={{84,65},{116,97}})));

      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB resolveInFrame=Types.ResolveInFrameAB.frame_a
        "Frame in which output vector r_rel shall be resolved (world, frame_a, frame_b, or frame_resolve)";

    protected
      Internal.BasicRelativePosition relativePosition(resolveInFrame=resolveInFrame)
        annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      Modelica_Mechanics_MultiBody.Interfaces.ZeroPosition zeroPosition if not (
        resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve)
        annotation (Placement(transformation(extent={{52,20},{72,40}})));

    equation
      connect(relativePosition.frame_a, frame_a) annotation (Line(
          points={{-10,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(relativePosition.frame_b, frame_b) annotation (Line(
          points={{10,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(relativePosition.frame_resolve, frame_resolve) annotation (Line(
          points={{10,8.1},{26,8.1},{26,8},{36,8},{36,80},{100,80}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, relativePosition.frame_resolve)
        annotation (Line(
          points={{52,30},{36,30},{36,8.1},{10,8.1}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(relativePosition.r_rel, r_rel) annotation (Line(
          points={{0,-11},{0,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      annotation ( Icon(coordinateSystem(
              preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
            Line(
              points={{0,-70},{0,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Text(
              extent={{-127,95},{134,143}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{18,-80},{102,-110}},
              lineColor={0,0,0},
              textString="r_rel")}),
        Documentation(info="<html>
<p>
The relative position vector between the origins of frame_a and frame_b are
determined and provided at the output signal connector <b>r_rel</b>.
</p>

<p>
Via parameter <b>resolveInFrame</b> it is defined, in which frame
the position vector is resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>resolveInFrame =<br>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve vector in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve vector in frame_a</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve vector in frame_b</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve vector in frame_resolve</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the conditional connector
\"frame_resolve\" is enabled and r_rel is resolved in the frame, to
which frame_resolve is connected. Note, if this connector is enabled, it must
be connected.
</p>

<p>
Example: If resolveInFrame = Types.ResolveInFrameAB.frame_a, the output vector is
computed as:
</p>

<pre>
    r_rel = MultiBody.Frames.resolve2(frame_a.R, frame_b.r_0 - frame_a.r_0);
</pre>
</html>"));
    end RelativePosition;

    model RelativeVelocity
      "Measure relative velocity vector between the origins of two frame connectors"
      extends Internal.PartialRelativeSensor;
      Modelica_Blocks.Interfaces.RealOutput v_rel[3](each final quantity="Velocity", each final
                unit =                                                                        "m/s")
        "Relative velocity vector resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=-90,
            origin={0,-110})));

      Modelica_Mechanics_MultiBody.Interfaces.Frame_resolve frame_resolve if
        resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve
        "Coordinate system in which v_rel is optionally resolved" annotation (
          Placement(transformation(extent={{84,64},{116,96}}),
            iconTransformation(extent={{84,65},{116,97}})));

      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB resolveInFrame=Types.ResolveInFrameAB.frame_a
        "Frame in which output vector v_rel shall be resolved (world, frame_a, frame_b, or frame_resolve)";

    protected
      RelativePosition relativePosition(resolveInFrame=Types.ResolveInFrameAB.frame_a)
        annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
      Modelica_Mechanics_MultiBody.Interfaces.ZeroPosition zeroPosition if not (
        resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve)
        annotation (Placement(transformation(extent={{50,-60},{70,-40}})));
      Modelica_Blocks.Continuous.Der der_r_rel[3]                      annotation (Placement(transformation(
            extent={{-20,-20},{0,0}},
            rotation=-90,
            origin={10,-40})));
      Modelica_Mechanics_MultiBody.Sensors.TransformRelativeVector tansformRelativeVector(
          frame_r_in=Types.ResolveInFrameAB.frame_a, frame_r_out=resolveInFrame)
        annotation (Placement(transformation(extent={{-10,-80},{10,-60}})));
    equation
      connect(relativePosition.frame_a, frame_a) annotation (Line(
          points={{-10,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(relativePosition.frame_b, frame_b) annotation (Line(
          points={{10,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(relativePosition.r_rel, der_r_rel.u)
                                              annotation (Line(
          points={{0,-11},{0,-18}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(der_r_rel.y, tansformRelativeVector.r_in) annotation (Line(
          points={{0,-41},{0,-58}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(tansformRelativeVector.r_out, v_rel) annotation (Line(
          points={{0,-81},{0,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(tansformRelativeVector.frame_a, frame_a) annotation (Line(
          points={{-10,-70},{-70,-70},{-70,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(tansformRelativeVector.frame_b, frame_b) annotation (Line(
          points={{10,-70},{80,-70},{80,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(tansformRelativeVector.frame_resolve, frame_resolve) annotation (Line(
          points={{10,-61.9},{35,-61.9},{35,80},{100,80}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, tansformRelativeVector.frame_resolve)
        annotation (Line(
          points={{50,-50},{35,-50},{35,-61.9},{10,-61.9}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      annotation (              Icon(coordinateSystem(
              preserveAspectRatio=true,  extent={{-100,-100},{100,100}}), graphics={
            Line(
              points={{0,-70},{0,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Text(
              extent={{-127,95},{134,143}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{18,-80},{102,-110}},
              lineColor={0,0,0},
              textString="v_rel")}),
        Documentation(info="<html>
<p>
The relative velocity vector between the origins of frame_a and of frame_b are
determined and provided at the output signal connector <b>v_rel</b>.
This vector is defined as:
</p>

<pre>
    r_rel = MultiBody.Frames.resolve2(frame_a.R, frame_b.r_0 - frame_a.r_0);
    v_rel = <b>der</b>(r_rel);
</pre>

<p>
Via parameter <b>resolveInFrame</b> it is defined, in which frame
the velocity vector is resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>resolveInFrame =<br>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve vector in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve vector in frame_a</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve vector in frame_b</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve vector in frame_resolve</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the conditional connector
\"frame_resolve\" is enabled and v_rel is resolved in the frame, to
which frame_resolve is connected. Note, if this connector is enabled, it must
be connected.
</p>

<p>
Example: If resolveInFrame = Types.ResolveInFrameAB.frame_b, the output vector is
computed as:
</p>

<pre>
    r_rel   = MultiBody.Frames.resolve2(frame_a.R, frame_b.r_0 - frame_a.r_0);
    v_rel_a = <b>der</b>(r_rel);
    v_rel   = MultiBody.Frames.resolveRelative(frame_a.R, frame_b.R, v_rel_a);
</pre>

</html>"));
    end RelativeVelocity;

    model RelativeAngles "Measure relative angles between two frame connectors"
      extends Modelica_Icons.RotationalSensor;
      Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a
        "Coordinate system a" annotation (Placement(transformation(extent={{-116,
                -16},{-84,16}}, rotation=0)));
      Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_b
        "Coordinate system b" annotation (Placement(transformation(extent={{84,
                -16},{116,16}}, rotation=0)));

      Modelica_Blocks.Interfaces.RealOutput angles[3](
        each final quantity="Angle",
        each final unit="rad",
        each displayUnit="deg")
        "Angles to rotate frame_a into frame_b via 'sequence'"
        annotation (Placement(transformation(
            origin={0,-110},
            extent={{-10,-10},{10,10}},
            rotation=270)));
      parameter Types.RotationSequence sequence(
        min={1,1,1},
        max={3,3,3})={1,2,3}
        "Angles are returned to rotate frame_a around axes sequence[1], sequence[2] and finally sequence[3] into frame_b"
        annotation (Evaluate=true);
      parameter Modelica_SIunits.Angle guessAngle1=0
        "Select angles[1] such that abs(angles[1] - guessAngle1) is a minimum";
      Modelica_Mechanics_MultiBody.Frames.Orientation R_rel
        "Relative orientation object from frame_a to frame_b";

    equation
      frame_a.f = zeros(3);
      frame_a.t = zeros(3);
      frame_b.f = zeros(3);
      frame_b.t = zeros(3);
      R_rel = Modelica_Mechanics_MultiBody.Frames.relativeRotation(frame_a.R,
        frame_b.R);
      angles = Frames.axesRotationsAngles(
            R_rel,
            sequence,
            guessAngle1);
      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                -100},{100,100}}), graphics={
            Text(
              extent={{-108,43},{-72,18}},
              lineColor={128,128,128},
              textString="a"),
            Text(
              extent={{72,41},{108,16}},
              lineColor={128,128,128},
              textString="b"),
            Line(
              points={{-70,0},{-96,0},{-96,0}},
              color={0,0,0},
              smooth=Smooth.None),
            Line(
              points={{96,0},{70,0},{70,0}},
              color={0,0,0},
              smooth=Smooth.None),
            Text(
              extent={{-132,90},{129,138}},
              textString="%name",
              lineColor={0,0,255}),
            Line(
              points={{0,-70},{0,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Text(
              extent={{0,-76},{110,-98}},
              lineColor={0,0,0},
              textString="angles")}),      Documentation(info="<html>
<p>
This model determines the 3 angles to rotate frame_a
into frame_b along the axes defined by parameter <b>sequence</b>.
For example, if sequence = {3,1,2} then frame_a is
rotated around angles[1] along the z-axis, afterwards it is rotated
around angles[2] along the x-axis, and finally it is rotated around
angles[3] along the y-axis and is then identical to frame_b.
The 3 angles are returned in the range
</p>
<pre>
    -<font face=\"Symbol\">p</font> &lt;= angles[i] &lt;= <font face=\"Symbol\">p</font>
</pre>
<p>
There are <b>two solutions</b> for \"angles[1]\" in this range.
Via parameter <b>guessAngle1</b> (default = 0) the
returned solution is selected such that |angles[1] - guessAngle1| is
minimal. The relative transformation matrix between frame_a and
frame_b may be in a singular configuration with respect to \"sequence\", i.e.,
there is an infinite number of angle values leading to the same relative
transformation matrix. In this case, the returned solution is
selected by setting angles[1] = guessAngle1. Then angles[2]
and angles[3] can be uniquely determined in the above range.
</p>
<p>
The parameter <b>sequence</b> has the restriction that
only values 1,2,3 can be used and that sequence[1] &ne; sequence[2]
and sequence[2] &ne; sequence[3]. Often used values are:
</p>
<pre>
  sequence = <b>{1,2,3}</b>  // Cardan or Tait-Bryan angle sequence
           = <b>{3,1,3}</b>  // Euler angle sequence
           = <b>{3,2,1}</b>
</pre>
</html>"));
    end RelativeAngles;

    model RelativeAngularVelocity
      "Measure relative angular velocity between two frame connectors"
      extends Internal.PartialRelativeSensor;
      Modelica_Blocks.Interfaces.RealOutput w_rel[3](each final quantity=
            "AngularVelocity", each final unit="rad/s")
        "Relative angular velocity vector between frame_a and frame_b resolved in frame defined by resolveInFrame"
        annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=-90,
            origin={0,-110})));

      Modelica_Mechanics_MultiBody.Interfaces.Frame_resolve frame_resolve if
        resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve
        "Coordinate system in which w_rel is optionally resolved" annotation (
          Placement(transformation(extent={{84,64},{116,96}}),
            iconTransformation(extent={{84,65},{116,97}})));

      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB resolveInFrame=Types.ResolveInFrameAB.frame_a
        "Frame in which output vector w_rel shall be resolved (world, frame_a, frame_b, or frame_resolve)";

    protected
      Internal.BasicRelativeAngularVelocity relativeAngularVelocity(resolveInFrame=
            resolveInFrame)
        annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
      Modelica_Mechanics_MultiBody.Interfaces.ZeroPosition zeroPosition if not (
        resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve)
        annotation (Placement(transformation(extent={{52,20},{72,40}})));

    equation
      connect(relativeAngularVelocity.frame_a, frame_a)
                                                 annotation (Line(
          points={{-10,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(relativeAngularVelocity.frame_b, frame_b)
                                                 annotation (Line(
          points={{10,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(relativeAngularVelocity.frame_resolve, frame_resolve)
                                                             annotation (Line(
          points={{10,8.1},{26,8.1},{26,8},{34,8},{34,80},{100,80}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, relativeAngularVelocity.frame_resolve)
        annotation (Line(
          points={{52,30},{34,30},{34,8.1},{10,8.1}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(relativeAngularVelocity.w_rel, w_rel)
                                             annotation (Line(
          points={{0,-11},{0,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      annotation ( Icon(coordinateSystem(
              preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
            Line(
              points={{0,-70},{0,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Text(
              extent={{-127,95},{134,143}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{14,-78},{98,-108}},
              lineColor={0,0,0},
              textString="w_rel")}),
        Documentation(info="<html>
<p>
The relative angular velocity between frame_a and frame_b is
determined and provided at the output signal connector <b>w_rel</b>.
</p>

<p>
Via parameter <b>resolveInFrame</b> it is defined, in which frame
the angular velocity is resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>resolveInFrame =<br>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve vector in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve vector in frame_a</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve vector in frame_b</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve vector in frame_resolve</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the conditional connector
\"frame_resolve\" is enabled and w_rel is resolved in the frame, to
which frame_resolve is connected. Note, if this connector is enabled, it must
be connected.
</p>

<p>
Example: If resolveInFrame = Types.ResolveInFrameAB.frame_a, the output vector is
computed as:
</p>

<pre>
    // Relative orientation object from frame_a to frame_b
    R_rel = MultiBody.Frames.relativeRotation(frame_a.R, frame_b.R);

    // Angular velocity resolved in frame_a
    w_rel = MultiBody.Frames.angularVelocity1(R_rel);
</pre>

</html>"));
    end RelativeAngularVelocity;

    model Distance
      "Measure the distance between the origins of two frame connectors"

      import Modelica_Mechanics_MultiBody.Frames;
      import Modelica_Mechanics_MultiBody.Types;

      extends Interfaces.PartialTwoFrames;
      extends Modelica_Icons.TranslationalSensor;
      Modelica_Blocks.Interfaces.RealOutput distance
        "Distance between the origin of frame_a and the origin of frame_b"
        annotation (Placement(transformation(
            origin={0,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));

      parameter Boolean animation=true
        "= true, if animation shall be enabled (show arrow)";
      input Modelica_SIunits.Diameter arrowDiameter=world.defaultArrowDiameter
        "Diameter of relative arrow from frame_a to frame_b"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Color arrowColor=Types.Defaults.SensorColor
        "Color of relative arrow from frame_a to frame_b"
        annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Position s_small(min=sqrt(Modelica_Constants.small))=
           1.E-10
        "Prevent zero-division if distance between frame_a and frame_b is zero"
        annotation (Dialog(tab="Advanced"));
    protected
      Modelica_Mechanics_MultiBody.Visualizers.Advanced.Arrow arrow(
        r=frame_a.r_0,
        r_head=frame_b.r_0 - frame_a.r_0,
        diameter=arrowDiameter,
        color=arrowColor,
        specularCoefficient=specularCoefficient) if world.enableAnimation and
        animation;

    protected
      Modelica_SIunits.Position r_rel_0[3]=frame_b.r_0 - frame_a.r_0
        "Position vector from frame_a to frame_b resolved in world frame";
      Modelica_SIunits.Area L2=r_rel_0*r_rel_0;
      Modelica_SIunits.Area s_small2=s_small^2;
    equation
      frame_a.f = zeros(3);
      frame_b.f = zeros(3);
      frame_a.t = zeros(3);
      frame_b.t = zeros(3);

      distance =  smooth(1,if noEvent(L2 > s_small2) then sqrt(L2) else L2/(2*s_small)*(3-L2/s_small2));
      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Line(points={{0,-60},{0,-100}}, color={0,0,255}),
            Line(points={{-70,0},{-101,0}}, color={0,0,0}),
            Line(points={{70,0},{100,0}}, color={0,0,0}),
            Text(
              extent={{-128,30},{133,78}},
              textString="%name",
              lineColor={0,0,255})}),
        Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                100,100}}), graphics={
            Line(points={{-70,0},{-101,0}}, color={0,0,0}),
            Line(points={{70,0},{100,0}}, color={0,0,0}),
            Line(points={{0,-60},{0,-100}}, color={0,0,255}),
            Text(
              extent={{-22,70},{20,46}},
              textString="s",
              lineColor={0,0,255}),
            Line(points={{-98,40},{88,40}}, color={0,0,255}),
            Polygon(
              points={{102,40},{87,46},{87,34},{102,40}},
              lineColor={0,0,255},
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid)}),
        Documentation(info="<HTML>
<p>
The <b>distance</b> between the origins of frame_a
and of frame_b are determined and provided at the
output signal connector <b>distance</b>. This
distance is always positive. <b>Derivatives</b> of this
signal can be easily obtained by connecting the
block
<a href=\"modelica://Modelica.Blocks.Continuous.Der\">Modelica.Blocks.Continuous.Der</a>
to \"distance\" (this block performs analytic differentiation
of the input signal using the der(..) operator).
</p>
<p>
In the following figure the animation of a Distance
sensor is shown. The light blue coordinate system is
frame_a, the dark blue coordinate system is frame_b, and
the yellow arrow is the animated sensor.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Sensors/Distance.png\">
</p>

<p>
If the distance is smaller as parameter <b>s_small</b> (in the \"advanced\" menu),
it is approximated such that its derivative is
finite for zero distance. Without such an approximation, the derivative would
be infinite and a division by zero would occur. The approximation is performed
in the following way: If distance > s_small, it is computed as sqrt(r*r) where
r is the position vector from the origin of frame_a to the origin of frame_b.
If the distance becomes smaller as s_small, the \"sqrt()\" function is approximated
by a second order polynomial, such that the function value and its first derivative
are identical for sqrt() and the polynomial at s_small. Furthermore, the polynomial
passes through zero. The effect is, that the distance function is continuous and
differentiable everywhere. The derivative at zero distance is 3/(2*s_small).
</p>
</HTML>"));
    end Distance;

    model CutForce "Measure cut force vector"

      Modelica_Blocks.Interfaces.RealOutput force[3](each final quantity="Force", each final unit="N")
        "Cut force resolved in frame defined by resolveInFrame"
           annotation (Placement(transformation(
            origin={-80,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));

      parameter Boolean animation=true
        "= true, if animation shall be enabled (show arrow)";
      parameter Boolean positiveSign=true
        "= true, if force with positive sign is returned (= frame_a.f), otherwise with negative sign (= frame_b.f)";

      input Real N_to_m(unit="N/m") = 1000
        "Force arrow scaling (length = force/N_to_m)"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter forceDiameter=world.defaultArrowDiameter
        "Diameter of force arrow"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Color forceColor=Types.Defaults.ForceColor
        "Color of force arrow"
        annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));

      extends
        Modelica_Mechanics_MultiBody.Sensors.Internal.PartialCutForceSensor;

    protected
      Modelica_SIunits.Position f_in_m[3]=frame_a.f*(if positiveSign then +1
           else -1)/N_to_m "Force mapped from N to m for animation";
      Visualizers.Advanced.Arrow forceArrow(
        diameter=forceDiameter,
        color=forceColor,
        specularCoefficient=specularCoefficient,
        R=frame_b.R,
        r=frame_b.r_0,
        r_tail=f_in_m,
        r_head=-f_in_m) if world.enableAnimation and animation;

      Internal.BasicCutForce cutForce(resolveInFrame=resolveInFrame, positiveSign=
            positiveSign)
        annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));
      Modelica_Mechanics_MultiBody.Interfaces.ZeroPosition zeroPosition if not (
        resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve)
        annotation (Placement(transformation(extent={{0,-40},{20,-20}})));
    equation
      connect(cutForce.frame_a, frame_a)      annotation (Line(
          points={{-50,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(cutForce.frame_b, frame_b)      annotation (Line(
          points={{-30,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(cutForce.frame_resolve, frame_resolve)      annotation (Line(
          points={{-32,-10},{-32,-60},{80,-60},{80,-100}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(cutForce.force, force)      annotation (Line(
          points={{-48,-11},{-48,-60},{-80,-60},{-80,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, cutForce.frame_resolve)      annotation (
          Line(
          points={{0,-30},{-32,-30},{-32,-10}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={Text(
              extent={{-190,-70},{-74,-96}},
              lineColor={0,0,0},
              textString="force"), Line(points={{-80,-100},{-80,0}}, color={0,0,
                  127})}),
        Documentation(info="<HTML>
<p>
The cut-force acting between the two frames to which this
model is connected, is determined and provided at the output signal connector
<b>force</b> (= frame_a.f). If parameter <b>positiveSign</b> =
<b>false</b>, the negative cut-force is provided (= frame_b.f).

<p>
Via parameter <b>resolveInFrame</b> it is defined, in which frame
the force vector is resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>resolveInFrame =<br>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve vector in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve vector in frame_a</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve vector in frame_b</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve vector in frame_resolve</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the conditional connector
\"frame_resolve\" is enabled and output force is resolved in the frame, to
which frame_resolve is connected. Note, if this connector is enabled, it must
be connected.
</p>

<p>
In the following figure the animation of a CutForce
sensor is shown. The dark blue coordinate system is frame_b,
and the green arrow is the cut force acting at frame_b and
with negative sign at frame_a.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Sensors/CutForce.png\">
</p>
</HTML>"));
    end CutForce;

    model CutTorque "Measure cut torque vector"

      Modelica_Blocks.Interfaces.RealOutput torque[3]
        "Cut torque resolved in frame defined by resolveInFrame"
           annotation (Placement(transformation(
            origin={-80,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));

      parameter Boolean animation=true
        "= true, if animation shall be enabled (show arrow)";
      parameter Boolean positiveSign=true
        "= true, if torque with positive sign is returned (= frame_a.t), otherwise with negative sign (= frame_b.t)";
      input Real Nm_to_m(unit="N.m/m") = 1000
        "Torque arrow scaling (length = torque/Nm_to_m)"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter torqueDiameter=world.defaultArrowDiameter
        "Diameter of torque arrow"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Color torqueColor=Types.Defaults.TorqueColor
        "Color of torque arrow"
        annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));

      extends
        Modelica_Mechanics_MultiBody.Sensors.Internal.PartialCutForceSensor;

    protected
      Modelica_SIunits.Position t_in_m[3]=frame_a.t*(if positiveSign then +1
           else -1)/Nm_to_m "Torque mapped from Nm to m for animation";
      Visualizers.Advanced.DoubleArrow torqueArrow(
        diameter=torqueDiameter,
        color=torqueColor,
        specularCoefficient=specularCoefficient,
        R=frame_b.R,
        r=frame_b.r_0,
        r_tail=t_in_m,
        r_head=-t_in_m) if world.enableAnimation and animation;
      Internal.BasicCutTorque cutTorque(resolveInFrame=resolveInFrame, positiveSign=
           positiveSign)
        annotation (Placement(transformation(extent={{-62,-10},{-42,10}})));
      Modelica_Mechanics_MultiBody.Interfaces.ZeroPosition zeroPosition if not (
        resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve)
        annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));
    equation
      connect(cutTorque.frame_a, frame_a) annotation (Line(
          points={{-62,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(cutTorque.frame_b, frame_b) annotation (Line(
          points={{-42,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(cutTorque.torque, torque) annotation (Line(
          points={{-60,-11},{-60,-80},{-80,-80},{-80,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(cutTorque.frame_resolve, frame_resolve) annotation (Line(
          points={{-44,-10},{-44,-74},{80,-74},{80,-100}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, cutTorque.frame_resolve) annotation (Line(
          points={{-20,-30},{-44,-30},{-44,-10}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                100}}), graphics={Text(
              extent={{-180,-72},{-64,-98}},
              lineColor={0,0,0},
              textString="torque"), Line(points={{-80,-100},{-80,0}}, color={0,0,
                  127})}),
        Documentation(info="<HTML>
<p>
The cut-torque acting between the two frames to which this
model is connected, is determined and provided at the output signal connector
<b>torque</b> (= frame_a.t). If parameter <b>positiveSign</b> =
<b>false</b>, the negative cut-torque is provided (= frame_b.t).
</p>

<p>
Via parameter <b>resolveInFrame</b> it is defined, in which frame
the torque vector is resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>resolveInFrame =<br>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve vector in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve vector in frame_a</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve vector in frame_b</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve vector in frame_resolve</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the conditional connector
\"frame_resolve\" is enabled and output torque is resolved in the frame, to
which frame_resolve is connected. Note, if this connector is enabled, it must
be connected.
</p>

<p>
In the following figure the animation of a CutTorque
sensor is shown. The dark blue coordinate system is frame_b,
and the green arrow is the cut torque acting at frame_b and
with negative sign at frame_a.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Sensors/CutTorque.png\">
</p>
</HTML>"));
    end CutTorque;

    model CutForceAndTorque "Measure cut force and cut torque vector"

      import Modelica_Mechanics_MultiBody.Types;

      Modelica_Blocks.Interfaces.RealOutput force[3](each final quantity="Force", each final unit="N")
        "Cut force resolved in frame defined by resolveInFrame"
           annotation (Placement(transformation(
            origin={-80,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));
      Modelica_Blocks.Interfaces.RealOutput torque[3]
        "Cut torque resolved in frame defined by resolveInFrame"
           annotation (Placement(transformation(
            origin={0,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));

      parameter Boolean animation=true
        "= true, if animation shall be enabled (show force and torque arrow)";
      parameter Boolean positiveSign=true
        "= true, if force and torque with positive sign is returned (= frame_a.f/.t), otherwise with negative sign (= frame_b.f/.t)";
      input Real N_to_m(unit="N/m") = 1000
        "Force arrow scaling (length = force/N_to_m)"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Real Nm_to_m(unit="N.m/m") = 1000
        "Torque arrow scaling (length = torque/Nm_to_m)"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter forceDiameter=world.defaultArrowDiameter
        "Diameter of force arrow"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter torqueDiameter=forceDiameter
        "Diameter of torque arrow"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Color forceColor=Types.Defaults.ForceColor
        "Color of force arrow"
        annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.Color torqueColor=Types.Defaults.TorqueColor
        "Color of torque arrow"
        annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));

      extends
        Modelica_Mechanics_MultiBody.Sensors.Internal.PartialCutForceSensor;

    protected
      parameter Integer csign=if positiveSign then +1 else -1;
      Modelica_SIunits.Position f_in_m[3]=frame_a.f*csign/N_to_m
        "Force mapped from N to m for animation";
      Modelica_SIunits.Position t_in_m[3]=frame_a.t*csign/Nm_to_m
        "Torque mapped from Nm to m for animation";
      Visualizers.Advanced.Arrow forceArrow(
        diameter=forceDiameter,
        color=forceColor,
        specularCoefficient=specularCoefficient,
        R=frame_b.R,
        r=frame_b.r_0,
        r_tail=f_in_m,
        r_head=-f_in_m) if world.enableAnimation and animation;
      Visualizers.Advanced.DoubleArrow torqueArrow(
        diameter=torqueDiameter,
        color=torqueColor,
        specularCoefficient=specularCoefficient,
        R=frame_b.R,
        r=frame_b.r_0,
        r_tail=t_in_m,
        r_head=-t_in_m) if world.enableAnimation and animation;
      Internal.BasicCutForce cutForce(resolveInFrame=resolveInFrame, positiveSign=
            positiveSign)
        annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
      Internal.BasicCutTorque cutTorque(resolveInFrame=resolveInFrame, positiveSign=
           positiveSign)
        annotation (Placement(transformation(extent={{-2,-10},{18,10}})));
      Modelica_Mechanics_MultiBody.Interfaces.ZeroPosition zeroPosition if not (
        resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve)
        annotation (Placement(transformation(extent={{60,30},{80,50}})));
    equation
      connect(cutForce.frame_a, frame_a) annotation (Line(
          points={{-60,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(cutForce.frame_b, cutTorque.frame_a) annotation (Line(
          points={{-40,0},{-2,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(cutTorque.frame_b, frame_b) annotation (Line(
          points={{18,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(cutForce.force, force) annotation (Line(
          points={{-58,-11},{-58,-20},{-80,-20},{-80,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(cutTorque.torque, torque) annotation (Line(
          points={{0,-11},{0,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, cutTorque.frame_resolve) annotation (Line(
          points={{60,40},{32,40},{32,-20},{16,-20},{16,-10}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, cutForce.frame_resolve) annotation (Line(
          points={{60,40},{-26,40},{-26,-20},{-42,-20},{-42,-10}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(cutForce.frame_resolve, frame_resolve) annotation (Line(
          points={{-42,-10},{-42,-70},{80,-70},{80,-100}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(cutTorque.frame_resolve, frame_resolve) annotation (Line(
          points={{16,-10},{16,-70},{80,-70},{80,-100}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                100}}), graphics={
            Line(points={{-80,-100},{-80,0}}, color={0,0,127}),
            Line(points={{0,-100},{0,-70}}, color={0,0,127}),
            Text(
              extent={{-188,-70},{-72,-96}},
              lineColor={0,0,0},
              textString="force"),
            Text(
              extent={{-56,-70},{60,-96}},
              lineColor={0,0,0},
              textString="torque")}),
        Documentation(info="<HTML>
<p>
The cut-force and cut-torque acting between the two frames to which this
model is connected, are determined and provided at the output signal connectors
<b>force</b> (= frame_a.f) and <b>torque</b> (= frame_a.t).
If parameter <b>positiveSign</b> =
<b>false</b>, the negative cut-force and cut-torque is provided
(= frame_b.f, frame_b.t).

<p>
Via parameter <b>resolveInFrame</b> it is defined, in which frame
the two vectors are resolved:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>resolveInFrame =<br>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve vectors in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve vectors in frame_a</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve vectors in frame_b</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve vectors in frame_resolve</td></tr>
</table>

<p>
If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the conditional connector
\"frame_resolve\" is enabled and the output vectors force and torque are resolved in the frame, to
which frame_resolve is connected. Note, if this connector is enabled, it must
be connected.
</p>

<p>
In the following figure the animation of a CutForceAndTorque
sensor is shown. The dark blue coordinate system is frame_b,
and the green arrows are the cut force and the cut torque,
respectively, acting at frame_b and
with negative sign at frame_a.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Sensors/CutForceAndTorque.png\">
</p>
</HTML>"));
    end CutForceAndTorque;

    model Power "Measure power flowing from frame_a to frame_b"
      extends Modelica_Icons.RotationalSensor;

      extends Modelica_Mechanics_MultiBody.Interfaces.PartialTwoFrames;
      Modelica_Blocks.Interfaces.RealOutput power(quantity="Power",unit="W")
        "Power at frame_a as output signal"
        annotation (Placement(transformation(
            origin={-80,-110},
            extent={{10,-10},{-10,10}},
            rotation=90)));

    equation
      Connections.branch(frame_a.R, frame_b.R);
      frame_a.r_0 = frame_b.r_0;
      frame_a.R = frame_b.R;
      zeros(3) = frame_a.f + frame_b.f;
      zeros(3) = frame_a.t + frame_b.t;
      power = frame_a.f*Frames.resolve2(frame_a.R, der(frame_a.r_0))
         + frame_a.t*Frames.angularVelocity2(frame_a.R);
      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Line(points={{-70,0},{-101,0}}, color={0,0,0}),
            Line(points={{70,0},{100,0}}, color={0,0,0}),
            Line(points={{-80,0},{-80,-100}}, color={0,0,127}),
            Text(
              extent={{-60,-92},{16,-114}},
              lineColor={0,0,0},
              textString="power"),
            Text(
              extent={{-128,126},{126,68}},
              textString="%name",
              lineColor={0,0,255})}),
        Documentation(info="<HTML>
<p>
This component provides the power flowing from frame_a to frame_b
as output signal <b>power</b>.
</p>
</HTML>"));
    end Power;

    model TransformAbsoluteVector
      "Transform absolute vector in to another frame"
      extends Modelica_Icons.RotationalSensor;

      Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a
        "Coordinate system from which absolute kinematic quantities are measured"
        annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
              rotation=0)));

      Modelica_Mechanics_MultiBody.Interfaces.Frame_resolve frame_resolve if (
        frame_r_in == Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve)
         or (frame_r_out == Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve)
        "Coordinate system in which r_in or r_out is optionally resolved"
        annotation (Placement(transformation(extent={{84,-16},{116,16}}),
            iconTransformation(extent={{84,-15},{116,17}})));

      Modelica_Blocks.Interfaces.RealInput r_in[3]
        "Input vector resolved in frame defined by frame_r_in" annotation (
          Placement(transformation(
            extent={{-20,-20},{20,20}},
            rotation=-90,
            origin={0,120})));
      Modelica_Blocks.Interfaces.RealOutput r_out[3]
        "Input vector r_in resolved in frame defined by frame_r_out"
        annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=-90,
            origin={0,-110})));

      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameA frame_r_in=Types.ResolveInFrameA.frame_a
        "Frame in which vector r_in is resolved (world, frame_a, or frame_resolve)";
      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameA frame_r_out=
          frame_r_in
        "Frame in which vector r_in shall be resolved and provided as r_out (world, frame_a, or frame_resolve)";

    protected
      Internal.BasicTransformAbsoluteVector basicTransformVector(frame_r_in=
            frame_r_in, frame_r_out=frame_r_out)
        annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
      Modelica_Mechanics_MultiBody.Interfaces.ZeroPosition zeroPosition if not (
        frame_r_in == Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve
         or frame_r_out == Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve)
        annotation (Placement(transformation(extent={{40,18},{60,38}})));

    equation
      connect(basicTransformVector.frame_a, frame_a) annotation (Line(
          points={{-10,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(basicTransformVector.frame_resolve, frame_resolve) annotation (Line(
          points={{10,0},{100,0}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, basicTransformVector.frame_resolve)
        annotation (Line(
          points={{40,28},{32,28},{32,0},{10,0}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(basicTransformVector.r_out, r_out) annotation (Line(
          points={{0,-11},{0,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(basicTransformVector.r_in, r_in) annotation (Line(
          points={{0,12},{0,120}},
          color={0,0,127},
          smooth=Smooth.None));
      annotation ( Icon(coordinateSystem(
              preserveAspectRatio=true,  extent={{-100,-100},{100,100}}),
            graphics={
            Line(
              points={{0,-70},{0,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Line(
              points={{0,100},{0,70}},
              color={0,0,127},
              smooth=Smooth.None),
            Text(
              extent={{-104,124},{-18,96}},
              lineColor={0,0,0},
              textString="r_in"),
            Text(
              extent={{-124,-76},{2,-104}},
              lineColor={0,0,0},
              textString="r_out"),
            Line(
              points={{95,0},{95,0},{70,0},{70,0}},
              color={0,0,0},
              smooth=Smooth.None,
              pattern=LinePattern.Dot),
            Text(
              extent={{58,47},{189,22}},
              lineColor={95,95,95},
              textString="resolve"),
            Line(
              points={{-70,0},{-96,0},{-96,0}},
              color={0,0,0},
              smooth=Smooth.None),
            Text(
              extent={{-116,45},{-80,20}},
              lineColor={95,95,95},
              textString="a")}),
        Documentation(info="<html>
<p>
The input vector \"Real r_in[3]\" is assumed to be an absolute kinematic quantity
of frame_a that is defined to be resolved in the frame defined
with parameter \"frame_r_in\". This model resolves vector r_in in the
coordinate system defined with parameter \"frame_r_out\" and returns the
transformed output vector as \"Real r_out[3]\";
</p>
</html>"));
    end TransformAbsoluteVector;

    model TransformRelativeVector
      "Transform relative vector in to another frame"
      extends Internal.PartialRelativeSensor;

      Modelica_Mechanics_MultiBody.Interfaces.Frame_resolve frame_resolve if (
        frame_r_in == Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve)
         or (frame_r_out == Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve)
        "Coordinate system in which r_in or r_out is optionally resolved"
        annotation (Placement(transformation(extent={{84,64},{116,96}}),
            iconTransformation(extent={{84,65},{116,97}})));

      Modelica_Blocks.Interfaces.RealInput r_in[3]
        "Input vector resolved in frame defined by frame_r_in" annotation (
          Placement(transformation(
            extent={{-20,-20},{20,20}},
            rotation=-90,
            origin={0,120})));
      Modelica_Blocks.Interfaces.RealOutput r_out[3]
        "Input vector r_in resolved in frame defined by frame_r_out"
        annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=-90,
            origin={0,-110})));

      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB frame_r_in=Types.ResolveInFrameAB.frame_a
        "Frame in which vector r_in is resolved (world, frame_a, frame_b, or frame_resolve)";
      parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB frame_r_out=
          frame_r_in
        "Frame in which vector r_in shall be resolved and provided as r_out (world, frame_a, frame_b, or frame_resolve)";

    protected
      Modelica_Mechanics_MultiBody.Sensors.Internal.BasicTransformRelativeVector
        basicTransformVector(frame_r_in=frame_r_in, frame_r_out=frame_r_out)
        annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
      Modelica_Mechanics_MultiBody.Interfaces.ZeroPosition zeroPosition if not (
        frame_r_in == Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve
         or frame_r_out == Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB.frame_resolve)
        annotation (Placement(transformation(extent={{48,10},{68,30}})));

    equation
      connect(basicTransformVector.frame_a, frame_a) annotation (Line(
          points={{-10,0},{-100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(basicTransformVector.frame_b, frame_b) annotation (Line(
          points={{10,0},{100,0}},
          color={95,95,95},
          thickness=0.5,
          smooth=Smooth.None));
      connect(basicTransformVector.frame_resolve, frame_resolve) annotation (Line(
          points={{10,8.1},{20,8.1},{20,8},{32,8},{32,80},{100,80}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(zeroPosition.frame_resolve, basicTransformVector.frame_resolve)
        annotation (Line(
          points={{48,20},{32,20},{32,8.1},{10,8.1}},
          color={95,95,95},
          pattern=LinePattern.Dot,
          smooth=Smooth.None));
      connect(basicTransformVector.r_out, r_out) annotation (Line(
          points={{0,-11},{0,-110}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(basicTransformVector.r_in, r_in) annotation (Line(
          points={{0,12},{0,120}},
          color={0,0,127},
          smooth=Smooth.None));
      annotation ( Icon(coordinateSystem(
              preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
            Line(
              points={{0,-70},{0,-100}},
              color={0,0,127},
              smooth=Smooth.None),
            Line(
              points={{0,100},{0,70}},
              color={0,0,127},
              smooth=Smooth.None),
            Text(
              extent={{-104,124},{-18,96}},
              lineColor={0,0,0},
              textString="r_in"),
            Text(
              extent={{-124,-76},{2,-104}},
              lineColor={0,0,0},
              textString="r_out")}),
        Documentation(info="<html>
<p>
The input vector \"Real r_in[3]\" is assumed to be a relative kinematic quantity
between frame_a and frame_b
that is defined to be resolved in the frame defined
with parameter \"frame_r_in\". This model resolves vector r_in in the
coordinate system defined with parameter \"frame_r_out\" and returns the
transformed output vector as \"Real r_out[3]\";
</p>
</html>"));
    end TransformRelativeVector;

    package Internal "Internal package, should not be used by user"
      extends Modelica_Icons.InternalPackage;
      partial model PartialAbsoluteSensor
        "Partial absolute sensor model for sensors defined by components"
        extends Modelica_Icons.RotationalSensor;

        Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a
          "Coordinate system at which the kinematic quantities are measured"
          annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
                rotation=0)));

      equation
         assert(cardinality(frame_a) > 0, "Connector frame_a must be connected at least once");
        annotation ( Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={Text(
                extent={{-108,43},{-72,18}},
                lineColor={128,128,128},
                textString="a"), Line(
                points={{-70,0},{-96,0},{-96,0}},
                color={0,0,0},
                smooth=Smooth.None)}));
      end PartialAbsoluteSensor;

      model PartialAbsoluteBaseSensor
        "Partial absolute sensor models for sensors defined by equations (frame_resolve must be connected exactly once)"
        extends Modelica_Icons.RotationalSensor;

        Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a
          "Coordinate system from which kinematic quantities are measured"
          annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
                rotation=0)));

        Modelica_Mechanics_MultiBody.Interfaces.Frame_resolve frame_resolve
          "Coordinate system in which vector is optionally resolved"
          annotation (Placement(transformation(
              extent={{-16,-16},{16,16}},
              rotation=-90,
              origin={10,-100}), iconTransformation(
              extent={{-16,-16},{16,16}},
              rotation=-90,
              origin={0,-100})));

      equation
         assert(cardinality(frame_a) > 0, "Connector frame_a must be connected at least once");
         assert(cardinality(frame_resolve) == 1, "Connector frame_resolve must be connected exactly once");
         frame_a.f = zeros(3);
         frame_a.t = zeros(3);
         frame_resolve.f = zeros(3);
         frame_resolve.t = zeros(3);
        annotation ( Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-108,43},{-72,18}},
                lineColor={95,95,95},
                textString="a"),
              Line(
                points={{-70,0},{-96,0},{-96,0}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{0,15},{0,-15}},
                color={0,0,127},
                smooth=Smooth.None,
                origin={85,0},
                rotation=90),
              Line(
                points={{0,-95},{0,-95},{0,-70},{0,-70}},
                color={0,0,0},
                smooth=Smooth.None,
                pattern=LinePattern.Dot),
              Text(
                extent={{0,-75},{131,-100}},
                lineColor={95,95,95},
                textString="resolve")}));
      end PartialAbsoluteBaseSensor;

      partial model PartialRelativeSensor
        "Partial relative sensor model for sensors defined by components"
        extends Modelica_Icons.RotationalSensor;

        Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a
          "Coordinate system a" annotation (Placement(transformation(extent={{-116,
                  -16},{-84,16}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_b
          "Coordinate system b" annotation (Placement(transformation(extent={{
                  84,-16},{116,16}}, rotation=0)));

      equation
         assert(cardinality(frame_a) > 0, "Connector frame_a must be connected at least once");
         assert(cardinality(frame_b) > 0, "Connector frame_b must be connected at least once");
        annotation ( Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-108,43},{-72,18}},
                lineColor={128,128,128},
                textString="a"),
              Text(
                extent={{72,41},{108,16}},
                lineColor={128,128,128},
                textString="b"),
              Line(
                points={{-70,0},{-96,0},{-96,0}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{96,0},{70,0},{70,0}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{60,36},{60,36},{60,80},{95,80}},
                color={0,0,0},
                smooth=Smooth.None,
                pattern=LinePattern.Dot)}));
      end PartialRelativeSensor;

      model PartialRelativeBaseSensor
        "Partial relative sensor models for sensors defined by equations (frame_resolve must be connected exactly once)"
        extends Modelica_Icons.RotationalSensor;

        Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a
          "Coordinate system a (measurement is between frame_a and frame_b)"
          annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
                rotation=0)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_b
          "Coordinate system b (measurement is between frame_a and frame_b)"
          annotation (Placement(transformation(extent={{84,-16},{116,16}},
                rotation=0)));

        Modelica_Mechanics_MultiBody.Interfaces.Frame_resolve frame_resolve
          "Coordinate system in which vector is optionally resolved"
          annotation (Placement(transformation(extent={{84,64},{116,96}}),
              iconTransformation(extent={{84,65},{116,97}})));

      equation
         assert(cardinality(frame_a) > 0, "Connector frame_a must be connected at least once");
         assert(cardinality(frame_b) > 0, "Connector frame_b must be connected at least once");
         assert(cardinality(frame_resolve) == 1, "Connector frame_resolve must be connected exactly once");
         frame_a.f = zeros(3);
         frame_a.t = zeros(3);
         frame_b.f = zeros(3);
         frame_b.t = zeros(3);
         frame_resolve.f = zeros(3);
         frame_resolve.t = zeros(3);
        annotation ( Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-108,43},{-72,18}},
                lineColor={128,128,128},
                textString="a"),
              Text(
                extent={{72,41},{108,16}},
                lineColor={128,128,128},
                textString="b"),
              Line(
                points={{-70,0},{-96,0},{-96,0}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{96,0},{70,0},{70,0}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{0,-70},{0,-100}},
                color={0,0,127},
                smooth=Smooth.None),
              Line(
                points={{60,36},{60,36},{60,80},{95,80}},
                color={0,0,0},
                smooth=Smooth.None,
                pattern=LinePattern.Dot)}));
      end PartialRelativeBaseSensor;

      model BasicAbsolutePosition
        "Measure absolute position vector (same as Sensors.AbsolutePosition, but frame_resolve is not conditional and must be connected)"
        import Modelica_Mechanics_MultiBody.Types.ResolveInFrameA;
        extends
          Modelica_Mechanics_MultiBody.Sensors.Internal.PartialAbsoluteBaseSensor;
        Modelica_Blocks.Interfaces.RealOutput r[3](each final quantity="Length", each final
                  unit = "m")
          "Absolute position vector frame_a.r_0 resolved in frame defined by resolveInFrame"
          annotation (Placement(transformation(
              origin={110,0},
              extent={{-10,-10},{10,10}},
              rotation=0)));

        parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameA resolveInFrame=
            ResolveInFrameA.frame_a
          "Frame in which output vector r is resolved (world, frame_a, or frame_resolve)";

      equation
         if resolveInFrame == ResolveInFrameA.world then
            r = frame_a.r_0;
         elseif resolveInFrame == ResolveInFrameA.frame_a then
            r = Frames.resolve2(frame_a.R, frame_a.r_0);
         elseif resolveInFrame == ResolveInFrameA.frame_resolve then
            r = Frames.resolve2(frame_resolve.R, frame_a.r_0);
         else
            assert(false, "Wrong value for parameter resolveInFrame");
            r = zeros(3);
         end if;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{61,47},{145,17}},
                lineColor={0,0,0},
                textString="r"), Text(
                extent={{-127,75},{134,123}},
                textString="%name",
                lineColor={0,0,255})}));
      end BasicAbsolutePosition;

      model BasicAbsoluteAngularVelocity "Measure absolute angular velocity"
        import Modelica_Mechanics_MultiBody.Frames;
        import Modelica_Mechanics_MultiBody.Types.ResolveInFrameA;

        extends
          Modelica_Mechanics_MultiBody.Sensors.Internal.PartialAbsoluteBaseSensor;
        Modelica_Blocks.Interfaces.RealOutput w[3](each final quantity="AngularVelocity",each final unit = "rad/s")
          "Absolute angular velocity vector"
          annotation (Placement(transformation(
              origin={110,0},
              extent={{-10,-10},{10,10}},
              rotation=0)));
        parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameA resolveInFrame=
            ResolveInFrameA.frame_a
          "Frame in which output vector w is resolved (world, frame_a, or frame_resolve)";

      equation
         if resolveInFrame == ResolveInFrameA.world then
            w = Frames.angularVelocity1(frame_a.R);
         elseif resolveInFrame == ResolveInFrameA.frame_a then
            w = Frames.angularVelocity2(frame_a.R);
         elseif resolveInFrame == ResolveInFrameA.frame_resolve then
            w = Frames.resolveRelative(Frames.angularVelocity1(frame_a.R), frame_a.R, frame_resolve.R);
         else
            assert(false, "Wrong value for parameter resolveInFrame");
            w = zeros(3);
         end if;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{62,48},{146,18}},
                lineColor={0,0,0},
                textString="w"), Text(
                extent={{-130,76},{131,124}},
                textString="%name",
                lineColor={0,0,255})}));
      end BasicAbsoluteAngularVelocity;

      model BasicRelativePosition
        "Measure relative position vector (same as Sensors.RelativePosition, but frame_resolve is not conditional and must be connected)"
        import Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB;
        extends
          Modelica_Mechanics_MultiBody.Sensors.Internal.PartialRelativeBaseSensor;
        Modelica_Blocks.Interfaces.RealOutput r_rel[3](each final quantity="Length", each final
                  unit = "m")
          "Relative position vector frame_b.r_0 - frame_a.r_0 resolved in frame defined by resolveInFrame"
          annotation (Placement(transformation(
              origin={0,-110},
              extent={{-10,-10},{10,10}},
              rotation=270)));

        parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB resolveInFrame=
            ResolveInFrameAB.frame_a
          "Frame in which output vector r_rel is resolved (world, frame_a, frame_b, or frame_resolve)";

      equation
         if resolveInFrame == ResolveInFrameAB.frame_a then
            r_rel = Frames.resolve2(frame_a.R, frame_b.r_0 - frame_a.r_0);
         elseif resolveInFrame == ResolveInFrameAB.frame_b then
            r_rel = Frames.resolve2(frame_b.R, frame_b.r_0 - frame_a.r_0);
         elseif resolveInFrame == ResolveInFrameAB.world then
            r_rel = frame_b.r_0 - frame_a.r_0;
         elseif resolveInFrame == ResolveInFrameAB.frame_resolve then
            r_rel = Frames.resolve2(frame_resolve.R, frame_b.r_0 - frame_a.r_0);
         else
            assert(false, "Wrong value for parameter resolveInFrame");
            r_rel = zeros(3);
         end if;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{12,-76},{96,-106}},
                lineColor={0,0,0},
                textString="r_rel"), Text(
                extent={{-127,95},{134,143}},
                textString="%name",
                lineColor={0,0,255})}));
      end BasicRelativePosition;

      model BasicRelativeAngularVelocity "Measure relative angular velocity"
        import Modelica_Mechanics_MultiBody.Frames;
        import Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB;

        extends
          Modelica_Mechanics_MultiBody.Sensors.Internal.PartialRelativeBaseSensor;
        Modelica_Blocks.Interfaces.RealOutput w_rel[3](each final quantity="AngularVelocity",each final unit = "rad/s")
          "Relative angular velocity vector"
          annotation (Placement(transformation(
              origin={0,-110},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB resolveInFrame=
            ResolveInFrameAB.frame_a
          "Frame in which output vector w_rel is resolved (world, frame_a, frame_b, or frame_resolve)";

      protected
        Modelica_Mechanics_MultiBody.Frames.Orientation R_rel
          "Relative orientation object from frame_a to frame_b";
      equation
         R_rel = Frames.relativeRotation(frame_a.R, frame_b.R);
         if resolveInFrame == ResolveInFrameAB.frame_a then
            w_rel = Frames.angularVelocity1(R_rel);
         elseif resolveInFrame == ResolveInFrameAB.frame_b then
            w_rel = Frames.angularVelocity2(R_rel);
         elseif resolveInFrame == ResolveInFrameAB.world then
            w_rel = Frames.resolve1(frame_a.R, Frames.angularVelocity1(R_rel));
         elseif resolveInFrame == ResolveInFrameAB.frame_resolve then
            w_rel = Frames.resolveRelative(Frames.angularVelocity1(R_rel), frame_a.R, frame_resolve.R);
         else
            assert(false, "Wrong value for parameter resolveInFrame");
            w_rel = zeros(3);
         end if;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{12,-76},{96,-106}},
                lineColor={0,0,0},
                textString="w_rel"), Text(
                extent={{-132,90},{129,138}},
                textString="%name",
                lineColor={0,0,255})}));
      end BasicRelativeAngularVelocity;

      model BasicTransformAbsoluteVector
        "Transform absolute vector in to another frame"
        import Modelica_Mechanics_MultiBody.Frames;
        import Modelica_Mechanics_MultiBody.Types.ResolveInFrameA;

        extends Modelica_Icons.RotationalSensor;

        parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameA frame_r_in=
            ResolveInFrameA.frame_a
          "Frame in which vector r_in is resolved (world, frame_a, or frame_resolve)";
        parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameA frame_r_out=
            frame_r_in
          "Frame in which vector r_out (= r_in in other frame) is resolved (world, frame_a, or frame_resolve)";

        Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a
          "Coordinate system from which absolute kinematic quantities are measured"
          annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
                rotation=0)));

        Modelica_Mechanics_MultiBody.Interfaces.Frame_resolve frame_resolve
          "Coordinate system in which vector is optionally resolved"
          annotation (Placement(transformation(
              extent={{-16,-16},{16,16}},
              rotation=0,
              origin={100,0}), iconTransformation(
              extent={{-16,-16},{16,16}},
              rotation=0,
              origin={100,0})));

        Modelica_Blocks.Interfaces.RealInput r_in[3]
          "Input vector resolved in frame defined by frame_r_in" annotation (
            Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120})));
        Modelica_Blocks.Interfaces.RealOutput r_out[3]
          "Input vector r_in resolved in frame defined by frame_r_out"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=-90,
              origin={0,-110})));

      protected
        Modelica_Mechanics_MultiBody.Frames.Orientation R1
          "Orientation object from world frame to frame in which r_in is resolved";
      equation
         assert(cardinality(frame_a) > 0, "Connector frame_a must be connected at least once");
         assert(cardinality(frame_resolve) == 1, "Connector frame_resolve must be connected exactly once");
         frame_a.f = zeros(3);
         frame_a.t = zeros(3);
         frame_resolve.f = zeros(3);
         frame_resolve.t = zeros(3);

         if frame_r_out == frame_r_in then
            r_out = r_in;
            R1 = Frames.nullRotation();
         else
            if frame_r_in == ResolveInFrameA.world then
               R1 = Frames.nullRotation();
            elseif frame_r_in == ResolveInFrameA.frame_a then
               R1 = frame_a.R;
            elseif frame_r_in == ResolveInFrameA.frame_resolve then
               R1 = frame_resolve.R;
            else
               assert(false, "Wrong value for parameter frame_r_in");
               R1 = Frames.nullRotation();
            end if;

            if frame_r_out == ResolveInFrameA.world then
               r_out = Frames.resolve1(R1, r_in);
            elseif frame_r_out == ResolveInFrameA.frame_a then
               r_out = Frames.resolveRelative(r_in, R1, frame_a.R);
            elseif frame_r_out == ResolveInFrameA.frame_resolve then
               r_out = Frames.resolveRelative(r_in, R1, frame_resolve.R);
            else
               assert(false, "Wrong value for parameter frame_r_out");
               r_out = zeros(3);
            end if;
         end if;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                  -100},{100,100}}), graphics={
              Text(
                extent={{-128,-84},{-2,-112}},
                lineColor={0,0,0},
                textString="r_out"),
              Text(
                extent={{-108,137},{-22,109}},
                lineColor={0,0,0},
                textString="r_in"),
              Line(
                points={{0,100},{0,70}},
                color={0,0,127},
                smooth=Smooth.None),
              Line(
                points={{0,-70},{0,-100}},
                color={0,0,127},
                smooth=Smooth.None),
              Text(
                extent={{58,47},{189,22}},
                lineColor={95,95,95},
                textString="resolve"),
              Text(
                extent={{-116,45},{-80,20}},
                lineColor={95,95,95},
                textString="a"),
              Line(
                points={{-70,0},{-96,0},{-96,0}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{95,0},{95,0},{70,0},{70,0}},
                color={0,0,0},
                smooth=Smooth.None,
                pattern=LinePattern.Dot)}));
      end BasicTransformAbsoluteVector;

      model BasicTransformRelativeVector
        "Transform relative vector in to another frame"
        import Modelica_Mechanics_MultiBody.Frames;
        import Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB;
        extends
          Modelica_Mechanics_MultiBody.Sensors.Internal.PartialRelativeBaseSensor;
        parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB frame_r_in=
            ResolveInFrameAB.frame_a
          "Frame in which vector r_in is resolved (world, frame_a, frame_b, or frame_resolve)";
        parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameAB frame_r_out=
            frame_r_in
          "Frame in which vector r_out (= r_in in other frame) is resolved (world, frame_a, frame_b, or frame_resolve)";

        Modelica_Blocks.Interfaces.RealInput r_in[3]
          "Input vector resolved in frame defined by frame_r_in" annotation (
            Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120})));
        Modelica_Blocks.Interfaces.RealOutput r_out[3]
          "Input vector r_in resolved in frame defined by frame_r_out"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=-90,
              origin={0,-110})));

      protected
        Modelica_Mechanics_MultiBody.Frames.Orientation R1
          "Orientation object from world frame to frame in which r_in is resolved";
      equation
         if frame_r_out == frame_r_in then
            r_out = r_in;
            R1 = Frames.nullRotation();
         else
            if frame_r_in == ResolveInFrameAB.world then
               R1 = Frames.nullRotation();
            elseif frame_r_in == ResolveInFrameAB.frame_a then
               R1 = frame_a.R;
            elseif frame_r_in == ResolveInFrameAB.frame_b then
               R1 = frame_b.R;
            else
               R1 = frame_resolve.R;
            end if;

            if frame_r_out == ResolveInFrameAB.world then
               r_out = Frames.resolve1(R1, r_in);
            elseif frame_r_out == ResolveInFrameAB.frame_a then
               r_out = Frames.resolveRelative(r_in, R1, frame_a.R);
            elseif frame_r_out == ResolveInFrameAB.frame_b then
               r_out = Frames.resolveRelative(r_in, R1, frame_b.R);
            else
               r_out = Frames.resolveRelative(r_in, R1, frame_resolve.R);
            end if;
         end if;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                  -100},{100,100}}), graphics={
              Text(
                extent={{-128,-92},{-2,-120}},
                lineColor={0,0,0},
                textString="r_out"),
              Text(
                extent={{-108,144},{-22,116}},
                lineColor={0,0,0},
                textString="r_in"),
              Line(
                points={{0,100},{0,70}},
                color={0,0,127},
                smooth=Smooth.None)}));
      end BasicTransformRelativeVector;

      model ZeroForceAndTorque "Set force and torque to zero"
         extends Modelica_Blocks.Icons.Block;
        Interfaces.Frame_a frame_a
          annotation (Placement(transformation(extent={{-116,-16},{-84,16}})));
      equation
        frame_a.f = zeros(3);
        frame_a.t = zeros(3);
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-74,24},{80,-20}},
                lineColor={0,0,0},
                textString="f = t = 0")}));
      end ZeroForceAndTorque;

      partial model PartialCutForceSensor
        "Base model to measure the cut force and/or torque between two frames, defined by components"

        extends Modelica_Icons.RotationalSensor;
        Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a
          "Coordinate system a" annotation (Placement(transformation(extent={{-116,
                  -16},{-84,16}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_b
          "Coordinate system b" annotation (Placement(transformation(extent={{
                  84,-16},{116,16}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_resolve frame_resolve if
          resolveInFrame == Modelica_Mechanics_MultiBody.Types.ResolveInFrameA.frame_resolve
          "Output vectors are optionally resolved in this frame (cut-force/-torque are set to zero)"
          annotation (Placement(transformation(
              origin={80,-100},
              extent={{-16,-16},{16,16}},
              rotation=270)));

        parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameA resolveInFrame=Types.ResolveInFrameA.frame_a
          "Frame in which output vector(s) is/are resolved (world, frame_a, or frame_resolve)";

      protected
        outer Modelica_Mechanics_MultiBody.World world;
      equation
        assert(cardinality(frame_a) > 0,
          "Connector frame_a of cut-force/-torque sensor object is not connected");
        assert(cardinality(frame_b) > 0,
          "Connector frame_b of cut-force/-torque sensor object is not connected");

        annotation (
          Documentation(info="<html>
<p>
This is a base class for 3-dim. mechanical components with two frames
and one output port in order to measure the cut-force and/or
cut-torque acting between the two frames and
to provide the measured signals as output for further processing
with the blocks of package Modelica.Blocks.
</p>
</html>"),       Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-70,0},{-101,0}}, color={0,0,0}),
              Line(points={{70,0},{100,0}}, color={0,0,0}),
              Text(
                extent={{-132,76},{129,124}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{-118,55},{-82,30}},
                lineColor={128,128,128},
                textString="a"),
              Text(
                extent={{83,55},{119,30}},
                lineColor={128,128,128},
                textString="b"),
              Text(
                extent={{70,-66},{201,-91}},
                lineColor={95,95,95},
                textString="resolve"),
              Line(
                points={{80,0},{80,-100}},
                color={95,95,95},
                pattern=LinePattern.Dot)}));
      end PartialCutForceSensor;

      partial model PartialCutForceBaseSensor
        "Base model to measure the cut force and/or torque between two frames, defined by equations (frame_resolve must be connected exactly once)"

        extends Modelica_Icons.RotationalSensor;
        Modelica_Mechanics_MultiBody.Interfaces.Frame_a frame_a
          "Coordinate system a" annotation (Placement(transformation(extent={{-116,
                  -16},{-84,16}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_b frame_b
          "Coordinate system b" annotation (Placement(transformation(extent={{
                  84,-16},{116,16}}, rotation=0)));
        Modelica_Mechanics_MultiBody.Interfaces.Frame_resolve frame_resolve
          "The output vector is optionally resolved in this frame (cut-force/-torque are set to zero)"
          annotation (Placement(transformation(
              origin={80,-100},
              extent={{-16,-16},{16,16}},
              rotation=270)));

        parameter Modelica_Mechanics_MultiBody.Types.ResolveInFrameA resolveInFrame=Types.ResolveInFrameA.frame_a
          "Frame in which output vector is resolved (world, frame_a, or frame_resolve)";

      protected
        outer Modelica_Mechanics_MultiBody.World world;
      equation
        Connections.branch(frame_a.R, frame_b.R);
        assert(cardinality(frame_a) > 0,
          "Connector frame_a of cut-force/-torque sensor object is not connected");
        assert(cardinality(frame_b) > 0,
          "Connector frame_b of cut-force/-torque sensor object is not connected");

        // frame_a and frame_b are identical
        frame_a.r_0 = frame_b.r_0;
        frame_a.R = frame_b.R;

        // force and torque balance
        zeros(3) = frame_a.f + frame_b.f;
        zeros(3) = frame_a.t + frame_b.t;
        frame_resolve.f = zeros(3);
        frame_resolve.t = zeros(3);
        annotation (
          Documentation(info="<html>
<p>
This is a base class for 3-dim. mechanical components with two frames
and one output port in order to measure the cut-force and/or
cut-torque acting between the two frames and
to provide the measured signals as output for further processing
with the blocks of package Modelica.Blocks.
</p>
</html>"),       Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-70,0},{-101,0}}, color={0,0,0}),
              Line(points={{70,0},{100,0}}, color={0,0,0}),
              Text(
                extent={{-132,76},{129,124}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{-118,55},{-82,30}},
                lineColor={128,128,128},
                textString="a"),
              Text(
                extent={{83,55},{119,30}},
                lineColor={128,128,128},
                textString="b"),
              Text(
                extent={{70,-66},{201,-91}},
                lineColor={95,95,95},
                textString="resolve"),
              Line(
                points={{80,0},{80,-100}},
                color={95,95,95},
                pattern=LinePattern.Dot)}));
      end PartialCutForceBaseSensor;

      model BasicCutForce
        "Measure cut force vector (frame_resolve must be connected)"

        import Modelica_Mechanics_MultiBody.Types.ResolveInFrameA;
        import Modelica_Mechanics_MultiBody.Frames;

        extends
          Modelica_Mechanics_MultiBody.Sensors.Internal.PartialCutForceBaseSensor;
        Modelica_Blocks.Interfaces.RealOutput force[3](each final quantity="Force", each final unit="N")
          "Cut force resolved in frame defined by resolveInFrame"
             annotation (Placement(transformation(
              origin={-80,-110},
              extent={{10,-10},{-10,10}},
              rotation=90)));
          parameter Boolean positiveSign=true
          "= true, if force with positive sign is returned (= frame_a.f), otherwise with negative sign (= frame_b.f)";
      protected
        parameter Integer csign=if positiveSign then +1 else -1;
      equation
         if resolveInFrame == ResolveInFrameA.world then
            force = Frames.resolve1(frame_a.R, frame_a.f)*csign;
         elseif resolveInFrame == ResolveInFrameA.frame_a then
            force = frame_a.f*csign;
         elseif resolveInFrame == ResolveInFrameA.frame_resolve then
            force = Frames.resolveRelative(frame_a.f, frame_a.R, frame_resolve.R)*csign;
         else
            assert(false,"Wrong value for parameter resolveInFrame");
            force = zeros(3);
         end if;
        annotation (
           Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Text(
                extent={{-190,-70},{-74,-96}},
                lineColor={0,0,0},
                textString="force"), Line(points={{-80,-100},{-80,0}}, color={0,0,
                    127})}),
          Documentation(info="<HTML>

</HTML>"));
      end BasicCutForce;

      model BasicCutTorque
        "Measure cut torque vector (frame_resolve must be connected)"

        import Modelica_Mechanics_MultiBody.Types.ResolveInFrameA;
        import Modelica_Mechanics_MultiBody.Frames;

        extends
          Modelica_Mechanics_MultiBody.Sensors.Internal.PartialCutForceBaseSensor;
        Modelica_Blocks.Interfaces.RealOutput torque[3](each final quantity="Torque", each final unit=
              "N.m") "Cut torque resolved in frame defined by resolveInFrame"
             annotation (Placement(transformation(
              origin={-80,-110},
              extent={{10,-10},{-10,10}},
              rotation=90)));

        parameter Boolean positiveSign=true
          "= true, if torque with positive sign is returned (= frame_a.t), otherwise with negative sign (= frame_b.t)";

      protected
        parameter Integer csign=if positiveSign then +1 else -1;
      equation
         if resolveInFrame == ResolveInFrameA.world then
            torque = Frames.resolve1(frame_a.R, frame_a.t)*csign;
         elseif resolveInFrame == ResolveInFrameA.frame_a then
            torque = frame_a.t*csign;
         elseif resolveInFrame == ResolveInFrameA.frame_resolve then
            torque = Frames.resolveRelative(frame_a.t, frame_a.R, frame_resolve.R)*csign;
         else
            assert(false,"Wrong value for parameter resolveInFrame");
            torque = zeros(3);
         end if;
        annotation (
           Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Text(
                extent={{-190,-70},{-74,-96}},
                lineColor={0,0,0},
                textString="torque"), Line(points={{-80,-100},{-80,0}}, color={0,
                    0,127})}));
      end BasicCutTorque;
    end Internal;

    model TansformAbsoluteVector
      "Obsolete model will be removed in future versions, use TransformAbsoluteVector instead!"
      extends TransformAbsoluteVector;
      // extends Modelica.Icons.ObsoleteModel;
    end TansformAbsoluteVector;

    model TansformRelativeVector
      "Obsolete model will be removed in future versions, use TransformRelativeVector instead!"
      extends TransformRelativeVector;
      // extends Modelica.Icons.ObsoleteModel;
    end TansformRelativeVector;

    annotation ( Documentation(info="<html>
<p>
Package <b>Sensors</b> contains <b>ideal measurement</b>
components to determine absolute and relative kinematic
quantities, as well as cut-forces, cut-torques and power. All
measured quantities can be provided in every desired
coordinate system.
</p>
</html>"));
  end Sensors;

  package Visualizers "3-dimensional visual objects used for animation"
    extends Modelica_Icons.Package;

    model FixedShape
      "Visualizing an elementary shape with dynamically varying shape attributes (has one frame connector)"
      import Modelica_Mechanics_MultiBody.Types;
      extends Modelica_Mechanics_MultiBody.Interfaces.PartialVisualizer;

      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Types.ShapeType shapeType="box" "Type of shape"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Position r_shape[3]={0,0,0}
        "Vector from frame_a to shape origin, resolved in frame_a"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Axis lengthDirection={1,0,0}
        "Vector in length direction of shape, resolved in frame_a"
        annotation (Evaluate=true, Dialog(group="if animation = true", enable=animation));
      input Types.Axis widthDirection={0,1,0}
        "Vector in width direction of shape, resolved in frame_a"
        annotation (Evaluate=true, Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Distance length(start=1) "Length of shape"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Distance width(start=0.1) "Width of shape"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Distance height(start=0.1) "Height of shape"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_Mechanics_MultiBody.Types.Color color={0,128,255}
        "Color of shape" annotation (Dialog(
          colorSelector=true,
          group="if animation = true",
          enable=animation));
      input Types.ShapeExtra extra=0.0
        "Additional data for cylinder, cone, pipe, gearwheel and spring"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));

    protected
      Advanced.Shape vis(
        shapeType=shapeType,
        r_shape=r_shape,
        lengthDirection=lengthDirection,
        widthDirection=widthDirection,
        length=length,
        width=width,
        height=height,
        color=color,
        extra=extra,
        specularCoefficient=specularCoefficient,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;
    equation
      // No forces and torques
      frame_a.f = zeros(3);
      frame_a.t = zeros(3);
      annotation (
        Documentation(info="<HTML>
<p>
Model <b>FixedShape</b> defines a visual shape that is
shown at the location of its frame_a.
All describing data such as size and color can vary dynamically by
providing appropriate expressions in the input fields of the
parameter menu. The only exception is parameter shapeType
that cannot be changed during simulation.
The following shapes are currently supported via
parameter <b>shapeType</b> (e.g., shapeType=\"box\"):<br>&nbsp;
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Shape.png\" ALT=\"model Visualizers.FixedShape\">
</p>

<p>
The dark blue arrows in the figure above are directed along
variable <b>lengthDirection</b>. The light blue arrows are directed
along variable <b>widthDirection</b>. The <b>coordinate systems</b>
in the figure represent frame_a of the FixedShape component.
</p>

<p>
Additionally, <b>external shapes</b> can be specified as (not all options might be supported by all tools):
</p>

<ul>
<li> <b>\"1\", \"2\", ...</b><br>
     define external shapes specified in DXF format in files \"1.dxf\", \"2.dxf\", ...
     The DXF-files must be found either in the current directory or in the directory where
     the Shape instance is stored that references the DXF file.
     This (very limited) option should not be used for new models. Example:<br>
    shapeType=\"1\".<br></li>

<li> \"<b>modelica:</b>//&lt;Modelica-name&gt;/&lt;relative-path-file-name&gt;\"<br>
     characterizes the file that is stored under the location of the
     &lt;Modelica-name&gt; library path with the given relative file name.
     Example:<br> shapeType = \"modelica://Modelica/Resources/Data/Shapes/Engine/piston.dxf\".<br></li>

<li> \"<b>file:</b>//&lt;absolute-file-name&gt;\"<br>
     characterizes an absolute file name in the file system. Example:<br>
     shapeType=\"file://C:/users/myname/shapes/piston.dxf\".</li>
</ul>

<p>
The supported file formats are tool dependent. Most tools support
at least DXF-files (a tool might support 3-dim. Face of the DXF format only),
but may support other format as well (such as stl, obj, 3ds).
Since visualization files contain color and other data, the corresponding
information in the model is usually ignored.
</p>

<p>
The sizes of any of the above components are specified by the
<b>length</b>, <b>width</b> and <b>height</b> variables.
Via variable <b>extra</b> additional data can be defined:
</p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>shapeType</b></th><th>Meaning of parameter <b>extra</b></th></tr>
<tr>
  <td valign=\"top\">\"cylinder\"</td>
  <td valign=\"top\">if extra &gt; 0, a black line is included in the
      cylinder to show the rotation of it.</td>
</tr>
<tr>
  <td valign=\"top\">\"cone\"</td>
  <td valign=\"top\">extra = diameter-left-side / diameter-right-side, i.e.,<br>
      extra = 1: cylinder<br>
      extra = 0: \"real\" cone.</td>
</tr>
<tr>
  <td valign=\"top\">\"pipe\"</td>
  <td valign=\"top\">extra = outer-diameter / inner-diameter, i.e, <br>
      extra = 1: cylinder that is completely hollow<br>
      extra = 0: cylinder without a hole.</td>
</tr>
<tr>
  <td valign=\"top\">\"gearwheel\"</td>
  <td valign=\"top\">extra is the number of teeth of the (external) gear.
If extra &lt; 0, an internal gear is visualized with |extra| teeth.
The axis of the gearwheel is along \"lengthDirection\", and usually:
width = height = 2*radiusOfGearWheel.</td>
</tr>
<tr>
  <td valign=\"top\">\"spring\"</td>
  <td valign=\"top\">extra is the number of windings of the spring.
      Additionally, \"height\" is <b>not</b> the \"height\" but
      2*coil-width.</td>
</tr>
<tr>
  <td valign=\"top\">external shape</td>
  <td valign=\"top\">extra = 0: Visualization from file is not scaled.<br>
                     extra = 1: Visualization from file is scaled with \"length\", \"width\" and height\"
                                of the shape</td>
</tr>
</table>
<p>
Parameter <b>color</b> is a vector with 3 elements,
{r, g, b}, and specifies the color of the shape.
{r,g,b} are the \"red\", \"green\" and \"blue\" color parts.
Note, r g, b are given as Integer[3] in the ranges 0 .. 255,
respectively. The predefined type
<a href=\"modelica://Modelica.Mechanics.MultiBody.Types.Color\">MultiBody.Types.Color</a> contains a menu
definition of the colors used in the MultiBody library together with a color editor.
</p>
</html>"),     Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Polygon(
              points={{-100,33},{-100,-61},{-10,-41},{50,-61},{50,33},{-10,11},{-100,
                  33}},
              lineColor={0,127,255},
              fillColor={0,127,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-98,34},{-64,46},{0,30},{74,56},{50,32},{-10,12},{-98,34}},
              lineColor={255,255,255},
              fillColor={160,160,164},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{72,54},{50,32},{50,-60},{72,-32},{72,54}},
              lineColor={255,255,255},
              fillColor={160,160,164},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,-65},{150,-95}},
              lineColor={0,0,0},
              textString="%shapeType"),
            Text(
              extent={{-150,100},{150,60}},
              textString="%name",
              lineColor={0,0,255})}));
    end FixedShape;

    model FixedShape2
      "Visualizing an elementary shape with dynamically varying shape attributes (has two frame connectors)"

      import Modelica_Mechanics_MultiBody.Frames;
      import Modelica_Mechanics_MultiBody.Types;
      import Modelica_SIunits.Conversions.to_unit1;

      Interfaces.Frame_a frame_a
        "Coordinate system a (all shape definition vectors are resolved in this frame)"
         annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
              rotation=0)));
      Interfaces.Frame_b frame_b "Coordinate system b"
         annotation (Placement(transformation(extent={{84,-16},{116,16}},
              rotation=0)));

      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Types.ShapeType shapeType="box" "Type of shape"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Position r[3]={1,0,0}
        "Vector from frame_a to frame_b resolved in frame_a";
      input Modelica_SIunits.Position r_shape[3]={0,0,0}
        "Vector from frame_a to shape origin, resolved in frame_a"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Axis lengthDirection = to_unit1(r - r_shape)
        "Vector in length direction of shape, resolved in frame_a"
        annotation (Evaluate=true, Dialog(group="if animation = true", enable=animation));
      input Types.Axis widthDirection={0,1,0}
        "Vector in width direction of shape, resolved in frame_a"
        annotation (Evaluate=true, Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Length length=Modelica_Math.Vectors.length(r -
          r_shape) "Length of shape"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Distance width=0.1 "Width of shape"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Distance height=width "Height of shape"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.ShapeExtra extra=0.0
        "Additional data for cylinder, cone, pipe, gearwheel and spring"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Color color={0,128,255} "Color of shape"
        annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));

    protected
      outer World world;
      Advanced.Shape shape(
        shapeType=shapeType,
        r_shape=r_shape,
        lengthDirection=lengthDirection,
        widthDirection=widthDirection,
        length=length,
        width=width,
        height=height,
        extra=extra,
        color=color,
        specularCoefficient = specularCoefficient,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;
    equation
      Connections.branch(frame_a.R, frame_b.R);
      assert(cardinality(frame_a) > 0 or cardinality(frame_b) > 0, "Neither connector frame_a nor frame_b of
MultiBody.Visualizers.FixedShape2 object is connected");

      frame_b.r_0 = frame_a.r_0 + Frames.resolve1(frame_a.R, r);
      frame_b.R = frame_a.R;

      /* Force and torque balance */
      zeros(3) = frame_a.f + frame_b.f;
      zeros(3) = frame_a.t + frame_b.t + cross(r, frame_b.f);
      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Text(
              extent={{-150,115},{150,75}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{150,-90},{-150,-60}},
              lineColor={0,0,0},
              textString="r=%r"),
            Polygon(
              points={{-100,50},{-100,-44},{-10,-24},{79,-43},{80,49},{-10,28},{-100,
                  50}},
              lineColor={0,127,255},
              fillColor={0,127,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-101,50},{-65,62},{-1,46},{100,70},{79,49},{-11,28},{-101,
                  50}},
              lineColor={255,255,255},
              fillColor={160,160,164},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-86,15},{-50,-10}},
              lineColor={0,0,0},
              textString="a"),
            Text(
              extent={{37,15},{73,-10}},
              lineColor={0,0,0},
              textString="b"),
            Polygon(
              points={{100,70},{78,48},{78,-44},{100,-16},{100,70}},
              lineColor={255,255,255},
              fillColor={160,160,164},
              fillPattern=FillPattern.Solid)}),
        Documentation(info="<HTML>
<p>
Model <b>FixedShape2</b> defines a visual shape that is
shown at the location of its frame_a. This model is identical
to <b>FixedShape</b> with the only difference that an
additional frame_b is present which is parallel to frame_a.
This makes it more convenient to connect several visual
shapes together when building up more complex visual
objects. All describing data such as size and color can vary dynamically by
providing appropriate expressions in the input fields of the
parameter menu. The only exception is parameter shapeType
that cannot be changed during simulation.
The following shapes are currently supported via
parameter <b>shapeType</b> (e.g., shapeType=\"box\"):<br>&nbsp;
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Shape.png\" ALT=\"model Visualizers.FixedShape2\">
</p>

<p>&nbsp;<br>
The dark blue arrows in the figure above are directed along
variable <b>lengthDirection</b>. The light blue arrows are directed
along variable <b>widthDirection</b>. The <b>coordinate systems</b>
in the figure represent frame_a of the FixedShape component.
</p>

<p>
Additionally, <b>external shapes</b> can be specified as (not all options might be supported by all tools):
</p>

<ul>
<li> <b>\"1\", \"2\", ...</b><br>
     define external shapes specified in DXF format in files \"1.dxf\", \"2.dxf\", ...
     The DXF-files must be found either in the current directory or in the directory where
     the Shape instance is stored that references the DXF file.
     This (very limited) option should not be used for new models. Example:<br>
    shapeType=\"1\".<br></li>

<li> \"<b>modelica:</b>//&lt;Modelica-name&gt;/&lt;relative-path-file-name&gt;\"<br>
     characterizes the file that is stored under the location of the
     &lt;Modelica-name&gt; library path with the given relative file name.
     Example:<br> shapeType = \"modelica://Modelica/Resources/Data/Shapes/Engine/piston.dxf\".<br></li>

<li> \"<b>file:</b>//&lt;absolute-file-name&gt;\"<br>
     characterizes an absolute file name in the file system. Example:<br>
     shapeType=\"file://C:/users/myname/shapes/piston.dxf\".</li>
</ul>

<p>
The supported file formats are tool dependent. Most tools support
at least DXF-files (a tool might support 3-dim. Face of the DXF format only),
but may support other format as well (such as stl, obj, 3ds).
Since visualization files contain color and other data, the corresponding
information in the model is usually ignored.
</p>

<p>
The sizes of any of the above components are specified by the
<b>length</b>, <b>width</b> and <b>height</b> variables.
Via variable <b>extra</b> additional data can be defined:
</p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>shapeType</b></th><th>Meaning of parameter <b>extra</b></th></tr>
<tr>
  <td valign=\"top\">\"cylinder\"</td>
  <td valign=\"top\">if extra &gt; 0, a black line is included in the
      cylinder to show the rotation of it.</td>
</tr>
<tr>
  <td valign=\"top\">\"cone\"</td>
  <td valign=\"top\">extra = diameter-left-side / diameter-right-side, i.e.,<br>
      extra = 1: cylinder<br>
      extra = 0: \"real\" cone.</td>
</tr>
<tr>
  <td valign=\"top\">\"pipe\"</td>
  <td valign=\"top\">extra = outer-diameter / inner-diameter, i.e, <br>
      extra = 1: cylinder that is completely hollow<br>
      extra = 0: cylinder without a hole.</td>
</tr>
<tr>
  <td valign=\"top\">\"gearwheel\"</td>
  <td valign=\"top\">extra is the number of teeth of the (external) gear.
If extra &lt; 0, an internal gear is visualized with |extra| teeth.
The axis of the gearwheel is along \"lengthDirection\", and usually:
width = height = 2*radiusOfGearWheel.</td>
</tr>
<tr>
  <td valign=\"top\">\"spring\"</td>
  <td valign=\"top\">extra is the number of windings of the spring.
      Additionally, \"height\" is <b>not</b> the \"height\" but
      2*coil-width.</td>
</tr>
<tr>
  <td valign=\"top\">external shape</td>
  <td valign=\"top\">extra = 0: Visualization from file is not scaled.<br>
                     extra = 1: Visualization from file is scaled with \"length\", \"width\" and height\"
                                of the shape</td>
</tr>
</table>
<p>
Parameter <b>color</b> is a vector with 3 elements,
{r, g, b}, and specifies the color of the shape.
{r,g,b} are the \"red\", \"green\" and \"blue\" color parts.
Note, r g, b are given as Integer[3] in the ranges 0 .. 255,
respectively. The predefined type
<a href=\"modelica://Modelica.Mechanics.MultiBody.Types.Color\">MultiBody.Types.Color</a> contains a menu
definition of the colors used in the MultiBody library together with a color editor.
</p>
<p>
In the following figure the relationships between
frame_a and frame_b are shown. The origin of frame_b
with respect to frame_a is specified via parameter
vector <b>r</b>.
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/FixedTranslation.png\" ALT=\"Parts.FixedTranslation\">
</p>
</html>"));
    end FixedShape2;

    model FixedFrame
      "Visualizing a coordinate system including axes labels (visualization data may vary dynamically)"

      import Modelica_Mechanics_MultiBody.Types;
      extends Modelica_Mechanics_MultiBody.Interfaces.PartialVisualizer;
      parameter Boolean animation=true "= true, if animation shall be enabled";
      parameter Boolean showLabels=true "= true, if labels shall be shown"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Distance length=0.5 "Length of axes arrows"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Distance diameter=length/world.defaultFrameDiameterFraction
        "Diameter of axes arrows"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Color color_x=Types.Defaults.FrameColor "Color of x-arrow"
        annotation (Dialog(colorSelector=true,group="if animation = true", enable=animation));
      input Types.Color color_y=color_x "Color of y-arrow"
        annotation (Dialog(colorSelector=true,group="if animation = true", enable=animation));
      input Types.Color color_z=color_x "Color of z-arrow"
        annotation (Dialog(colorSelector=true,group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));
    protected
      parameter Boolean animation2 = world.enableAnimation and animation;
      parameter Boolean showLabels2= world.enableAnimation and animation and showLabels;

      // Parameters to define axes
      Modelica_SIunits.Length headLength=min(length, diameter*Types.Defaults.FrameHeadLengthFraction);
      Modelica_SIunits.Length headWidth=diameter*Types.Defaults.FrameHeadWidthFraction;
      Modelica_SIunits.Length lineLength=max(0, length - headLength);
      Modelica_SIunits.Length lineWidth=diameter;

      // Parameters to define axes labels
      Modelica_SIunits.Length scaledLabel=Types.Defaults.FrameLabelHeightFraction
          *diameter;
      Modelica_SIunits.Length labelStart=1.05*length;

      // x-axis
      Visualizers.Advanced.Shape x_arrowLine(
        shapeType="cylinder",
        length=lineLength,
        width=lineWidth,
        height=lineWidth,
        lengthDirection={1,0,0},
        widthDirection={0,1,0},
        color=color_x,
        specularCoefficient=specularCoefficient,
        r=frame_a.r_0,
        R=frame_a.R) if animation2;
      Visualizers.Advanced.Shape x_arrowHead(
        shapeType="cone",
        length=headLength,
        width=headWidth,
        height=headWidth,
        lengthDirection={1,0,0},
        widthDirection={0,1,0},
        color=color_x,
        specularCoefficient=specularCoefficient,
        r=frame_a.r_0 + Frames.resolve1(frame_a.R, {lineLength,0,0}),
        R=frame_a.R) if animation2;
      Visualizers.Internal.Lines x_label(
        lines=scaledLabel*{[0, 0; 1, 1],[0, 1; 1, 0]},
        diameter=diameter,
        color=color_x,
        specularCoefficient=specularCoefficient,
        r_lines={labelStart,0,0},
        n_x={1,0,0},
        n_y={0,1,0},
        r=frame_a.r_0,
        R=frame_a.R) if showLabels2;

      // y-axis
      Visualizers.Advanced.Shape y_arrowLine(
        shapeType="cylinder",
        length=lineLength,
        width=lineWidth,
        height=lineWidth,
        lengthDirection={0,1,0},
        widthDirection={1,0,0},
        color=color_y,
        specularCoefficient=specularCoefficient,
        r=frame_a.r_0,
        R=frame_a.R) if animation2;
      Visualizers.Advanced.Shape y_arrowHead(
        shapeType="cone",
        length=headLength,
        width=headWidth,
        height=headWidth,
        lengthDirection={0,1,0},
        widthDirection={1,0,0},
        color=color_y,
        specularCoefficient=specularCoefficient,
        r=frame_a.r_0 + Frames.resolve1(frame_a.R, {0,lineLength,0}),
        R=frame_a.R) if animation2;
      Visualizers.Internal.Lines y_label(
        lines=scaledLabel*{[0, 0; 1, 1.5],[0, 1.5; 0.5, 0.75]},
        diameter=diameter,
        color=color_y,
        specularCoefficient=specularCoefficient,
        r_lines={0,labelStart,0},
        n_x={0,1,0},
        n_y={-1,0,0},
        r=frame_a.r_0,
        R=frame_a.R) if showLabels2;

      // z-axis
      Visualizers.Advanced.Shape z_arrowLine(
        shapeType="cylinder",
        length=lineLength,
        width=lineWidth,
        height=lineWidth,
        lengthDirection={0,0,1},
        widthDirection={0,1,0},
        color=color_z,
        specularCoefficient=specularCoefficient,
        r=frame_a.r_0,
        R=frame_a.R) if animation2;
      Visualizers.Advanced.Shape z_arrowHead(
        shapeType="cone",
        length=headLength,
        width=headWidth,
        height=headWidth,
        lengthDirection={0,0,1},
        widthDirection={0,1,0},
        color=color_z,
        specularCoefficient=specularCoefficient,
        r=frame_a.r_0 + Frames.resolve1(frame_a.R, {0,0,lineLength}),
        R=frame_a.R) if animation2;
      Visualizers.Internal.Lines z_label(
        lines=scaledLabel*{[0, 0; 1, 0],[0, 1; 1, 1],[0, 1; 1, 0]},
        diameter=diameter,
        color=color_z,
        specularCoefficient=specularCoefficient,
        r_lines={0,0,labelStart},
        n_x={0,0,1},
        n_y={0,1,0},
        r=frame_a.r_0,
        R=frame_a.R) if showLabels2;
    equation
      frame_a.f = zeros(3);
      frame_a.t = zeros(3);
      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-100,100},{100,-100}},
              lineColor={0,127,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-2,92},{-14,52},{12,52},{-2,92},{-2,92}},
              lineColor={0,191,0},
              fillColor={0,191,0},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-2,-18},{-2,52}},
              color={0,191,0},
              thickness=0.5),
            Text(
              extent={{16,93},{67,43}},
              lineColor={0,191,0},
              textString="y"),
            Text(
              extent={{43,11},{92,-38}},
              lineColor={0,0,0},
              textString="x"),
            Polygon(
              points={{98,-70},{74,-44},{64,-60},{98,-70}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-2,-18},{72,-54}},
              color={0,0,0},
              thickness=0.5),
            Line(
              points={{-72,-54},{-2,-18}},
              thickness=0.5,
              color={0,0,255}),
            Polygon(points={{-98,-68},{-66,-60},{-78,-46},{-98,-68}}, lineColor={
                  0,0,255}),
            Text(
              extent={{-87,13},{-38,-36}},
              textString="z",
              lineColor={0,0,255}),
            Text(
              extent={{-150,145},{150,105}},
              textString="%name",
              lineColor={0,0,255})}),
        Documentation(info="<HTML>
<p>
Model <b>FixedFrame</b> visualizes the three axes of
its coordinate system <b>frame_a</b> together with appropriate axes
labels. A typical example is shown in the following figure:
<br>&nbsp;
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/FixedFrame.png\" ALT=\"model Visualizers.FixedFrame\">
</p>

<p>
The sizes of the axes, the axes colors and the specular coefficient
(= reflection factor for
ambient light) can vary dynamically by
providing appropriate expressions in the input fields of the
parameter menu.
</p>
</HTML>"));
    end FixedFrame;

    model FixedArrow
      "Visualizing an arrow with dynamically varying size in frame_a"

      import Modelica_Mechanics_MultiBody.Types;
      extends Modelica_Mechanics_MultiBody.Interfaces.PartialVisualizer;
      parameter Boolean animation=true "= true, if animation shall be enabled";
      input Modelica_SIunits.Position r_tail[3]={0,0,0}
        "Vector from frame_a to arrow tail, resolved in frame_a"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Axis n={1,0,0}
        "Vector in arrow direction, resolved in frame_a"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Length length=0.1 "Length of complete arrow"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter diameter=world.defaultArrowDiameter
        "Diameter of arrow line"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Types.Color color={0,0,255} "Color of arrow"
        annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));
    protected
      Modelica_SIunits.Length headLength=min(length, diameter*Types.Defaults.ArrowHeadLengthFraction);
      Modelica_SIunits.Length headWidth=diameter*Types.Defaults.ArrowHeadWidthFraction;
      Modelica_SIunits.Length lineLength=max(0, length - headLength);
      Visualizers.Advanced.Shape arrowLine(
        shapeType="cylinder",
        length=lineLength,
        width=diameter,
        height=diameter,
        lengthDirection=n,
        widthDirection={0,1,0},
        color=color,
        specularCoefficient=specularCoefficient,
        r_shape=r_tail,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;
      Visualizers.Advanced.Shape arrowHead(
        shapeType="cone",
        length=headLength,
        width=headWidth,
        height=headWidth,
        lengthDirection=n,
        widthDirection={0,1,0},
        color=color,
        specularCoefficient=specularCoefficient,
        r_shape=r_tail + Modelica_Math.Vectors.normalize(
                                          n)*lineLength,
        r=frame_a.r_0,
        R=frame_a.R) if world.enableAnimation and animation;

    equation
      frame_a.f = zeros(3);
      frame_a.t = zeros(3);

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,28},{20,-30}},
              lineColor={128,128,128},
              fillColor={128,128,128},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{20,60},{100,0},{20,-60},{20,60}},
              lineColor={128,128,128},
              fillColor={128,128,128},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,105},{150,65}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{-150,-75},{150,-105}},
              lineColor={0,0,0},
              textString="%length")}),
        Documentation(info="<html>
<p>
Model <b>FixedArrow</b> defines an arrow that is
shown at the location of its frame_a.
<br>&nbsp;
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Arrow.png\" ALT=\"model Visualizers.FixedArrow\">
</p>

<p>
The direction of the arrow specified with vector
<b>n</b> is with respect to frame_a, i.e., the local frame to which the
arrow component is attached. The direction and length of the arrow, its diameter
and color can vary dynamically by
providing appropriate expressions in the input fields of the
parameter menu.
</p>
</html>"));
    end FixedArrow;

    model SignalArrow
      "Visualizing an arrow with dynamically varying size in frame_a based on input signal"

      import Modelica_Mechanics_MultiBody.Types;

      extends Modelica_Mechanics_MultiBody.Interfaces.PartialVisualizer;
      parameter Boolean animation=true "= true, if animation shall be enabled";
      input Modelica_SIunits.Position r_tail[3]={0,0,0}
        "Vector from frame_a to arrow tail, resolved in frame_a"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_SIunits.Diameter diameter=world.defaultArrowDiameter
        "Diameter of arrow line"
        annotation (Dialog(group="if animation = true", enable=animation));
      input Modelica_Mechanics_MultiBody.Types.Color color={0,0,255}
        "Color of arrow" annotation (Dialog(
          colorSelector=true,
          group="if animation = true",
          enable=animation));
      input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        "Reflection of ambient light (= 0: light is completely absorbed)"
        annotation (Dialog(group="if animation = true", enable=animation));

      Modelica_Blocks.Interfaces.RealInput r_head[3](each final quantity="Length", each final unit="m")
        "Position vector from origin of frame_a to head of arrow, resolved in frame_a"
        annotation (Placement(transformation(
            origin={0,-120},
            extent={{-20,-20},{20,20}},
            rotation=90)));

    protected
      Visualizers.Advanced.Arrow arrow(
        R=frame_a.R,
        r=frame_a.r_0,
        r_tail=r_tail,
        r_head=r_head,
        diameter=diameter,
        color=color,
        specularCoefficient=specularCoefficient) if world.enableAnimation and animation;
    equation
      frame_a.f = zeros(3);
      frame_a.t = zeros(3);

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,28},{20,-30}},
              lineColor={128,128,128},
              fillColor={128,128,128},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{20,60},{100,0},{20,-60},{20,60}},
              lineColor={128,128,128},
              fillColor={128,128,128},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,105},{150,65}},
              textString="%name",
              lineColor={0,0,255}),
            Line(points={{0,-102},{0,-30}}, color={0,0,255})}),
        Documentation(info="<HTML>
<p>
Model <b>SignalArrow</b> defines an arrow that is dynamically visualized
at the location where its frame_a is attached. The
position vector from the tail to the head of the arrow,
resolved in frame_a, is defined via the signal vector of
the connector <b>r_head</b> (Real r_head[3]):<br>&nbsp;
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Arrow.png\" ALT=\"model Visualizers.SignalArrow\">
</p>
<p>
The tail of the arrow is defined with parameter <b>r_tail</b>
with respect to frame_a (vector from the origin of frame_a to the arrow tail).
</p>
</HTML>"));
    end SignalArrow;

     model Ground "Visualizing the ground (box in z=0)"
        parameter Boolean animation=true
        "= true, if animation of ground shall be enabled";
        parameter Modelica_SIunits.Position length = 10
        "Length and width of box (center is at x=y=0)"                  annotation (Dialog(enable=animation));
        parameter Modelica_SIunits.Position height = 0.02
        "Height of box (upper surface is at z=0, lower surface is at z=-height)"
                                                                          annotation (Dialog(enable=animation));
        parameter Modelica_Mechanics_MultiBody.Types.Color groundColor={0,255,0}
        "Color of box" annotation (Dialog(colorSelector=true, enable=animation));

        Modelica_Mechanics_MultiBody.Visualizers.FixedShape ground(
        lengthDirection={1,0,0},
        widthDirection={0,1,0},
        animation=animation,
        r_shape={-length/2,0,-height},
        length=length,
        height=height,
        color=groundColor,
        width=length)
        annotation (Placement(transformation(extent={{-20,0},{0,20}})));
        Modelica_Mechanics_MultiBody.Parts.Fixed fixed
        annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
     equation

        connect(fixed.frame_b, ground.frame_a) annotation (Line(
            points={{-40,10},{-20,10}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={
              Polygon(
                points={{-20,60},{-100,-32},{20,-92},{100,8},{-20,60}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={0,255,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{2,82},{44,54}},
                lineColor={0,0,0},
                textString="z"),
              Polygon(
                points={{100,8},{100,-4},{20,-104},{20,-92},{100,8}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={0,255,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-100,-32},{-100,-44},{20,-104},{20,-92},{-100,-32}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={0,255,0},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-11,-7},{-1,-12}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-6,-10},{-6,88}},
                color={0,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{-6,102},{-14,72},{2,72},{-6,102}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Text(
              extent={{-150,-105},{150,-145}},
              textString="%name",
              lineColor={0,0,255})}),        Documentation(info="<html>
<p>
This shape visualizes the x-y plane by a box
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Ground.png\">
</blockquote>
</html>"));
     end Ground;

    model Torus "Visualizing a torus"
      extends Modelica_Mechanics_MultiBody.Interfaces.PartialVisualizer;

      parameter Boolean animation=true "= true, if animation shall be enabled";

      parameter Modelica_SIunits.Radius ri=0.5 "Inner radius of torus" annotation(Dialog(enable=animation));
      parameter Modelica_SIunits.Radius ro=0.1
        "Outer radius of torus (=width/2)"                                         annotation(Dialog(enable=animation));
      parameter Modelica_SIunits.Angle opening=0 "Opening angle of torus" annotation(Dialog(enable=animation));
      parameter Modelica_SIunits.Angle startAngle=-3.1415926535898
        "Start angle of torus slice" annotation(Dialog(enable=animation));
      parameter Modelica_SIunits.Angle stopAngle=3.1415926535898
        "End angle of torus slice" annotation(Dialog(enable=animation));
      parameter Boolean wireframe=false
        "= true: 3D model will be displayed without faces"
        annotation (Dialog(enable=animation, group="Material properties"),choices(checkBox=true));
      input Modelica_Mechanics_MultiBody.Types.RealColor color={0,128,255}
        "Color of surface" annotation (Dialog(
          enable=animation and not multiColoredSurface,
          colorSelector=true,
          group="Material properties"));
      input Types.SpecularCoefficient specularCoefficient = 0.7
        "Reflection of ambient light (= 0: light is completely absorbed)" annotation(Dialog(enable=animation,group="Material properties"));
      input Real transparency=0
        "Transparency of shape: 0 (= opaque) ... 1 (= fully transparent)"
                                   annotation(Dialog(enable=animation,group="Material properties"));
      parameter Integer n_ri=40 "Number of points along ri" annotation(Dialog(enable=animation,tab="Discretization"));
      parameter Integer n_ro=20 "Number of points along ro" annotation(Dialog(enable=animation,tab="Discretization"));

    protected
      Advanced.Surface surface( redeclare function surfaceCharacteristic =
            M_S_L.Mechanics.MultiBody.Visualizers.Advanced.SurfaceCharacteristics.torus
            (   ri=ri, ro=ro, opening=opening, startAngle=startAngle, stopAngle=stopAngle),
              nu=n_ri,
              nv=n_ro,
              multiColoredSurface=false,
              wireframe=wireframe,
              color=color,
              specularCoefficient=specularCoefficient,
              transparency=transparency,
        R=frame_a.R,
        r_0=frame_a.r_0) if world.enableAnimation and animation
        annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
    equation
      // No forces and torques
      frame_a.f = zeros(3);
      frame_a.t = zeros(3);
      annotation (Icon(graphics={Bitmap(extent={{-98,98},{98,-98}}, fileName=
                  "modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/TorusIcon.png"),
              Text(
              extent={{-150,100},{150,140}},
              lineColor={0,0,255},
              textString="%name")}), Documentation(info="<html>
<p>
Model <b>Torus</b> visualizes a torus. The center of the torus is located at
connector frame_a (visualized by the red coordinate system in the figure below).
The left image below shows a torus with ri=0.5 m and ro = 0.2 m.
The right images below shows the torus with the additional parameter
settings:
</p>
<pre>
  opening    =   45 degree
  startAngle = -135 degree
  stopAngle  =  135 degree
</pre>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Torus.png\">
</blockquote>

<p>
In the advanced menu the discretization of the surface visualization can be defined by
the number of points of the inner radius of the torus (n_ri) and by
the number of points of the outer radius of the torus (n_ro).
In case the torus is closed (that is, opening = 0 degree),
the actual number of points is one less (that is n_ri-1, n_ro-1), because the first and
the last point of the parametrization coincide in this case.
</p>
</html>",   revisions="<html>
  <ul>
  <li> July 2010 by Martin Otter<br>
       Adapted to the new Surface model.</li>
  <li> July 2005 by Dirk Zimmer (practical training at DLR)<br>
       First version to visualize a multi-level tyre wheel model.</li>
  </ul>
</html>"));
    end Torus;

    model VoluminousWheel "Visualizing a voluminous wheel"
      extends Modelica_Mechanics_MultiBody.Interfaces.PartialVisualizer;

      parameter Boolean animation=true "= true, if animation shall be enabled";

      parameter Modelica_SIunits.Radius rTire=0.25 "Radius of the tire";
      parameter Modelica_SIunits.Radius rRim=0.14 "Radius of the rim";
      parameter Modelica_SIunits.Radius width=0.25 "Width of the tire";
      parameter Modelica_SIunits.Radius rCurvature=0.30
        "Radius of the curvature of the tire";

      parameter Modelica_Mechanics_MultiBody.Types.RealColor color={64,64,64}
        "Color of tire" annotation (Dialog(
          enable=animation and not multiColoredSurface,
          colorSelector=true,
          group="Material properties"));
      parameter Types.SpecularCoefficient specularCoefficient = 0.5
        "Reflection of ambient light (= 0: light is completely absorbed)" annotation(Dialog(enable=animation,group="Material properties"));
      parameter Integer n_rTire=40 "Number of points along rTire" annotation(Dialog(enable=animation,tab="Discretization"));
      parameter Integer n_rCurvature=20 "Number of points along rCurvature" annotation(Dialog(enable=animation,tab="Discretization"));

    protected
      parameter Modelica_SIunits.Radius rw=(width/2);
      parameter Modelica_SIunits.Radius rCurvature2=if rCurvature > rw then
          rCurvature else rw;
      parameter Modelica_SIunits.Radius h=sqrt(1 - (rw/rCurvature2)*(rw/
          rCurvature2))*rCurvature2;
      parameter Modelica_SIunits.Radius ri=rTire - rCurvature2;
      parameter Modelica_SIunits.Radius rRim2=if rRim < 0 then 0 else if rRim
           > ri + h then ri + h else rRim;

        Visualizers.Advanced.Shape pipe(
          shapeType="pipe",
          color=color,
          length= width,
          width=2*(ri+h),
          height=2*(ri+h),
          lengthDirection={0,1,0},
          widthDirection={0,0,1},
          extra=(rRim2)/(ri+h),
          r=frame_a.r_0,
          r_shape= -{0,1,0}*(width/2),
          R= frame_a.R,
          specularCoefficient = specularCoefficient) if world.enableAnimation and animation
              annotation (Placement(transformation(extent={{-20,-10},{0,10}})));

        Visualizers.Advanced.Surface torus(redeclare function
          surfaceCharacteristic =
            M_S_L.Mechanics.MultiBody.Visualizers.Advanced.SurfaceCharacteristics.torus
            (     ri=ri,
                  ro=rCurvature2,
                  opening=Modelica_Constants.pi - Modelica_Math.asin(rw/rCurvature2)),
              nu=n_rTire,
              nv=n_rCurvature,
              multiColoredSurface=false,
              wireframe=false,
              color=color,
              specularCoefficient=specularCoefficient,
              transparency=0,
              R=frame_a.R,
              r_0=frame_a.r_0) if world.enableAnimation and animation
        annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));

    equation
      // No forces and torques
      frame_a.f = zeros(3);
      frame_a.t = zeros(3);
      annotation (Icon(graphics={
              Text(
              extent={{-150,100},{150,140}},
              lineColor={0,0,255},
              textString="%name"),
            Bitmap(extent={{-96,96},{102,-96}}, fileName=
                  "modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/VoluminousWheelIcon.png"),
            Rectangle(
              extent={{-96,8},{-18,-8}},
              lineColor={95,95,95},
              fillColor={215,215,215},
              fillPattern=FillPattern.HorizontalCylinder)}),
                                     Documentation(info="<html>
<p>
Model <b>VoluminousWheel</b> provides a simple visualization of a tire using
a torus and a pipe shape object. The center of the wheel is located at
connector frame_a (visualized by the red coordinate system in the figure below).
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/VoluminousWheel.png\">
</blockquote>
</html>",     revisions="<html>
  <ul>
  <li> July 2010 by Martin Otter<br>
       Adapted to the new Surface model.</li>
  <li> July 2005 by Dirk Zimmer (practical training at DLR)<br>
       First version to visualize a multi-level tyre wheel model.</li>
  </ul>
</html>"));
    end VoluminousWheel;

    model PipeWithScalarField
      "Visualizing a pipe with scalar field quantities along the pipe axis"
      extends Modelica_Mechanics_MultiBody.Interfaces.PartialVisualizer;

      parameter Boolean animation=true "= true, if animation shall be enabled";

      parameter Modelica_SIunits.Radius rOuter "Outer radius of pipe" annotation(Dialog(enable=animation));
      parameter Modelica_SIunits.Length length "Length of pipe" annotation(Dialog(enable=animation));

      parameter Real xsi[:](each min=0, each max=1)= Modelica_Math.Vectors.relNodePositions(12)
        "[:] Relative position along the pipe with x[1] = 0, x[end] = 1"
        annotation(Dialog(enable=animation));
      input Real T[size(xsi,1)]
        "[:] Scalar values at position xsi*length (will be visualized by color)"
                                                                                 annotation(Dialog(enable=animation));
      parameter Real T_min
        "Minimum value of T that corresponds to colorMap[1,:]"                        annotation(Dialog(enable=animation));
      parameter Real T_max
        "Maximum value of T that corresponds to colorMap[end,:]"                       annotation(Dialog(enable=animation));
      replaceable function colorMap =
          Modelica_Mechanics_MultiBody.Visualizers.Colors.ColorMaps.jet
        constrainedby Modelica_Mechanics_MultiBody.Interfaces.partialColorMap
        "Function defining the color map"
              annotation(choicesAllMatching=true, Dialog(enable=animation,group="Color coding"));

      parameter Integer n_colors=64 "Number of colors in the colorMap" annotation(Dialog(enable=animation,group="Color coding"));
      parameter Types.SpecularCoefficient specularCoefficient = 0.7
        "Reflection of ambient light (= 0: light is completely absorbed)" annotation(Dialog(enable=animation,group="Color coding"));
      parameter Real transparency=0
        "Transparency of shape: 0 (= opaque) ... 1 (= fully transparent)"
                                   annotation(Dialog(enable=animation,group="Color coding"));

      parameter Integer n_rOuter=30 "Number of points along outer radius" annotation(Dialog(enable=animation,tab="Discretization"));
      parameter Integer n_length=20 "Number of points along length" annotation(Dialog(enable=animation,tab="Discretization"));

    protected
      Advanced.PipeWithScalarField pipe(redeclare function colorMap = colorMap,
             rOuter=rOuter,
             length=length,
             xsi=xsi,
             T=T,
             T_min=T_min,
             T_max=T_max,
             n_colors=n_colors,
             n_rOuter=n_rOuter,
             n_length=n_length,
             specularCoefficient=specularCoefficient,
             transparency=transparency,
             R=frame_a.R,
             r_0=frame_a.r_0) if world.enableAnimation and animation
        annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
    equation
      // No forces and torques
      frame_a.f = zeros(3);
      frame_a.t = zeros(3);

      annotation (Icon(graphics={
              Text(
              extent={{-150,50},{150,90}},
              lineColor={0,0,255},
              textString="%name"), Bitmap(extent={{-100,58},{98,-62}}, fileName=
                  "modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/PipeWithScalarFieldIcon.png")}),
                                     Documentation(info="<html>
<p>
Model <b>PipeWithScalarField</b> visualizes a pipe and a scalar
field along the pipe axis. The latter is shown by mapping the scalar
field to color values with a color map and utilizing this color
at the perimeter associated with the corresponding axis location.
Typically the scalar field value is a temperature, but might
be also another quantity.
Predefined color maps are available from
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps\">MultiBody.Visualizers.Colors.ColorMaps</a>
and can be selected via parameter \"colorMap\".
A color map with the corresponding scalar field values can be exported
as vector-graphics in svg-format with function
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">MultiBody.Visualizers.Colors.colorMapToSvg</a>.
Connector frame_a of this component is located in the center of the
circle at the left side of the pipe and the pipe axis is oriented
along the x-axis of frame_a, see figure below in which frame_a is visualized
with a coordinate system:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/PipeWithScalarField.png\">
</blockquote>

<p>
The color coding is shown in the next figure. It was generated with
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">MultiBody.Visualizers.Colors.colorMapToSvg</a>
using the following call:
</p>

<blockquote>
<pre>
colorMapToSvg(Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps.jet(),
              height=50, nScalars=6, T_max=100, caption=\"Temperature in C\");
</pre>
</blockquote>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/PipeWithScalarField-ColorMap.png\">
</blockquote>
</html>",   revisions="<html>
  <ul>
  <li> July 2010 by Martin Otter<br>
       Adapted to the new Surface model.</li>
  <li> July 2005 by Dirk Zimmer (practical training at DLR)<br>
       First version to visualize a multi-level tyre wheel model.</li>
  </ul>
</html>"));
    end PipeWithScalarField;

    package Colors "Library of functions operating on color"
      extends Modelica_Icons.Package;
      package ColorMaps "Library of functions returning color maps"
        extends Modelica_Icons.Package;

        function jet "Returns the \"jet\" color map"
        extends Modelica_Mechanics_MultiBody.Interfaces.partialColorMap;
        protected
           Real a=ceil(n_colors/4);
           Real d=1/a;
           Real b=ceil(a/2);
           Real c=floor(a/2);
           Real v1[:]={1-(b-i)*d for i in 1:b};
           Real v2[:]=0+d:d:1;
           Real v3[:]=1-d:-d:0;
           Real v4[:]={0.5+(c-i)*d for i in 1:c};
           Real cm[integer(ceil(n_colors/4))*4,3];
        algorithm
           cm:=255*[zeros(size(v1,1)),zeros(size(v1,1)),  v1;
                    zeros(size(v2,1)), v2,  fill(1., size(v2,1));
                    v2,              fill(1, size(v2,1)), v3;
                    fill(1, size(v3,1)),v3, fill(0.,size(v3,1));
                    v4, fill(0,size(v4,1)),fill(0.,size(v4,1))];
           colorMap:=cm[1:n_colors,:];

          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ColorMaps.<b>jet</b>();
ColorMaps.<b>jet</b>(n_colors=64);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the color map \"jet.\" A color map
is a Real[:,3] array where every row represents a color.
With the optional argument \"n_colors\" the number of rows
of the returned array can be defined. The default value is
\"n_colors=64\" (it is usually best if n_colors is a multiple of 4).
Image of the \"jet\" color map:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Colors/jet.png\">
</blockquote>

<h4>See also</h4>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps\">ColorMaps</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">colorMapToSvg</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.scalarToColor\">scalarToColor</a>.
</html>"));
        end jet;

        function hot "Returns the \"hot\" color map"
        extends Modelica_Mechanics_MultiBody.Interfaces.partialColorMap;
        protected
           Real a=ceil(n_colors/3);
           Real d=1/a;
           Real v1[:]=0+d:d:1;
           Real cm[integer(ceil(n_colors/3))*3,3];
        algorithm
         cm := 255*[v1, zeros(size(v1, 1)),zeros(size(v1, 1));
                                  fill(1., size(v1, 1)), v1,zeros(size(v1, 1));
                                  fill(1., size(v1, 1)),fill(1., size(v1, 1)),v1];
         colorMap:=cm[1:n_colors,:];

          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ColorMaps.<b>hot</b>();
ColorMaps.<b>hot</b>(n_colors=64);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the color map \"hot.\" A color map
is a Real[:,3] array where every row represents a color.
With the optional argument \"n_colors\" the number of rows
of the returned array can be defined. The default value is
\"n_colors=64\" (it is usually best if n_colors is a multiple of 4).
Image of the \"hot\" color map:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Colors/hot.png\">
</blockquote>

<h4>See also</h4>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps\">ColorMaps</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">colorMapToSvg</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.scalarToColor\">scalarToColor</a>.
</html>"));
        end hot;

        function gray "Returns the \"gray\" color map"
        extends Modelica_Mechanics_MultiBody.Interfaces.partialColorMap;
        algorithm
          if n_colors > 1 then
            colorMap := 255*[linspace(0,1.,n_colors),linspace(0,1.,n_colors),linspace(0,1.,n_colors)];
          else
            colorMap:=[0,0,0];
           end if;

          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ColorMaps.<b>gray</b>();
ColorMaps.<b>gray</b>(n_colors=64);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the color map \"gray.\" A color map
is a Real[:,3] array where every row represents a color.
With the optional argument \"n_colors\" the number of rows
of the returned array can be defined. The default value is
\"n_colors=64\" (it is usually best if n_colors is a multiple of 4).
Image of the \"gray\" color map:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Colors/gray.png\">
</blockquote>

<h4>See also</h4>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps\">ColorMaps</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">colorMapToSvg</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.scalarToColor\">scalarToColor</a>.
</html>"));
        end gray;

        function spring "Returns the \"spring\" color map"
        extends Modelica_Mechanics_MultiBody.Interfaces.partialColorMap;
        algorithm
          if n_colors > 1 then
             colorMap := 255*[fill(1,n_colors),linspace(0,1.,n_colors),linspace(1,0,n_colors)];
           else
            colorMap:=255*[1,0,1];
           end if;

          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ColorMaps.<b>spring</b>();
ColorMaps.<b>spring</b>(n_colors=64);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the color map \"spring.\" A color map
is a Real[:,3] array where every row represents a color.
With the optional argument \"n_colors\" the number of rows
of the returned array can be defined. The default value is
\"n_colors=64\" (it is usually best if n_colors is a multiple of 4).
Image of the \"spring\" color map:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Colors/spring.png\">
</blockquote>

<h4>See also</h4>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps\">ColorMaps</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">colorMapToSvg</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.scalarToColor\">scalarToColor</a>.
</html>"));
        end spring;

        function summer "Returns the \"summer\" color map"
        extends Modelica_Mechanics_MultiBody.Interfaces.partialColorMap;
        algorithm
          if n_colors > 1 then
             colorMap := 255*[linspace(0,1.,n_colors),linspace(0.5,1.,n_colors),fill(0.4,n_colors)];
           else
            colorMap:=255*[0,0.5,0.4];
           end if;

          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ColorMaps.<b>summer</b>();
ColorMaps.<b>summer</b>(n_colors=64);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the color map \"summer.\" A color map
is a Real[:,3] array where every row represents a color.
With the optional argument \"n_colors\" the number of rows
of the returned array can be defined. The default value is
\"n_colors=64\" (it is usually best if n_colors is a multiple of 4).
Image of the \"summer\" color map:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Colors/summer.png\">
</blockquote>

<h4>See also</h4>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps\">ColorMaps</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">colorMapToSvg</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.scalarToColor\">scalarToColor</a>.
</html>"));
        end summer;

        function autumn "Returns the \"autumn\" color map"
        extends Modelica_Mechanics_MultiBody.Interfaces.partialColorMap;
        algorithm
          if n_colors > 1 then
             colorMap := 255*[fill(1,n_colors),linspace(0,1.,n_colors),zeros(n_colors)];
           else
            colorMap:=255*[1,0,0];
           end if;

          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ColorMaps.<b>autumn</b>();
ColorMaps.<b>autumn</b>(n_colors=64);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the color map \"autumn.\" A color map
is a Real[:,3] array where every row represents a color.
With the optional argument \"n_colors\" the number of rows
of the returned array can be defined. The default value is
\"n_colors=64\" (it is usually best if n_colors is a multiple of 4).
Image of the \"autumn\" color map:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Colors/autumn.png\">
</blockquote>

<h4>See also</h4>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps\">ColorMaps</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">colorMapToSvg</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.scalarToColor\">scalarToColor</a>.
</html>"));
        end autumn;

        function winter "Returns the \"winter\" color map"
        extends Modelica_Mechanics_MultiBody.Interfaces.partialColorMap;
        algorithm
          if n_colors > 1 then
             colorMap := 255*[zeros(n_colors),linspace(0,1,n_colors),linspace(1,0.5,n_colors)];
           else
            colorMap:=[0,0,255];
           end if;

          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ColorMaps.<b>winter</b>();
ColorMaps.<b>winter</b>(n_colors=64);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the color map \"winter.\" A color map
is a Real[:,3] array where every row represents a color.
With the optional argument \"n_colors\" the number of rows
of the returned array can be defined. The default value is
\"n_colors=64\" (it is usually best if n_colors is a multiple of 4).
Image of the \"winter\" color map:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Colors/winter.png\">
</blockquote>

<h4>See also</h4>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps\">ColorMaps</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">colorMapToSvg</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.scalarToColor\">scalarToColor</a>.
</html>"));
        end winter;

        annotation (Documentation(info="<html>
<p>
This package contains functions that return color maps.
A color map is a Real[:,3] array where every row represents a color.
Currently the following color maps are returned from the
respective function:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Colors/ColorMaps.png\">
</blockquote>
</html>"));
      end ColorMaps;

      function colorMapToSvg
        "Save a color map on file in svg (scalable vector graphics) format"
        extends Modelica_Icons.Function;
       encapsulated type HeaderType = enumeration(
            svgBeginAndEnd,
            svgBegin,
            svgEnd,
            noHeader);
        import Modelica_Utilities.Streams.print;
        input Real colorMap[:,3] "Color map to be stored in svg format"
          annotation(choices( choice=M_S_L.Mechanics.MultiBody.Visualizers.Colors.ColorMaps.jet(),
                              choice=M_S_L.Mechanics.MultiBody.Visualizers.Colors.ColorMaps.hot(),
                              choice=M_S_L.Mechanics.MultiBody.Visualizers.Colors.ColorMaps.gray(),
                              choice=M_S_L.Mechanics.MultiBody.Visualizers.Colors.ColorMaps.spring(),
                              choice=M_S_L.Mechanics.MultiBody.Visualizers.Colors.ColorMaps.summer(),
                              choice=M_S_L.Mechanics.MultiBody.Visualizers.Colors.ColorMaps.autumn(),
                              choice=M_S_L.Mechanics.MultiBody.Visualizers.Colors.ColorMaps.winter()));
        input String fileName="colorMap.svg"
          "File where the svg representation shall be stored";
        input Real width(unit="mm")=10 "Width in svg-figure";
        input Real height(unit="mm")=100 "Height in svg-figure";
        input Real x(unit="mm")=20 "X-Coordinate of left upper corner";
        input Real y(unit="mm")=10 "Y-Coordinate of left upper corner";
        input Real T_min=0 "Value of scalar corresponding to colorMap[1,:]";
        input Real T_max=100 "Value of scalar corresponding to colorMap[end,:]";
        input Integer nScalars=11
          "Number of scalars to be displayed at the right side";
        input String format=".3g" "Format of the numbers";
        input Real fontSize=11 "Font size in [pt]";
        input Real textWidth(unit="mm")=8
          "Numbers are right justified starting at x+width+textWidth";
        input String caption="" "Caption above the map";
        input HeaderType headerType=Colors.colorMapToSvg.HeaderType.svgBeginAndEnd
          "Type of header";
      protected
        Integer nc = size(colorMap,1);
        Real dy=height/nc;
        Real yy=y-dy;
        String strWidth=String(width);
        String strHeight=String(dy);
        Real T;
        Integer ni;
        constant Real ptToMm=127/360 "1 Point = ptToMm mm";
        Real fontHeight(unit="mm") = fontSize*ptToMm;
        Real xx=x+width+textWidth;
        String strXX=String(xx);
        Real xHeading=x+width/2;
        Real yHeading=y-1.2*fontHeight;
      algorithm
        if headerType==HeaderType.svgBeginAndEnd or
           headerType==HeaderType.svgBegin then
           Modelica_Utilities.Files.remove(fileName);
           print("... generating svg-file: " + Modelica_Utilities.Files.fullPathName(fileName));
        end if;
        if caption<>"" then
           print("... " + caption);
        end if;

        if headerType==HeaderType.svgBeginAndEnd or
           headerType==HeaderType.svgBegin then
           print("<svg xmlns=\"http://www.w3.org/2000/svg\">", fileName);
        end if;

        print("  <g>", fileName);

        // Print colors
        for i in nc:-1:1 loop
           // print:  <rect x="XXmm" y="XXmm" width="YYmm" height="ZZmm" style="fill:rgb(100,128,255);stroke:none"/>
           yy :=yy + dy;
           print("    <rect x=\"" + String(x) +
                 "mm\" y=\"" + String(yy) +
                 "mm\" width=\"" + strWidth +
                 "mm\" height=\"" + strHeight +
                 "mm\" style=\"fill:rgb(" + String(integer(colorMap[i,1])) + ","
                                          + String(integer(colorMap[i,2])) + ","
                                          + String(integer(colorMap[i,3])) +
                 ");stroke:none\"/>", fileName);
        end for;

        // Print numbers
        ni :=if nScalars == 1 then 2 else if nScalars < 1 then
                                   0 else nScalars;
        dy:=height/(ni-1);
        yy:=y - dy+0.3*fontHeight;
        for i in ni:-1:1 loop
          // print: <text x="22mm" y="12mm" font-family="Arial,sans-serif" font-size="11pt">1.2345</text>
          yy :=yy + dy;
          T := T_min + (T_max - T_min)*(i-1)/(ni-1);
          print("    <text x=\"" + strXX +
                "mm\" y=\"" + String(yy) +
                "mm\" font-family=\"Fixedsys\" font-size=\"" + String(fontSize) +
                "pt\" text-anchor=\"end\">" + String(T,format=format) +
                "</text>", fileName);
        end for;

        if caption <> "" then
           print("   <text x=\"" + String(xHeading) +
                 "mm\" y=\"" + String(yHeading) +
                 "mm\" font-family=\"Fixedsys\" font-size=\"" + String(fontSize) +
                 "pt\" text-anchor=\"middle\">" + caption +
                 "</text>", fileName);
        end if;

        print("  </g>", fileName);

        if headerType==HeaderType.svgBeginAndEnd or
           headerType==HeaderType.svgEnd then
           print("</svg>",fileName);
        end if;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Colors.<b>colorMapToSvg</b>(colorMap);
Colors.<b>colorMapToSvg</b>(colorMap,
                     fileName   = \"colorMap.svg\",
                     width      =  10,  // [mm]
                     height     = 100,  // [mm]
                     x          =  20,  // [mm]
                     y          =  10,  // [mm]
                     T_min      =   0,
                     T_max      = 100,
                     nScalars   =  11,
                     format     = \".3g\",
                     fontSize   =  11,  // [pt]
                     textWidth  =   8,  // [mm]
                     caption    = \"\",
                     headerType = Colors.colorMapToSvg.Header.svgBeginAndEnd)
                                                           // svgBegin
                                                           // svgEnd
                                                           // svgNoHeader
</pre></blockquote>
<h4>Description</h4>
<p>
This function saves the color map \"Real colorMap[:,3]\" on file \"fileName\"
in svg format. The color map has a width of \"width\" and a height of \"height\" and
the upper left corner is placed at coordinates \"(x,y)\".
Over the color map, a caption \"caption\" is placed.
On the right side of the color map, a set of scalar field values T is
displayed where \"T_min\" is placed at colorMap[1,:],
\"T_max\" is placed at colorMap[end,:] and \"nScalars\" values between
\"T_min\" and \"T_max\" (including T_min and T_max) are shown.
The printing format of the numbers is defined with \"format\", see definition below.
With argument \"headerType\" it is defined whether \"svg\" begin and end
lines are printed. If the \"begin\" svg tag shall be printed, file \"fileName\"
is deleted, if it already exists. Otherwise, all output is appended to the
file \"fileName\".
</p>

<p>
A \"svg\" file can be displayed by a web browser, such as
<a href=\"http://www.mozilla.org/firefox\">Firefox</a> by dragging the
file in the browser window.
Alternatively, a svg-file can be loaded in a graphics program,
such as the free <a href=\"http://inkscape.org\">Inkscape</a>,
can be manipulated and can be exported in other graphic formats.
The following image was generated with a call to \"colorMapToSvg\", the
generated file was loaded in Inkscape and exported in \"png\" format:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Colors/jet.png\">
</blockquote>

<p>
The \"format\" argument defines the string formatting according to
ANSI-C without \"%\" and \"*\" character<br>
(e.g., \".6g\", \"14.5e\", \"+6f\"). In particular:
</p>

<p>
format = \"[&lt;flags&gt;] [&lt;width&gt;] [.&lt;precision&gt;] &lt;conversion&gt;\"
with
</p>

<blockquote>
<table>
<tr>
  <td>&lt;flags&gt;</td>
  <td> zero, one or more of<br>
       \"-\": left adjustment of the converted number<br>
       \"+\": number will always be printed with a sign<br>
       \"0\": padding to the field width with leading zeros</td></tr>
<tr>
  <td>&lt;width&gt;</td>
  <td> Minimum field width. The converted number will be printed in a field at<br>
       least this wide and wider if necessary. If the converted number has <br>
       fewer characters it will be padded on the left (or the right depending<br>
       on &lt;flags&gt;) with blanks or 0 (depending on &lt;flags&gt;).</td></tr>
<tr>
  <td>&lt;precision&gt;</td>
  <td> The number of digits to be printed after the decimal point for <br>
       e, E, or f conversions, or the number of significant digits for <br>
       g or G conversions.</td></tr>
<tr>
  <td> &lt;conversion&gt;</td>
  <td> = \"e\": Exponential notation using a  lower case e<br>
       = \"E\": Exponential notation using an upper case E<br>
       = \"f\": Fixed point notation<br>
       = \"g\": Either \"e\" or \"f\"<br>
       = \"G\": Same as \"g\", but with upper case E</td></tr>
</table>
</blockquote>
</html>"));
      end colorMapToSvg;

      function scalarToColor "Map a scalar to a color using a color map"
        extends Modelica_Icons.Function;

        input Real T "Scalar value" annotation(Dialog);
        input Real T_min "T <= T_min is mapped to colorMap[1,:]" annotation(Dialog);
        input Real T_max "T >= T_max is mapped to colorMap[end,:]" annotation(Dialog);
        input Real colorMap[:,3] "Color map" annotation(Dialog);
        output Real color[3] "Color of scalar value T";
      algorithm
        /* old version, that could give an error
  color :=colorMap[integer((size(colorMap, 1) - 1)/(T_max - T_min)*
                            min((max(T,T_min) - T_min), T_max) + 1), :];
  */
        color := colorMap[1 + integer((size(colorMap,1)-1)*(max(T_min,min(T,T_max))-T_min)
                                    / (T_max-T_min)), :];
        annotation(Inline=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
//Real T, T_min, T_max, colorMap[:,3];
Colors.<b>scalarToColor</b>(T, T_min, T_max, colorMap);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns an rgb color Real[3] that corresponds to the value of \"T\".
The color is selected from the colorMap by interpolation so that
\"T_min\" corresponds to \"colorMap[1,:]\" and
\"T_max\" corresponds to \"colorMap[end,:]\".
</p>

<h4>See also</h4>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps\">ColorMaps</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">colorMapToSvg</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.PipeWithScalarField\">PipeWithScalarField</a>.

</html>"));
      end scalarToColor;
      annotation (Documentation(info="<html>
<p>
This package contains functions to operate on colors.
Note, a color is represented as a Real array with 3 elements where
the elements are the red, green, blue values of the RGB color model.
Every element must be in the range 0..255.
The type of a color is Real and not Integer in order that a color
can be used with less problems in a model, since in a model an Integer
type could only be used in a when-clause. Typical declaration of a color value:
</p>

<blockquote>
<pre>
  Real color[3](each min=0, each max=255);
</pre>
</blockquote>

<p>
This definition is also available as type
<a href=\"modelica://Modelica.Mechanics.MultiBody.Types.RealColor\">Modelica.Mechanics.MultiBody.Types.RealColor</a>.
</p>
</html>"));
    end Colors;

    package Advanced
      "Visualizers that require basic knowledge about Modelica in order to use them"

      extends Modelica_Icons.Package;
      model Arrow
        "Visualizing an arrow with variable size; all data have to be set as modifiers (see info layer)"

        import Modelica_Mechanics_MultiBody.Types;
        import Modelica_Mechanics_MultiBody.Frames;
        import T = Modelica_Mechanics_MultiBody.Frames.TransformationMatrices;
        import Modelica_SIunits.Conversions.to_unit1;

        input Frames.Orientation R=Frames.nullRotation()
          "Orientation object to rotate the world frame into the arrow frame" annotation(Dialog);
        input Modelica_SIunits.Position r[3]={0,0,0}
          "Position vector from origin of world frame to origin of arrow frame, resolved in world frame"
          annotation (Dialog);
        input Modelica_SIunits.Position r_tail[3]={0,0,0}
          "Position vector from origin of arrow frame to arrow tail, resolved in arrow frame"
          annotation (Dialog);
        input Modelica_SIunits.Position r_head[3]={0,0,0}
          "Position vector from arrow tail to the head of the arrow, resolved in arrow frame"
          annotation (Dialog);
        input Modelica_SIunits.Diameter diameter=world.defaultArrowDiameter
          "Diameter of arrow line" annotation (Dialog);
        input Modelica_Mechanics_MultiBody.Types.Color color=Types.Defaults.ArrowColor
          "Color of arrow" annotation (Dialog(colorSelector=true));
        input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
          "Material property describing the reflecting of ambient light (= 0 means, that light is completely absorbed)"
                                                                                                              annotation(Dialog);

      protected
        outer Modelica_Mechanics_MultiBody.World world;
        Modelica_SIunits.Length length=Modelica_Math.Vectors.length(r_head)
          "Length of arrow";
        Real e_x[3](each final unit="1", start={1,0,0}) = noEvent(if length < 1.e-10 then {1,0,0} else r_head/length);
        Real rxvisobj[3](each final unit="1") = transpose(R.T)*e_x
          "X-axis unit vector of shape, resolved in world frame"
            annotation (HideResult=true);
        Modelica_SIunits.Position rvisobj[3]=r + T.resolve1(R.T, r_tail)
          "Position vector from world frame to shape frame, resolved in world frame"
          annotation (HideResult=true);
        Modelica_SIunits.Length arrowLength=noEvent(max(0, length - diameter*
            Types.Defaults.ArrowHeadLengthFraction))
          annotation (HideResult=true);
        Visualizers.Advanced.Shape arrowLine(
          length=arrowLength,
          width=diameter,
          height=diameter,
          lengthDirection = to_unit1(r_head),
          widthDirection={0,1,0},
          shapeType="cylinder",
          color=color,
          specularCoefficient=specularCoefficient,
          r_shape=r_tail,
          r=r,
          R=R) if world.enableAnimation;
        Visualizers.Advanced.Shape arrowHead(
          length=noEvent(max(0, min(length, diameter*Types.Defaults.
              ArrowHeadLengthFraction))),
          width=noEvent(max(0, diameter*Types.Defaults.ArrowHeadWidthFraction)),
          height=noEvent(max(0, diameter*Types.Defaults.ArrowHeadWidthFraction)),
          lengthDirection = to_unit1(r_head),
          widthDirection={0,1,0},
          shapeType="cone",
          color=color,
          specularCoefficient=specularCoefficient,
          r=rvisobj + rxvisobj*arrowLength,
          R=R) if world.enableAnimation;

        annotation (
          Documentation(info="<HTML>
<p>
Model <b>Arrow</b> defines an arrow that is dynamically
visualized at the defined location (see variables below).
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Arrow.png\" ALT=\"model Visualizers.Advanced.Arrow\">
</p>

<p>
The variables under heading <b>Parameters</b> below
are declared as (time varying) <b>input</b> variables.
If the default equation is not appropriate, a corresponding
modifier equation has to be provided in the
model where an <b>Arrow</b> instance is used, e.g., in the form
</p>
<pre>
    Visualizers.Advanced.Arrow arrow(diameter = sin(time));
</pre>

<p>
Variable <b>color</b> is an Integer vector with 3 elements,
{r, g, b}, and specifies the color of the shape.
{r,g,b} are the \"red\", \"green\" and \"blue\" color parts.
Note, r g, b are given in the range 0 .. 255.
The predefined type <b>MultiBody.Types.Color</b> contains
a menu definition of the colors used in the MultiBody
library (will be replaced by a color editor).
</p>
</HTML>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-100,28},{20,-30}},
                lineColor={128,128,128},
                fillColor={128,128,128},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{20,60},{100,0},{20,-60},{20,60}},
                lineColor={128,128,128},
                fillColor={128,128,128},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,105},{150,65}},
                textString="%name",
                lineColor={0,0,255})}));
      end Arrow;

      model DoubleArrow
        "Visualizing a double arrow with variable size; all data have to be set as modifiers (see info layer)"

        import Modelica_Mechanics_MultiBody.Types;
        import Modelica_Mechanics_MultiBody.Frames;
        import T = Modelica_Mechanics_MultiBody.Frames.TransformationMatrices;
        import Modelica_SIunits.Conversions.to_unit1;

        input Frames.Orientation R=Frames.nullRotation()
          "Orientation object to rotate the world frame into the arrow frame" annotation(Dialog);
        input Modelica_SIunits.Position r[3]={0,0,0}
          "Position vector from origin of world frame to origin of arrow frame, resolved in world frame"
          annotation (Dialog);
        input Modelica_SIunits.Position r_tail[3]={0,0,0}
          "Position vector from origin of arrow frame to double arrow tail, resolved in arrow frame"
          annotation (Dialog);
        input Modelica_SIunits.Position r_head[3]={0,0,0}
          "Position vector from double arrow tail to the head of the double arrow, resolved in arrow frame"
          annotation (Dialog);
        input Modelica_SIunits.Diameter diameter=world.defaultArrowDiameter
          "Diameter of arrow line" annotation (Dialog);
        input Modelica_Mechanics_MultiBody.Types.Color color=Types.Defaults.ArrowColor
          "Color of double arrow" annotation (Dialog(colorSelector=true));
        input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
          "Material property describing the reflecting of ambient light (= 0 means, that light is completely absorbed)"
                                                                                                              annotation(Dialog);

      protected
        outer Modelica_Mechanics_MultiBody.World world;
        Modelica_SIunits.Length length=Modelica_Math.Vectors.length(r_head)
          "Length of arrow";
        Real e_x[3](each final unit="1", start={1,0,0}) = noEvent(if length < 1.e-10 then {1,0,0} else r_head/length);
        Real rxvisobj[3](each final unit="1") = transpose(R.T)*e_x
          "X-axis unit vector of shape, resolved in world frame"
            annotation (HideResult=true);
        Modelica_SIunits.Position rvisobj[3]=r + T.resolve1(R.T, r_tail)
          "Position vector from world frame to shape frame, resolved in world frame"
          annotation (HideResult=true);

        Modelica_SIunits.Length headLength=noEvent(max(0, min(length, diameter*
            Types.Defaults.ArrowHeadLengthFraction)));
        Modelica_SIunits.Length headWidth=noEvent(max(0, diameter*Types.Defaults.ArrowHeadWidthFraction));
        Modelica_SIunits.Length arrowLength=noEvent(max(0, length - 1.5*
            diameter*Types.Defaults.ArrowHeadLengthFraction));
        Visualizers.Advanced.Shape arrowLine(
          length=arrowLength,
          width=diameter,
          height=diameter,
          lengthDirection = to_unit1(r_head),
          widthDirection={0,1,0},
          shapeType="cylinder",
          color=color,
          specularCoefficient=specularCoefficient,
          r_shape=r_tail,
          r=r,
          R=R) if world.enableAnimation;
        Visualizers.Advanced.Shape arrowHead1(
          length=headLength,
          width=headWidth,
          height=headWidth,
          lengthDirection = to_unit1(r_head),
          widthDirection={0,1,0},
          shapeType="cone",
          color=color,
          specularCoefficient=specularCoefficient,
          r=rvisobj + rxvisobj*arrowLength,
          R=R) if world.enableAnimation;
        Visualizers.Advanced.Shape arrowHead2(
          length=headLength,
          width=headWidth,
          height=headWidth,
          lengthDirection = to_unit1(r_head),
          widthDirection={0,1,0},
          shapeType="cone",
          color=color,
          specularCoefficient=specularCoefficient,
          r=rvisobj + rxvisobj*(arrowLength + 0.5*headLength),
          R=R) if world.enableAnimation;

        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-100,28},{0,-28}},
                lineColor={128,128,128},
                fillColor={128,128,128},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{40,60},{100,0},{40,-60},{40,60}},
                lineColor={128,128,128},
                fillColor={128,128,128},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,105},{150,65}},
                textString="%name",
                lineColor={0,0,255}),
              Polygon(
                points={{0,60},{60,0},{0,-60},{0,60}},
                lineColor={128,128,128},
                fillColor={128,128,128},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<HTML>
<p>
Model <b>DoubleArrow</b> defines a double arrow that is dynamically
visualized at the defined location (see variables below).
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/DoubleArrow.png\" ALT=\"model Visualizers.Advanced.DoubleArrow\">
</p>

<p>
The variables under heading <b>Parameters</b> below
are declared as (time varying) <b>input</b> variables.
If the default equation is not appropriate, a corresponding
modifier equation has to be provided in the
model where an <b>Arrow</b> instance is used, e.g., in the form
</p>
<pre>
    Visualizers.Advanced.DoubleArrow doubleArrow(diameter = sin(time));
</pre>
<p>
Variable <b>color</b> is an Integer vector with 3 elements,
{r, g, b}, and specifies the color of the shape.
{r,g,b} are the \"red\", \"green\" and \"blue\" color parts.
Note, r g, b are given in the range 0 .. 255.
The predefined type <b>MultiBody.Types.Color</b> contains
a menu definition of the colors used in the MultiBody
library (will be replaced by a color editor).
</p>
</HTML>"));
      end DoubleArrow;

      model Shape
        "Visualizing an elementary object with variable size; all data have to be set as modifiers (see info layer)"

         extends ModelicaServices.Animation.Shape;
         extends
          Modelica_Utilities.Internal.PartialModelicaServices.Animation.PartialShape;

          annotation (
           Icon(coordinateSystem(
               preserveAspectRatio=true,
               extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,-100},{80,60}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-100,60},{-80,100},{100,100},{80,60},{-100,60}},
                lineColor={0,0,255},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{100,100},{100,-60},{80,-100},{80,60},{100,100}},
                lineColor={0,0,255},
                fillColor={160,160,164},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-100,-54},{80,8}},
                lineColor={0,0,0},
                textString="%shapeType"),
              Text(
                extent={{-150,150},{150,110}},
                lineColor={0,0,255},
                textString="%name")}),
           Documentation(info="<HTML>
<p>
Model <b>Shape</b> defines a visual shape that is
shown at the location of its reference coordinate system, called
'object frame' below. All describing variables such
as size and color can vary dynamically (with the only exception
of parameter shapeType). The default equations in the
declarations should be modified by providing appropriate modifier
equations. Model <b>Shape</b> is usually used as a basic building block to
implement simpler to use graphical components.
</p>
<p>
The following shapes are supported via
parameter <b>shapeType</b> (e.g., shapeType=\"box\"):<br>&nbsp;
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Shape.png\" ALT=\"model Visualizers.FixedShape\">
</p>

<p>&nbsp;<br>
The dark blue arrows in the figure above are directed along
variable <b>lengthDirection</b>. The light blue arrows are directed
along variable <b>widthDirection</b>. The <b>coordinate systems</b>
in the figure represent frame_a of the Shape component.
</p>

<p>
Additionally, <b>external shapes</b> can be specified as (not all options might be supported by all tools):
</p>

<ul>
<li> <b>\"1\", \"2\", ...</b><br>
     define external shapes specified in DXF format in files \"1.dxf\", \"2.dxf\", ...
     The DXF-files must be found either in the current directory or in the directory where
     the Shape instance is stored that references the DXF file.
     This (very limited) option should not be used for new models. Example:<br>
    shapeType=\"1\".<br></li>

<li> \"<b>modelica:</b>//&lt;Modelica-name&gt;/&lt;relative-path-file-name&gt;\"<br>
     characterizes the file that is stored under the location of the
     &lt;Modelica-name&gt; library path with the given relative file name.
     Example:<br> shapeType = \"modelica://Modelica/Resources/Data/Shapes/Engine/piston.dxf\".<br></li>

<li> \"<b>file:</b>//&lt;absolute-file-name&gt;\"<br>
     characterizes an absolute file name in the file system. Example:<br>
     shapeType=\"file://C:/users/myname/shapes/piston.dxf\".</li>
</ul>

<p>
The supported file formats are tool dependent. Most tools support
at least DXF-files (a tool might support 3-dim. Face of the DXF format only),
but may support other format as well (such as stl, obj, 3ds).
Since visualization files contain color and other data, the corresponding
information in the model is usually ignored.
</p>

<p>
The sizes of any of the above components are specified by the
<b>length</b>, <b>width</b> and <b>height</b> variables.
Via variable <b>extra</b> additional data can be defined:
</p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>shapeType</b></th><th>Meaning of parameter <b>extra</b></th></tr>
<tr>
  <td valign=\"top\">\"cylinder\"</td>
  <td valign=\"top\">if extra &gt; 0, a black line is included in the
      cylinder to show the rotation of it.</td>
</tr>
<tr>
  <td valign=\"top\">\"cone\"</td>
  <td valign=\"top\">extra = diameter-left-side / diameter-right-side, i.e.,<br>
      extra = 1: cylinder<br>
      extra = 0: \"real\" cone.</td>
</tr>
<tr>
  <td valign=\"top\">\"pipe\"</td>
  <td valign=\"top\">extra = outer-diameter / inner-diameter, i.e, <br>
      extra = 1: cylinder that is completely hollow<br>
      extra = 0: cylinder without a hole.</td>
</tr>
<tr>
  <td valign=\"top\">\"gearwheel\"</td>
  <td valign=\"top\">extra is the number of teeth of the (external) gear.
If extra &lt; 0, an internal gear is visualized with |extra| teeth.
The axis of the gearwheel is along \"lengthDirection\", and usually:
width = height = 2*radiusOfGearWheel.</td>
</tr>
<tr>
  <td valign=\"top\">\"spring\"</td>
  <td valign=\"top\">extra is the number of windings of the spring.
      Additionally, \"height\" is <b>not</b> the \"height\" but
      2*coil-width.</td>
</tr>
<tr>
  <td valign=\"top\">external shape</td>
  <td valign=\"top\">extra = 0: Visualization from file is not scaled.<br>
                   extra = 1: Visualization from file is scaled with \"length\", \"width\" and height\"
                              of the shape</td>
</tr>
</table>
<p>
Parameter <b>color</b> is a vector with 3 elements,
{r, g, b}, and specifies the color of the shape.
{r,g,b} are the \"red\", \"green\" and \"blue\" color parts.
Note, r g, b are given as Integer[3] in the ranges 0 .. 255,
respectively. The predefined type
<a href=\"modelica://Modelica.Mechanics.MultiBody.Types.Color\">MultiBody.Types.Color</a> contains a menu
definition of the colors used in the MultiBody library together with a color editor.
</p>

<p>
The variables under heading <b>Parameters</b> below
are declared as (time varying) <b>input</b> variables.
If the default equation is not appropriate, a corresponding
modifier equation has to be provided in the
model where a <b>Shape</b> instance is used, e.g., in the form
</p>
<pre>
    Visualizers.Advanced.Shape shape(length = sin(time));
</pre>
</html>"));
      end Shape;

      model Surface
        "Visualizing a moveable, parameterized surface; the surface characteristic is provided by a function"
        extends Modelica_Mechanics_MultiBody.Icons.Surface;
        extends
          Modelica_Utilities.Internal.PartialModelicaServices.Animation.PartialSurface;
        extends ModelicaServices.Animation.Surface;
        annotation (Icon(graphics={Polygon(
                points={{-102,40},{-98,92},{28,-8},{96,146},{104,-118},{-18,-34},{-52,
                    -130},{-102,40}},
                lineColor={0,0,255},
                smooth=Smooth.Bezier,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,140},{150,100}},
                lineColor={0,0,255},
                textString="%name")}), Documentation(info="<html>
<p>
Model <b>Surface</b> defines a moveable, parametrized surface in 3-dim. space
that is used for animation. This object is specified by:
</p>

<ul>
<li> The surface frame (orientation object \"R\" and origin \"r_0\")
     in which the data is specified.</li>
<li> A set of two parameters, one in u- and one in v-direction,
     that defines the control points. </li>
<li> A time-varying position of each control point with respect to
     the surface frame.</li>
</ul>

<p>
The parameter values (u,v) are given by the ordinal numbers of the
corresponding control point in u- or in v-direction, respectively.
The surface is then defined by the replaceable function \"surfaceCharacteristic\" with the
interface <a href=\"modelica://Modelica.Mechanics.MultiBody.Interfaces.partialSurfaceCharacteristic\">partialSurfaceCharacteristic</a>
that returns the x-, y-, z- coordinate of every control point in form of 3 arrays X, Y, Z, and an optional color array C, if every control point shall have a different color:
</p>

<pre>
  Real X[nu,nv], Y[nu,nv], Z[nu,nv], C[nu,nv,3];
</pre>

<p>
An example of a parameterized surface with color coding is shown in the next figure:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Surface.png\">
</blockquote>

<p>
Models <a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Torus\">Torus</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.VoluminousWheel\">VoluminousWheel</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.PipeWithScalarField\">PipeWithScalarField</a>,
demonstrate how new visualizer objects can be constructed with the Surface model.<br>
The direct usage of the Surface model, as well as of the Torus and the VoluminousWheel models, are demonstrated with example
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.Surfaces\">Examples.Elementary.Surfaces</a>.
</p>
</html>"));
      end Surface;

      model PipeWithScalarField "Visualizing a pipe with a scalar field"
        input Frames.Orientation R=Frames.nullRotation()
          "Orientation object to rotate the world frame into the surface frame"
          annotation(Dialog(group="Surface frame"));
        input Modelica_SIunits.Position r_0[3]={0,0,0}
          "Position vector from origin of world frame to origin of surface frame, resolved in world frame"
          annotation(Dialog(group="Surface frame"));

        parameter Modelica_SIunits.Radius rOuter "Outer radius of pipe" annotation(Dialog(group="Surface properties"));
        parameter Modelica_SIunits.Length length "Length of pipe" annotation(Dialog(group="Surface properties"));
        parameter Integer n_rOuter=30 "Number of points along outer radius" annotation(Dialog(group="Surface properties"));
        parameter Integer n_length=10 "Number of points along length" annotation(Dialog(group="Surface properties"));
        parameter Types.SpecularCoefficient specularCoefficient = 0.7
          "Reflection of ambient light (= 0: light is completely absorbed)" annotation(Dialog(group="Surface properties"));
        parameter Real transparency=0
          "Transparency of shape: 0 (= opaque) ... 1 (= fully transparent)"
                                     annotation(Dialog(group="Surface properties"));

        parameter Real xsi[:](each min=0,each max=1)= Modelica_Math.Vectors.relNodePositions(12)
          "[:] Relative position along the pipe with x[1] = 0, x[end] = 1"
          annotation(Dialog(group="Color coding"));
        input Real T[size(xsi,1)]
          "[:] Scalar values at position xsi*length (will be visualized by color)"
                                                                                                         annotation(Dialog(group="Color coding"));
        parameter Real T_min
          "Minimum value of T that corresponds to colorMap[1,:]"                    annotation(Dialog(group="Color coding"));
        parameter Real T_max
          "Maximum value of T that corresponds to colorMap[end,:]"                       annotation(Dialog(group="Color coding"));
        parameter Integer n_colors=64 "Number of colors in the colorMap" annotation(Dialog(group="Color coding"));
        replaceable function colorMap =
            Modelica_Mechanics_MultiBody.Visualizers.Colors.ColorMaps.jet
          constrainedby Modelica_Mechanics_MultiBody.Interfaces.partialColorMap
          "Function defining the color map"
                annotation(choicesAllMatching=true, Dialog(group="Color coding"));
      protected
        parameter Real colorMapData[n_colors,3] = colorMap(n_colors) annotation(HideResult=true);
        Surface surface(
          R=R,
          r_0=r_0,
          nu=n_length,
          nv=n_rOuter,
          wireframe=false,
          multiColoredSurface=true,
          specularCoefficient=specularCoefficient,
          transparency=transparency,
          redeclare function surfaceCharacteristic =
              M_S_L.Mechanics.MultiBody.Visualizers.Advanced.SurfaceCharacteristics.pipeWithScalarField
              (rOuter=rOuter,
               length=length,
               xsi=xsi,
               T=T,
               T_min=T_min,
               T_max=T_max,
               colorMap=colorMapData))
          annotation (Placement(transformation(extent={{-20,2},{0,22}})));
        annotation (Icon(graphics={Bitmap(extent={{-99,60},{99,-60}}, fileName=
                    "modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/PipeWithScalarFieldIcon.png"),
                Text(
                extent={{-150,54},{150,94}},
                lineColor={0,0,255},
                textString="%name")}), Documentation(info="<html>
<p>
Model <b>PipeWithScalarField</b> visualizes a pipe and a scalar
field along the pipe axis. The latter is shown by mapping scalar
field to color values with a color map and utilizing this color
at the perimeter associated with the corresponding axis location.
Typically the scalar field value is a temperature, but might
be also another quantity.
Predefined color maps are available from
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps\">MultiBody.Visualizers.Colors.ColorMaps</a>
and can be selected via parameter \"colorMap\".
A color map with the corresponding scalar field values can be exported
as vector-graphics in svg-format with function
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">MultiBody.Visualizers.Colors.colorMapToSvg</a>.
The position and orientation of the center of the
circle at the left end of the pipe is defined via parameters
\"r_0\" and \"R\", respectively. The pipe axis is oriented along
the x-axis of the local coordinate system described by \"R\",
see figure below:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/PipeWithScalarField.png\">
</blockquote>

<p>
The color coding is shown in the next figure. It was generated with
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">MultiBody.Visualizers.Colors.colorMapToSvg</a>
using the following call:
</p>

<blockquote>
<pre>
colorMapToSvg(Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps.jet(),
              height=50, nScalars=6, T_max=100, caption=\"Temperature in C\");
</pre>
</blockquote>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/PipeWithScalarField-ColorMap.png\">
</blockquote>
</html>"));
      end PipeWithScalarField;

      package SurfaceCharacteristics "Functions returning surface descriptions"
          extends Modelica_Icons.Package;
        function torus
          "Function defining the surface characteristic of a torus"
          extends
            Modelica_Mechanics_MultiBody.Interfaces.partialSurfaceCharacteristic(
              final multiColoredSurface=false);
          input Modelica_SIunits.Radius ri=1 "Inner radius of torus" annotation(Dialog);
          input Modelica_SIunits.Radius ro=0.2
            "Outer radius of torus (=width/2)"                                    annotation(Dialog);
          input Modelica_SIunits.Angle opening=0 "Opening angle of torus" annotation(Dialog);
          input Modelica_SIunits.Angle startAngle= -Modelica_Constants.pi
            "Start angle of torus slice" annotation(Dialog);
          input Modelica_SIunits.Angle stopAngle=Modelica_Constants.pi
            "End angle of torus slice" annotation(Dialog);
        protected
          Modelica_SIunits.Angle alpha;
          Modelica_SIunits.Angle beta;
          Modelica_SIunits.Angle phi_start;
          Modelica_SIunits.Angle phi_stop;
        algorithm
          phi_start :=-Modelica_Constants.pi + opening;
          phi_stop  :=Modelica_Constants.pi - opening;
          for i in 1:nu loop
              alpha := startAngle + (stopAngle-startAngle)*(i-1)/(nu-1);
              for j in 1:nv loop
                  beta := phi_start + (phi_stop-phi_start)*(j-1)/(nv-1);
                  X[i,j] := (ri + ro*cos(beta))*sin(alpha);
                  Y[i,j] := ro*sin(beta);
                  Z[i,j] := (ri + ro*cos(beta))*cos(alpha);
              end for;
          end for;
          annotation (Documentation(info="<html>
<p>
Function <b>torus</b> computes the X,Y,Z arrays to visualize a torus
with model <a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Torus\">Torus</a>.
The left image below shows a torus with ri=0.5 m and ro = 0.2 m.
The right images below shows the torus with the additional parameter
settings:
</p>
<pre>
  opening    =   45 degree
  startAngle = -135 degree
  stopAngle  =  135 degree
</pre>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Torus.png\">
</blockquote>
</html>"));
        end torus;

        function pipeWithScalarField
          "Function defining the surface characteristic of a pipe where a scalar field value is displayed with color along the pipe axis"
          extends
            Modelica_Mechanics_MultiBody.Interfaces.partialSurfaceCharacteristic(
              final multiColoredSurface=true);
          input Modelica_SIunits.Radius rOuter "Outer radius of cylinder" annotation(Dialog);
          input Modelica_SIunits.Length length "Length of cylinder"  annotation(Dialog);
          input Modelica_SIunits.Position xsi[:]
            "Relative position along the pipe with x[1] = 0, x[end] = 1"                                       annotation(Dialog);
          input Real T[size(xsi,1)] "Scalar field value at position xsi*length"
                                                                                annotation(Dialog);
          input Real T_min "T <= T_min is mapped to colorMap[1,:]" annotation(Dialog);
          input Real T_max "T >= T_max is mapped to colorMap[end,:]" annotation(Dialog);
          input Real colorMap[:,3]
            "Color map to map scalar T to a corresponding color"                                                annotation(Dialog);
        protected
          Real beta;
          Real xsi_i;
          Real Ti;
          Real Ci[3];
          Integer k;
        algorithm
          k:=1;
          for i in 1:nu loop
             // Compute actual xsi-position along cylinder axis
             xsi_i := (i-1)/(nu-1);

             // Interpolate in xsi and T to determine the corresponding value of Ti(xsi_i)
             (Ti,k) := Modelica_Math.Vectors.interpolate(xsi, T, xsi_i, k);

             // Map the scalar field value Ti to a color value
            Ci := Modelica_Mechanics_MultiBody.Visualizers.Colors.scalarToColor(
                      Ti,
                      T_min,
                      T_max,
                      colorMap);

             // Determine outputs
             for j in 1:nv loop
                beta := 2*Modelica_Constants.pi*(j-1)/(nv-1);
                X[i,j] := length*xsi_i;
                Y[i,j] := rOuter*sin(beta);
                Z[i,j] := rOuter*cos(beta);
                C[i,j,:] := Ci;
             end for;
          end for;
          annotation (Documentation(info="<html>
<p>
Function <b>pipeWithScalarField</b> computes the X,Y,Z,C arrays in order to
visualize a pipe and a scalar field along the pipe axis with model
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.PipeWithScalarField\">PipeWithScalarField</a>.
The latter is shown by mapping scalar
field to color values with a color map and utilizing this color
at the perimeter associated with the corresponding axis location.
Typically the scalar field value is a temperature, but might
be also another quantity.
Predefined color maps are available from
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps\">MultiBody.Visualizers.Colors.ColorMaps</a>
and can be selected via input argument \"colorMap\".
A color map with the corresponding scalar field values can be exported
as vector-graphics in svg-format with function
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">MultiBody.Visualizers.Colors.colorMapToSvg</a>.
An example is shown in the next figure:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/PipeWithScalarField.png\">
</blockquote>

<p>
The color coding is shown in the next figure. It was generated with
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg</a>
using the following call:
</p>

<blockquote>
<pre>
colorMapToSvg(Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps.jet(),
              height=50, nScalars=6, T_max=100, heading=\"Temperature in C\");
</pre>
</blockquote>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/PipeWithScalarField-ColorMap.png\">
</blockquote>
</html>"));
        end pipeWithScalarField;
        annotation (Documentation(info="<html>
<p>
This package contains functions that are used to define
parameterized surfaces for use with the
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface\">Surface</a>
model.
</p>
</html>"));
      end SurfaceCharacteristics;
      annotation ( Documentation(info="<HTML>
<p>
Package <b>Visualizers.Advanced</b> contains components to visualize
3-dimensional shapes with dynamical sizes. None of the components
has a frame connector. The position and orientation is set via
modifiers. Basic knowledge of Modelica
is needed in order to utilize the components of this package.
These components have also to be used for models,
where the forces and torques in the frame connector are set via
equations (in this case, the models of the Visualizers package cannot be used,
since they all have frame connectors).
</p>
<h4>Content</h4>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Arrow\">Arrow</a></td>
      <td valign=\"top\">Visualizing an arrow where all parts of the arrow can vary dynamically:<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Arrow.png\" ALT=\"model Visualizers.Advanced.Arrow\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.DoubleArrow\">DoubleArrow</a></td>
      <td valign=\"top\">Visualizing a double arrow where all parts of the arrow can vary dynamically:<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/DoubleArrow.png\" ALT=\"model Visualizers.Advanced.DoubleArrow\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape\">Shape</a></td>
      <td valign=\"top\">Visualizing an elementary object with variable size.
      The following shape types are supported:<br>&nbsp;<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/FixedShape.png\" ALT=\"model Visualizers.Advanced.Shape\">
      </td>
  </tr>

  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface\">Surface</a></td>
      <td valign=\"top\">Visualizing a moveable parameterized surface:<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Surface_small.png\">
      </td>
  </tr>

  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.PipeWithScalarField\">PipeWithScalarField</a></td>
      <td valign=\"top\">Visualizing a pipe with a scalar field represented by a color coding:<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/PipeWithScalarFieldIcon.png\">
      </td>
  </tr>
</table>
</HTML>"));
    end Advanced;

    package Internal
      "Visualizers that will be replaced by improved versions in the future (do not use them)"

      extends Modelica_Icons.InternalPackage;

      model FixedLines
        "Visualizing a set of lines as cylinders (e.g., used to display characters)"

        import MultiBody = Modelica_Mechanics_MultiBody;
        import Modelica_Mechanics_MultiBody.Types;
        extends Modelica_Mechanics_MultiBody.Interfaces.PartialVisualizer;

        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        input Real scale(min=0) = 1
          "The 'lines' are visualized 'scale' times bigger"
          annotation (Dialog(group="if animation = true", enable=animation));
        input Modelica_SIunits.Position lines[:,2,2]={[0,0; 1,1],[0,1; 1,0]}
          "List of start and end points of cylinders resolved along n_x and n_y"
          annotation (Dialog(group="if animation = true", enable=animation));
        input Modelica_SIunits.Distance diameter(min=0) = 0.05
          "Diameter of the cylinders defined by lines"
          annotation (Dialog(group="if animation = true", enable=animation));
        input Modelica_SIunits.Position r_lines[3]={0,0,0}
          "Position vector from origin of frame_a to the origin of the 'lines' frame, resolved in frame_a"
          annotation (Dialog(group="if animation = true", enable=animation));
        input Real n_x[3](each final unit="1")={1,0,0}
          "Vector in direction of x-axis of 'lines' frame, resolved in frame_a."
          annotation (Dialog(group="if animation = true", enable=animation));
        input Real n_y[3](each final unit="1")={0,1,0}
          "Vector in direction of y-axis of 'lines' frame, resolved in frame_a."
          annotation (Dialog(group="if animation = true", enable=animation));
        input MultiBody.Types.Color color={0,128,255} "Color of cylinders"
          annotation (Dialog(colorSelector=true, group="if animation = true", enable=animation));
        input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog(group="if animation = true", enable=animation));

      protected
        Lines x_label(
          lines=scale*lines,
          diameter=scale*diameter,
          color=color,
          specularCoefficient = specularCoefficient,
          r_lines=r_lines,
          n_x=n_x,
          n_y=n_y,
          r=frame_a.r_0,
          R=frame_a.R) if world.enableAnimation and animation;
      equation
        frame_a.f = zeros(3);
        frame_a.t = zeros(3);
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={128,128,128},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,145},{150,105}},
                textString="%name",
                lineColor={0,0,255}),
              Polygon(
                points={{-82,-24},{-20,46},{-10,38},{-72,-32},{-82,-24}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-24,-34},{-82,40},{-72,46},{-14,-26},{-24,-34}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{42,-18},{10,40},{20,48},{50,-6},{42,-18}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{10,-68},{84,48},{96,42},{24,-72},{10,-68}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<HTML>
<p>
With model <b>FixedLines</b> a set of lines is defined
that are located relatively to frame_a. Every line
is represented by a cylinder. This allows to define simple shaped
3-dimensional characters. An example is shown in the
following figure:<br>&nbsp;
</p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/FixedLines.png\" ALT=\"model Visualizers.FixedLines\">
<p>&nbsp;<br>
The two letters \"x\" and \"y\" are constructed with 4 lines
by providing the following data for parameter <b>lines</b>
</p>
<pre>
   lines = {[0, 0; 1, 1],[0, 1; 1, 0],[1.5, -0.5; 2.5, 1],[1.5, 1; 2, 0.25]}
</pre>
<p>
Via parameter vectors <b>n_x</b> and <b>n_y</b> a two-dimensional
coordinate system is defined. The points defined with parameter
<b>lines</b> are with respect to this coordinate system. For example
\"[0, 0; 1, 1]\" defines a line that starts at {0,0} and ends at {1,1}.
The diameter and color of all line cylinders are identical.
</p>
</HTML>"));
      end FixedLines;

      model Lines
        "Visualizing a set of lines as cylinders with variable size, e.g., used to display characters (no Frame connector)"

        import MultiBody = Modelica_Mechanics_MultiBody;
        import Modelica_Mechanics_MultiBody.Types;
        import Modelica_Mechanics_MultiBody.Frames;
        import T = Modelica_Mechanics_MultiBody.Frames.TransformationMatrices;
        input Modelica_Mechanics_MultiBody.Frames.Orientation R=
            Frames.nullRotation()
          "Orientation object to rotate the world frame into the object frame"
          annotation (Dialog);
        input Modelica_SIunits.Position r[3]={0,0,0}
          "Position vector from origin of world frame to origin of object frame, resolved in world frame"
          annotation (Dialog);
        input Modelica_SIunits.Position r_lines[3]={0,0,0}
          "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame"
          annotation (Dialog);
        input Real n_x[3](each final unit="1")={1,0,0}
          "Vector in direction of x-axis of 'lines' frame, resolved in object frame"
           annotation(Dialog);
        input Real n_y[3](each final unit="1")={0,1,0}
          "Vector in direction of y-axis of 'lines' frame, resolved in object frame"
         annotation(Dialog);
        input Modelica_SIunits.Position lines[:,2,2]=zeros(
                  0,
                  2,
                  2)
          "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}"
          annotation (Dialog);
        input Modelica_SIunits.Length diameter(min=0) = 0.05
          "Diameter of the cylinders defined by lines" annotation (Dialog);
        input Modelica_Mechanics_MultiBody.Types.Color color={0,128,255}
          "Color of cylinders" annotation (Dialog(colorSelector=true));
        input Types.SpecularCoefficient specularCoefficient = 0.7
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog);
      protected
        parameter Integer n=size(lines, 1) "Number of cylinders";
        T.Orientation R_rel=T.from_nxy(n_x, n_y);
        T.Orientation R_lines=T.absoluteRotation(R.T, R_rel);
        Modelica_SIunits.Position r_abs[3]=r + T.resolve1(R.T, r_lines);
        Modelica_Mechanics_MultiBody.Visualizers.Advanced.Shape cylinders[n](
          each shapeType="cylinder",
          lengthDirection={T.resolve1(R_rel, vector([lines[i, 2, :] - lines[i,
              1, :]; 0])) for i in 1:n},
          length={Modelica_Math.Vectors.length(lines[i, 2, :] - lines[i, 1, :])
              for i in 1:n},
          r={r_abs + T.resolve1(R_lines, vector([lines[i, 1, :]; 0])) for i in
              1:n},
          each width=diameter,
          each height=diameter,
          each widthDirection={0,1,0},
          each color=color,
          each R=R,
          each specularCoefficient=specularCoefficient);
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={128,128,128},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-24,-34},{-82,40},{-72,46},{-14,-26},{-24,-34}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-82,-24},{-20,46},{-10,38},{-72,-32},{-82,-24}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{42,-18},{10,40},{20,48},{50,-6},{42,-18}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{10,-68},{84,48},{96,42},{24,-72},{10,-68}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,145},{150,105}},
                textString="%name",
                lineColor={0,0,255})}),
          Documentation(info="<HTML>
<p>
With model <b>Lines</b> a set of dynamic lines is defined
that are located relatively to frame_a. Every line
is represented by a cylinder. This allows, e.g., to define simple shaped
3-dimensional characters. Note, if the lines are fixed relatively to frame_a,
it is more convenient to use model <b>Visualizers.FixedLines</b>.
An example for dynamic lines is shown in the following figure:<br>&nbsp;
</p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/FixedLines.png\" ALT=\"model Visualizers.FixedLines\">
<p>&nbsp;<br>
The two letters \"x\" and \"y\" are constructed with 4 lines
by providing the following data for input variable <b>lines</b>
</p>
<pre>
   lines = {[0, 0; 1, 1],[0, 1; 1, 0],[1.5, -0.5; 2.5, 1],[1.5, 1; 2, 0.25]}
</pre>
<p>
Via vectors <b>n_x</b> and <b>n_y</b> a two-dimensional
coordinate system is defined. The points defined with variable
<b>lines</b> are with respect to this coordinate system. For example
\"[0, 0; 1, 1]\" defines a line that starts at {0,0} and ends at {1,1}.
The diameter and color of all line cylinders are identical
and are defined by parameters.
</p>

</html>"));

      end Lines;

      annotation (Documentation(info="<html>
<p>
This package contains components to construct 3-dim. fonts
with \"cylinder\" elements for the animation window.
This is just a temporary hack until 3-dim. fonts are supported in
Modelica tools. The components are used to construct the \"x\", \"y\",
\"z\" labels of coordinates systems in the animation.
</p>
</html>"));
    end Internal;
    annotation ( Documentation(info="<HTML>
<p>
Package <b>Visualizers</b> contains components to visualize
3-dimensional shapes. These components are the basis for the
animation features of the MultiBody library.
</p>
<h4>Content</h4>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.FixedShape\">FixedShape</a><br>
             <a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.FixedShape2\">FixedShape2</a></td>
      <td valign=\"top\">Visualizing an elementary shape with dynamically varying shape attributes.
      FixedShape has one connector frame_a, whereas FixedShape2 has additionally
          a frame_b for easier connection to further visual objects.
          The following shape types are supported:<br>&nbsp;<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/FixedShape.png\" ALT=\"model Visualizers.FixedShape\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.FixedFrame\">FixedFrame</a></td>
      <td valign=\"top\">Visualizing a coordinate system including axes labels with fixed sizes:<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/FixedFrame2.png\"
       ALT=\"model Visualizers.FixedFrame\">
      </td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.FixedArrow\">FixedArrow</a>,<br>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.SignalArrow\">SignalArrow</a></td>
      <td valign=\"top\">Visualizing an arrow. Model \"FixedArrow\" provides
      a fixed sized arrow, model \"SignalArrow\" provides
      an arrow with dynamically varying length that is defined
      by an input signal vector:<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Arrow.png\">
      </td>
  </tr>

  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Ground\">Ground</a></td>
      <td valign=\"top\">Visualizing the x-y plane by a box:<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/GroundSmall.png\">
      </td>
  </tr>

  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Torus\">Torus</a></td>
      <td valign=\"top\">Visualizing a torus:<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/TorusIcon.png\">
      </td>
  </tr>

  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.VoluminousWheel\">VoluminousWheel</a></td>
      <td valign=\"top\">Visualizing a wheel:<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/VoluminousWheelIcon.png\">
      </td>
  </tr>

  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.PipeWithScalarField\">PipeWithScalarField</a></td>
      <td valign=\"top\">Visualizing a pipe with a scalar field represented by a color coding:<br>
      <IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/PipeWithScalarFieldIcon.png\">
      </td>
  </tr>

<tr><td valign=\"top\"><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced\">Advanced</a></td>
      <td valign=\"top\"> <b>Package</b> that contains components to visualize
          3-dimensional shapes where all parts of the shape
          can vary dynamically. Basic knowledge of Modelica is
          needed in order to utilize the components of this package.
      </td>
  </tr>
</table>
<p>
The colors of the visualization components are declared with
the predefined type <b>MultiBody.Types.Color</b>.
This is a vector with 3 elements,
{r, g, b}, and specifies the color of the shape.
{r,g,b} are the \"red\", \"green\" and \"blue\" color parts.
Note, r g, b are given as Integer[3] in the ranges 0 .. 255,
respectively.
</p>
</HTML>"),   Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
              {100,100}}), graphics={
          Rectangle(
            extent={{-80,26},{26,-70}},
            lineColor={95,95,95},
            fillPattern=FillPattern.Solid,
            fillColor={245,245,245}),
          Polygon(
            points={{-80,26},{-16,70},{80,70},{26,26},{-80,26}},
            lineColor={95,95,95},
            smooth=Smooth.None,
            fillColor={245,245,245},
            fillPattern=FillPattern.Solid),
          Polygon(
            points={{80,70},{26,26},{26,-70},{80,-32},{80,70}},
            lineColor={95,95,95},
            smooth=Smooth.None,
            fillColor={245,245,245},
            fillPattern=FillPattern.Solid)}));
  end Visualizers;

  package Types "Constants and types with choices, especially to build menus"
    extends Modelica_Icons.TypesPackage;

    type Axis = Modelica_Icons.TypeReal[3](each final unit="1")
      "Axis vector with choices for menus"                                      annotation (
      preferredView="text",
      Evaluate=true,
      choices(
        choice={1,0,0} "{1,0,0} \"x axis\"",
        choice={0,1,0} "{0,1,0} \"y axis\"",
        choice={0,0,1} "{0,0,1} \"z axis\"",
        choice={-1,0,0} "{-1,0,0} \"negative x axis\"",
        choice={0,-1,0} "{0,-1,0} \"negative y axis\"",
        choice={0,0,-1} "{0,0,-1} \"negative z axis\""),
      Documentation(info="<html>
</html>"));

    type AxisLabel = Modelica_Icons.TypeString
      "Label of axis with choices for menus"                                          annotation (
        preferredView="text", choices(
        choice="x" "x",
        choice="y" "y",
        choice="z" "z"));

    type RotationSequence = Modelica_Icons.TypeInteger[3] (min={1,1,1}, max={3,3,3})
      "Sequence of planar frame rotations with choices for menus" annotation (
      preferredView="text",
      Evaluate=true,
      choices(
        choice={1,2,3} "{1,2,3} \"Cardan/Tait-Bryan angles\"",
        choice={3,1,3} "{3,1,3} \"Euler angles\"",
        choice={3,2,1} "{3,2,1}"));

    type Color = Modelica_Icons.TypeInteger[3] (each min=0, each max=255)
      "RGB representation of color"
      annotation (
        Dialog(colorSelector=true),
        choices(
          choice={0,0,0} "{0,0,0}       \"black\"",
          choice={155,0,0} "{155,0,0}     \"dark red\"",
          choice={255,0,0} "{255,0,0 }    \"red\"",
          choice={255,65,65} "{255,65,65}   \"light red\"",
          choice={0,128,0} "{0,128,0}     \"dark green\"",
          choice={0,180,0} "{0,180,0}     \"green\"",
          choice={0,230,0} "{0,230,0}     \"light green\"",
          choice={0,0,200} "{0,0,200}     \"dark blue\"",
          choice={0,0,255} "{0,0,255}     \"blue\"",
          choice={0,128,255} "{0,128,255}   \"light blue\"",
          choice={255,255,0} "{255,255,0}   \"yellow\"",
          choice={255,0,255} "{255,0,255}   \"pink\"",
          choice={100,100,100} "{100,100,100} \"dark grey\"",
          choice={155,155,155} "{155,155,155} \"grey\"",
          choice={255,255,255} "{255,255,255} \"white\""),
      Documentation(info="<html>
<p>
Type <b>Color</b> is an Integer vector with 3 elements,
{r, g, b}, and specifies the color of a shape.
{r,g,b} are the \"red\", \"green\" and \"blue\" color parts.
Note, r g, b are given in the range 0 .. 255.
</p>
</html>"));
    type RealColor =
                 Modelica_Icons.TypeReal[3] (each min=0, each max=255)
      "RGB representation of color as Real type"
      annotation (
        Dialog(colorSelector=true),
        choices(
          choice={0,0,0} "{0,0,0}       \"black\"",
          choice={155,0,0} "{155,0,0}     \"dark red\"",
          choice={255,0,0} "{255,0,0 }    \"red\"",
          choice={255,65,65} "{255,65,65}   \"light red\"",
          choice={0,128,0} "{0,128,0}     \"dark green\"",
          choice={0,180,0} "{0,180,0}     \"green\"",
          choice={0,230,0} "{0,230,0}     \"light green\"",
          choice={0,0,200} "{0,0,200}     \"dark blue\"",
          choice={0,0,255} "{0,0,255}     \"blue\"",
          choice={0,128,255} "{0,128,255}   \"light blue\"",
          choice={255,255,0} "{255,255,0}   \"yellow\"",
          choice={255,0,255} "{255,0,255}   \"pink\"",
          choice={100,100,100} "{100,100,100} \"dark grey\"",
          choice={155,155,155} "{155,155,155} \"grey\"",
          choice={255,255,255} "{255,255,255} \"white\""),
      Documentation(info="<html>
<p>
Type <b>RealColor</b> is a Real vector with 3 elements,
{r, g, b}, and specifies the color of a shape.
{r,g,b} are the \"red\", \"green\" and \"blue\" color parts.
Note, r g, b are given in the range 0 .. 255.
</p>
</html>"));
    type SpecularCoefficient = Modelica_Icons.TypeReal(min=0)
      "Reflection of ambient light (= 0: light is completely absorbed)"
         annotation (
           choices(choice=0 "\"0.0 (dull)\"",choice=0.7 "\"0.7 (medium)\"", choice=1
          "\"1.0 (glossy)\""),
      Documentation(info="<html>
<p>
Type <b>SpecularCoefficient</b> defines the reflection of
ambient light on shape surfaces. If value = 0, the light
is completely absorbed. Often, 0.7 is a reasonable value.
It might be that from some viewing directions, a body is no
longer visible, if the SpecularCoefficient value is too high.
In the following image, the different values of SpecularCoefficient
are shown for a cylinder:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/SpecularCoefficient.png\" />
</p>
</html>"));
    type ShapeType = Modelica_Icons.TypeString
      "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring, <external shape>)"
       annotation ( choices(
        choice="box" "\"box\"",
        choice="sphere" "\"sphere\"",
        choice="cylinder" "\"cylinder\"",
        choice="pipecylinder" "\"pipecylinder\"",
        choice="cone" "\"cone\"",
        choice="pipe" "\"pipe\"",
        choice="beam" "\"beam\"",
        choice="gearwheel" "\"gearwheel\"",
        choice="spring" "\"spring\"",
        choice="modelica://PackageName/PathName.dxf"),
      Documentation(info="<html>
<p>
Type <b>ShapeType</b> is used to define the shape of the
visual object as parameter String. Usually, \"shapeType\" is used
as instance name. The following
values for shapeType are possible, e.g., shapeType=\"box\":
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Shape.png\" ALT=\"model Visualizers.FixedShape\">
</p>

<p>
The dark blue arrows in the figure above are directed along
variable <b>lengthDirection</b>. The light blue arrows are directed
along variable <b>widthDirection</b>. The <b>coordinate systems</b>
in the figure represent frame_a of the Shape component.
</p>

<p>
Additionally, external shapes can be specified as (not all options might be supported by all tools):
</p>

<ul>
<li> <b>\"1\", \"2\", ...</b><br>
     define external shapes specified in DXF format in files \"1.dxf\", \"2.dxf\", ...
     The DXF-files must be found either in the current directory or in the directory where
     the Shape instance is stored that references the DXF file.
     This (very limited) option should not be used for new models. Example:<br>
    shapeType=\"1\".<br></li>

<li> \"<b>modelica:</b>//&lt;Modelica-name&gt;/&lt;relative-path-file-name&gt;\"<br>
     characterizes the file that is stored under the location of the
     &lt;Modelica-name&gt; library path with the given relative file name.
     Example:<br> shapeType = \"modelica://Modelica/Resources/Data/Shapes/Engine/piston.dxf\".<br></li>

<li> \"<b>file:</b>//&lt;absolute-file-name&gt;\"<br>
     characterizes an absolute file name in the file system. Example:<br>
     shapeType=\"file://C:/users/myname/shapes/piston.dxf\".</li>
</ul>

<p>
The supported file formats are tool dependent. Most tools support
at least DXF-files (a tool might support 3-dim. Face of the DXF format only),
but may support other format as well (such as stl, obj, 3ds).
Since visualization files contain color and other data, the corresponding
information in the model is usually ignored.
</p>
</html>"));
    type ShapeExtra = Modelica_Icons.TypeReal
      "Type of the additional data that can be defined for an elementary ShapeType"
         annotation (
      Documentation(info="<html>
<p>
This type is used in shapes of visual objects to define
extra data depending on the shape type. Usually, input
variable <b>extra</b> is used as instance name:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>shapeType</b></th><th>Meaning of parameter <b>extra</b></th></tr>
<tr>
  <td valign=\"top\">\"cylinder\"</td>
  <td valign=\"top\">if extra &gt; 0, a black line is included in the
      cylinder to show the rotation of it.</td>
</tr>
<tr>
  <td valign=\"top\">\"cone\"</td>
  <td valign=\"top\">extra = diameter-left-side / diameter-right-side, i.e.,<br>
      extra = 1: cylinder<br>
      extra = 0: \"real\" cone.</td>
</tr>
<tr>
  <td valign=\"top\">\"pipe\"</td>
  <td valign=\"top\">extra = outer-diameter / inner-diameter, i.e, <br>
      extra = 1: cylinder that is completely hollow<br>
      extra = 0: cylinder without a hole.</td>
</tr>
<tr>
  <td valign=\"top\">\"gearwheel\"</td>
  <td valign=\"top\">extra is the number of teeth of the (external) gear.
If extra &lt; 0, an internal gear is visualized with |extra| teeth.
The axis of the gearwheel is along \"lengthDirection\", and usually:
width = height = 2*radiusOfGearWheel.</td>
</tr>
<tr>
  <td valign=\"top\">\"spring\"</td>
  <td valign=\"top\">extra is the number of windings of the spring.
      Additionally, \"height\" is <b>not</b> the \"height\" but
      2*coil-width.</td>
</tr>
<tr>
  <td valign=\"top\">external shape</td>
  <td valign=\"top\">extra = 0: Visualization from file is not scaled.<br>
                     extra = 1: Visualization from file is scaled with \"length\", \"width\" and height\"
                                of the shape</td>
</tr>

</table>

</html>"));

    type ResolveInFrameA = enumeration(
        world "Resolve in world frame",
        frame_a "Resolve in frame_a",
        frame_resolve
          "Resolve in frame_resolve (frame_resolve must be connected)")
      "Enumeration to define the frame in which an absolute vector is resolved (world, frame_a, frame_resolve)"
                                                 annotation (Documentation(info="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.ResolveInFrameA.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve vector in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve vector in frame_a</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve vector in frame_resolve (frame_resolve must be connected)</td></tr>
</table>
</html>"));
    type ResolveInFrameB = enumeration(
        world "Resolve in world frame",
        frame_b "Resolve in frame_b",
        frame_resolve
          "Resolve in frame_resolve (frame_resolve must be connected)")
      "Enumeration to define the frame in which an absolute vector is resolved (world, frame_b, frame_resolve)"
                                                 annotation (Documentation(info="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.ResolveInFrameB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve vector in world frame</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve vector in frame_b</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve vector in frame_resolve (frame_resolve must be connected)</td></tr>
</table>
</html>"));
    type ResolveInFrameAB = enumeration(
        world "Resolve in world frame",
        frame_a "Resolve in frame_a",
        frame_b "Resolve in frame_b",
        frame_resolve
          "Resolve in frame_resolve (frame_resolve must be connected)")
      "Enumeration to define the frame in which a relative vector is resolved (world, frame_a, frame_b, frame_resolve)"
                                                 annotation (Documentation(info="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">world</td>
    <td valign=\"top\">Resolve vector in world frame</td></tr>

<tr><td valign=\"top\">frame_a</td>
    <td valign=\"top\">Resolve vector in frame_a</td></tr>

<tr><td valign=\"top\">frame_b</td>
    <td valign=\"top\">Resolve vector in frame_b</td></tr>

<tr><td valign=\"top\">frame_resolve</td>
    <td valign=\"top\">Resolve vector in frame_resolve (frame_resolve must be connected)</td></tr>
</table>
</html>"));

    type RotationTypes = enumeration(
        RotationAxis "Rotating frame_a around an angle with a fixed axis",
        TwoAxesVectors "Resolve two vectors of frame_b in frame_a",
        PlanarRotationSequence "Planar rotation sequence")
      "Enumeration defining in which way the fixed orientation of frame_b with respect to frame_a is specified"
        annotation (
          Documentation(Evaluate=true, info="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.RotationTypes.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">RotationAxis</td>
    <td valign=\"top\">frame_b is defined by rotating the coordinate system along
        an axis fixed in frame_a and with a fixed angle.</td></tr>

<tr><td valign=\"top\">TwoAxesVectors</td>
    <td valign=\"top\">frame_b is defined by resolving two vectors of frame_b in frame_a.</td></tr>

<tr><td valign=\"top\">PlanarRotationSequence</td>
    <td valign=\"top\">frame_b is defined by rotating the coordinate system along
        3 consecutive axes vectors with fixed rotation angles
        (e.g., Cardan or Euler angle sequence rotation).</td></tr>
</table>
</html>"));

    type GravityTypes = enumeration(
        NoGravity "No gravity field",
        UniformGravity "Uniform gravity field",
        PointGravity "Point gravity field")
      "Enumeration defining the type of the gravity field"
        annotation (Documentation(info="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.GravityTypes.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">NoGravity</td>
    <td valign=\"top\">No gravity field</td></tr>

<tr><td valign=\"top\">UniformGravity</td>
    <td valign=\"top\">Gravity field is described by a vector of constant gravity acceleration</td></tr>

<tr><td valign=\"top\">PointGravity</td>
    <td valign=\"top\">Central gravity field. The gravity acceleration vector is directed to
        the field center and the gravity is proportional to 1/r^2, where
        r is the distance to the field center.</td></tr>
</table>
</html>"));

  type Init = enumeration(
        Free,
        PositionVelocity,
        SteadyState,
        Position,
        Velocity,
        VelocityAcceleration,
        PositionVelocityAcceleration);

    package Defaults "Default settings of the MultiBody library via constants"
      extends Modelica_Icons.Package;

      // Color defaults
      constant Types.Color BodyColor={0,128,255}
        "Default color for body shapes that have mass (light blue)";
      constant Types.Color RodColor={155,155,155}
        "Default color for massless rod shapes (grey)";
      constant Types.Color JointColor={255,0,0}
        "Default color for elementary joints (red)";
      constant Types.Color ForceColor={0,128,0}
        "Default color for force arrow (dark green)";
      constant Types.Color TorqueColor={0,128,0}
        "Default color for torque arrow (dark green)";
      constant Types.Color SpringColor={0,0,255}
        "Default color for a spring (blue)";
      constant Types.Color SensorColor={255,255,0}
        "Default color for sensors (yellow)";
      constant Types.Color FrameColor={0,0,0}
        "Default color for frame axes and labels (black)";
      constant Types.Color ArrowColor={0,0,255}
        "Default color for arrows and double arrows (blue)";

      // Arrow and frame defaults
      constant Real FrameHeadLengthFraction=5.0
        "Frame arrow head length / arrow diameter";
      constant Real FrameHeadWidthFraction=3.0
        "Frame arrow head width / arrow diameter";
      constant Real FrameLabelHeightFraction=3.0
        "Height of frame label / arrow diameter";
      constant Real ArrowHeadLengthFraction=4.0
        "Arrow head length / arrow diameter";
      constant Real ArrowHeadWidthFraction=3.0
        "Arrow head width / arrow diameter";

      // Other defaults
      constant Modelica_SIunits.Diameter BodyCylinderDiameterFraction=3
        "Default for body cylinder diameter as a fraction of body sphere diameter";
      constant Real JointRodDiameterFraction=2
        "Default for rod diameter as a fraction of joint sphere diameter attached to rod";

      /*
  constant Real N_to_m(unit="N/m") = 1000
    "Default force arrow scaling (length = force/N_to_m_default)";
  constant Real Nm_to_m(unit="N.m/m") = 1000
    "Default torque arrow scaling (length = torque/Nm_to_m_default)";
*/
      annotation ( Documentation(info="<html>
<p>
This package contains constants used as default setting
in the MultiBody library.
</p>
</html>"));
    end Defaults;

    annotation ( Documentation(info="<HTML>
<p>
In this package <b>types</b> and <b>constants</b> are defined that are used in the
MultiBody library. The types have additional annotation choices
definitions that define the menus to be built up in the graphical
user interface when the type is used as parameter in a declaration.
</p>
</HTML>"));
  end Types;

  package Icons "Icons for MultiBody package"
    extends Modelica_Icons.IconsPackage;
    model Surface "Surface icon"
      annotation (Icon(graphics={Polygon(
              points={{-102,40},{-98,92},{28,-8},{96,146},{104,-118},{-18,-34},{-52,
                  -130},{-102,40}},
              lineColor={0,0,255},
              smooth=Smooth.Bezier,
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,140},{150,100}},
              lineColor={0,0,255},
              textString="%name")}), Documentation(info="<html>
<p>
Model <b>Surface</b> defines a moveable, parametrized surface in 3-dim. space
that is used for animation. This object is specified by:
</p>

<ul>
<li> The surface frame (orientation object \"R\" and origin \"r_0\")
     in which the data is specified.</li>
<li> A set of two parameters, one in u- and one in v-direction,
     that defines the control points. </li>
<li> A time-varying position of each control point with respect to
     the surface frame.</li>
</ul>

<p>
The parameter values (u,v) are given by the ordinal numbers of the
corresponding control point in u- or in v-direction, respectively.
The surface is then defined by the replaceable function \"surfaceCharacteristic\" with the
interface <a href=\"modelica://Modelica.Mechanics.MultiBody.Interfaces.partialSurfaceCharacteristic\">partialSurfaceCharacteristic</a>
that returns the x-, y-, z- coordinate of every control point in form of 3 positional
arrays and an optional color array, if every control point shall have a different
color:
</p>

<pre>
  Real X[nu,nv], Y[nu,nv], Z[nu,nv], colorArray[nu,nv];
</pre>

<p>
Models <a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Torus\">Torus</a>
and <a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.VoluminousWheel\">VoluminousWheel</a>
demonstrate how new visualizer objects can be constructed with the Surface model.<br>
The direct usage of the Surface model, as well as of the Torus and the VoluminousWheel models, are demonstrated with example
<a href=\"modelica://Modelica.Mechanics.MultiBody.Examples.Elementary.Surfaces\">Examples.Elementary.Surfaces</a>.
</p>
</html>"));
    end Surface;

    partial class MotorIcon "Icon of an electrical motor."

      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              lineColor={82,0,2},
              fillColor={252,37,57},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-100.0,-50.0},{30.0,50.0}},
              radius=10.0),
            Polygon(
              fillColor={64,64,64},
              fillPattern=FillPattern.Solid,
              points={{-100.0,-90.0},{-90.0,-90.0},{-60.0,-20.0},{-10.0,-20.0},{20.0,-90.0},{30.0,-90.0},{30.0,-100.0},{-100.0,-100.0},{-100.0,-90.0}}),
            Rectangle(
              lineColor={64,64,64},
              fillColor={255,255,255},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{30.0,-10.0},{90.0,10.0}})}),
        Documentation(info="<html>
<p>
Icon of an <b>electrical motor</b> model.
</p>
</html>"));
    end MotorIcon;
  end Icons;
annotation (
  Documentation(info="<HTML>
<p>
Library <b>MultiBody</b> is a <b>free</b> Modelica package providing
3-dimensional mechanical components to model in a convenient way
<b>mechanical systems</b>, such as robots, mechanisms, vehicles.
Typical animations generated with this library are shown
in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/MultiBody.png\">
</p>

<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide\">MultiBody.UsersGuide</a>
     discusses the most important aspects how to use this library.</li>
<li> <a href=\"modelica://Modelica.Mechanics.MultiBody.Examples\">MultiBody.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>

<p>
Copyright &copy; 1998-2013, Modelica Association and DLR.
</p>
<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a> or visit <a href=\"https://www.modelica.org/licenses/ModelicaLicense2\"> https://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>
</HTML>"), Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
            {100,100}}), graphics={
        Polygon(
          points={{-58,76},{6,76},{-26,50},{-58,76}},
          lineColor={95,95,95},
          smooth=Smooth.None,
          fillColor={255,255,255},
          fillPattern=FillPattern.Solid),
        Line(
          points={{-26,50},{28,-50}},
          color={0,0,0},
          smooth=Smooth.None),
        Ellipse(
          extent={{-4,-14},{60,-78}},
          lineColor={135,135,135},
          fillPattern=FillPattern.Sphere,
          fillColor={255,255,255})}),
    uses(                           ModelicaServices(version="1.2"), M_S_L(
          version="3.2.2")));
end Modelica_Mechanics_MultiBody;
