within ;
encapsulated package Modelica_Fluid
  "Library of 1-dim. thermo-fluid flow models using the Modelica_Media media description"
  import Modelica_Icons;
  import Modelica_Media_Interfaces;
  import Modelica_Constants;
  import Modelica_Fluid_Interfaces;
  import Modelica_Thermal_HeatTransfer_Interfaces;
  import Modelica_Blocks_Interfaces;
  import Modelica_Math;
  import Modelica_Media;
  import Modelica_Mechanics_Translational_Interfaces;
  import Modelica_Mechanics_Rotational_Interfaces;
  import Modelica_Blocks;
  import Modelica_Utilities;
  extends Modelica_Icons.Package;
import SI = Modelica_SIunits;
import Cv = Modelica_SIunits.Conversions;

package UsersGuide "User's Guide"
  extends Modelica_Icons.Information;

  class Overview "Overview"
    extends Modelica_Icons.Information;

    annotation (Documentation(info="<HTML>
<p>
The Modelica_Fluid library provides basic interfaces and
components to model 1-dimensional thermo-fluid flow in networks of pipes.
It is not the intention that this library covers all
application cases because the fluid flow area is too large and
because for special applications it is possible to implement
libraries with simpler component interfaces.
Instead, the goal is that the Modelica_Fluid library provides
a <b>reasonable set of components</b> and that it <b>demonstrates</b>
how to implement components of a fluid flow library in Modelica,
in particular to cope with difficult issues such as connector
design, reversing flow and initialization. It is planned to
include more components in the future. User proposals are
welcome.
</p>
<p>
This library has the following main features:
</p>
<ul>
<li> The connectors Modelica_Fluid.Interfaces.FluidPort_a/_b are designed
     for one-dimensional flow of a <b>single substance</b>
     or of a <b>mixture of substances</b> with optional <b>multiple phases</b>.
     All media models from Modelica_Media can be utilized when
     connecting components. For one substance media, the additional arrays for
     multiple
     substance media have zero dimension and are therefore removed
     from the code during translation. The general connector definition
     therefore does not introduce an overhead for special cases.<br>&nbsp;</li>
<li> All the components of the Modelica_Fluid library are designed
     that they can be utilized for all media models from
     Modelica_Media if this is possible. For example, all media can
     be utilized for the Modelica_Fluid.Sensors/Sources components.
     For some components only special media are possible, since additional
     functionality is required. For example,
     Modelica_Fluid.Components.Evaporator requires a two phase medium
     (extending from Modelica_Media.Interfaces.PartialTwoPhaseMedium).
     <br>&nbsp;</li>
<li> In order to simplify the initialization in the components,
     there is the restriction that only media models are supported
     that have T, (p,T), (p,h), (T,X), (p,T,X) or (p,h,X) as
     independent variables. Other media models would be possible,
     e.g., with (T,d) as independent variables. However, this requires
     to rewrite the code for the component initialization.
     (Note, T is temperature, p is pressure, d is density,
     h is specific enthalpy, and X is a mass fraction vector).
     <br>&nbsp;</li>
<li> All components work for <b>incompressible</b> and <b>compressible</b> media.
     This is implemented by a small change in the initialization of a
     component, if the medium is incompressible. Otherwise, the equations
     of the components are not influenced by this property.<br>&nbsp;</li>
<li> All components allow fluid flow in both directions, i.e.,
     <b>reversing flow</b> is supported. However, it is possible to declare that
     the flow through a component only has the design direction, in order to
     obtain faster simulation code.<br>&nbsp;</li>
<li> Two or more components can be connected together. This means that
     the pressures of all connected ports are equal and the mass flow rates
     sum up to zero. Specific enthalpy, mass fractions and trace substances are
     mixed according to the mass flow rates.<br>&nbsp;</li>
<li> The <b>momentum balance</b> and the <b>energy balance</b> are only fulfilled exactly if
     <b>two ports of equal diameter</b> are connected. In all other cases, the balances
     are approximated, because kinetic and friction effect are neglected. An explicit fitting
     or junction should be used if these are important for the specific problem at hand.
     In all circuits where friction dominates, or components such as pumps determine the flow rate,
     kinetic pressure is typically irrelevant. You can consider the
     <a href=\"modelica://Modelica_Fluid.Examples.Explanatory.MomentumBalanceFittings\">Modelica_Fluid.Examples.Explanatory.MomentumBalanceFittings</a> model (and its documentation)
     to see one case where the momentum balance essentially depends on kinetic pressure,
     so it is necessary to use explicit fittings in order to obtain correct results.
     <br>&nbsp;</li>
<li> Given the above-mentioned limitations, there is no restriction how components can be connected
     together. The resulting simulation performance however often strongly depends on the
     model structure and modeling assumptions made. In particular the direct connection of
     fluid volumes generally results in high-index DAEs for the pressures. The direct
     connection of flow models generally results in systems of implicit nonlinear algebraic
     equations.<br>&nbsp;</li>
</ul>
</html>"));
  end Overview;

  class GettingStarted "Getting started"
    extends Modelica_Icons.Information;

    annotation (Documentation(info="<html>

<p>
Please explore the
<a href=\"modelica://Modelica_Fluid.Examples\">Examples</a>,
which provide simple models for a broad variety of applications.
</p>
</html>"));
  end GettingStarted;

  package ComponentDefinition "Component definition"
    extends Modelica_Icons.Information;

  class FluidConnectors "Fluid connectors"
    extends Modelica_Icons.Information;

    annotation (Documentation(info="<html>
<p>
In this section the design of the fluid connectors is
explained.
</p>
<p>
Fluid connectors represent the points in a device (e.g., the
flanges) through which a fluid can flow into or out of the component, carrying its
thermodynamic properties; these flanges are assumed to be fixed in space.
</p>
<p>
A major design goal is that components can be arbitrarily
connected and that the important balance equations are automatically
fulfilled when 2 or more components are connected together at
one point as shown in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/UsersGuide/MixingConnections.png\"
     alt=\"MixingConnections.png\">
</p>

<p>
In such a case the balance equations define <b>ideal mixing</b>,
i.e., the upstream discretization scheme of each component uses
values that result from ideal mixing in
an infinitely small time period. If more realistic modelling
is desired that takes into account mixing losses, an explicit
model has to be used in the connection point.
</p>
<h4>Single substance media</h4>
<p>
For a single substance medium, the connector definition in
Modelica_Fluid.Interfaces.FluidPort reduces to
</p>
<pre>
  <b>connector</b> FluidPort
     <b>replaceable package</b> Medium = Modelica_Media.Interfaces.PartialMedium
              \"Medium model of the fluid\";
     <b>flow</b> Medium.MassFlowRate m_flow;
              \"Mass flow rate from the connection point into the component\";
     Medium.AbsolutePressure p
              \"Thermodynamic pressure in the connection point\";
     <b>stream</b> Medium.SpecificEnthalpy h_outflow
               \"Specific thermodynamic enthalpy close to the connection point if m_flow &lt; 0\";
  <b>end</b> FluidPort;
</pre>
<p>
The first statement defines the Medium flowing through the connector.
In a medium, medium specific types such as \"Medium.AbsolutePressure\"
are defined that contain medium specific values for the min, max and
nominal attributes. Furthermore, Medium.MassFlowRate is defined as:
</p>
<pre>
   <b>type</b> MassFlowRate =
      Modelica_SIunits.MassFlowRate(quantity=\"MassFlowRate.\" + mediumName);
</pre>
<p>
With the current library design, it is necessary to explicitly select the medium
model for each component in a circuit. This model is then propagated to the ports,
and a Modelica translator will check that the quantity and unit attributes
of connected interfaces are identical. Therefore, an error occurs,
if connected FluidPorts do not have a medium with the same medium name.
In the future, automatic propagation of fluid models through the ports will be
introduced, but this still not possible with Modelica 3.0.
</p>
<p>
The thermodynamic pressure is an <i>effort</i> variable, which means that the connection
of two or more ports states that the port pressures are the same.
</p>
<p>
The mass flow rate is a <i>flow</i> variable, which means that the connection of two or
more ports states that the sum of all flow rates is zero.
</p>
<p>
The last variable is a <i>stream</i> variable, i.e., a specific quantity carried by the
flow variable. The quantity on the connector always
corresponds to the value close to the connection point, assuming that the fluid is
flowing out of the connector, regardless of the actual direction of the flow. This helps
avoiding singularities when the mass flow goes through zero. The stream properties for the
other flow direction can be inquired with the built-in operator inStream(..), while the
value of the stream variable corresponding to the actual flow direction can be inquired
through the built-in operator actualStream(..).
</p>
<p>
The actual equations corresponding to these operators are introduced and solved automatically
by the tool. In principle, they correspond to the balance equation
sum(flow_variable) = 0 and sum(flow_variable*stream_variable_at_connection) = 0 applied to the set of connected ports. In this case the first equation is the mass balance sum(m_flow) = 0, and the second is the energy balance at the connection point sum(m_flow*h_connection) = 0.
</p>
<p>
In the simpler case of a one-to-one connections between port_a and port_b,
inStream(port_a.h_outflow) just returns port_b.h_outflow. For multiple-way connections,
mixing equations are generated, and special care is taken in order to avoid discontinuities
around zero flow rates. For more details, see this
<a href=\"modelica://Modelica/Resources/Documentation/Fluid/Stream-Connectors-Overview-Rationale.pdf\">presentation</a>
which illustrates the stream concept rationale and the underlying technicalities.
</p>

<p>
A connector should have only the minimal number of variables to
describe the interface, otherwise there will be connection
restrictions in certain cases. Therefore, in the connector
no redundant variables are present, e.g., the temperature T
is not present because it can be computed from the connector
variables pressure p and specific enthalpy h.
</p>

<p>
Here are two simple examples to illustrate modeling with stream connectors. The first
one is a rigid adiabatic volume mixing two flows, where the kinetic and gravitational
terms in the energy balance are neglected for simplicity.
</p>

<pre>
model MixingVolume \"Volume that mixes two flows\"
  replaceable package Medium = Modelica_Media.Interfaces.PartialPureSubstance;
  FluidPort port_a, port_b;
  parameter Modelica_SIunits.Volume V \"Volume of device\";
  Modelica_SIunits.Mass             m \"Mass in device\";
  Modelica_SIunits.Energy           U \"Inner energy in device\";
  Medium.BaseProperties medium(preferredMediumStates=true) \"Medium in the device\";
equation
  // Definition of port variables
  port_a.p         = medium.p;
  port_b.p         = medium.p;
  port_a.h_outflow = medium.h;  // The stream variable always corresponds to the
  port_b.h_outflow = medium.h;  // properties of the fluid holdup (outgoing flow)

  // Total quantities
  m = V*medium.d;
  U = m*medium.u;
   // Mass and energy balance (actualStream(..) is a built-in operator for streams to
  // compute the right h, depending on the flow direction)
  der(m) = port_a.m_flow + port_b.m_flow;
  der(U) = port_a.m_flow*actualStream(port_a.h_outflow) +
           port_b.m_flow*actualStream(port_b.h_outflow);
end MixingVolume;
</pre>

<p>
The second example is the model of a component describing a lumped pressure loss
between two ports, with no energy storage and no heat transfer. An isenthalpic
transformation is assumed (changes in kinetic and potential energy between
inlet and outlet are neglected)
</p>
<pre>
model PressureLoss \"Pressure loss component\"
  replaceable package Medium=Modelica_Media.Interfaces.PartialPureSubstance;
  FluidPort port_a, port_b:
  Medium.ThermodynamicState port_a_state_inflow \"State at port_a if inflowing\";
  Medium.ThermodynamicState port_b_state_inflow \"State at port_b if inflowing\";
  Medium density d_a, d_b \"Density at ports a and b if inflowing\";
  replaceable function f \"Function to compute the mass flow rate\";
equation
  // Medium states for inflowing fluid
  port_a_state_inflow = Medium.setState_phX(port_a.p, inStream(port_a.h_outflow));
  port_b_state_inflow = Medium.setState_phX(port_b.p, inStream(port_b.h_outflow));
  // Mass balance
  0 = port_a.m_flow + port_b.m_flow;
  // Instantaneous propagation of enthalpy flow between the ports with
  // isenthalpic state transformation (no storage and no loss of energy)
  port_a.h_outflow = inStream(port_b.h_outflow);
  port_b.h_outflow = inStream(port_a.h_outflow);
  // (Regularized) Momentum balance
  port_a.m_flow = f(port_a.p, port_b.p, d_a, d_b);
end PressureLoss;
</pre>

<p>
If many such components are connected in series between two models with storage, the
specific enthalpies are propagated in both directions and available to all pressure
loss components, without problems when the mass flow goes through zero. The function
f then uses either d_a or d_b depending on the sign of port_a.p-port_b.p, with a
suitable regularization around zero to avoid discontinuities.
</p>

<p>
Please note that these models are highly idealized in order to explain the stream connector
concept. Device models in the library are much more complete, handling issues such as
initialization, steady vs. dynamic modelling, heat transfer from the outside, etc.
</p>

<h4>Multiple-substance media</h4>
<p>
Modelica_Fluid can handle models where the fluid contains multiple substances, so that its
composition can be characterized by mass fraction vectors.
</p>
<pre>
<b>connector</b> FluidPort
   <b>replaceable package</b> Medium = Modelica_Media.Interfaces.PartialMedium
      \"Medium model of the fluid\";
   <b>flow</b> Medium.MassFlowRate m_flow;
      \"Mass flow rate from the connection point into the component\"
   Medium.AbsolutePressure p
      \"Thermodynamic pressure in the connection point\";
   <b>stream</b> Medium.SpecificEnthalpy h_outflow
       \"Specific thermodynamic enthalpy close to the connection point if m_flow &lt; 0\";
   <b>stream</b> Medium.MassFraction Xi_outflow[Medium.nXi]
       \"Independent mixture mass fractions m_i/m close to the connection point if m_flow &lt; 0\";
   <b>stream</b> Medium.ExtraProperty C_outflow[Medium.nC]
       \"Properties c_i/m close to the connection point if m_flow &lt; 0\";
  <b>end</b> FluidPort;
</pre>
The mass fraction vectors Xi and C are also stream quantities, as they are carried by the mass
flow rate. The corresponding connection equations are sum(m_flow*Xi) and sum(m_flow*C), which correspond to mass balances for the single substances. The vector Xi contains the mass fractions
of the main components of the fluid, and is used together with p and h to determine the
thermodynamic state of the fluid. The vector C contains the mass fraction of the trace components,
which are accounted for in mass balances, but is ignored when computing the fluid properties. This
allows to easily declare and use medium models with trace components starting from existing medium
models (e.g., adding CO<sub>2</sub> traces to Moist Air for air conditioning models).

<h4>Approximations in balance equations at connection point</h4>
<p>
Summing up, when two or more ports of the type FluidPort are connected, the following
equations are generated by the tool:
</p>
<pre>
sum(port_j.m_flow) = 0;               // Total Mass balance
port_j = port_k;                      // Momentum balance
sum(port_j.m_flow*h_connection) = 0;  // Energy balance
sum(port_j.m_flow*Xi_connection) = 0; // Single component mass balances
sum(port_j.m_flow*C_connection) = 0;  // Trace components mass balances
</pre>
<p>
It is <b>very important</b> to bear in mind that
</p>
<ul>
<li> the mass balances are always exact; </li>
<li> the momentum and energy balance are only exact when two port with the same
diameter are connected, because there is no friction and no change in fluid velocity. </li>
</ul>
<p>
In all other cases, i.e., different port diameters and/or multiple port connections:
</p>
<ul>
<li> The momentum balance does not consider friction effects and changes of pressure due to changes
in velocity. </li>
<li> There might thus be errors in the momentum balance of the order of magnitude
of the dynamic pressure &rho;v<sup>2</sup>/2.</li>
<li> The energy balance does not consider the kinetic terms (gravity terms cancel out due
to the infinitesimal size of the connection volume). There might thus be errors in the momentum balance of the order of magnitude of the kinetic energy v^2/2. </li>
</ul>
<p>
In many applications, where fluid speeds are low and thermal phenomena are mainly of interest,
these approximations are commonly made and lead to acceptable results.
In all other cases, explicit fitting and junction models should be used, that model explicitly
all the kinetic phenomena with the appropriate level of detail.
</p></html>"));
  end FluidConnectors;

  class BalanceEquations "Balance equations"
    extends Modelica_Icons.Information;

    annotation (Documentation(info="<html>

<p>
For one-dimensional flow
along the coordinate \"x\", the following partial differential
equations hold
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td> Mass balance</td>
      <td> <img src=\"modelica://Modelica/Resources/Images/Fluid/UsersGuide/massBalance.png\"
                alt=\"massBalance.png\"></td>
  </tr>
  <tr><td> Momentum balance</td>
      <td> <img src=\"modelica://Modelica/Resources/Images/Fluid/UsersGuide/momentumBalance.png\"
                alt=\"momentumBalance.png\"></td>
  </tr>
  <tr><td> Energy balance 1</td>
      <td> <img src=\"modelica://Modelica/Resources/Images/Fluid/UsersGuide/energyBalance1.png\"
                alt=\"energyBalance1.png\"></td>
  </tr>
  <tr><td> Pipe friction</td>
      <td> <img src=\"modelica://Modelica/Resources/Images/Fluid/UsersGuide/pipeFriction.png\"
                alt=\"pipeFriction.png\"></td>
  </tr>
  <tr><td></td>
      <td>x: independent spatial coordinate (flow is along coordinate x)<br>
          t: time<br>
          v(x,t): mean velocity<br>
          p(x,t): mean pressure<br>
          T(x,t): mean temperature<br>
          &rho;(x,t): mean density<br>
          u(x,t): specific internal energy<br>
          z(x): height over ground<br>
          A(x): area perpendicular to direction x<br>
          g: gravity constant<br>
          f: Fanning friction factor<br>
          S: circumference
  </tr>
</table>
<p>
An alternative energy balance can be derived by multiplying
the momentum balance with \"v\" and subtracting it
from the energy balance 1 above. This results in
the \"energy balance 2\":
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td> Energy balance 2</td>
      <td> <img src=\"modelica://Modelica/Resources/Images/Fluid/UsersGuide/energyBalance2.png\"
                alt=\"energyBalance2.png\"></td>
  </tr>
</table>

<p>
This formulation separates the internal energy of the fluid from the kinetic energy of fluid flow.
The internal energy is treated by the energy balance 2, the kinetic energy is treated by the momentum balance equally well.
The evaluation of medium properties, which are independent of the kinetic energy, and the formulation of many fluid models is simplified with the energy balance 2.
The overall conservation of energy is achieved by considering the mutual dependencies of energy and momentum balance.
</p>
<p>
Some components in the library, like DynamicPipe, provide a rigorous implementation of mass,
momentum and energy balance, using the energy balance 2 equation. Other components, like Valves and
Fittings, neglect the impact of changes of the kinetic energy and potential energy on the energy
balance, because they are usually irrelevant compared to changes due to heat flows. The StaticPipe
component neglects the effect of kinetic energy, but includes the potential energy in the balance,
which might be substantial.
</p>
<p>
All modelling assumptions and simplifications are stated in the component documentation; please note that some of the assumptions might be stated in the base classes the
component inherits from.
</p>
</html>"));
  end BalanceEquations;

  class UpstreamDiscretization "Upstream discretization"
    extends Modelica_Icons.Information;

    annotation (Documentation(info="<html>

<p>
When implementing a Fluid component, the difficult arises that
the value of intensive quantities (such as p, T, &rho;)
shall be accessed from the
<b>upstream</b> volume. For example, if the fluid flows
from volume A to volume B, then the intensive quantities of
volume B have no influence on the fluid between the
two volumes. On the other hand, if the flow direction is reversed,
the intensive quantities of volume A have no influence
on the fluid between the two volumes.
</p>
<p>
In the Modelica_Fluid library, such a situation is handled
with the following code fragment
(from Interfaces.PartialTwoPortTransport):
</p>
<pre>    <b>replaceable package</b> Medium =
                   Modelica_Media.Interfaces.PartialMedium
                   <b>annotation</b>(choicesAllMatching = <b>true</b>);

    Interfaces.FluidPort_a port_a(<b>redeclare package</b> Medium = Medium);
    Interfaces.FluidPort_b port_b(<b>redeclare package</b> Medium = Medium);

    Medium.ThermodynamicState port_a_state_inflow
                    \"Medium state close to port_a for inflowing mass flow\";
    Medium.ThermodynamicState port_b_state_inflow
                    \"Medium state close to port_b for inflowing mass flow\";

  <b>equation</b>
    // Isenthalpic state transformation (no storage and no loss of energy)
    port_a.h_outflow  = <b>inStream</b>(port_b.h_outflow);
    port_b.h_outflow  = <b>inStream</b>(port_a.h_outflow);

    port_a.Xi_outflow = <b>inStream</b>(port_b.Xi_outflow);
    port_b.Xi_outflow = <b>inStream</b>(port_a.Xi_outflow);

    // Mass balance
    port_a.m_flow + port_b.m_flow = 0;

    // Medium states for inflowing medium
    port_a_state_inflow = Medium.setState_phX(port_a.p, port_b.h_outflow, port_b.Xi_outflow);
    port_b_state_inflow = Medium.setState_phX(port_b.p, port_a.h_outflow, port_a.Xi_outflow);

    // Densities close to the parts when mass flows in to the respective port
    port_a_rho_inflow = Medium.density(port_a_state_inflow);
    port_b_rho_inflow = Medium.density(port_b_state_inflow);

    // Pressure drop correlation (k_ab, k_ba are the loss factors for the two flow
    // directions; e.g., for a circular device: k = 8*zeta/(pi*diameter)^2)^2)
    m_flow = Utilities.regRoot2(port_a.p - port_b.p, dp_small,
                                port_a_rho_inflow/k1, port_b_rho_inflow/k2);
</pre>
<p>
The medium states for inflowing media can be used to compute density and dynamic
viscosity which in turn can be use to formulate the pressure drop equation.
The standard pressure drop equation
</p>

<pre>
   dp = port_a - port_b;
   m_flow = sqrt(2/(zeta*diameter))*if dp >= 0 then  sqrt(dp)
                                               else -sqrt(-dp)
</pre>

<p>
cannot be used, since the function has an infinite derivative at dp=0.
Instead the region around zero mass flow rate must be regularized using
one of the regularization functions of Modelica_Fluid.Utilities.
This requires to have density and/or other medium properties for both
flow directions at the same time. These media properties can be computed
from the medium states of the inflowing fluid at the two ports.
</p>

<p>
If the above component is connected between two volumes, i.e.,
the independent medium variables in port_a and port_b are
usually states, then port_a.h and port_b.h are either states
(i.e., known quantities in the model) or are computed from
states. In either case they are \"known\". In such a situation,
all equations can be directly evaluated without any problems.
Zero or reversed mass flow rate does not pose any problems because
the medium properties are always computed for both flow directions
and are then used in the regularization function.
</p>

<p>
If 3 or more components are connected together, it can be shown
that a system of non-linear algebraic equations appear.
The equations are written by purpose in such a form, that
a tool can select mass flow rates and pressures as iteration
variables of this system. The advantage is that these iteration
variables are continuous and even often differentiable. The
alternative to use the medium states as iteration variables
is not good, because T,h,d are discontinuous for reversing flow
direction.
</p>
</html>"));
  end UpstreamDiscretization;

  class RegularizingCharacteristics "Regularizing characteristics"
    extends Modelica_Icons.Information;

    annotation (Documentation(info="<html>

<p>
Pressure drop equations and other fluid characteristics are usually
computed by <b>semi-empirical</b> equations. Unfortunately, the developers
of semi-empirical equations nearly never take into account that the
equation might be used in a simulation program. As a consequence, these
semi-empirical equations can nearly never be used blindly but must
be slightly modified or adapted in order that obvious
simulation problems are avoided. Below, examples are given to
demonstrate what problems occur and how to regularize the characteristics:
</p>

<h4>Square root function</h4>
<p>
In several empirical formulae, expressions of the following form
are present, e.g., for turbulent flow in a pipe:
</p>
<pre>   y = <b>if</b> x &lt; 0 <b>then</b> -<b>sqrt</b>( <b>abs</b>(x) ) <b>else</b> <b>sqrt</b>(x)
</pre>
<p>
A plot of this characteristic is shown in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/UsersGuide/sqrt.png\"
     alt=\"sqrt.png\">
</p>

<p>
The difficulty with this function is that the derivative at x=0 is infinity.
In reality, such a function does not exist. E.g., for pipe flow,
the flow becomes laminar for small velocities and therefore around zero the
sqrt() function is replaced by a linear function. Since the laminar region is
usually of not much practical interest, the above approximation is used.
</p>
<p>
The direct implementation above does not work in Modelica, because
an event is generated when x &lt; 0 changes sign. In order to detect
this event, an event iteration takes place. During the event iteration,
the active if-branch is not changed. For example, assume that x is positive
(= \"else\" branch) and shall become negative. During the event iteration
x is slightly negative and the else branch, i.e., sqrt(x), is evaluated.
Since this results in an imaginary number, an error occurs.
It would be possible to fix this, by using the <b>noEvent</b>() operator
to explicitly switch of an event:
</p>
<pre>   y = <b>if</b> <b>noEvent</b>(x &lt; 0) <b>then</b> -<b>sqrt</b>( <b>abs</b>(x) ) <b>else</b> <b>sqrt</b>(x)
</pre>
<p>
Still, it is highly likely that good integrators will not work well
around x=0, because they will recognize that the derivative changes very
sharply and will reduce the step size drastically.
</p>
<p>
There are several solutions around this problem: Around x=0, the sqrt() function
can be replaced by a polynomial of 3rd order which is determined in such a way
that it smoothly touches the sqrt() function, i.e., the whole function is continuous
and continuously differentiable. In the Modelica_Fluid library, implementations of
such critical functions are provided in sublibrary Modelica_Fluid.Utilities.
The above sqrt() type function is computed by function <b>Utilities.regRoot</b>().
This function is defined as:
</p>
<pre>     y := x/(x*x+delta*delta)^0.25;
</pre>
<p>
where \"delta\" is the size of the small region around zero where the
sqrt() function is approximated by another function. The plot of the
function above is practically identical to the one of the original function.
However, it has a finite derivative at x=0 and is differentiable upto
any order. With the default value of delta=0.01, the difference between
the function above and regRoot(x) is 16% around x=0.01, 0.25% around x=0.1
and 0.0025% around x=1.
</p>
</html>"));
  end RegularizingCharacteristics;

  class WallFriction "Wall friction"
    extends Modelica_Icons.Information;

    annotation (Documentation(info="<html>

<p>
One important special case for a pressure loss is the friction at the
wall of a pipe under the assumption of quasi steady state flow (i.e., the
mass flow rate varies only slowly). In this section it is explained how this case is
handled in the Modelica_Fluid library for pipes with
<b>nonuniform roughness</b>, including the smooth pipe
as a special case (see
<a href=\"modelica://Modelica_Fluid.Pipes.BaseClasses.WallFriction\">Pipes.BaseClasses.WallFriction</a>).
The treatment is non-standard in order to get a
numerically well-posed description.
</p>

<p>
For pipes with circular cross section the pressure drop is computed as:
</p>

<pre>
   dp = &lambda;(Re,<font face=\"Symbol\">D</font>)*(L/D)*&rho;*v*|v|/2
      = &lambda;(Re,<font face=\"Symbol\">D</font>)*8*L/(&pi;^2*D^5*&rho;)*m_flow*|m_flow|
      = &lambda;2(Re,<font face=\"Symbol\">D</font>)*k2*sign(m_flow);

with
   Re     = |v|*D*&rho;/&mu;
          = |m_flow|*4/(&pi;*D*&mu;)
   m_flow = A*v*&rho;
   A      = &pi;*(D/2)^2
   &lambda;2     = &lambda;*Re^2
   k2     = L*&mu;^2/(2*D^3*&rho;)
</pre>

<p>
where
</p>
<ul>
<li> L is the length of the pipe.</li>
<li> D is the diameter of the pipe. If the pipe has not a
     circular cross section, D = 4*A/P, where A is the cross section
     area and P is the wetted perimeter.</li>
<li> &lambda; = &lambda;(Re,<font face=\"Symbol\">D</font>) is the \"usual\" wall friction coefficient.</li>
<li> &lambda;2 = &lambda;*Re^2 is the used friction coefficient to get a numerically
     well-posed formulation.</li>
<li> Re = |v|*D*&rho;/&mu; is the Reynolds number.</li>
<li> <font face=\"Symbol\">D</font> = <font face=\"Symbol\">d</font>/D is the relative roughness where
     \"<font face=\"Symbol\">d</font>\" is
     the absolute \"roughness\", i.e., the averaged height of asperities in the pipe
     (<font face=\"Symbol\">d</font> may change over time due to growth of surface asperities during
      service, see <i>[Idelchick 1994, p. 85, Tables 2-1, 2-2])</i>.</li>
<li> &rho; is the upstream density.</li>
<li> &mu; is the upstream dynamic viscosity.</li>
<li> v is the mean velocity.</li>
</ul>
<p>
The first form with &lambda; is used and presented in textbooks,
see \"blue\" curve in the next figure:
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFriction1.png\" ALT=\"PipeFriction1\">
</p>

<p>
This form is not suited for a simulation program since
&lambda; = 64/Re if Re &lt; 2000, i.e., a division by zero occurs for
zero mass flow rate because Re = 0 in this case.
More useful for a simulation model is the friction coefficient
&lambda;2 = &lambda;*Re^2, because &lambda;2 = 64*Re if Re &lt; 2000 and
therefore no problems for zero mass flow rate occur.
The characteristic of &lambda;2 is shown in the next figure and is
used in Modelica_Fluid:
</p>

<p>
<IMG src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFriction2.png\" ALT=\"PipeFriction2\">
</p>

<p>
The pressure loss characteristic is divided into three regions:
</p>

<ul>
<li> <b>Region 1</b>:
     For <b>Re &le; 2000</b>, the flow is <b>laminar</b> and the exact solution of the
     3-dim. Navier-Stokes equations (momentum and mass balance) is used under the
     assumptions of steady flow, constant pressure gradient and constant
     density and viscosity (= Hagen-Poiseuille flow) leading to &lambda;2 = 64*Re.
     Therefore:
     <pre> dp = 128*&mu;*L/(&pi;*D^4*&rho;)*m_flow </pre> <br>&nbsp;
</li>

<li> <b>Region 3</b>:
     For <b>Re &ge; 4000</b>, the flow is <b>turbulent</b>.
     Depending on the calculation direction (see \"inverse formulation\"
     below) either of two explicit equations are used. If the pressure drop dp
     is assumed to be known, &lambda;2 = |dp|/k2. The
     Colebrook-White equation
     <i>[Colebrook 1939; Idelchik 1994, p. 83, eq. (2-9)]</i>:
     <pre>1/sqrt(&lambda;) = -2*lg( 2.51/(Re*sqrt(&lambda;)) + 0.27*<font face=\"Symbol\">D</font>) </pre>
     gives an implicit relationship between Re and &lambda;.
     Inserting &lambda;2 = &lambda;*Re^2 allows to solve this equation analytically
     for Re: <pre>Re = -2*sqrt(&lambda;2)*lg(2.51/sqrt(&lambda;2) + 0.27*<font face=\"Symbol\">D</font>)</pre>
     Finally, the mass flow rate m_flow is computed from Re via
     m_flow = Re*&pi;*D*&mu;/4*sign(dp).
     These are the <b>red</b> curves in the diagrams above.<br>
     If the mass flow rate is assumed known (and therefore implicitly
     also the Reynolds number), then &lambda;2 is computed by an
     approximation of the inverse of the Colebrook-White equation
     <i>[Swamee and Jain 1976;
     Miller 1990, p. 191, eq.(8.4)]</i> adapted to &lambda;2:
     <pre> &lambda;2 = 0.25*(Re/lg(<font face=\"Symbol\">D</font>/3.7 + 5.74/Re^0.9))^2 </pre>
     The pressure drop is then computed as dp = k2*&lambda;2*sign(m_flow).
     These are the <b>blue</b> curves in the diagrams above.<br>&nbsp;</li>

<li> <b>Region 2</b>:
     For <b>2000 &le; Re &le; 4000</b> there is a transition region between laminar
     and turbulent flow. The value of &lambda;2 depends on more factors as just
     the Reynolds number and the relative roughness, therefore only crude
     approximations are possible in this area.<br>
     The deviation from the laminar region depends on the
     relative roughness. A laminar flow at Re=2000 is only reached for smooth pipes.
     The deviation Reynolds number Re1 is computed according to
     <i>[Samoilenko 1968; Idelchik 1994, p. 81, sect. 2.1.21]</i> as:
     <pre>Re1 = 745*e^(if <font face=\"Symbol\">D</font> &le; 0.0065 then 1 else 0.0065/<font face=\"Symbol\">D</font>)</pre>
     These are the <b>blue</b> curves in the diagrams above.<br>
     Between Re1=Re1(<font face=\"Symbol\">d</font>/D) and Re2=4000,
     &lambda;2 is approximated by a cubic
     polynomial in the \"lg(&lambda;2) - lg(Re)\" chart (see figures above) such that the
     first derivative is continuous at these two points. In order to avoid
     the solution of non-linear equations, two different cubic polynomials are used
     for the direct and the inverse formulation. This leads to some discrepancies
     in &lambda;2 (= differences between the red and the blue curves).
     This is acceptable, because the transition region is anyway not
     precisely known since the actual friction coefficient depends on
     additional factors and since the operating points are usually
     not in this region.</li>
</ul>
<p>
The absolute roughness <font face=\"Symbol\">d</font> has usually to
be estimated. In <i>[Idelchik 1994, pp. 105-109,
Table 2-5; Miller 1990, p. 190, Table 8-1]</i> many examples are given.
As a short summary:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><b>Smooth pipes</b></td>
      <td>Drawn brass, copper, aluminium, glass, etc.</td>
      <td><font face=\"Symbol\">d</font> = 0.0025 mm</td>
  </tr>
  <tr><td rowspan=\"3\"><b>Steel pipes</b></td>
      <td>New smooth pipes</td>
      <td><font face=\"Symbol\">d</font> = 0.025 mm</td>
  </tr>
  <tr><td>Mortar lined, average finish</td>
      <td><font face=\"Symbol\">d</font> = 0.1 mm</td>
  </tr>
  <tr><td>Heavy rust</td>
      <td><font face=\"Symbol\">d</font> = 1 mm</td>
  </tr>
  <tr><td rowspan=\"3\"><b>Concrete pipes</b></td>
      <td>Steel forms, first class workmanship</td>
      <td><font face=\"Symbol\">d</font> = 0.025 mm</td>
  </tr>
  <tr><td>Steel forms, average workmanship</td>
      <td><font face=\"Symbol\">d</font> = 0.1 mm</td>
  </tr>
  <tr><td>Block linings</td>
      <td><font face=\"Symbol\">d</font> = 1 mm</td>
  </tr>
</table>
<p>
The equations above are valid for incompressible flow.
They can also be applied for <b>compressible</b> flow up to about <b>Ma = 0.6</b>
(Ma is the Mach number) with a maximum error in &lambda; of about 3 %.
The effect of gas compressibility in a wide region can be taken into
account by the following formula derived by Voronin
<i>[Voronin 1959; Idelchick 1994, p. 97, sect. 2.1.81]</i>:
</p>
<pre>
  &lambda;_comp = &lambda;*(1 + (&kappa;-1)/2 * Ma^2)^(-0.47)
</pre>
<p>
where &kappa; is the isentropic coefficient
(for ideal gases, &kappa; is the ratio of specific heat capacities cp/cv).
An appreciable decrease in the coefficient \"&lambda;_comp\" is observed
only in a narrow transonic region and also at supersonic flow velocities
by about 15% <i>[Idelchick 1994, p. 97, sect. 2.1.81]</i>.
This effect is not yet included in Modelica_Fluid.
Another restriction is that the pressure drop model is valid
only for steady state or slowly changing mass flow rate.
For large fluid acceleration, the pressure drop depends additionally
on the frequency of the changing mass flow rate.
</p>

<h4>Inverse formulation</h4>

<p>
In the \"Advanced menu\" it is possible via parameter
\"from_dp\" to define in which form the
pressure drop equation is actually evaluated (<b>default</b> is from_dp = <b>true</b>):
</p>
<pre>
   from_dp = <b>true</b>:   m_flow = f1(dp)
           = <b>false</b>:  dp     = f2(m_flow)
</pre>
<p>
\"from_dp\" can be useful to avoid nonlinear systems of equations
in cases where the inverse pressure loss function is needed.
</p>

<h4>Summary</h4>

<p>
A detailed pressure drop model for pipe wall friction is
provided in the form m_flow = f1(dp, <font face=\"Symbol\">D</font>) or
dp = f2(m_flow, <font face=\"Symbol\">D</font>).
These functions are continuous and differentiable,
are provided in an explicit form without solving non-linear equations,
and do behave well also at small mass flow rates. This pressure drop
model can be used stand-alone in a static momentum balance and in
a dynamic momentum balance as the friction pressure drop term.
It is valid for incompressible and compressible flow up to a Mach number of 0.6.
</p>

<h4>References</h4>

<dl><dt>Colebrook F. (1939):</dt>
    <dd><b>Turbulent flow in pipes with particular reference to the transition
         region between the smooth and rough pipe laws</b>.
         J. Inst. Civ. Eng. no. 4, 14-25.</dd>
    <dt>Idelchik I.E. (1994):</dt>
    <dd><a href=\"http://www.bookfinder.com/dir/i/Handbook_of_Hydraulic_Resistance/0849399084/\"><b>Handbook of Hydraulic Resistance</b></a>. 3rd edition, Begell House, ISBN 0-8493-9908-4</dd>
    <dt>Miller D. S. (1990):</dt>
    <dd><b>Internal flow systems</b>.
    2nd edition. Cranfield:BHRA(Information Services).</dd>
    <dt>Samoilenko L.A. (1968):</dt>
    <dd><b>Investigation of the Hydraulic Resistance of Pipelines in the
        Zone of Transition from Laminar into Turbulent Motion</b>.
        Thesis (Cand. of Technical Science), Leningrad.</dd>
    <dt>Swamee P.K. and Jain A.K. (1976):</dt>
    <dd><b>Explicit equations for pipe-flow problems</b>.
         Proc. ASCE, J.Hydraul. Div., 102 (HY5), pp. 657-664.</dd>
    <dt>Voronin F.S. (1959):</dt>
    <dd><b>Effect of contraction on the friction coefficient in a
           turbulent gas flow</b>.
           Inzh. Fiz. Zh., vol. 2, no. 11, pp. 81-85.</dd>
</dl>

</html>"));
  end WallFriction;

  class ValveCharacteristics "Valve characteristics"
    extends Modelica_Icons.Information;

    annotation (Documentation(info="<html>
<p>
The control valves in
<a href=\"modelica://Modelica_Fluid.Valves\">Modelica_Fluid.Valves</a>
have the parameters <b>Kv</b> and <b>Cv</b>. They are defined
as unit-less variables, but in the description text a unit
is given. The reason for this definition is the following:
</p>

<p>
The basic equation for valves is:
</p>

<pre>
  q = Av*sqrt(dp/rho)
</pre>

<p>
In SI units, [q] is m3/s, [dp] is Pascal, [rho] is [kg/m3], and Av is an area, thus [Av] = m2. Basically, the equation stems from Bernoulli's law. Av is roughly 1.4 times the area of the valve throat. Now, usually valves aren't so big that their throat area is of the order of magnitude of square meters - depending on the applications it is from a few square millimeters to a few square centimeters. Therefore, in the common engineering practice, the following equations are used:
</p>

<p>
Europe:
</p>

<pre>
  q = Kv sqrt(dp/(rho/rho0)) , with [q] = m3/h, [dp] = bar
</pre>

<p>
US:
</p>

<pre>
  q = Cv sqrt(dp/(rho/rho0)) , with [q] = USG/min, [dp] = psi
</pre>

<p>
In both cases rho0 is the density of cold water at 4 &deg;C, 999 kg/m3. Note that these equations use relative, not absolute densities.
</p>

<p>
It turns out that Kv = 1e6/27.7*Av and Cv = 1e6/24*Av, so both US and EU engineers get more or less the same numbers (just by sheer luck), with a range between a few units and a few hundred units for typical industrial applications, and everybody is happy.
</p>

<p>
Now, we've got two problems here. First, depending on the unit, we change the equation: with SI units, we use the density, with non-SI units, we use the relative density. So the quantities (not only the units!) of Av and Cv/Kv are different.
</p>

<p>
Second, the units of Kv and Cv are usually labeled \"m3/h\" and \"USG/min\", but as a matter of fact they are different, as can be seen from the equations above: they are actually
m3/(h*sqrt(bar)) and USG/(min*sqrt(psi)). If I have a valve with Kv = 10 m3/h, it means I get 10 m3/h \"for a pressure drop of 1 bar\". Unfortunately, this is not correct from the point of view of strict dimensional analysis, but nobody uses sqrt(Pa) or sqrt(bar).
</p>

<p>
You might think this is crazy (it is, especially when you try to explain it), but as a matter of fact the valve coefficient is <b>never</b> given in square meters in any catalog or datasheet; Cv is still the most used (even in Europe), followed by Kv. So, it will be very inconvenient for users to type in Av in square meters.
</p>

<p>
The pragmatic approach used in Modelica_Fluid.ControlValves is to accept the fact that m3/h and USG/min are not the real units of Cv and Kv, so we can't use the general unit conversion mechanism, put them just as mnemonic labels in the comment, use non-dimensional coefficients in the interface, and then define properly dimensioned unit conversion within the model
</p>

</html>"));
  end ValveCharacteristics;

    annotation (Documentation(info="<html>

<p>
In this section it is described how the components
of the Modelica_Fluid library are implemented.
If you would like to introduce new components either in
Modelica_Fluid or your own library, you should be aware
of the issues discussed in this section.
</p>
<p>
This section is partly based on the following paper:
</p>
<dl>
<dt> Elmqvist H., Tummescheit H., and Otter M.:</dt>
<dd> <b>Object-Oriented Modeling of Thermo-Fluid Systems</b>.
     Modelica 2003 Conference, Link&ouml;ping, Sweden,
     pp. 269-286, Nov. 3-4, 2003.
     Download from:
     <a href=\"https://www.modelica.org/events/Conference2003/papers/h40_Elmqvist_fluid.pdf\">https://www.modelica.org/events/Conference2003/papers/h40_Elmqvist_fluid.pdf</a>
     </dd>
</dl>
Please note that the design of the connectors has been changed with respect to the design presented in that paper.
</html>"));
  end ComponentDefinition;

  package BuildingSystemModels "Building system models"
    extends Modelica_Icons.Information;
    class SystemComponent "System component"
      extends Modelica_Icons.Information;

      annotation (Documentation(info="<html>
<p>
The Modelica_Fluid library is designed so that each model of a system must
include an instance <code>system</code> of the <code>System</code> component at the top level, in the same way as the <code>World</code> model of the MultiBody Library. The System component contains the parameters that
describe the environment surrounding the components (ambient pressure and
temperature, gravity acceleration), and also provides default settings
for many parameters which are used consistently by the models in the library.
These parameters are then propagated to the individual components
using the inner/outer variable mechanism. In case the system model is structured
hierarchically, it is possible to either put a single System
component at the top level, or possibly to put many of them at different levels,
which will only influence the system components from that level down.
</p>
<p>All the parameters defined in the System model are used as default values for the parameters of the individual components of the system model. Note that it is always possible to override these defaults locally by changing the value of the parameters in the specific component instance.
</p>
<ul>
<li> The <i>General</i> tab of the System model allows to set the default environment variables (pressure, temperature and gravity)
used by all the components.
</li>
<li> The <i>Assumptions</i> tab allows to change the default modelling assumptions
used by all the components (see the section <i>Customizing a system model later</i>)</li>
<li> The <i>Initialization</i> tab allows to define default start values for mass flow rates, pressures and temperatures in the model; this can be useful to help nonlinear solver converge to the solution of any nonlinear system of equations that involves such variables, by providing meaningful guess values. </li>
<li> The <i>Advanced</i> tab contains default values for parameters used in
the advanced settings of some components.</li>
</ul>
<p>
Remember to <b>always add a System component</b> at the top level of
your system model, otherwise you will get errors when compiling the model. The tool will automatically name it <code>system</code>, so that it
is recognized by all other components.
</p>
</html>"));
    end SystemComponent;

    class MediumDefinition "Definition of the medium models"
      extends Modelica_Icons.Information;

      annotation (Documentation(info="<html>

<p>
All the models in Modelica_Fluid compute fluid properties by using medium
models defined by Modelica_Media packages. Custom fluid models can also be
used, provided they extend the interfaces defined in
Modelica_Media.Interfaces.
</p>
<p>
All the components in Modelica_Fluid use a <i>replaceable</i> medium package, called <code>Medium</code>: the model is written for a generic fluid, and a specific fluid model can then be specified when building a system model by redeclaring the package. This can be done in different ways:
<ul>
<li>
If several components use the same medium, it is possible to select
all of them within a GUI, and set them simultaneously (as they are
all named Medium).
</li>
<li>It is also possible to declare one or more (possibly replaceable) medium packages in the model, and then use them to set up the individual components.</li>
</ul>
</html>"));
    end MediumDefinition;

    class CustomizingModel "Customizing a system model"
      extends Modelica_Icons.Information;

      annotation (Documentation(info="<html>
<p>
Once a system model has been built, it is possible to obtain different approximations by
appropriately setting the defaults in the System component (and/or the settings of specific
components.
</p>
<p>
The Assumptions | allowFlowReversal parameter determines whether reversing flow conditions
(i.e., flow direction opposite to design direction) are modelled or not. By default,
reversing flow conditions are considered by the models, but this causes a significant increase
of complexity in the equations, due to the conditional equations depending on the flow direction.
If you know in advance that the flow in a certain component (or in the whole system) will always
be in the design direction, then setting this parameter to false will produce a much faster and
possibly more robust simulation code.
</p>
<p>
The flags in the Assumptions | Dynamics tab allow different degrees of approximation on
the mass, energy, and momentum equations of the components.
</p>
<ul>
<li>DynamicFreeInitial: dynamic equations are considered (nonzero storage), no
initial equations are provided, and the start values are used as guess values.</li>
<li>FixedInitial: dynamic equations are considered (nonzero storage) and initial
equations are included, fixing the states to the start values provided by the
component parameters.</li>
<li>SteadyStateInitial: dynamic equations are considered (nonzero storage), initial
equations are included, declaring that the state derivatives are zero (steady-state
initialization) and the start values are used as guess values for the nonlinear solver. </li>
<li>SteadyState: algebraic (or static) balance equations are considered (no storage)
and the start values are used as guess values for the nonlinear solver.</li>
</ul>
<p>
It is then possible to neglect the storage of mass, momentum, and energy in the whole system
(or just in parts of it) just by a few mouse clicks in a GUI, and also to change the type of
initialization when considering dynamic models. Please note that some combinations of the
options might be contradictory, and will therefore trigger compilation errors.
</p>
</html>"));
    end CustomizingModel;
    annotation (Documentation(info="<html>

<p>
This section is a quick primer explaining how to build a system model using Modelica_Fluid.
It covers some key issues, such as the System component, the definition of medium models in the
system, and the typical customizations available in the Modelica_Fluid models.
</p>
</html>"));
  end BuildingSystemModels;

  class ReleaseNotes "Release notes"
    extends Modelica_Icons.ReleaseNotes;

    annotation (Documentation(info="<HTML>

<h4>Version 1.1, 2009-06-21</h4>

<p>
The Modelica_Fluid library (revisionId = r2625) was included as Modelica_Fluid in the
Modelica Standard Library 3.1.
</p>

<h4>Version 1.0, 2009-01-28</h4>

<p>
Modelica_Fluid was refactored and finalized for the release:
</p>

<ul>
<li> Refactoring of the code<br>
     This became necessary as the previous release Modelica_Fluid Streams Beta3
     still reflected the long development history, while the basic concepts had been crystallized.
     Please consult the subversion control (SVN) logs for individual changes.</li>

<li> Device oriented package names<br>
     The former sub-packages Junctions and PressureLosses have been combined into the new subpackage Fittings.
     The former Pumps and Volumes.SweptVolume have become the initial version of fluid Machines.
     The former Volumes package is now called Vessels.</li>

<li> Complete implementation of one-dimensional fluid flow<br>
     The balance equations as documented in
     <a href=\"modelica://Modelica_Fluid.UsersGuide.ComponentDefinition.BalanceEquations\">UsersGuide.ComponentDefinition.BalanceEquations</a>
     are now completely implemented. The implementations with generic boundary flow and source terms find in:
     <ul>
     <li><a href=\"modelica://Modelica_Fluid.Interfaces.PartialDistributedVolume\">Interfaces.PartialDistributedVolume</a>,
         <a href=\"modelica://Modelica_Fluid.Interfaces.PartialLumpedVolume\">Interfaces.PartialLumpedVolume</a>:
         Energy, Mass and Substance balances</li>
     <li><a href=\"modelica://Modelica_Fluid.Interfaces.PartialDistributedFlow\">Interfaces.PartialDistributedFlow</a>,
         <a href=\"modelica://Modelica_Fluid.Interfaces.PartialLumpedFlow\">Interfaces.PartialLumpedFlow</a>:
         Momentum balance</li>
     </ul>
     Specific models combine the balances and define the boundary flow and source terms as appropriate.
     For instance
     <ul>
     <li><a href=\"modelica://Modelica_Fluid.Vessels.OpenTank\">Vessels.OpenTank</a> extends from
         <a href=\"modelica://Modelica_Fluid.Interfaces.PartialLumpedVolume\">Interfaces.PartialLumpedVolume</a>,</li>
     <li><a href=\"modelica://Modelica_Fluid.Fittings.SimpleGenericOrifice\">Fittings.SimpleGenericOrifice</a> extends from
         <a href=\"modelica://Modelica_Fluid.Interfaces.PartialLumpedFlow\">Interfaces.PartialLumpedFlow</a>, besides
         <a href=\"modelica://Modelica_Fluid.Interfaces.PartialTwoPortTransport\">Interfaces.PartialTwoPortTransport</a>,</li>
     <li><a href=\"modelica://Modelica_Fluid.Pipes.DynamicPipe\">Pipes.DynamicPipe</a> is based on
         <a href=\"modelica://Modelica_Fluid.Interfaces.PartialDistributedVolume\">Interfaces.PartialDistributedVolume</a> and
         <a href=\"modelica://Modelica_Fluid.Interfaces.PartialDistributedFlow\">Interfaces.PartialDistributedFlow</a>,
         besides <a href=\"modelica://Modelica_Fluid.Interfaces.PartialTwoPort\">Interfaces.PartialTwoPort</a>.</li>
     </ul>
     All non-trivial mass and energy balances of Vessels, Machines and Fittings have been replaced with PartialLumpedVolume.
     The mass and energy balances of Pipes are based on PartialDistributedVolume.<br>
     See <a href=\"modelica://Modelica_Fluid.Examples.BranchingDynamicPipes\">Examples.BranchingDynamicPipes</a>
     for an example utilizing the complete balance equations.

<li> New approach for the connection of distributed flow models<br>
     The staggered grid approach offers different choices for the connection approach. So far the preferred modeling was to put full mass balances
     into the pipes and expose half momentum balances through the ports (ModelStructure a_v_b).
     This resulted in nonlinear equation systems for pressure/flow correlations in connection sets.
     A new default ModelStructure av_vb has been introduced putting full momentum balances into the models and
     exposing half mass balances through the ports (av_vb replaces the former avb). This way the nonlinear equation systems are avoided.
     High-index DAEs need to be treated instead in connection sets.
     Alternatively a Fitting like SuddenExpansion can be introduced to account for different cross flow areas of connected flow models.</li>

<li> New Vessels.BaseClasses.PartialLumpedVessel treating the ports, including hydraulic resistances, for ClosedVolume, SimpleTank and SweptVolume.</li>

<li> Clarification of modeling assumptions<br>
     The documentation has been extended to better explain the modeling assumptions made. In particular the section
     <a href=\"modelica://Modelica_Fluid.UsersGuide.ComponentDefinition.FluidConnectors\">UsersGuide.ComponentDefinition.FluidConnectors</a>
     now makes clear that the ports represent the thermodynamic enthalpy, as opposed to stagnation enthalpy,
     and thermodynamic or static pressure, as opposed to total pressure. An new package Explanatory has been added to the
     examples to show the difference between static pressure and total pressure and possible implications. See
     <a href=\"modelica://Modelica_Fluid.Examples.Explanatory.MomentumBalanceFittings\">Examples.Explanatory.MomentumBalanceFittings</a>.

<li> System (former Ambient)<br>
     The use of the global System object has been extended towards common default values for
     modeling assumptions, initialization, and advanced settings that are different for each application of the library
     but should nevertheless provide default values for reasons of convenience.
     In particular steady-state initialization and complete steady-state simulation can now be specified system-wide.
     A new Types.Init.Dynamics has been introduced, combining steady-state and initial conditions.
     The former Types.Init has become obsolete.
     <br>See <a href=\"modelica://Modelica_Fluid.Examples.HeatingSystem\">Examples.HeatingSystem</a></li>

<li> Extension of pumps for better consideration of zero flow and heat transfer with environment<br>
     The simplified mass and energy balances have been replaced with a rigorous formulation.
     Moreover an optional heat transfer model can be configured for heat exchanged with the environment or the housing.<br>
     See <a href=\"modelica://Modelica_Fluid.Machines.BaseClasses.PartialPump\">Machines.BaseClasses.PartialPump</a></li>

<li> Refinement of valves for flow reversal<br>
     All valves now use upstream discretization for reverting flow conditions.</li>

<li> Finalization of trace substances<br>
     Modelica_Fluid now provides a sound implementation for trace substances,
     which can easily be added to existing Media models, in order to study their evolution in a fluid system.<br>
     See <a href=\"modelica://Modelica_Fluid.Examples.TraceSubstances.RoomCO2WithControls\">Examples.TraceSubstances.RoomCO2WithControls</a></li>

<li> Vectorized ports for volumes<br>
     The ports of models that typically have large volumes, like Vessels and Sources,
     have been vectorized. Formerly the connection of multiple flow models to the same port
     of such volume models resulted in unintended mixing equations for stream variables
     in connection sets outside the volumes. The mixing takes place inside the volumes
     when using multiple ports. Moreover a
     <a href=\"modelica://Modelica_Fluid.Fittings.MultiPort\">Fittings.MultiPort</a>
     has been introduced. It can be attached to components like pipes,
     which do not have vectorized ports on their own.</li>

<li> Inverse parameterization of flow models with nominal operational conditions<br>
     Flow models have been added or extended to support the parameterization with nominal values
     (Machines.ControlledPump, Orifices.SimpleGenericOrifice, Pipes.BaseClasses.FlowModels.NominalTurbulentFlow).
     They are intended for early phases of system modeling, if geometries and flow characteristics
     are of secondary interest. As these models use the same interfaces, base classes and naming conventions,
     they can easily be replaced with more detailed models
     as more information shall be taken into account later on.<br>
     See <a href=\"modelica://Modelica_Fluid.Examples.InverseParameterization\">Examples.InverseParameterization</a></li>

<li> Replaceable HeatTransfer models<br>
     The Vessels and the Machines now have replaceable HeatTransfer models,
     besides the Pipes. All HeatTransfer models are optional.
     The heat transfer models are parameterized with the Medium and the ThermodynamicState
     of involved flow segments.<br>
     See <a href=\"modelica://Modelica_Fluid.Interfaces.PartialHeatTransfer\">Interfaces.PartialHeatTransfer</a>.

<li> All examples are working now (using Dymola 7.1).<br>
     The number of examples has been extended with the former critical test cases
     HeatingSystem and IncompressibleFluidNetwork. Moreover the HeatExchangers have been
     moved into Examples.</li>

</ul>

<h4>Version 1.0 Streams Beta 3, 2008-10-12</h4>

<p>
Modelica_Fluid was further improved:
</p>

<ul>
<li> Volumes, tanks, junctions<br>
     Added asserts to require that ports are connected at most once.
     If a user would perform more than one connection, ideal mixing
     takes place for the connected components and this is nearly never
     what the user would like to have </li>

<li> Ambient<br>
     Renamed Ambient to System, including adaptation of models.<br>
     Introduced default values system.flowDirection and
     as a comment system.initType. system.flowDirection is used in
     two port components as default.</li>

<li> GenericJunction<br>
     Corrected specification of flowDirection.<br>
     Added a HeatPort.</li>

<li> PartialDistributedFlow models<br>
     Adapted determination of velocities to usage of
     upstream properties at ports.<br>
     Corrected and unified initialization of p_start[*] values.</li>

<li> DistributedPipe models<br>
     Changed treatment of port densities and viscosities
     to the treatment of the lumped pipe model. This way events are
     avoided if the mass flow rate crosses or approaches zero.<br>
     Correct determination of Reynolds numbers.<br>
     Added test model DistributedPipeClosingValve.</li>

<li> ControlValves<br>
     Changed flowCharacteristic into valveCharacteristic<br>
     Removed parameter Kv and added dp_nom, m_flow_nom from linear
     and discrete valve interfaces. Added test cases.<br>
     Adapted Examples to new LinearValve and DiscreteValve,
     using nominal values instead of Kv. <br>
     Changed default flow coefficient selection to OpPoint</li>

<li> Fixed units for Kv and Cv in control valve models.</li>

<li> Updated tests for valves.</li>

<li> Bug in Modelica_Fluid.Test.TestComponents.Pumps.TestWaterPump2 corrected
     (complicated redeclaration issue).</li>

<li> Adapted AST_BatchPlant so that \"Check\" is successful.
     Simulation fails after 600 s.</li>

<li> Introduced
     density_pTX(Medium.p_default, Medium.T_default, Medium.X_default)
     as default value for nominal densities (previously it was a literal
     such as 1000).</li>

<li> Pumps<br>
     Updated energy balance equations for pumps (no division by zero anymore,
     fixed several bugs related to Np).<br>
     Added two more test cases for pumps.<br>
     Fixed pump initialization options.</li>

<li> PartialPump<br>
     Explanation for the energy balanced added as comment<br>
     \"h=0\" replaced by \"h=Medium.h_default\" since otherwise an assert is triggered
     if \"h=0\" is not in the medium range.<br>
     Fluid ports positioned in the middle line
     and using the same size as for all other components.</li>

<li> Pumps.Pump <br>
     Resized input connector, so that it has the same size as the
     standard input connectors.<br>
     Changed icon text to input connector to \"N_in [rpm]\".<br>
     Added unit 1/min to the external and internal input connector.</li>

<li> PartialValve<br>
     fillcolor=white added to icon<br>
     made line Thickness = Single,
     since icon does not look nice sometimes</li>

<li> All components<br>
     Changed %name color from black to blue
     (is a conversion bug, since Modelica 2 has blue as default
     color whereas Modelica 3 has black and Dymola is not
     taking care off this).</li>

<li> Sources<br>
     Made icon elements invisible, if corresponding input is disabled.</li>

<li> Valves, Pipes, PressureLosses, HeatExchangers, two port senors<br>
     Added an arrow in the icon for the \"design flow direction\" from
     port_a to port_b.</li>

<li> Moved default initialization in \"System\" in to a comment, since no effect yet</li>

<li> Added the explanation from Francesco for Kv, Cv for valves in the
     User's Guide and added links in the corresponding valves to this description</li>
</ul>

<p>
\"Check\" for the library is successful. \"Check with Simulation\"
(i.e., simulating all test models in the library) is successful
with the exceptions:
</p>

<ul>
<li> Examples.AST_BatchPlant.BatchPlant_StandardWater<br>
     Need to be fixed in a later release (requires quite a lot of work).</li>
<li> Test.TestOverdeterminedSteadyStateInit.Test5<br>
     Test.TestOverdeterminedSteadyStateInit.Test6<br>
     These are test cases where too much initial conditions are given.
     The goal is to work on methods how this can be handled.
     So, this is a principal problem that these models do not simulate.</li>
</ul>

<h4>Version 1.0 Streams Beta 2, 2008-10-08</h4>

<p>
Modelica_Fluid was transformed to Modelica 3 and to Modelica Standard
library 3.0 (by automatic conversion). Further changes:
</p>

<ul>
<li> Emulated enumerations changed to real enumerations.</li>
<li> Improved ControlValves code</li>
<li> Introduced stream connectors with stream keyword (was previously an annotation)</li>
<li> Introduced inStream() instead of inflow() </li>
<li> Introduced m_flow*actualStream(h_outflow) instead of
     streamFlow() or semiLinear(m_flow, inStream(h_outflow), medium.h)</li>
<li> Removed Modelica_Fluid.Media and all references to it (since now available
     in Modelica_Media of MSL3.0).</li>
<li> Fixed PartialLumpedVolume for media with multiple substances</li>
<li> New function \"Utilities.RegFun3\" for regularization with static head</li>
<li> Fix density in static head models with the new RegFun3 functions
     (ticket 7)</li>
<li> Minor bug in MixingVolume corrected:<br>
     V_lumped and Wb_flow have been set as modifiers when extending from PartialLumpedVolume,
     although they are not declared as input. This is not allowed in Modelica 3.
     Fixed by replacing the modifiers by equations.</li>
<li> Modelica_Fluid.Sources.FixedBoundary<br>
     Introduced p_default, T_default, h_default as default values, since
     otherwise warnings will always be printed because parameter value is missing.</li>
<li> Modelica_Fluid.Sources.Boundary_pT<br>
     Modelica_Fluid.Sources.Boundary_ph<br>
     Modelica_Fluid.Sources.MassFlowSource_T<br>
     Changed default values of parameters reference_p, reference_T to
     p_default, T_default (some have been xx_default, some reference_xx,
     it seems best to always use the same approach)</li>
<li> Modelica_Fluid.Pipes.BaseClasses.PartialDistributedFlow<br>
     Added default value for parameter \"rho_nominal\" =
     Medium.density_pTX(Medium.p_default, Medium.T_default, Medium.X_default)
     in order to avoid unnecessary warning messages.
     Should be replaced by \"Medium.rho_default\", once available.</li>
<li> Modelica_Fluid.Pipes.DistributedPipe<br>
     Modelica_Fluid.Pipes.DistributedPipeSb<br>
     Modelica_Fluid.Pipes.DistributedPipeSa<br>
     Added default value for parameter \"mu_nominal\"
    (computed with default values of p,T,X from dynamicViscosity(..))</li>
<li> Modelica_Fluid.Pipes.BaseClasses.PartialDistributedFlowLumpedPressure<br>
     Replaced default value \"rho_nominal=0.01\" by
     Medium.density_pTX(Medium.p_default, Medium.T_default, Medium.X_default)</li>
<li> Modelica_Fluid.Volumes.OpenTank<br>
     Modelica_Fluid.Volumes.Tank<br>
     Corrected icons of ports (wrongly sized by automatic conversion from
     Modelica 2 to Modelica 3).</li>
<li> Examples.BranchingDistributedPipes<br>
     Modelica_Fluid.Test.TestComponents.Junctions.TestGenericJunction<br>
     Modelica_Fluid.Test.TestComponents.Pipes.TestDistributedPipe01<br>
     Parameters dp_nom, m_flow_nom are not defined in junction components.
     Values provided.</li>
<li> PressureLosses.BaseClasses.QuadraticTurbulent.BaseModel<br>
     No default or start values for \"parameter LossFactorData data\"
     Changed the model to \"partial model\" to avoid warning messages</li>
</ul>

<h4>Version 1.0 Streams Beta 1, 2008-05-02</h4>

<p>
Changed connectors to stream connectors and adapted the following sublibraries:
</p>

<ul>
<li> Volumes</li>
<li> PressureLosses </li>
<li> Sensors </li>
<li> Sources </li>
<li> ControlValves </li>
<li> HeatExchangers </li>
<li> Junctions </li>
<li> Pipes </li>
<li> Pumps </li>
<li> Test and Examples (most of the examples and tests are simulating)</li>
</ul>

<p>
Other changes:
</p>

<ul>
<li> Introduced HeatPorts with vectorized icon in Modelica_Fluid.Interfaces</li>
<li> Deleted Modelica_Fluid.WorkInProgress since it seems to be too much work
     to convert it to stream connectors</li>
<li> Added Modelica_Fluid.Media (contains ConstantLiquidWater
     medium because functions are missing in Modelica_Media)</li>
<li> Added two additional test cases with LumpedPipes
    (to identify problems with hierarchically connected stream connectors).</li>
<li> Deleted TestPortVolumes since PortVolumes can no longer be implemented with
     stream connectors</li>
<li> Leakage flow introduced for valves</li>
<li> DrumBoiler Example corrected</li>
<li> Regularization for sensors (T,h,...), in order that no discontinuity
     for bi-directional flow</li>
<li> Density computation in static head corrected</li>
<li> New functions Utilities.regUnitStep, regStep</li>
<li> New components (TestComponents.Sensors.TestOnePortSensors1/.TestOnePortSensors2l,
     TestRegStep)</li>
<li> PartialTwoPortTransport<br>
     <ul>
     <li> Introduced port_a.T, port_b.T (for plotting)</li>
     <li> Removed initialization menu</li>
     <li> Introduced dp_start, m_flow_start</li>
     <li> Removed previous start values of PartialTwoPortTransport in all models</li>
     </ul></li>
<li> PartialPump: Removed p_nom, since no longer needed (only dp_nom)</li>
<li> Made \"%name\" in the icons of all components unified (and better looking)</li>
<li> Changed default value of leakage flow of valves to zero.</li>
<li> Fixed Modelica_Fluid.Junctions.MassFlowRatio so that it compiles
     (inflow(..) currently only supported for scalars, not for vectors)</li>
<li> Added script libraryinfo.mos, in order that Modelica_Fluid appears in the
     Dymola library window automatically (provided library is in MODELICAPATH)</li>
<li> Replaced semiLinear(..) by streamFlow(..) (not yet at all places)</li>
<li> Introduced check-boxes in parameter menu of Sources (is more convenient to use)</li>
<li> TwoPortTransport<br>
     Computation of V_flow and optionally port_a_T, port_b_T.
     Error in temperature calculation corrected</li>
<li> Tank:<br>
     Default of bottom pipe diameter changed from 0 to 0.1, since
     otherwise a division by zero (if not connected and not changed).</li>
<li> Modelica_Fluid.ControlValves.ValveVaporizing:<br>
     Due to changes in PartialTwoPortTransport, port_a_T_inflow does no longer exist
     and the usage to it is removed.
     </li>
<li> Modelica_Fluid.Test.TestComponents.Sensors.TestTemperatureSensor:<br>
     Due to changes in PartialTwoPortTransport,
     p_start does no longer exist and the usage to it is removed.</li>
<li> VersionBuild introduced, as well as automatic update of
     VersionBuild/VersionDate</li>
</ul>

<h4>Version 1.0 Beta 4, 2008-04-26</h4>

<p>
Changes according to the Modelica Design Meetings since the
last beta version. This version is used to \"freeze\" the current
development, in order to change to a version with a new
connector design using stream variables.
</p>

<h4>Version 1.0 Beta 3, 2007-06-05</h4>

<p>
Changes according to the Modelica Design Meetings since the
Modelica'2006 conference, especially, improved initialization,
changed Source components (input connectors must be enabled),
improved tank component, moved test models from Examples to
new package Test, many more test models, etc.
This version is slightly non-backward compatible to version 1.0 Beta 2.
</p>

<h4>Version 1.0 Beta 2, 2006-08-28</h4>

<p>
Package considerably restructured and some new components added.
New examples (ControlledTankSystem, AST_BatchPlant).
</p>

<h4>Version 0.96, 2006-01-08</h4>

<ul>
<li> New package Modelica_Fluid.PressureLosses.</li>
<li> New package Modelica_Fluid.WorkInProgress.</li>
<li> New components in Modelica_Fluid.Components:<br>
     ShortPipe, OpenTank, ValveDiscrete, StaticHead.</li>
<li> New components in Modelica_Fluid.Examples.</li>
<li> Improved users guide.</li>
</ul>

<h4>Version 0.910, 2005-10-25</h4>
<ul>
<li> Changes as decided on 41th-45th Modelica Design Meetings
     (details, see minutes).
</ul>
<h4>Version 0.900, 2004-10-18</h4>
<ul>
<li> Changes as decided on 40th Modelica Design Meeting in Dresden
     (see also minutes)
</ul>
<h4>Version 0.794, 2004-05-31</h4>
<ul>
<li> Sensors.mo, Examples/DrumBoiler.mo: extend sensors with user choice
     for measurement unit.</li>
<li> Components.mo, Types.mo: moved components and types to
     package Examples.</li>
<li> Moved Examples from <b>file</b> Modelica_Fluid/package.mo to
     Modelica_Media/Examples <b>subdirectory</b> and created separate
     file per sub-package. This shall simplify the maintenance of
     examples by different authors</li>
<li> Moved Interfaces from file Modelica_Fluid/package.mo to
     Modelica_Fluid/Interfaces.mo</li>
</ul>
<h4>Version 0.793, 2004-05-18</h4>
<ul>
<li> Removed \"semiLinear\" function since available as
     Modelica 2.1 built-in operator in Dymola.</li>
<li> Minor bug in \"Components.ShortPipe\" corrected.</li>
<li> Bug in \"Components.Orifice\" corrected
     (dp was previously calculated in
      Interfaces.PartialTwoPortTransport,
      but this was removed and not updated in Orifice).</li>
</ul>
<h4>Version 0.792, 2003-11-07</h4>
<p>
This is the first consolidated version made up from
several changes for Modelica'2003.
Modelica_Fluid is still quite far away
from a library that could be included in the Modelica
standard library.
</p>
<h4>Previous Releases</h4>
<ul>
<li><i>Oct., 2003</i><br>
       by Martin Otter: Adapted to latest design of the Modelica_Media
       library.<br>
       by Ruediger Franke: Included sensor components and
       Modelica_Fluid.Examples.DrumBoiler example.</li>
<li><i>Sept., 2003</i><br>
       by Martin Otter: Changes according to the decisions of the
       Modelica design meeting in Dearborn, Sept. 2-4, 2003.
       Fluid library split into two packages: Modelica_Media
       that contains the media models and Modelica_Fluid that
       contains fluid flow components. Modelica_Media is
       independent of Modelica_Fluid and my be used also from
       other packages that may have a different design as
       Modelica_Fluid.</li>
<li><i>Aug., 2003</i><br>
       by Martin Otter: Improved documentation, PortVicinity (now called semiLinear)
       manually expanded, two different volume types,
       replaced number of massFractions from n to n-1 in order
       that usage of model for single substances is easier
       and in order that no special cases have to be treated
       in the equations (previously the massFraction equations had to
       be removed for single substance flow; now they are removed
       automatically, since the dimensions are zero, and not one
       as previously), included asserts to check the validity of
       the medium models, included the dynamic viscosity in the
       medium models, adapted the examples and medium models to the
       changes in Interfaces, improved menus according to the new
       features in Dymola 5.1. Added \"Components.ShortPipe\" that
       contains a detailed model of the frictional losses in pipes
       over a very wide range.</li>
<li><i>Feb., 2003</i><br>
       by Martin Otter: Included several elementary components and
       a model for moist air. Some elementary components, such as
       FixedAmbient, are adapted versions from the SimpleFlow fluid library
       of Anton Haumer.</li>
<li><i>Dec., 2002</i><br>
       by Hubertus Tummescheit:
       Improved version of the high precision water model
       (Copy from ThermoFluid library, code reorganization,
       enhanced documentation, additional functions).</li>
<li><i>Nov. 30, 2002</i><br>
       by Martin Otter: Improved the design from the design meeting:
       Adapted to Modelica standard library 1.5,
       added \"choicesAllMatching=true\" annotation,
       added short documentation to \"Interfaces\",
       added packages \"Examples\" and \"Media\" (previously called \"Properties\")
       from previous versions and adapted them to the updated
       \"Interfaces\" package.</li>
<li><i>Nov. 20-21, 2002</i><br>
       by Hilding Elmqvist, Mike Tiller, Allan Watson, John Batteh, Chuck Newman,
       Jonas Eborn: Improved at the 32nd Modelica Design Meeting.</li>
<li><i>Nov. 11, 2002</i><br>
       by Hilding Elmqvist, Martin Otter: improved version.</li>
<li><i>Nov. 6, 2002</i><br>
       by Hilding Elmqvist: first version of the basic design.</li>
</ul>
</html>"));
  end ReleaseNotes;

class Contact "Contact"
  extends Modelica_Icons.Contact;

    annotation (Documentation(info="<html>
<dl>
<dt><b>Library Officers:</b><br>&nbsp;</dt>
<dd>
<table border=0 cellspacing=0 cellpadding=2>
<tr>
<td>
    Francesco Casella<br>
    Dipartimento di Elettronica e Informazione<br>
    Politecnico di Milano<br>
    Via Ponzio 34/5<br>
    I-20133 Milano, Italy<br>
    email: <A HREF=\"mailto:casella@elet.polimi.it\">casella@elet.polimi.it</A><br>&nbsp;
</td>
<td></td>
<td>and</td>
<td></td>
<td>
    R&uuml;diger Franke<br>
    ABB AG<br>
    PTSP-E22<br>
    Kallstadter Str. 1<br>
    D-68163, Germany<br>
    email: <A HREF=\"mailto:ruediger.franke@de.abb.com\">ruediger.franke@de.abb.com</A><br>&nbsp;
</td>
</tr>
</table>
</dd>
</dl>
<p><b>Acknowledgements:</b></p>
<p>
The development of this library has been a collaborative effort
and many have contributed.
</p>
<ul>
<li>The previous design of this library (until beginning of 2008) was based on the paper
     Elmqvist H., Tummescheit H., and Otter M.:
     <a href=\"https://www.modelica.org/events/Conference2003/papers/h40_Elmqvist_fluid.pdf\">Object-Oriented Modeling of Thermo-Fluid Systems</a>.
     Modelica 2003 Conference, Link&ouml;ping, Sweden, pp. 269-286, Nov. 3-4, 2003.<br>
     This design has been partly changed, especially by the introduction of the streams
     concept.</li>

<li>The Fluid library development was organized in 2002-2004 by Martin
     Otter, since 2004 it is organized by Francesco Casella, and
     since 2008 it is organized jointly by Francesco Casella and R&uuml;diger Franke.</li>

<li>Francesco Casella included several components of his ThermoPower
     library with some rewriting. The stream connector concept used in Modelica_Fluid is
     based on a similar concept developed by him for the ThermoPower library.</li>

<li>R&uuml;diger Franke initiated the stream connector concept as an extension
     and improved version of the ThermoPower concept. In Nov. 2008 - Jan. 2009 he
     greatly restructured and improved the library.</li>

<li>Michael Wetter introduced trace constituents in Modelica_Fluid consistently and
     provided corresponding examples under Examples.TraceSubstances.</li>

<li>The following people contributed to the fluid component models,
     examples, and the further design of the library
     (alphabetical list):<br>
     John Batteh,
     Francesco Casella, Jonas Eborn, Hilding Elmqvist,
     R&uuml;diger Franke, Manuel Gr&auml;ber, Henning Knigge,
     Sven Erik Mattsson, Chuck Newman, Hans Olsson,
     Martin Otter, Katrin Pr&ouml;l&szlig;,
     Christoph Richter, Michael Sielemann, Mike Tiller, Hubertus Tummescheit,
     Allan Watson, Michael Wetter.</li>
</ul>

<p>
  Partial financial support of ABB and DLR by BMBF (BMBF F&ouml;rderkennzeichen: 01IS07022F) for the further development
     of this library within the <a href=\"http://www.itea2.org\">ITEA</a> project
     <a href=\"http://www.itea2.org/public/project_leaflets/EUROSYSLIB_profile_oct-07.pdf\">EUROSYSLIB</a>
     is highly appreciated.</p>

</html>"));
end Contact;
  annotation (DocumentationClass=true, Documentation(info="<HTML>
<p>
Library <b>Modelica_Fluid</b> is a <b>free</b> Modelica package providing components for
<b>1-dimensional thermo-fluid flow</b> in networks of pipes. A unique feature is that the
component equations and the media models
as well as pressure loss and heat transfer correlations are decoupled from each other.
All components are implemented such that they can be used for
media from the Modelica_Media library. This means especially that an
incompressible or compressible medium, a single or a multiple
substance medium with one or more phases might be used.
</p>
</HTML>"));
end UsersGuide;

  model System
    "System properties and default values (ambient, flow direction, initialization)"

    package Medium = Modelica_Media_Interfaces.PartialMedium
      "Medium model for default start values"
        annotation (choicesAllMatching = true);
    parameter SI.AbsolutePressure p_ambient=101325 "Default ambient pressure"
      annotation (Dialog(group="Environment"));
    parameter SI.Temperature T_ambient=293.15 "Default ambient temperature"
      annotation (Dialog(group="Environment"));
    parameter SI.Acceleration g=Modelica_Constants.g_n
      "Constant gravity acceleration" annotation (Dialog(group="Environment"));

    // Assumptions
    parameter Boolean allowFlowReversal = true
      "= false to restrict to design flow direction (port_a -> port_b)"
      annotation(Dialog(tab="Assumptions"), Evaluate=true);
    parameter Types.Dynamics energyDynamics=Types.Dynamics.DynamicFreeInitial
      "Default formulation of energy balances"
      annotation (Evaluate=true, Dialog(tab="Assumptions", group="Dynamics"));
    parameter Types.Dynamics massDynamics=energyDynamics
      "Default formulation of mass balances"
      annotation (Evaluate=true, Dialog(tab="Assumptions", group="Dynamics"));
    final parameter Types.Dynamics substanceDynamics=massDynamics
      "Default formulation of substance balances"
      annotation (Evaluate=true, Dialog(tab="Assumptions", group="Dynamics"));
    final parameter Types.Dynamics traceDynamics=massDynamics
      "Default formulation of trace substance balances"
      annotation (Evaluate=true, Dialog(tab="Assumptions", group="Dynamics"));
    parameter Types.Dynamics momentumDynamics=Types.Dynamics.SteadyState
      "Default formulation of momentum balances, if options available"
      annotation (Evaluate=true, Dialog(tab="Assumptions", group="Dynamics"));

    // Initialization
    parameter SI.MassFlowRate m_flow_start=0
      "Default start value for mass flow rates"
      annotation (Dialog(tab="Initialization"));
    parameter SI.AbsolutePressure p_start=p_ambient
      "Default start value for pressures"
      annotation (Dialog(tab="Initialization"));
    parameter SI.Temperature T_start=T_ambient
      "Default start value for temperatures"
      annotation (Dialog(tab="Initialization"));
    // Advanced
    parameter Boolean use_eps_Re = false
      "= true to determine turbulent region automatically using Reynolds number"
      annotation(Evaluate=true, Dialog(tab = "Advanced"));
    parameter SI.MassFlowRate m_flow_nominal=if use_eps_Re then 1 else 1e2*
        m_flow_small "Default nominal mass flow rate"
      annotation (Dialog(tab="Advanced", enable=use_eps_Re));
    parameter Real eps_m_flow(min=0) = 1e-4
      "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal"
      annotation(Dialog(tab = "Advanced", enable = use_eps_Re));
    parameter SI.AbsolutePressure dp_small(min=0)=1
      "Default small pressure drop for regularization of laminar and zero flow"
      annotation (Dialog(
        tab="Advanced",
        group="Classic",
        enable=not use_eps_Re));
    parameter SI.MassFlowRate m_flow_small(min=0)=1e-2
      "Default small mass flow rate for regularization of laminar and zero flow"
      annotation (Dialog(
        tab="Advanced",
        group="Classic",
        enable=not use_eps_Re));
  initial equation
    //assert(use_eps_Re, "*** Using classic system.m_flow_small and system.dp_small."
    //       + " They do not distinguish between laminar flow and regularization of zero flow."
    //       + " Absolute small values are error prone for models with local nominal values."
    //       + " Moreover dp_small can generally be obtained automatically."
    //       + " Please update the model to new system.use_eps_Re = true  (see system, Advanced tab). ***",
    //       level=AssertionLevel.warning);
    annotation (
      defaultComponentName="system",
      defaultComponentPrefixes="inner",
      missingInnerMessage="
Your model is using an outer \"system\" component but
an inner \"system\" component is not defined.
For simulation drag Modelica_Fluid.System into your model
to specify system properties.
",    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
              100}}), graphics={
          Rectangle(
            extent={{-100,100},{100,-100}},
            lineColor={0,0,255},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid),
          Text(
            extent={{-150,150},{150,110}},
            lineColor={0,0,255},
            textString="%name"),
          Line(points={{-86,-30},{82,-30}}, color={0,0,0}),
          Line(points={{-82,-68},{-52,-30}}, color={0,0,0}),
          Line(points={{-48,-68},{-18,-30}}, color={0,0,0}),
          Line(points={{-14,-68},{16,-30}}, color={0,0,0}),
          Line(points={{22,-68},{52,-30}}, color={0,0,0}),
          Line(points={{74,84},{74,14}}, color={0,0,0}),
          Polygon(
            points={{60,14},{88,14},{74,-18},{60,14}},
            lineColor={0,0,0},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid),
          Text(
            extent={{16,20},{60,-18}},
            lineColor={0,0,0},
            textString="g"),
          Text(
            extent={{-90,82},{74,50}},
            lineColor={0,0,0},
            textString="defaults"),
          Line(
            points={{-82,14},{-42,-20},{2,30}},
            color={0,0,0},
            thickness=0.5),
          Ellipse(
            extent={{-10,40},{12,18}},
            pattern=LinePattern.None,
            lineColor={0,0,0},
            fillColor={255,0,0},
            fillPattern=FillPattern.Solid)}),
      Documentation(info="<html>
<p>
 A system component is needed in each fluid model to provide system-wide settings, such as ambient conditions and overall modeling assumptions.
 The system settings are propagated to the fluid models using the inner/outer mechanism.
</p>
<p>
 A model should never directly use system parameters.
 Instead a local parameter should be declared, which uses the global setting as default.
 The only exceptions are:</p>
 <ul>
  <li>the gravity system.g,</li>
  <li>the global system.eps_m_flow, which is used to define a local m_flow_small for the local m_flow_nominal:
      <pre>m_flow_small = system.eps_m_flow*m_flow_nominal</pre>
  </li>
 </ul>
<p>
 The global system.m_flow_small and system.dp_small are classic parameters.
 They do not distinguish between laminar flow and regularization of zero flow.
 Absolute small values are error prone for models with local nominal values.
 Moreover dp_small can generally be obtained automatically.
 Consider using the new system.use_eps_Re = true (see Advanced tab).
</p>
</html>"));
  end System;

  package Vessels "Devices for storing fluid"
      extends Modelica_Icons.VariantsPackage;

      model ClosedVolume
      "Volume of fixed size, closed to the ambient, with inlet/outlet ports"
      import Modelica_Constants.pi;

        // Mass and energy balance, ports
        extends BaseClasses.PartialLumpedVessel(
        final fluidVolume=V,
        vesselArea=pi*(3/4*V)^(2/3),
        heatTransfer(surfaceAreas={4*pi*(3/4*V/pi)^(2/3)}));

      parameter SI.Volume V "Volume";

      equation
        Wb_flow = 0;
        for i in 1:nPorts loop
          vessel_ps_static[i] = medium.p;
        end for;

        annotation (defaultComponentName="volume",
          Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                100,100}}), graphics={Ellipse(
              extent={{-100,100},{100,-100}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={170,213,255}), Text(
              extent={{-150,12},{150,-18}},
              lineColor={0,0,0},
              textString="V=%V")}),
        Documentation(info="<html>
<p>
Ideally mixed volume of constant size with two fluid ports and one medium model.
The flow properties are computed from the upstream quantities, pressures are equal in both nodes and the medium model if <code>use_portsData=false</code>.
Heat transfer through a thermal port is possible, it equals zero if the port remains unconnected.
A spherical shape is assumed for the heat transfer area, with V=4/3*pi*r^3, A=4*pi*r^2.
Ideal heat transfer is assumed per default; the thermal port temperature is equal to the medium temperature.
</p>
<p>
If <code>use_portsData=true</code>, the port pressures represent the pressures just after the outlet (or just before the inlet) in the attached pipe.
The hydraulic resistances <code>portsData.zeta_in</code> and <code>portsData.zeta_out</code> determine the dissipative pressure drop between volume and port depending on
the direction of mass flow. See <a href=\"modelica://Modelica_Fluid.Vessels.BaseClasses.VesselPortsData\">VesselPortsData</a> and <i>[Idelchik, Handbook of Hydraulic Resistance, 2004]</i>.
</p>
</html>"));
      end ClosedVolume;

  model OpenTank "Simple tank with inlet/outlet ports"
      import Modelica_Constants.pi;

    // Tank properties
      SI.Height level(stateSelect=StateSelect.prefer, start=level_start_eps)
        "Level height of tank";
      SI.Volume V(stateSelect=StateSelect.never) "Actual tank volume";

    // Tank geometry
      parameter SI.Height height "Height of tank";
      parameter SI.Area crossArea "Area of tank";

    // Ambient
    parameter
        Modelica_Fluid_Interfaces.PartialLumpedVolume.Medium.AbsolutePressure p_ambient=system.p_ambient
        "Tank surface pressure"
        annotation (Dialog(tab="Assumptions", group="Ambient"));
    parameter Medium.Temperature T_ambient=system.T_ambient
        "Tank surface Temperature"
      annotation(Dialog(tab = "Assumptions", group = "Ambient"));

    // Initialization
      parameter SI.Height level_start(min=0)=0.5*height
        "Start value of tank level" annotation (Dialog(tab="Initialization"));

    // Mass and energy balance, ports
    extends BaseClasses.PartialLumpedVessel(
        final fluidVolume=V,
        final fluidLevel=level,
        final fluidLevel_max=height,
        final vesselArea=crossArea,
        heatTransfer(surfaceAreas={crossArea + 2*sqrt(crossArea*pi)*level}),
        final initialize_p=false,
        final p_start=p_ambient);

    protected
      final parameter SI.Height level_start_eps=max(level_start,
          Modelica_Constants.eps);

  equation
    // Total quantities
    V = crossArea*level "Volume of fluid";
    medium.p = p_ambient;

    // Source termsEnergy balance
    if Medium.singleState or energyDynamics == Types.Dynamics.SteadyState then
      Wb_flow = 0
          "Mechanical work is neglected, since also neglected in medium model (otherwise unphysical small temperature change, if tank level changes)";
    else
      Wb_flow = -p_ambient*der(V);
    end if;

    //Determine port properties
    for i in 1:nPorts loop
      vessel_ps_static[i] = max(0, level - portsData_height[i])*system.g*medium.d + p_ambient;
    end for;

  initial equation
    if massDynamics == Types.Dynamics.FixedInitial then
      level = level_start_eps;
    elseif massDynamics == Types.Dynamics.SteadyStateInitial then
      der(level) = 0;
    end if;

      annotation (defaultComponentName="tank",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            initialScale=0.2), graphics={
            Rectangle(
              extent={{-100,100},{100,-100}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.VerticalCylinder),
            Rectangle(
              extent=DynamicSelect({{-100,-100},{100,10}}, {{-100,-100},{100,(-100
                   + 200*level/height)}}),
              lineColor={0,0,0},
              fillColor={85,170,255},
              fillPattern=FillPattern.VerticalCylinder),
            Line(points={{-100,100},{-100,-100},{100,-100},{100,100}}, color={0,0,
                  0}),
            Text(
              extent={{-95,60},{95,40}},
              lineColor={0,0,0},
              textString="level ="),
            Text(
              extent={{-95,-24},{95,-44}},
              lineColor={0,0,0},
              textString=DynamicSelect("%level_start", String(
                  level,
                  minimumLength=1,
                  significantDigits=2)))}),
        Documentation(info="<HTML>
<p>
Model of a tank that is open to the ambient at the fixed pressure
<code>p_ambient</code>.
</p>
<p>
The vector of connectors <b>ports</b> represents fluid ports at configurable heights, relative to the bottom of tank.
Fluid can flow either out of or in to each port.
</p>
The following assumptions are made:
<ul>
<li>The tank is filled with a single or multiple-substance medium having a density higher than the density of the ambient medium.</li>
<li>The fluid has uniform density, temperature and mass fractions</li>
<li>No liquid is leaving the tank through the open top; the simulation breaks with an assertion if the liquid level growths over the height.</li>
</ul>
<p>
The port pressures represent the pressures just after the outlet (or just before the inlet) in the attached pipe.
The hydraulic resistances <code>portsData.zeta_in</code> and <code>portsData.zeta_out</code> determine the dissipative pressure drop between tank and port depending on
the direction of mass flow. See <a href=\"modelica://Modelica_Fluid.Vessels.BaseClasses.VesselPortsData\">VesselPortsData</a> and <i>[Idelchik, Handbook of Hydraulic Resistance, 2004]</i>.
</p>
<p>
With the setting <code>use_portsData=false</code>, the port pressure represents the static head
at the height of the respective port.
The relationship between pressure drop and mass flow rate at the port must then be provided by connected components;
Heights of ports as well as kinetic and potential energy of fluid entering or leaving are not taken into account anymore.
</p>
</HTML>",   revisions="<html>
<ul>
<li><i>Dec. 12, 2008</i> by Ruediger Franke: move port definitions
   to BaseClasses.PartialLumpedVessel; also use energy and mass balance from common base class</li>
<li><i>Dec. 8, 2008</i> by Michael Wetter (LBNL):<br>
Implemented trace substances.</li>
<li><i>Jan. 6, 2006</i> by Katja Poschlad, Manuel Remelhe (AST Uni Dortmund),
   Martin Otter (DLR):<br>
   Implementation based on former tank model.</li>
<li><i>Oct. 29, 2007</i> by Carsten Heinrich (ILK Dresden):<br>
Adapted to the new fluid library interfaces:
<ul> <li>FluidPorts_b is used instead of FluidPort_b (due to it is defined as an array of ports)</li>
    <li>Port name changed from port to ports</li></ul>Updated documentation.</li>
<li><i>Apr. 25, 2006</i> by Katrin Pr&ouml;l&szlig; (TUHH):<br>
Limitation to bottom ports only, added inlet and outlet loss factors.</li>
</ul>
</html>"));
  end OpenTank;

    package BaseClasses
      "Base classes used in the Vessels package (only of interest to build new component models)"
      extends Modelica_Icons.BasesPackage;

        partial model PartialLumpedVessel
        "Lumped volume with a vector of fluid ports and replaceable heat transfer model"
        import Modelica_Fluid;
          extends Modelica_Fluid_Interfaces.PartialLumpedVolume;

          // Port definitions
          parameter Integer nPorts=0 "Number of ports"
            annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));
          VesselFluidPorts_b ports[nPorts](redeclare each package Medium = Medium)
          "Fluid inlets and outlets"
            annotation (Placement(transformation(extent={{-40,-10},{40,10}},
              origin={0,-100})));

          // Port properties
          parameter Boolean use_portsData=true
          "= false to neglect pressure loss and kinetic energy"
            annotation(Evaluate=true, Dialog(tab="General",group="Ports"));
          parameter VesselPortsData[if use_portsData then nPorts else 0] portsData
          "Data of inlet/outlet ports" annotation (Dialog(
            tab="General",
            group="Ports",
            enable=use_portsData));

          parameter Medium.MassFlowRate m_flow_nominal = if system.use_eps_Re then system.m_flow_nominal else 1e2*system.m_flow_small
          "Nominal value for mass flow rates in ports"
            annotation(Dialog(tab="Advanced", group="Port properties", enable=stiffCharacteristicForEmptyPort));
        parameter SI.MassFlowRate m_flow_small(min=0)=if system.use_eps_Re
           then system.eps_m_flow*m_flow_nominal else system.m_flow_small
          "Regularization range at zero mass flow rate" annotation (Dialog(
            tab="Advanced",
            group="Port properties",
            enable=stiffCharacteristicForEmptyPort));
          parameter Boolean use_Re = system.use_eps_Re
          "= true, if turbulent region is defined by Re, otherwise by m_flow_small"
            annotation(Dialog(tab="Advanced", group="Port properties"), Evaluate=true);
        /*
  parameter Medium.AbsolutePressure dp_small = system.dp_small
    "Turbulent flow if |dp| >= dp_small (regularization of zero flow)"
    annotation(Dialog(tab="Advanced",group="Ports"));
*/
          Medium.EnthalpyFlowRate ports_H_flow[nPorts];
          Medium.MassFlowRate ports_mXi_flow[nPorts,Medium.nXi];
          Medium.MassFlowRate[Medium.nXi] sum_ports_mXi_flow
          "Substance mass flows through ports";
          Medium.ExtraPropertyFlowRate ports_mC_flow[nPorts,Medium.nC];
          Medium.ExtraPropertyFlowRate[Medium.nC] sum_ports_mC_flow
          "Trace substance mass flows through ports";

          // Heat transfer through boundary
          parameter Boolean use_HeatTransfer = false
          "= true to use the HeatTransfer model"
              annotation (Dialog(tab="Assumptions", group="Heat transfer"));
          replaceable model HeatTransfer =
              Modelica_Fluid.Vessels.BaseClasses.HeatTransfer.IdealHeatTransfer
          constrainedby
          Modelica_Fluid.Vessels.BaseClasses.HeatTransfer.PartialVesselHeatTransfer
          "Wall heat transfer"
              annotation (Dialog(tab="Assumptions", group="Heat transfer",enable=use_HeatTransfer),choicesAllMatching=true);
          HeatTransfer heatTransfer(
            redeclare final package Medium = Medium,
            final n=1,
            final states = {medium.state},
            final use_k = use_HeatTransfer)
              annotation (Placement(transformation(
                extent={{-10,-10},{30,30}},
                rotation=90,
                origin={-50,-10})));
          Modelica_Thermal_HeatTransfer_Interfaces.HeatPort_a heatPort if
          use_HeatTransfer
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

          // Conservation of kinetic energy
          Medium.Density[nPorts] portInDensities
          "densities of the fluid at the device boundary";
        SI.Velocity[nPorts] portVelocities
          "velocities of fluid flow at device boundary";
        SI.EnergyFlowRate[nPorts] ports_E_flow
          "flow of kinetic and potential energy at device boundary";

          // Note: should use fluidLevel_start - portsData.height
          Real[nPorts] s(each start = fluidLevel_max)
          "curve parameters for port flows vs. port pressures; for further details see, Modelica Tutorial: Ideal switching devices";
          Real[nPorts] ports_penetration
          "penetration of port with fluid, depending on fluid level and port diameter";

          // treatment of pressure losses at ports
        SI.Area[nPorts] portAreas={Modelica_Constants.pi/4*portsData_diameter[i]
            ^2 for i in 1:nPorts};
          Medium.AbsolutePressure[nPorts] vessel_ps_static
          "static pressures inside the vessel at the height of the corresponding ports, zero flow velocity";

          // determination of turbulent region
        constant SI.ReynoldsNumber Re_turbulent=100 "cf. suddenExpansion";
        SI.MassFlowRate[nPorts] m_flow_turbulent;

      protected
        input SI.Height fluidLevel=0
          "level of fluid in the vessel for treating heights of ports";
        parameter SI.Height fluidLevel_max=1
          "maximum level of fluid in the vessel";
        parameter SI.Area vesselArea=Modelica_Constants.inf
          "Area of the vessel used to relate to cross flow area of ports";

          // Treatment of use_portsData=false to neglect portsData and to not require its specification either in this case.
          // Remove portsData conditionally if use_portsData=false. Simplify their use in model equations by always
          // providing portsData_diameter and portsData_height, independent of the use_portsData setting.
          // Note: this moreover serves as work-around if a tool does not support a zero sized portsData record.
          Modelica_Blocks_Interfaces.RealInput[nPorts] portsData_diameter_internal=portsData.diameter
          if use_portsData and nPorts > 0;
          Modelica_Blocks_Interfaces.RealInput[nPorts] portsData_height_internal = portsData.height if use_portsData and nPorts > 0;
          Modelica_Blocks_Interfaces.RealInput[nPorts] portsData_zeta_in_internal = portsData.zeta_in if use_portsData and nPorts > 0;
          Modelica_Blocks_Interfaces.RealInput[nPorts] portsData_zeta_out_internal = portsData.zeta_out if use_portsData and nPorts > 0;
          Modelica_Blocks_Interfaces.RealInput[nPorts] portsData_diameter;
          Modelica_Blocks_Interfaces.RealInput[nPorts] portsData_height;
          Modelica_Blocks_Interfaces.RealInput[nPorts] portsData_zeta_in;
          Modelica_Blocks_Interfaces.RealInput[nPorts] portsData_zeta_out;
          Modelica_Blocks_Interfaces.BooleanInput[nPorts] regularFlow(each start=true);
          Modelica_Blocks_Interfaces.BooleanInput[nPorts] inFlow(each start=false);

        equation
          mb_flow = sum(ports.m_flow);
          mbXi_flow = sum_ports_mXi_flow;
          mbC_flow  = sum_ports_mC_flow;
          Hb_flow = sum(ports_H_flow) + sum(ports_E_flow);
          Qb_flow = heatTransfer.Q_flows[1];

          // Only one connection allowed to a port to avoid unwanted ideal mixing
          for i in 1:nPorts loop
            assert(cardinality(ports[i]) <= 1,"
each ports[i] of volume can at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");       end for;
          // Check for correct solution
          assert(fluidLevel <= fluidLevel_max, "Vessel is overflowing (fluidLevel > fluidLevel_max = " + String(fluidLevel) + ")");
          assert(fluidLevel > -1e-6*fluidLevel_max, "Fluid level (= " + String(fluidLevel) + ") is below zero meaning that the solution failed.");

          // Boundary conditions

          // treatment of conditional portsData
          connect(portsData_diameter, portsData_diameter_internal);
          connect(portsData_height, portsData_height_internal);
          connect(portsData_zeta_in, portsData_zeta_in_internal);
          connect(portsData_zeta_out, portsData_zeta_out_internal);
          if not use_portsData then
            portsData_diameter = zeros(nPorts);
            portsData_height = zeros(nPorts);
            portsData_zeta_in = zeros(nPorts);
            portsData_zeta_out = zeros(nPorts);
          end if;

          // actual definition of port variables
          for i in 1:nPorts loop
            portInDensities[i] = Medium.density(Medium.setState_phX(vessel_ps_static[i], inStream(ports[i].h_outflow), inStream(ports[i].Xi_outflow)));
            if use_portsData then
              // dp = 0.5*zeta*d*v*|v|
              // Note: assume vessel_ps_static for portVelocities to avoid algebraic loops for ports.p
              portVelocities[i] = smooth(0, ports[i].m_flow/portAreas[i]/Medium.density(Medium.setState_phX(vessel_ps_static[i], actualStream(ports[i].h_outflow), actualStream(ports[i].Xi_outflow))));
              // Note: the penetration should not go too close to zero as this would prevent a vessel from running empty
              ports_penetration[i] = Utilities.regStep(fluidLevel - portsData_height[i] - 0.1*portsData_diameter[i], 1, 1e-3, 0.1*portsData_diameter[i]);
              m_flow_turbulent[i]=if not use_Re then m_flow_small else
                max(m_flow_small, (Modelica_Constants.pi/8)*portsData_diameter[i]
                                   *(Medium.dynamicViscosity(Medium.setState_phX(vessel_ps_static[i], inStream(ports[i].h_outflow), inStream(ports[i].Xi_outflow)))
                                     + Medium.dynamicViscosity(medium.state))*Re_turbulent);
            else
              // an infinite port diameter is assumed
              portVelocities[i] = 0;
              ports_penetration[i] = 1;
              m_flow_turbulent[i] =Modelica_Constants.inf;
            end if;

            // fluid flow through ports
            regularFlow[i] = fluidLevel >= portsData_height[i];
            inFlow[i]      = not regularFlow[i] and (s[i] > 0 or portsData_height[i] >= fluidLevel_max);
            if regularFlow[i] then
              // regular operation: fluidLevel is above ports[i]
              // Note: >= covers default values of zero as well
              if use_portsData then
                /* Without regularization
                 ports[i].p = vessel_ps_static[i] + 0.5*ports[i].m_flow^2/portAreas[i]^2
                              * noEvent(if ports[i].m_flow>0 then zeta_in[i]/portInDensities[i] else -zeta_out[i]/medium.d);
              */

                ports[i].p = homotopy(vessel_ps_static[i] + (0.5/portAreas[i]^2*Utilities.regSquare2(ports[i].m_flow, m_flow_turbulent[i],
                                             (portsData_zeta_in[i] - 1 + portAreas[i]^2/vesselArea^2)/portInDensities[i]*ports_penetration[i],
                                             (portsData_zeta_out[i] + 1 - portAreas[i]^2/vesselArea^2)/medium.d/ports_penetration[i])),
                                      vessel_ps_static[i]);
                /*
                // alternative formulation m_flow=f(dp); not allowing the ideal portsData_zeta_in[i]=1 though
                ports[i].m_flow = smooth(2, portAreas[i]*Utilities.regRoot2(ports[i].p - vessel_ps_static[i], dp_small,
                                       2*portInDensities[i]/portsData_zeta_in[i],
                                       2*medium.d/portsData_zeta_out[i]));
              */
              else
                ports[i].p = vessel_ps_static[i];
              end if;
              s[i] = fluidLevel - portsData_height[i];

            elseif inFlow[i] then
              // ports[i] is above fluidLevel and has inflow
              ports[i].p = vessel_ps_static[i];
              s[i] = ports[i].m_flow;

            else
              // ports[i] is above fluidLevel, preventing outflow
              ports[i].m_flow = 0;
              s[i] = (ports[i].p - vessel_ps_static[i])/Medium.p_default*(portsData_height[i] - fluidLevel);
            end if;

            ports[i].h_outflow  = medium.h;
            ports[i].Xi_outflow = medium.Xi;
            ports[i].C_outflow  = C;

            ports_H_flow[i] = ports[i].m_flow * actualStream(ports[i].h_outflow)
            "Enthalpy flow";
            ports_E_flow[i] = ports[i].m_flow*(0.5*portVelocities[i]*portVelocities[i] + system.g*portsData_height[i])
            "Flow of kinetic and potential energy";
            ports_mXi_flow[i,:] = ports[i].m_flow * actualStream(ports[i].Xi_outflow)
            "Component mass flow";
            ports_mC_flow[i,:]  = ports[i].m_flow * actualStream(ports[i].C_outflow)
            "Trace substance mass flow";
          end for;

          for i in 1:Medium.nXi loop
            sum_ports_mXi_flow[i] = sum(ports_mXi_flow[:,i]);
          end for;

          for i in 1:Medium.nC loop
            sum_ports_mC_flow[i]  = sum(ports_mC_flow[:,i]);
          end for;

          connect(heatPort, heatTransfer.heatPorts[1]) annotation (Line(
              points={{-100,0},{-87,0},{-87,0},{-74,0}},
              color={191,0,0},
              smooth=Smooth.None));
         annotation (
          Documentation(info="<html>
<p>
This base class extends PartialLumpedVolume with a vector of fluid ports and a replaceable wall HeatTransfer model.
</p>
<p>
The following modeling assumption are made:
<ul>
<li>homogeneous medium, i.e., phase separation is not taken into account,</li>
<li>no kinetic energy in the fluid, i.e., kinetic energy dissipates into the internal energy,</li>
<li>pressure loss definitions at vessel ports assume incompressible fluid,</li>
<li>outflow of ambient media is prevented at each port assuming check valve behavior.
    If <code> fluidlevel &lt; portsData_height[i] </code>and &nbsp; <code> ports[i].p &lt; vessel_ps_static[i]</code> massflow at the port is set to 0.</li>
</ul>
<p>
Each port has a (hydraulic) diameter and a height above the bottom of the vessel, which can be configured using the &nbsp;<b><code>portsData</code></b> record.
Alternatively the impact of port geometries can be neglected with <code>use_portsData=false</code>. This might be useful for early
design studies. Note that this means to assume an infinite port diameter at the bottom of the vessel.
Pressure drops and heights of the ports as well as kinetic and potential energy fluid entering or leaving the vessel are neglected then.
</p>
<p>
The following variables need to be defined by an extending model:
</p>
<ul>
<li><code>input fluidVolume</code>, the volume of the fluid in the vessel,</li>
<li><code>vessel_ps_static[nPorts]</code>, the static pressures inside the vessel at the height of the corresponding ports, at zero flow velocity, and</li>
<li><code>Wb_flow</code>, work term of the energy balance, e.g., p*der(V) if the volume is not constant or stirrer power.</li>
</ul>
<p>
An extending model should define:
</p>
<ul>
<li><code>parameter vesselArea</code> (default: Modelica_Constants.inf m2), the area of the vessel, to be related to cross flow areas of the ports for the consideration of dynamic pressure effects.</li>
</ul>
<p>
Optionally the fluid level may vary in the vessel, which effects the flow through the ports at configurable <code>portsData_height[nPorts]</code>.
This is why an extending model with varying fluid level needs to define:
</p>
<ul>
<li><code>input fluidLevel (default: 0m)</code>, the level the fluid in the vessel, and</li>
<li><code>parameter fluidLevel_max (default: 1m)</code>, the maximum level that must not be exceeded. Ports at or above fluidLevel_max can only receive inflow.</li>
</ul>
<p>
An extending model should not access the <code>portsData</code> record defined in the configuration dialog,
as an access to <code>portsData</code> may fail for <code>use_portsData=false</code> or <code>nPorts=0</code>.
</p>
<p>
Instead the predefined variables
</p>
<ul>
<li><code>portsData_diameter[nPorts]</code>,</li>
<li><code>portsData_height[nPorts]</code>,</li>
<li><code>portsData_zeta_in[nPorts]</code>, and</li>
<li><code>portsData_zeta_out[nPorts]</code></li>
</ul>
<p>
should be used if these values are needed.
</p>
</html>",         revisions="<html>
<ul>
<li><i>Jan. 2009</i> by R&uuml;diger Franke: extended with
   <ul><li>portsData record and threat configurable port heights,</li>
       <li>consideration of kinetic and potential energy of fluid entering or leaving in energy balance</li>
   </ul>
</li>
<li><i>Dec. 2008</i> by R&uuml;diger Franke: derived from OpenTank, in order to make general use of configurable port diameters</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                  {100,100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255})}));
        end PartialLumpedVessel;

    package HeatTransfer "HeatTransfer models for vessels"
      extends Modelica_Icons.Package;

      partial model PartialVesselHeatTransfer
          "Base class for vessel heat transfer models"
        extends Modelica_Fluid_Interfaces.PartialHeatTransfer;

        annotation(Documentation(info="<html>
Base class for vessel heat transfer models.
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                    {100,100}}), graphics={Ellipse(
                  extent={{-60,64},{60,-56}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={232,0,0}), Text(
                  extent={{-38,26},{40,-14}},
                  lineColor={0,0,0},
                  textString="%name")}));
      end PartialVesselHeatTransfer;

      model IdealHeatTransfer
          "IdealHeatTransfer: Ideal heat transfer without thermal resistance"
        extends PartialVesselHeatTransfer;

      equation
        Ts = heatPorts.T;

        annotation(Documentation(info="<html>
Ideal heat transfer without thermal resistance.
</html>"));
      end IdealHeatTransfer;

      model ConstantHeatTransfer
          "ConstantHeatTransfer: Constant heat transfer coefficient"
        extends PartialVesselHeatTransfer;
          parameter SI.CoefficientOfHeatTransfer alpha0
            "constant heat transfer coefficient";

      equation
        Q_flows = {(alpha0+k)*surfaceAreas[i]*(heatPorts[i].T - Ts[i]) for i in 1:n};

        annotation(Documentation(info="<html>
Simple heat transfer correlation with constant heat transfer coefficient.
</html>"));
      end ConstantHeatTransfer;
      annotation (Documentation(info="<html>
Heat transfer correlations for pipe models
</html>"));

    end HeatTransfer;

      record VesselPortsData "Data to describe inlet/outlet ports at vessels:
    diameter -- Inner (hydraulic) diameter of inlet/outlet port
    height -- Height over the bottom of the vessel
    zeta_out -- Hydraulic resistance out of vessel, default 0.5 for small diameter mounted flush with the wall
    zeta_in -- Hydraulic resistance into vessel, default 1.04 for small diameter mounted flush with the wall"
            extends Modelica_Icons.Record;
        parameter SI.Diameter diameter
          "Inner (hydraulic) diameter of inlet/outlet port";
        parameter SI.Height height=0 "Height over the bottom of the vessel";
        parameter Real zeta_out(min=0)=0.5
          "Hydraulic resistance out of vessel, default 0.5 for small diameter mounted flush with the wall";
        parameter Real zeta_in(min=0)=1.04
          "Hydraulic resistance into vessel, default 1.04 for small diameter mounted flush with the wall";
        annotation (preferredView="info", Documentation(info="<html>
<h4>Vessel Port Data</h4>
<p>
This record describes the <b>ports</b> of a <b>vessel</b>. The variables in it are mostly self-explanatory (see list below); only the &zeta;
loss factors are discussed further. All data is quoted from Idelchik (1994).
</p>

<h4>Outlet Coefficients</h4>

<p>
If a <b>straight pipe with constant cross section is mounted flush with the wall</b>, its outlet pressure loss coefficient will be <code>&zeta; = 0.5</code> (Idelchik, p. 160, Diagram 3-1, paragraph 2).
</p>
<p>
If a <b>straight pipe with constant cross section is mounted into a vessel such that the entrance into it is at a distance</b> <code>b</code> from the wall (inside) the following table can be used. Herein, &delta; is the tube wall thickness (Idelchik, p. 160, Diagram 3-1, paragraph 1).
</p>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <caption align=\"bottom\">Pressure loss coefficients for outlets, entrance at a distance from wall</caption>
  <tr>
    <td></td> <td>   </td><th colspan=\"5\" align=\"center\"> b / D_hyd  </th>
  </tr>
  <tr>
    <td></td> <td>   </td><th> 0.000 </th><th> 0.005 </th><th> 0.020 </th><th> 0.100 </th><th> 0.500-&#8734; </th>
  </tr>
  <tr>
     <th rowspan=\"5\" valign=\"middle\">&delta; / D_hyd</th> <th> 0.000 </th><td> 0.50 </td><td> 0.63  </td><td> 0.73  </td><td> 0.86  </td><td>      1.00     </td>
  </tr>
  <tr>
              <th> 0.008 </th><td> 0.50 </td><td> 0.55  </td><td> 0.62  </td><td> 0.74  </td><td>      0.88     </td>
  </tr>
  <tr>
              <th> 0.016 </th><td> 0.50 </td><td> 0.51  </td><td> 0.55  </td><td> 0.64  </td><td>      0.77     </td>
  </tr>
  <tr>
              <th> 0.024 </th><td> 0.50 </td><td> 0.50  </td><td> 0.52  </td><td> 0.58  </td><td>      0.68     </td>
  </tr>
  <tr>
              <th> 0.040 </th><td> 0.50 </td><td> 0.50  </td><td> 0.51  </td><td> 0.51  </td><td>      0.54     </td>
  </tr>
</table>

<p>
If a <b>straight pipe with a circular bellmouth inlet (collector) without baffle is mounted flush with the wall</b> then its pressure loss coefficient can be established from the following table. Herein, r is the radius of the bellmouth inlet surface (Idelchik, p. 164 f., Diagram 3-4, paragraph b)
</p>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <caption align=\"bottom\">Pressure loss coefficients for outlets, bellmouth flush with wall</caption>
  <tr>
    <td></td> <th colspan=\"6\" align=\"center\"> r / D_hyd  </th>
  </tr>
  <tr>
    <td></td> <th> 0.01 </th><th> 0.03 </th><th> 0.05 </th><th> 0.08 </th><th> 0.16 </th><th>&ge;0.20</th>
  </tr>
  <tr>
     <th>&zeta;</th> <td> 0.44 </td><td> 0.31 </td><td> 0.22  </td><td> 0.15  </td><td> 0.06  </td><td>      0.03     </td>
  </tr>
</table>

<p>
If a <b>straight pipe with a circular bellmouth inlet (collector) without baffle is mounted at a distance from a wall</b> then its pressure loss coefficient can be established from the following table. Herein, r is the radius of the bellmouth inlet surface (Idelchik, p. 164 f., Diagram 3-4, paragraph a)
</p>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <caption align=\"bottom\">Pressure loss coefficients for outlets, bellmouth at a distance of wall</caption>
  <tr>
    <td></td> <th colspan=\"6\" align=\"center\"> r / D_hyd  </th>
  </tr>
  <tr>
    <td></td> <th> 0.01 </th><th> 0.03 </th><th> 0.05 </th><th> 0.08 </th><th> 0.16 </th><th>&ge;0.20</th>
  </tr>
  <tr>
     <th>&zeta;</th> <td> 0.87 </td><td> 0.61 </td><td> 0.40  </td><td> 0.20  </td><td> 0.06  </td><td>      0.03     </td>
  </tr>
</table>

<h4>Inlet Coefficients</h4>

<p>
If a <b>straight pipe with constant circular cross section is mounted flush with the wall</b>, its vessel inlet pressure loss coefficient will be according to the following table (Idelchik, p. 209 f., Diagram 4-2 with <code>A_port/A_vessel = 0</code> and Idelchik, p. 640, Diagram 11-1, graph a). According to the text, <code>m = 9</code> is appropriate for fully developed turbulent flow.
</p>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <caption align=\"bottom\">Pressure loss coefficients for inlets, circular tube flush with wall</caption>
  <tr>
    <td></td> <th colspan=\"6\" align=\"center\"> m  </th>
  </tr>
  <tr>
    <td></td> <th> 1.0 </th><th> 2.0 </th><th> 3.0 </th><th> 4.0 </th><th> 7.0 </th><th>9.0</th>
  </tr>
  <tr>
     <th>&zeta;</th> <td> 2.70 </td><td> 1.50 </td><td> 1.25  </td><td> 1.15  </td><td> 1.06  </td><td>      1.04     </td>
  </tr>
</table>

<p>
For larger port diameters, relative to the area of the vessel, the inlet pressure loss coefficient will be according to the following table (Idelchik, p. 209 f., Diagram 4-2 with <code>m = 7</code>).
</p>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <caption align=\"bottom\">Pressure loss coefficients for inlets, circular tube flush with wall</caption>
  <tr>
    <td></td> <th colspan=\"6\" align=\"center\"> A_port / A_vessel  </th>
  </tr>
  <tr>
    <td></td> <th> 0.0 </th><th> 0.1 </th><th> 0.2 </th><th> 0.4 </th><th> 0.6 </th><th>0.8</th>
  </tr>
  <tr>
     <th>&zeta;</th> <td> 1.04 </td><td> 0.84 </td><td> 0.67  </td><td> 0.39  </td><td> 0.18  </td><td>      0.06     </td>
  </tr>
</table>

<h4>References</h4>

<dl><dt>Idelchik I.E. (1994):</dt>
    <dd><a href=\"http://www.bookfinder.com/dir/i/Handbook_of_Hydraulic_Resistance/0849399084/\"><b>Handbook
        of Hydraulic Resistance</b></a>. 3rd edition, Begell House, ISBN
        0-8493-9908-4</dd>
</dl>
</html>"));
      end VesselPortsData;

      connector VesselFluidPorts_a
        "Fluid connector with filled, large icon to be used for horizontally aligned vectors of FluidPorts (vector dimensions must be added after dragging)"
        extends Modelica_Fluid_Interfaces.FluidPort;
        annotation (defaultComponentName="ports_b",
                    Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Text(extent={{-75,130},{75,100}}, textString="%name"),
              Rectangle(
                extent={{-25,100},{25,-100}},
                lineColor={0,0,0}),
              Ellipse(
                extent={{-22,100},{-10,-100}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-6,100},{6,-100}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{10,100},{22,-100}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid)}),
             Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Rectangle(
                extent={{-50,200},{50,-200}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-44,200},{-20,-200}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-12,200},{12,-200}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{20,200},{44,-200}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid)}));
      end VesselFluidPorts_a;

      connector VesselFluidPorts_b
        "Fluid connector with outlined, large icon to be used for horizontally aligned vectors of FluidPorts (vector dimensions must be added after dragging)"
        extends Modelica_Fluid_Interfaces.FluidPort;
        annotation (defaultComponentName="ports_b",
                    Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Text(extent={{-75,130},{75,100}}, textString="%name"),
              Rectangle(
                extent={{-25,100},{25,-100}},
                lineColor={0,0,0}),
              Ellipse(
                extent={{-22,100},{-10,-100}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-20,-69},{-12,69}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-6,100},{6,-100}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{10,100},{22,-100}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-4,-69},{4,69}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{12,-69},{20,69}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
             Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Rectangle(
                extent={{-50,200},{50,-200}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-44,200},{-20,-200}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-12,200},{12,-200}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{20,200},{44,-200}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-39,-118.5},{-25,113}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-7,-118.5},{7,113}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{25,-117.5},{39,114}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}));
      end VesselFluidPorts_b;
    end BaseClasses;
    annotation (Documentation(info="<html>

</html>"));
  end Vessels;

  package Pipes "Devices for conveying fluid"
      extends Modelica_Icons.VariantsPackage;

    model StaticPipe "Basic pipe flow model without storage of mass or energy"

      // extending PartialStraightPipe
      extends BaseClasses.PartialStraightPipe;

      // Initialization
      parameter Medium.AbsolutePressure p_a_start=system.p_start
        "Start value of pressure at port a"
        annotation(Dialog(tab = "Initialization"));
      parameter Medium.AbsolutePressure p_b_start=p_a_start
        "Start value of pressure at port b"
        annotation(Dialog(tab = "Initialization"));
      parameter Medium.MassFlowRate m_flow_start = system.m_flow_start
        "Start value for mass flow rate"
         annotation(Evaluate=true, Dialog(tab = "Initialization"));

      FlowModel flowModel(
              redeclare final package Medium = Medium,
              final n=2,
              states={Medium.setState_phX(port_a.p, inStream(port_a.h_outflow), inStream(port_a.Xi_outflow)),
                     Medium.setState_phX(port_b.p, inStream(port_b.h_outflow), inStream(port_b.Xi_outflow))},
              vs={port_a.m_flow/Medium.density(flowModel.states[1])/flowModel.crossAreas[1],
                  -port_b.m_flow/Medium.density(flowModel.states[2])/flowModel.crossAreas[2]}/nParallel,
              final momentumDynamics=Types.Dynamics.SteadyState,
              final allowFlowReversal=allowFlowReversal,
              final p_a_start=p_a_start,
              final p_b_start=p_b_start,
              final m_flow_start=m_flow_start,
              final nParallel=nParallel,
              final pathLengths={length},
              final crossAreas={crossArea, crossArea},
              final dimensions={4*crossArea/perimeter, 4*crossArea/perimeter},
              final roughnesses={roughness, roughness},
              final dheights={height_ab},
              final g=system.g) "Flow model"
         annotation (Placement(transformation(extent={{-38,-18},{38,18}},rotation=0)));
    equation
      // Mass balance
      port_a.m_flow = flowModel.m_flows[1];
      0 = port_a.m_flow + port_b.m_flow;
      port_a.Xi_outflow = inStream(port_b.Xi_outflow);
      port_b.Xi_outflow = inStream(port_a.Xi_outflow);
      port_a.C_outflow = inStream(port_b.C_outflow);
      port_b.C_outflow = inStream(port_a.C_outflow);

      // Energy balance, considering change of potential energy
      // Wb_flow = v*A*dpdx + v*F_fric
      //         = m_flow/d/A * (A*dpdx + A*pressureLoss.dp_fg - F_grav)
      //         = m_flow/d/A * (-A*g*height_ab*d)
      //         = -m_flow*g*height_ab
      port_b.h_outflow = inStream(port_a.h_outflow) - system.g*height_ab;
      port_a.h_outflow = inStream(port_b.h_outflow) + system.g*height_ab;

      annotation (defaultComponentName="pipe",
    Documentation(info="<html>
<p>Model of a straight pipe with constant cross section and with steady-state mass, momentum and energy balances, i.e., the model does not store mass or energy.
There exist two thermodynamic states, one at each fluid port. The momentum balance is formulated for the two states, taking into account
momentum flows, friction and gravity. The same result can be obtained by using <a href=\"modelica://Modelica_Fluid.Pipes.DynamicPipe\">DynamicPipe</a> with
steady-state dynamic settings. The intended use is to provide simple connections of vessels or other devices with storage, as it is done in:
</p>
<ul>
<li><a href=\"modelica://Modelica_Fluid.Examples.Tanks.EmptyTanks\">Examples.Tanks.EmptyTanks</a></li>
<li><a href=\"modelica://Modelica_Fluid.Examples.InverseParameterization\">Examples.InverseParameterization</a></li>
</ul>
<h4>Numerical Issues</h4>
<p>
With the stream connectors the thermodynamic states on the ports are generally defined by models with storage or by sources placed upstream and downstream of the static pipe.
Other non storage components in the flow path may yield to state transformation. Note that this generally leads to nonlinear equation systems if multiple static pipes,
or other flow models without storage, are directly connected.
</p>
</html>"));
    end StaticPipe;

    model DynamicPipe "Dynamic pipe model with storage of mass and energy"

      import Modelica_Fluid.Types.ModelStructure;

      // extending PartialStraightPipe
      extends BaseClasses.PartialStraightPipe(final port_a_exposesState=(
            modelStructure == ModelStructure.av_b) or (modelStructure ==
            ModelStructure.av_vb), final port_b_exposesState=(modelStructure
             == ModelStructure.a_vb) or (modelStructure == ModelStructure.av_vb));

      // extending PartialTwoPortFlow
      extends BaseClasses.PartialTwoPortFlow(
        final lengths=fill(length/n, n),
        final crossAreas=fill(crossArea, n),
        final dimensions=fill(4*crossArea/perimeter, n),
        final roughnesses=fill(roughness, n),
        final dheights=height_ab*dxs);

      // Wall heat transfer
      parameter Boolean use_HeatTransfer = false
        "= true to use the HeatTransfer model"
          annotation (Dialog(tab="Assumptions", group="Heat transfer"));
      replaceable model HeatTransfer =
          BaseClasses.HeatTransfer.IdealFlowHeatTransfer constrainedby
        BaseClasses.HeatTransfer.PartialFlowHeatTransfer "Wall heat transfer"
          annotation (Dialog(tab="Assumptions", group="Heat transfer",enable=use_HeatTransfer),choicesAllMatching=true);
      Modelica_Fluid_Interfaces.HeatPorts_a[nNodes] heatPorts if
                                                  use_HeatTransfer annotation (
          Placement(transformation(extent={{-10,45},{10,65}}),
            iconTransformation(extent={{-30,36},{32,52}})));

      HeatTransfer heatTransfer(
        redeclare each final package Medium = Medium,
        final n=n,
        final nParallel=nParallel,
        final surfaceAreas=perimeter*lengths,
        final lengths=lengths,
        final dimensions=dimensions,
        final roughnesses=roughnesses,
        final states=mediums.state,
        final vs = vs,
        final use_k = use_HeatTransfer) "Heat transfer model"
          annotation (Placement(transformation(extent={{-45,20},{-23,42}}, rotation=0)));
      final parameter Real[n] dxs = lengths/sum(lengths);
    equation
      Qb_flows = heatTransfer.Q_flows;
      // Wb_flow = v*A*dpdx + v*F_fric
      //         = v*A*dpdx + v*A*flowModel.dp_fg - v*A*dp_grav
      if n == 1 or useLumpedPressure then
        Wb_flows = dxs * ((vs*dxs)*(crossAreas*dxs)*((port_b.p - port_a.p) + sum(flowModel.dps_fg) - system.g*(dheights*mediums.d)))*nParallel;
      else
        if modelStructure == ModelStructure.av_vb or modelStructure == ModelStructure.av_b then
          Wb_flows[2:n-1] = {vs[i]*crossAreas[i]*((mediums[i+1].p - mediums[i-1].p)/2 + (flowModel.dps_fg[i-1]+flowModel.dps_fg[i])/2 - system.g*dheights[i]*mediums[i].d) for i in 2:n-1}*nParallel;
        else
          Wb_flows[2:n-1] = {vs[i]*crossAreas[i]*((mediums[i+1].p - mediums[i-1].p)/2 + (flowModel.dps_fg[i]+flowModel.dps_fg[i+1])/2 - system.g*dheights[i]*mediums[i].d) for i in 2:n-1}*nParallel;
        end if;
        if modelStructure == ModelStructure.av_vb then
          Wb_flows[1] = vs[1]*crossAreas[1]*((mediums[2].p - mediums[1].p)/2 + flowModel.dps_fg[1]/2 - system.g*dheights[1]*mediums[1].d)*nParallel;
          Wb_flows[n] = vs[n]*crossAreas[n]*((mediums[n].p - mediums[n-1].p)/2 + flowModel.dps_fg[n-1]/2 - system.g*dheights[n]*mediums[n].d)*nParallel;
        elseif modelStructure == ModelStructure.av_b then
          Wb_flows[1] = vs[1]*crossAreas[1]*((mediums[2].p - mediums[1].p)/2 + flowModel.dps_fg[1]/2 - system.g*dheights[1]*mediums[1].d)*nParallel;
          Wb_flows[n] = vs[n]*crossAreas[n]*((port_b.p - mediums[n-1].p)/1.5 + flowModel.dps_fg[n-1]/2+flowModel.dps_fg[n] - system.g*dheights[n]*mediums[n].d)*nParallel;
        elseif modelStructure == ModelStructure.a_vb then
          Wb_flows[1] = vs[1]*crossAreas[1]*((mediums[2].p - port_a.p)/1.5 + flowModel.dps_fg[1]+flowModel.dps_fg[2]/2 - system.g*dheights[1]*mediums[1].d)*nParallel;
          Wb_flows[n] = vs[n]*crossAreas[n]*((mediums[n].p - mediums[n-1].p)/2 + flowModel.dps_fg[n]/2 - system.g*dheights[n]*mediums[n].d)*nParallel;
        elseif modelStructure == ModelStructure.a_v_b then
          Wb_flows[1] = vs[1]*crossAreas[1]*((mediums[2].p - port_a.p)/1.5 + flowModel.dps_fg[1]+flowModel.dps_fg[2]/2 - system.g*dheights[1]*mediums[1].d)*nParallel;
          Wb_flows[n] = vs[n]*crossAreas[n]*((port_b.p - mediums[n-1].p)/1.5 + flowModel.dps_fg[n]/2+flowModel.dps_fg[n+1] - system.g*dheights[n]*mediums[n].d)*nParallel;
        else
          assert(false, "Unknown model structure");
        end if;
      end if;

      connect(heatPorts, heatTransfer.heatPorts)
        annotation (Line(points={{0,55},{0,54},{-34,54},{-34,38.7}},
                                                 color={191,0,0}));
      annotation (defaultComponentName="pipe",
    Documentation(info="<html>
<p>Model of a straight pipe with distributed mass, energy and momentum balances. It provides the complete balance equations for one-dimensional fluid flow as formulated in <a href=\"modelica://Modelica_Fluid.UsersGuide.ComponentDefinition.BalanceEquations\">UsersGuide.ComponentDefinition.BalanceEquations</a>. </p>
<p>This generic model offers a large number of combinations of possible parameter settings. In order to reduce model complexity, consider defining and/or using a tailored model for the application at hand, such as
<a href=\"modelica://Modelica_Fluid.Examples.HeatExchanger.HeatExchangerSimulation\">HeatExchanger</a>.</p>
<p>DynamicPipe treats the partial differential equations with the finite volume method and a staggered grid scheme for momentum balances. The pipe is split into nNodes equally spaced segments along the flow path. The default value is nNodes=2. This results in two lumped mass and energy balances and one lumped momentum balance across the dynamic pipe. </p>
<p>Note that this generally leads to high-index DAEs for pressure states if dynamic pipes are directly connected to each other, or generally to models with storage exposing a thermodynamic state through the port. This may not be valid if the dynamic pipe is connected to a model with non-differentiable pressure, like a Sources.Boundary_pT with prescribed jumping pressure. The <code><b>modelStructure</b></code> can be configured as appropriate in such situations, in order to place a momentum balance between a pressure state of the pipe and a non-differentiable boundary condition. </p>
<p>The default <code><b>modelStructure</b></code> is <code>av_vb</code> (see Advanced tab). The simplest possible alternative symmetric configuration, avoiding potential high-index DAEs at the cost of the potential introduction of nonlinear equation systems, is obtained with the setting <code>nNodes=1, modelStructure=a_v_b</code>. Depending on the configured model structure, the first and the last pipe segment, or the flow path length of the first and the last momentum balance, are of half size. See the documentation of the base class <a href=\"modelica://Modelica_Fluid.Pipes.BaseClasses.PartialTwoPortFlow\">Pipes.BaseClasses.PartialTwoPortFlow</a>, also covering asymmetric configurations. </p>
<p>The <code><b>HeatTransfer</b></code> component specifies the source term <code>Qb_flows</code> of the energy balance. The default component uses a constant coefficient for the heat transfer between the bulk flow and the segment boundaries exposed through the <code>heatPorts</code>. The <code>HeatTransfer</code> model is replaceable and can be exchanged with any model extended from <a href=\"modelica://Modelica_Fluid.Pipes.BaseClasses.HeatTransfer.PartialFlowHeatTransfer\">BaseClasses.HeatTransfer.PartialFlowHeatTransfer</a>. </p>
<p>The intended use is for complex networks of pipes and other flow devices, like valves. See, e.g., </p>
<ul>
<li><a href=\"modelica://Modelica_Fluid.Examples.BranchingDynamicPipes\">Examples.BranchingDynamicPipes</a>, or </li>
<li><a href=\"modelica://Modelica_Fluid.Examples.IncompressibleFluidNetwork\">Examples.IncompressibleFluidNetwork</a>.</li>
</ul>
</html>"),
    Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-100,44},{100,-44}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={0,127,255}),
            Ellipse(
              extent={{-72,10},{-52,-10}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{50,10},{70,-10}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-48,15},{46,-20}},
              lineColor={0,0,0},
              textString="%nNodes")}),
    Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,60},{100,50}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Backward),
            Rectangle(
              extent={{-100,-50},{100,-60}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Backward),
            Line(
              points={{100,45},{100,50}},
              arrow={Arrow.None,Arrow.Filled},
              color={0,0,0},
              pattern=LinePattern.Dot),
            Line(
              points={{0,45},{0,50}},
              arrow={Arrow.None,Arrow.Filled},
              color={0,0,0},
              pattern=LinePattern.Dot),
            Line(
              points={{100,-45},{100,-50}},
              arrow={Arrow.None,Arrow.Filled},
              color={0,0,0},
              pattern=LinePattern.Dot),
            Line(
              points={{0,-45},{0,-50}},
              arrow={Arrow.None,Arrow.Filled},
              color={0,0,0},
              pattern=LinePattern.Dot),
            Line(
              points={{-50,60},{-50,50}},
              smooth=Smooth.None,
              color={0,0,0},
              pattern=LinePattern.Dot),
            Line(
              points={{50,60},{50,50}},
              smooth=Smooth.None,
              color={0,0,0},
              pattern=LinePattern.Dot),
            Line(
              points={{0,-50},{0,-60}},
              smooth=Smooth.None,
              color={0,0,0},
              pattern=LinePattern.Dot)}));
    end DynamicPipe;

    package BaseClasses
      "Base classes used in the Pipes package (only of interest to build new component models)"
      extends Modelica_Icons.BasesPackage;

      partial model PartialStraightPipe "Base class for straight pipe models"
        extends Modelica_Fluid_Interfaces.PartialTwoPort;

        // Geometry

        // Note: define nParallel as Real to support inverse calculations
        parameter Real nParallel(min=1)=1 "Number of identical parallel pipes"
          annotation(Dialog(group="Geometry"));
        parameter SI.Length length "Length"
          annotation (Dialog(tab="General", group="Geometry"));
        parameter Boolean isCircular=true
          "= true if cross sectional area is circular"
          annotation (Evaluate, Dialog(tab="General", group="Geometry"));
        parameter SI.Diameter diameter "Diameter of circular pipe"
          annotation (Dialog(group="Geometry", enable=isCircular));
        parameter SI.Area crossArea=Modelica_Constants.pi*diameter*diameter/4
          "Inner cross section area" annotation (Dialog(
            tab="General",
            group="Geometry",
            enable=not isCircular));
        parameter SI.Length perimeter=Modelica_Constants.pi*diameter
          "Inner perimeter" annotation (Dialog(
            tab="General",
            group="Geometry",
            enable=not isCircular));
        parameter SI.Height roughness=2.5e-5
          "Average height of surface asperities (default: smooth steel pipe)"
          annotation (Dialog(group="Geometry"));
        final parameter SI.Volume V=crossArea*length*nParallel "volume size";

        // Static head
        parameter SI.Length height_ab=0 "Height(port_b) - Height(port_a)"
          annotation (Dialog(group="Static head"));

        // Pressure loss
        replaceable model FlowModel =
          FlowModels.DetailedPipeFlow constrainedby
          FlowModels.PartialStaggeredFlowModel
          "Wall friction, gravity, momentum flow"
            annotation(Dialog(group="Pressure loss"), choicesAllMatching=true);

      equation
        assert(length >= height_ab, "Parameter length must be greater or equal height_ab.");

        annotation (defaultComponentName="pipe",Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}}), graphics={Rectangle(
                extent={{-100,40},{100,-40}},
                fillPattern=FillPattern.Solid,
                fillColor={95,95,95},
                pattern=LinePattern.None), Rectangle(
                extent={{-100,44},{100,-44}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255})}),        Documentation(info="<html>
<p>
Base class for one dimensional flow models. It specializes a PartialTwoPort with a parameter interface and icon graphics.
</p>
</html>"));
      end PartialStraightPipe;

      partial model PartialTwoPortFlow "Base class for distributed flow models"

        import Modelica_Fluid.Types.ModelStructure;

        // extending PartialTwoPort
        extends Modelica_Fluid_Interfaces.PartialTwoPort(final
            port_a_exposesState=(modelStructure == ModelStructure.av_b) or (
              modelStructure == ModelStructure.av_vb), final
            port_b_exposesState=(modelStructure == ModelStructure.a_vb) or (
              modelStructure == ModelStructure.av_vb));

        // distributed volume model
        extends Modelica_Fluid_Interfaces.PartialDistributedVolume(final n=
              nNodes, final fluidVolumes={crossAreas[i]*lengths[i] for i in 1:n}
              *nParallel);

        // Geometry parameters
        parameter Real nParallel(min=1)=1
          "Number of identical parallel flow devices"
          annotation(Dialog(group="Geometry"));
        parameter SI.Length[n] lengths "lengths of flow segments"
          annotation (Dialog(group="Geometry"));
        parameter SI.Area[n] crossAreas "cross flow areas of flow segments"
          annotation (Dialog(group="Geometry"));
        parameter SI.Length[n] dimensions
          "hydraulic diameters of flow segments"
          annotation (Dialog(group="Geometry"));
        parameter SI.Height[n] roughnesses
          "Average heights of surface asperities"
          annotation (Dialog(group="Geometry"));

        // Static head
        parameter SI.Length[n] dheights=zeros(n)
          "Differences in heights of flow segments"
          annotation (Dialog(group="Static head"), Evaluate=true);

        // Assumptions
        parameter Types.Dynamics momentumDynamics=system.momentumDynamics
          "Formulation of momentum balances"
          annotation(Evaluate=true, Dialog(tab = "Assumptions", group="Dynamics"));

        // Initialization
        parameter Medium.MassFlowRate m_flow_start = system.m_flow_start
          "Start value for mass flow rate"
           annotation(Evaluate=true, Dialog(tab = "Initialization"));

        // Discretization
        parameter Integer nNodes(min=1)=2 "Number of discrete flow volumes"
          annotation(Dialog(tab="Advanced"),Evaluate=true);

        parameter Types.ModelStructure modelStructure=Types.ModelStructure.av_vb
          "Determines whether flow or volume models are present at the ports"
          annotation(Dialog(tab="Advanced"), Evaluate=true);

        parameter Boolean useLumpedPressure=false
          "=true to lump pressure states together"
          annotation(Dialog(tab="Advanced"),Evaluate=true);
        final parameter Integer nFM=if useLumpedPressure then nFMLumped else nFMDistributed
          "number of flow models in flowModel";
        final parameter Integer nFMDistributed=if modelStructure==Types.ModelStructure.a_v_b then n+1 else if (modelStructure==Types.ModelStructure.a_vb or modelStructure==Types.ModelStructure.av_b) then n else n-1;
        final parameter Integer nFMLumped=if modelStructure==Types.ModelStructure.a_v_b then 2 else 1;
        final parameter Integer iLumped=integer(n/2)+1
          "Index of control volume with representative state if useLumpedPressure"
          annotation(Evaluate=true);

        // Advanced model options
        parameter Boolean useInnerPortProperties=false
          "=true to take port properties for flow models from internal control volumes"
          annotation(Dialog(tab="Advanced"),Evaluate=true);
        Medium.ThermodynamicState state_a
          "state defined by volume outside port_a";
        Medium.ThermodynamicState state_b
          "state defined by volume outside port_b";
        Medium.ThermodynamicState[nFM+1] statesFM
          "state vector for flowModel model";

        // Pressure loss model
        replaceable model FlowModel =
          FlowModels.DetailedPipeFlow constrainedby
          FlowModels.PartialStaggeredFlowModel
          "Wall friction, gravity, momentum flow"
            annotation(Dialog(group="Pressure loss"), choicesAllMatching=true);
        FlowModel flowModel(
                redeclare final package Medium = Medium,
                final n=nFM+1,
                final states=statesFM,
                final vs=vsFM,
                final momentumDynamics=momentumDynamics,
                final allowFlowReversal=allowFlowReversal,
                final p_a_start=p_a_start,
                final p_b_start=p_b_start,
                final m_flow_start=m_flow_start,
                final nParallel=nParallel,
                final pathLengths=pathLengths,
                final crossAreas=crossAreasFM,
                final dimensions=dimensionsFM,
                final roughnesses=roughnessesFM,
                final dheights=dheightsFM,
                final g=system.g) "Flow model"
           annotation (Placement(transformation(extent={{-77,-37},{75,-19}},rotation=0)));

        // Flow quantities
        Medium.MassFlowRate[n+1] m_flows(
           each min=if allowFlowReversal then -Modelica_Constants.inf else 0,
           each start=m_flow_start)
          "Mass flow rates of fluid across segment boundaries";
        Medium.MassFlowRate[n+1, Medium.nXi] mXi_flows
          "Independent mass flow rates across segment boundaries";
        Medium.MassFlowRate[n+1, Medium.nC] mC_flows
          "Trace substance mass flow rates across segment boundaries";
        Medium.EnthalpyFlowRate[n+1] H_flows
          "Enthalpy flow rates of fluid across segment boundaries";

        SI.Velocity[n] vs={0.5*(m_flows[i] + m_flows[i + 1])/mediums[i].d/
            crossAreas[i] for i in 1:n}/nParallel
          "mean velocities in flow segments";

        // Model structure dependent flow geometry
      protected
        SI.Length[nFM] pathLengths "Lengths along flow path";
        SI.Length[nFM] dheightsFM
          "Differences in heights between flow segments";
        SI.Area[nFM + 1] crossAreasFM "Cross flow areas of flow segments";
        SI.Velocity[nFM + 1] vsFM "Mean velocities in flow segments";
        SI.Length[nFM + 1] dimensionsFM "Hydraulic diameters of flow segments";
        SI.Height[nFM + 1] roughnessesFM
          "Average heights of surface asperities";

      equation
        assert(nNodes > 1 or modelStructure <> ModelStructure.av_vb,
           "nNodes needs to be at least 2 for modelStructure av_vb, as flow model disappears otherwise!");
        // staggered grid discretization of geometry for flowModel, depending on modelStructure
        if useLumpedPressure then
          if modelStructure <> ModelStructure.a_v_b then
            pathLengths[1] = sum(lengths);
            dheightsFM[1] = sum(dheights);
            if n == 1 then
              crossAreasFM[1:2] = {crossAreas[1], crossAreas[1]};
              dimensionsFM[1:2] = {dimensions[1], dimensions[1]};
              roughnessesFM[1:2] = {roughnesses[1], roughnesses[1]};
            else // n > 1
              crossAreasFM[1:2] = {sum(crossAreas[1:iLumped-1])/(iLumped-1), sum(crossAreas[iLumped:n])/(n-iLumped+1)};
              dimensionsFM[1:2] = {sum(dimensions[1:iLumped-1])/(iLumped-1), sum(dimensions[iLumped:n])/(n-iLumped+1)};
              roughnessesFM[1:2] = {sum(roughnesses[1:iLumped-1])/(iLumped-1), sum(roughnesses[iLumped:n])/(n-iLumped+1)};
            end if;
          else
            if n == 1 then
              pathLengths[1:2] = {lengths[1]/2, lengths[1]/2};
              dheightsFM[1:2] = {dheights[1]/2, dheights[1]/2};
              crossAreasFM[1:3] = {crossAreas[1], crossAreas[1], crossAreas[1]};
              dimensionsFM[1:3] = {dimensions[1], dimensions[1], dimensions[1]};
              roughnessesFM[1:3] = {roughnesses[1], roughnesses[1], roughnesses[1]};
            else // n > 1
              pathLengths[1:2] = {sum(lengths[1:iLumped-1]), sum(lengths[iLumped:n])};
              dheightsFM[1:2] = {sum(dheights[1:iLumped-1]), sum(dheights[iLumped:n])};
              crossAreasFM[1:3] = {sum(crossAreas[1:iLumped-1])/(iLumped-1), sum(crossAreas)/n, sum(crossAreas[iLumped:n])/(n-iLumped+1)};
              dimensionsFM[1:3] = {sum(dimensions[1:iLumped-1])/(iLumped-1), sum(dimensions)/n, sum(dimensions[iLumped:n])/(n-iLumped+1)};
              roughnessesFM[1:3] = {sum(roughnesses[1:iLumped-1])/(iLumped-1), sum(roughnesses)/n, sum(roughnesses[iLumped:n])/(n-iLumped+1)};
            end if;
          end if;
        else
          if modelStructure == ModelStructure.av_vb then
            //nFM = n-1
            if n == 2 then
              pathLengths[1] = lengths[1] + lengths[2];
              dheightsFM[1] = dheights[1] + dheights[2];
            else
              pathLengths[1:n-1] = cat(1, {lengths[1] + 0.5*lengths[2]}, 0.5*(lengths[2:n-2] + lengths[3:n-1]), {0.5*lengths[n-1] + lengths[n]});
              dheightsFM[1:n-1] = cat(1, {dheights[1] + 0.5*dheights[2]}, 0.5*(dheights[2:n-2] + dheights[3:n-1]), {0.5*dheights[n-1] + dheights[n]});
            end if;
            crossAreasFM[1:n] = crossAreas;
            dimensionsFM[1:n] = dimensions;
            roughnessesFM[1:n] = roughnesses;
          elseif modelStructure == ModelStructure.av_b then
            //nFM = n
            pathLengths[1:n] = lengths;
            dheightsFM[1:n] = dheights;
            crossAreasFM[1:n+1] = cat(1, crossAreas[1:n], {crossAreas[n]});
            dimensionsFM[1:n+1] = cat(1, dimensions[1:n], {dimensions[n]});
            roughnessesFM[1:n+1] = cat(1, roughnesses[1:n], {roughnesses[n]});
          elseif modelStructure == ModelStructure.a_vb then
            //nFM = n
            pathLengths[1:n] = lengths;
            dheightsFM[1:n] = dheights;
            crossAreasFM[1:n+1] = cat(1, {crossAreas[1]}, crossAreas[1:n]);
            dimensionsFM[1:n+1] = cat(1, {dimensions[1]}, dimensions[1:n]);
            roughnessesFM[1:n+1] = cat(1, {roughnesses[1]}, roughnesses[1:n]);
          elseif modelStructure == ModelStructure.a_v_b then
            //nFM = n+1;
            pathLengths[1:n+1] = cat(1, {0.5*lengths[1]}, 0.5*(lengths[1:n-1] + lengths[2:n]), {0.5*lengths[n]});
            dheightsFM[1:n+1] = cat(1, {0.5*dheights[1]}, 0.5*(dheights[1:n-1] + dheights[2:n]), {0.5*dheights[n]});
            crossAreasFM[1:n+2] = cat(1, {crossAreas[1]}, crossAreas[1:n], {crossAreas[n]});
            dimensionsFM[1:n+2] = cat(1, {dimensions[1]}, dimensions[1:n], {dimensions[n]});
            roughnessesFM[1:n+2] = cat(1, {roughnesses[1]}, roughnesses[1:n], {roughnesses[n]});
          else
            assert(false, "Unknown model structure");
          end if;
        end if;

        // Source/sink terms for mass and energy balances
        for i in 1:n loop
          mb_flows[i] = m_flows[i] - m_flows[i + 1];
          mbXi_flows[i, :] = mXi_flows[i, :] - mXi_flows[i + 1, :];
          mbC_flows[i, :]  = mC_flows[i, :]  - mC_flows[i + 1, :];
          Hb_flows[i] = H_flows[i] - H_flows[i + 1];
        end for;

        // Distributed flow quantities, upwind discretization
        for i in 2:n loop
          H_flows[i] = semiLinear(m_flows[i], mediums[i - 1].h, mediums[i].h);
          mXi_flows[i, :] = semiLinear(m_flows[i], mediums[i - 1].Xi, mediums[i].Xi);
          mC_flows[i, :]  = semiLinear(m_flows[i], Cs[i - 1, :],         Cs[i, :]);
        end for;
        H_flows[1] = semiLinear(port_a.m_flow, inStream(port_a.h_outflow), mediums[1].h);
        H_flows[n + 1] = -semiLinear(port_b.m_flow, inStream(port_b.h_outflow), mediums[n].h);
        mXi_flows[1, :] = semiLinear(port_a.m_flow, inStream(port_a.Xi_outflow), mediums[1].Xi);
        mXi_flows[n + 1, :] = -semiLinear(port_b.m_flow, inStream(port_b.Xi_outflow), mediums[n].Xi);
        mC_flows[1, :] = semiLinear(port_a.m_flow, inStream(port_a.C_outflow), Cs[1, :]);
        mC_flows[n + 1, :] = -semiLinear(port_b.m_flow, inStream(port_b.C_outflow), Cs[n, :]);

        // Boundary conditions
        port_a.m_flow    = m_flows[1];
        port_b.m_flow    = -m_flows[n + 1];
        port_a.h_outflow = mediums[1].h;
        port_b.h_outflow = mediums[n].h;
        port_a.Xi_outflow = mediums[1].Xi;
        port_b.Xi_outflow = mediums[n].Xi;
        port_a.C_outflow = Cs[1, :];
        port_b.C_outflow = Cs[n, :];
        // The two equations below are not correct if C is stored in volumes.
        // C should be treated the same way as Xi.
        //port_a.C_outflow = inStream(port_b.C_outflow);
        //port_b.C_outflow = inStream(port_a.C_outflow);

        if useInnerPortProperties and n > 0 then
          state_a = Medium.setState_phX(port_a.p, mediums[1].h, mediums[1].Xi);
          state_b = Medium.setState_phX(port_b.p, mediums[n].h, mediums[n].Xi);
        else
          state_a = Medium.setState_phX(port_a.p, inStream(port_a.h_outflow), inStream(port_a.Xi_outflow));
          state_b = Medium.setState_phX(port_b.p, inStream(port_b.h_outflow), inStream(port_b.Xi_outflow));
        end if;

        // staggered grid discretization for flowModel, depending on modelStructure
        if useLumpedPressure then
          if modelStructure <> ModelStructure.av_vb then
            // all pressures are equal
            fill(mediums[1].p, n-1) = mediums[2:n].p;
          elseif n > 2 then
            // need two pressures
            fill(mediums[1].p, iLumped-2) = mediums[2:iLumped-1].p;
            fill(mediums[n].p, n-iLumped) = mediums[iLumped:n-1].p;
          end if;
          if modelStructure == ModelStructure.av_vb then
            port_a.p = mediums[1].p;
            statesFM[1] = mediums[1].state;
            m_flows[iLumped] = flowModel.m_flows[1];
            statesFM[2] = mediums[n].state;
            port_b.p = mediums[n].p;
            vsFM[1] = vs[1:iLumped-1]*lengths[1:iLumped-1]/sum(lengths[1:iLumped-1]);
            vsFM[2] = vs[iLumped:n]*lengths[iLumped:n]/sum(lengths[iLumped:n]);
          elseif modelStructure == ModelStructure.av_b then
            port_a.p = mediums[1].p;
            statesFM[1] = mediums[iLumped].state;
            statesFM[2] = state_b;
            m_flows[n+1] = flowModel.m_flows[1];
            vsFM[1] = vs*lengths/sum(lengths);
            vsFM[2] = m_flows[n+1]/Medium.density(state_b)/crossAreas[n]/nParallel;
          elseif modelStructure == ModelStructure.a_vb then
            m_flows[1] = flowModel.m_flows[1];
            statesFM[1] = state_a;
            statesFM[2] = mediums[iLumped].state;
            port_b.p = mediums[n].p;
            vsFM[1] = m_flows[1]/Medium.density(state_a)/crossAreas[1]/nParallel;
            vsFM[2] = vs*lengths/sum(lengths);
          elseif modelStructure == ModelStructure.a_v_b then
            m_flows[1] = flowModel.m_flows[1];
            statesFM[1] = state_a;
            statesFM[2] = mediums[iLumped].state;
            statesFM[3] = state_b;
            m_flows[n+1] = flowModel.m_flows[2];
            vsFM[1] = m_flows[1]/Medium.density(state_a)/crossAreas[1]/nParallel;
            vsFM[2] = vs*lengths/sum(lengths);
            vsFM[3] = m_flows[n+1]/Medium.density(state_b)/crossAreas[n]/nParallel;
          else
            assert(false, "Unknown model structure");
          end if;
        else
          if modelStructure == ModelStructure.av_vb then
            //nFM = n-1
            statesFM[1:n] = mediums[1:n].state;
            m_flows[2:n] = flowModel.m_flows[1:n-1];
            vsFM[1:n] = vs;
            port_a.p = mediums[1].p;
            port_b.p = mediums[n].p;
          elseif modelStructure == ModelStructure.av_b then
            //nFM = n
            statesFM[1:n] = mediums[1:n].state;
            statesFM[n+1] = state_b;
            m_flows[2:n+1] = flowModel.m_flows[1:n];
            vsFM[1:n] = vs;
            vsFM[n+1] = m_flows[n+1]/Medium.density(state_b)/crossAreas[n]/nParallel;
            port_a.p = mediums[1].p;
          elseif modelStructure == ModelStructure.a_vb then
            //nFM = n
            statesFM[1] = state_a;
            statesFM[2:n+1] = mediums[1:n].state;
            m_flows[1:n] = flowModel.m_flows[1:n];
            vsFM[1] = m_flows[1]/Medium.density(state_a)/crossAreas[1]/nParallel;
            vsFM[2:n+1] = vs;
            port_b.p = mediums[n].p;
          elseif modelStructure == ModelStructure.a_v_b then
            //nFM = n+1
            statesFM[1] = state_a;
            statesFM[2:n+1] = mediums[1:n].state;
            statesFM[n+2] = state_b;
            m_flows[1:n+1] = flowModel.m_flows[1:n+1];
            vsFM[1] = m_flows[1]/Medium.density(state_a)/crossAreas[1]/nParallel;
            vsFM[2:n+1] = vs;
            vsFM[n+2] = m_flows[n+1]/Medium.density(state_b)/crossAreas[n]/nParallel;
          else
            assert(false, "Unknown model structure");
          end if;
        end if;

        annotation (defaultComponentName="pipe",
      Documentation(info="<html>
<p>Base class for distributed flow models. The total volume is split into nNodes segments along the flow path.
The default value is nNodes=2.
</p>
<h4>Mass and Energy balances</h4>
<p>
The mass and energy balances are inherited from <a href=\"modelica://Modelica_Fluid.Interfaces.PartialDistributedVolume\">Interfaces.PartialDistributedVolume</a>.
One total mass and one energy balance is formed across each segment according to the finite volume approach.
Substance mass balances are added if the medium contains more than one component.
</p>
<p>
An extending model needs to define the geometry and the difference in heights between the flow segments (static head).
Moreover it needs to define two vectors of source terms for the distributed energy balance:
</p>
<ul>
<li><code><b>Qb_flows[nNodes]</b></code>, the heat flow source terms, e.g., conductive heat flows across segment boundaries, and</li>
<li><code><b>Wb_flows[nNodes]</b></code>, the work source terms.</li>
</ul>

<h4>Momentum balance</h4>
<p>
The momentum balance is determined by the <b><code>FlowModel</code></b> component, which can be replaced with any model extended from
<a href=\"modelica://Modelica_Fluid.Pipes.BaseClasses.FlowModels.PartialStaggeredFlowModel\">BaseClasses.FlowModels.PartialStaggeredFlowModel</a>.
The default setting is <a href=\"modelica://Modelica_Fluid.Pipes.BaseClasses.FlowModels.DetailedPipeFlow\">DetailedPipeFlow</a>.
</p>
<p>
This considers
</p>
<ul>
<li>pressure drop due to friction and other dissipative losses, and</li>
<li>gravity effects for non-horizontal devices.</li>
<li>variation of flow velocity along the flow path,
which occur due to changes in the cross sectional area or the fluid density, provided that <code>flowModel.use_Ib_flows</code> is true.
</ul>

<h4>Model Structure</h4>
<p>
The momentum balances are formulated across the segment boundaries along the flow path according to the staggered grid approach.
The configurable <b><code>modelStructure</code></b> determines the formulation of the boundary conditions at <code>port_a</code> and <code>port_b</code>.
The options include (default: av_vb):
</p>
<ul>
<li><code>av_vb</code>: Symmetric setting with nNodes-1 momentum balances between nNodes flow segments.
    The ports <code>port_a</code> and <code>port_b</code> expose the first and the last thermodynamic state, respectively.
    Connecting two or more flow devices therefore may result in high-index DAEs for the pressures of connected flow segments.
<li><code>a_v_b</code>: Alternative symmetric setting with nNodes+1 momentum balances across nNodes flow segments.
    Half momentum balances are placed between <code>port_a</code> and the first flow segment as well as between the last flow segment and <code>port_b</code>.
    Connecting two or more flow devices therefore results in algebraic pressures at the ports.
    The specification of good start values for the port pressures is essential for the solution of large nonlinear equation systems.</li>
<li><code>av_b</code>: Asymmetric setting with nNodes momentum balances, one between nth volume and <code>port_b</code>, potential pressure state at <code>port_a</code></li>
<li><code>a_vb</code>: Asymmetric setting with nNodes momentum balance, one between first volume and <code>port_a</code>, potential pressure state at <code>port_b</code></li>
</ul>
<p>
When connecting two components, e.g., two pipes, the momentum balance across the connection point reduces to
</p>
<pre>pipe1.port_b.p = pipe2.port_a.p</pre>
<p>
This is only true if the flow velocity remains the same on each side of the connection.
Consider using a fitting for any significant change in diameter or fluid density, if the resulting effects,
such as change in kinetic energy, cannot be neglected.
This also allows for taking into account friction losses with respect to the actual geometry of the connection point.
</p>
</html>", revisions="<html>
<ul>
<li><i>5 Dec 2008</i>
    by Michael Wetter:<br>
       Modified mass balance for trace substances. With the new formulation, the trace substances masses <code>mC</code> are stored
       in the same way as the species <code>mXi</code>.</li>
<li><i>Dec 2008</i>
    by R&uuml;diger Franke:<br>
       Derived model from original DistributedPipe models
    <ul>
    <li>moved mass and energy balances to PartialDistributedVolume</li>
    <li>introduced replaceable pressure loss models</li>
    <li>combined all model structures and lumped pressure into one model</li>
    <li>new ModelStructure av_vb, replacing former avb</li>
    </ul></li>
<li><i>04 Mar 2006</i>
    by Katrin Pr&ouml;l&szlig;:<br>
       Model added to the Fluid library</li>
</ul>
</html>"),
      Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={Ellipse(
                extent={{-72,10},{-52,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid), Ellipse(
                extent={{50,10},{70,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}),
      Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                  100,100}}), graphics={
              Polygon(
                points={{-100,-50},{-100,50},{100,60},{100,-60},{-100,-50}},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Polygon(
                points={{-34,-53},{-34,53},{34,57},{34,-57},{-34,-53}},
                smooth=Smooth.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Line(
                points={{-100,-50},{-100,50}},
                arrow={Arrow.Filled,Arrow.Filled},
                color={0,0,0},
                pattern=LinePattern.Dot),
              Text(
                extent={{-99,36},{-69,30}},
                lineColor={0,0,255},
                textString="crossAreas[1]",
                pattern=LinePattern.None),
              Line(
                points={{-100,70},{-34,70}},
                arrow={Arrow.Filled,Arrow.Filled},
                color={0,0,0},
                pattern=LinePattern.Dot),
              Text(
                extent={{0,36},{40,30}},
                lineColor={0,0,255},
                textString="crossAreas[2:n-1]",
                pattern=LinePattern.None),
              Line(
                points={{100,-60},{100,60}},
                arrow={Arrow.Filled,Arrow.Filled},
                color={0,0,0},
                pattern=LinePattern.Dot),
              Text(
                extent={{100.5,36},{130.5,30}},
                lineColor={0,0,255},
                textString="crossAreas[n]",
                pattern=LinePattern.None),
              Line(
                points={{-34,52},{-34,-53}},
                smooth=Smooth.None,
                color={0,0,0},
                pattern=LinePattern.Dash),
              Line(
                points={{34,57},{34,-57}},
                smooth=Smooth.None,
                color={0,0,0},
                pattern=LinePattern.Dash),
              Line(
                points={{34,70},{100,70}},
                arrow={Arrow.Filled,Arrow.Filled},
                color={0,0,0},
                pattern=LinePattern.Dot),
              Line(
                points={{-34,70},{34,70}},
                arrow={Arrow.Filled,Arrow.Filled},
                color={0,0,0},
                pattern=LinePattern.Dot),
              Text(
                extent={{-30,77},{30,71}},
                lineColor={0,0,255},
                textString="lengths[2:n-1]",
                pattern=LinePattern.None),
              Line(
                points={{-100,-70},{0,-70}},
                arrow={Arrow.None,Arrow.Filled},
                color={0,0,0}),
              Text(
                extent={{-80,-63},{-20,-69}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="flowModel.dps_fg[1]"),
              Line(
                points={{0,-70},{100,-70}},
                arrow={Arrow.None,Arrow.Filled},
                color={0,0,0}),
              Text(
                extent={{20.5,-63},{80,-69}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="flowModel.dps_fg[2:n-1]"),
              Line(
                points={{-95,0},{-5,0}},
                arrow={Arrow.None,Arrow.Filled},
                color={0,0,0}),
              Text(
                extent={{-62,7},{-32,1}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="m_flows[2]"),
              Line(
                points={{5,0},{95,0}},
                arrow={Arrow.None,Arrow.Filled},
                color={0,0,0}),
              Text(
                extent={{34,7},{64,1}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="m_flows[3:n]"),
              Line(
                points={{-150,0},{-105,0}},
                arrow={Arrow.None,Arrow.Filled},
                color={0,0,0}),
              Line(
                points={{105,0},{150,0}},
                arrow={Arrow.None,Arrow.Filled},
                color={0,0,0}),
              Text(
                extent={{-140,7},{-110,1}},
                lineColor={0,0,255},
                textString="m_flows[1]",
                pattern=LinePattern.None),
              Text(
                extent={{111,7},{141,1}},
                lineColor={0,0,255},
                textString="m_flows[n+1]",
                pattern=LinePattern.None),
              Text(
                extent={{35,-92},{100,-98}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="(ModelStructure av_vb, n=3)"),
              Line(
                points={{-100,-50},{-100,-86}},
                smooth=Smooth.None,
                color={0,0,0},
                pattern=LinePattern.Dot),
              Line(
                points={{0,-55},{0,-86}},
                smooth=Smooth.None,
                color={0,0,0},
                pattern=LinePattern.Dot),
              Line(
                points={{100,-60},{100,-86}},
                smooth=Smooth.None,
                color={0,0,0},
                pattern=LinePattern.Dot),
              Ellipse(
                extent={{-5,5},{5,-5}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{3,-4},{33,-10}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="states[2:n-1]"),
              Ellipse(
                extent={{95,5},{105,-5}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{104,-4},{124,-10}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="states[n]"),
              Ellipse(
                extent={{-105,5},{-95,-5}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-96,-4},{-76,-10}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="states[1]"),
              Text(
                extent={{-99.5,30},{-69.5,24}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="dimensions[1]"),
              Text(
                extent={{-0.5,30},{40,24}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="dimensions[2:n-1]"),
              Text(
                extent={{100.5,30},{130.5,24}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="dimensions[n]"),
              Line(
                points={{-34,73},{-34,52}},
                smooth=Smooth.None,
                color={0,0,0},
                pattern=LinePattern.Dot),
              Line(
                points={{34,73},{34,57}},
                smooth=Smooth.None,
                color={0,0,0},
                pattern=LinePattern.Dot),
              Line(
                points={{-100,50},{100,60}},
                smooth=Smooth.None,
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-100,-50},{100,-60}},
                smooth=Smooth.None,
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-100,73},{-100,50}},
                smooth=Smooth.None,
                color={0,0,0},
                pattern=LinePattern.Dot),
              Line(
                points={{100,73},{100,60}},
                smooth=Smooth.None,
                color={0,0,0},
                pattern=LinePattern.Dot),
              Line(
                points={{0,-55},{0,55}},
                arrow={Arrow.Filled,Arrow.Filled},
                color={0,0,0},
                pattern=LinePattern.Dot),
              Line(
                points={{-34,11},{34,11}},
                arrow={Arrow.None,Arrow.Filled},
                color={0,0,0}),
              Text(
                extent={{5,18},{25,12}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="vs[2:n-1]"),
              Text(
                extent={{-72,18},{-62,12}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="vs[1]"),
              Line(
                points={{-100,11},{-34,11}},
                arrow={Arrow.None,Arrow.Filled},
                color={0,0,0}),
              Text(
                extent={{63,18},{73,12}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="vs[n]"),
              Line(
                points={{34,11},{100,11}},
                arrow={Arrow.None,Arrow.Filled},
                color={0,0,0}),
              Text(
                extent={{-80,-75},{-20,-81}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="flowModel.pathLengths[1]"),
              Line(
                points={{-100,-82},{0,-82}},
                arrow={Arrow.Filled,Arrow.Filled},
                color={0,0,0}),
              Line(
                points={{0,-82},{100,-82}},
                arrow={Arrow.Filled,Arrow.Filled},
                color={0,0,0}),
              Text(
                extent={{15,-75},{85,-81}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="flowModel.pathLengths[2:n-1]"),
              Text(
                extent={{-100,77},{-37,71}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="lengths[1]"),
              Text(
                extent={{34,77},{100,71}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                textString="lengths[n]")}));
      end PartialTwoPortFlow;

      package FlowModels
        "Flow models for pipes, including wall friction, static head and momentum flow"
        extends Modelica_Icons.Package;
            partial model PartialStaggeredFlowModel
          "Base class for momentum balances in flow models"

              //
              // Internal interface
              // (not exposed to GUI; needs to be hard coded when using this model
              //
              replaceable package Medium =
                Modelica_Media_Interfaces.PartialMedium
            "Medium in the component"
                  annotation(Dialog(tab="Internal Interface",enable=false));

              parameter Integer n=2 "Number of discrete flow volumes"
                annotation(Dialog(tab="Internal Interface",enable=false));

              // Inputs
              input Medium.ThermodynamicState[n] states
            "Thermodynamic states along design flow";
              input SI.Velocity[n] vs "Mean velocities of fluid flow";

              // Geometry parameters and inputs
              parameter Real nParallel
            "number of identical parallel flow devices"
                 annotation(Dialog(tab="Internal Interface",enable=false,group="Geometry"));

          input SI.Area[n] crossAreas "Cross flow areas at segment boundaries";
          input SI.Length[n] dimensions
            "Characteristic dimensions for fluid flow (diameters for pipe flow)";
          input SI.Height[n] roughnesses "Average height of surface asperities";

              // Static head
          input SI.Length[n - 1] dheights
            "Height(states[2:n]) - Height(states[1:n-1])";

          parameter SI.Acceleration g=system.g "Constant gravity acceleration"
            annotation (Dialog(
              tab="Internal Interface",
              enable=false,
              group="Static head"));

              // Assumptions
              parameter Boolean allowFlowReversal=system.allowFlowReversal
            "= true to allow flow reversal, false restricts to design direction (states[1] -> states[n+1])"
                annotation(Dialog(tab="Internal Interface",enable=false,group="Assumptions"), Evaluate=true);
              parameter Types.Dynamics momentumDynamics=system.momentumDynamics
            "Formulation of momentum balance" annotation (Dialog(
              tab="Internal Interface",
              enable=false,
              group="Assumptions"), Evaluate=true);

              // Initialization
              parameter Medium.MassFlowRate m_flow_start=system.m_flow_start
            "Start value of mass flow rates"
                annotation(Dialog(tab="Internal Interface",enable=false,group = "Initialization"));
              parameter Medium.AbsolutePressure p_a_start
            "Start value for p[1] at design inflow"
                annotation(Dialog(tab="Internal Interface",enable=false,group = "Initialization"));
              parameter Medium.AbsolutePressure p_b_start
            "Start value for p[n+1] at design outflow"
                annotation(Dialog(tab="Internal Interface",enable=false,group = "Initialization"));

              //
              // Implementation of momentum balance
              //
              extends Modelica_Fluid_Interfaces.PartialDistributedFlow(final m=
                n - 1);

              // Advanced parameters
              parameter Boolean useUpstreamScheme = true
            "= false to average upstream and downstream properties across flow segments"
                 annotation(Dialog(group="Advanced"), Evaluate=true);

              parameter Boolean use_Ib_flows = momentumDynamics <> Types.Dynamics.SteadyState
            "= true to consider differences in flow of momentum through boundaries"
                 annotation(Dialog(group="Advanced"), Evaluate=true);

              // Variables
              Medium.Density[n] rhos = if use_rho_nominal then fill(rho_nominal, n) else Medium.density(states);
              Medium.Density[n-1] rhos_act "Actual density per segment";

              Medium.DynamicViscosity[n] mus = if use_mu_nominal then fill(mu_nominal, n) else Medium.dynamicViscosity(states);
              Medium.DynamicViscosity[n-1] mus_act
            "Actual viscosity per segment";

              // Variables
              SI.Pressure[n - 1] dps_fg(each start=(p_a_start - p_b_start)/(n
                 - 1)) "pressure drop between states";

              // Reynolds Number
          parameter SI.ReynoldsNumber Re_turbulent=4000
            "Start of turbulent regime, depending on type of flow device";
              parameter Boolean show_Res = false
            "= true, if Reynolds numbers are included for plotting"
                 annotation (Evaluate=true, Dialog(group="Diagnostics"));
          SI.ReynoldsNumber[n] Res=CharacteristicNumbers.ReynoldsNumber(
                          vs,
                          rhos,
                          mus,
                          dimensions) if show_Res "Reynolds numbers";
              Medium.MassFlowRate[n-1] m_flows_turbulent=
                  {nParallel*(Modelica_Constants.pi/4)*0.5*(dimensions[i] + dimensions[i+1])*mus_act[i]*Re_turbulent for i in 1:n-1} if
                     show_Res "Start of turbulent flow";
        protected
              parameter Boolean use_rho_nominal = false
            "= true, if rho_nominal is used, otherwise computed from medium"
                 annotation(Dialog(group="Advanced"), Evaluate=true);
          parameter SI.Density rho_nominal=Medium.density_pTX(
                          Medium.p_default,
                          Medium.T_default,
                          Medium.X_default)
            "Nominal density (e.g., rho_liquidWater = 995, rho_air = 1.2)"
            annotation (Dialog(group="Advanced", enable=use_rho_nominal));

              parameter Boolean use_mu_nominal = false
            "= true, if mu_nominal is used, otherwise computed from medium"
                 annotation(Dialog(group="Advanced"), Evaluate=true);
          parameter SI.DynamicViscosity mu_nominal=Medium.dynamicViscosity(
              Medium.setState_pTX(
                          Medium.p_default,
                          Medium.T_default,
                          Medium.X_default))
            "Nominal dynamic viscosity (e.g., mu_liquidWater = 1e-3, mu_air = 1.8e-5)"
            annotation (Dialog(group="Advanced", enable=use_mu_nominal));

            equation
              if not allowFlowReversal then
                rhos_act = rhos[1:n-1];
                mus_act = mus[1:n-1];
              elseif not useUpstreamScheme then
                rhos_act = 0.5*(rhos[1:n-1] + rhos[2:n]);
                mus_act = 0.5*(mus[1:n-1] + mus[2:n]);
              else
                for i in 1:n-1 loop
                  rhos_act[i] = noEvent(if m_flows[i] > 0 then rhos[i] else rhos[i+1]);
                  mus_act[i] = noEvent(if m_flows[i] > 0 then mus[i] else mus[i+1]);
                end for;
              end if;

              if use_Ib_flows then
                Ib_flows = nParallel*{rhos[i]*vs[i]*vs[i]*crossAreas[i] - rhos[i+1]*vs[i+1]*vs[i+1]*crossAreas[i+1] for i in 1:n-1};
                // alternatively use densities rhos_act of actual streams, together with mass flow rates,
                // not conserving momentum if fluid density changes between flow segments:
                //Ib_flows = {((rhos[i]*vs[i])^2*crossAreas[i] - (rhos[i+1]*vs[i+1])^2*crossAreas[i+1])/rhos_act[i] for i in 1:n-1};
              else
                Ib_flows = zeros(n-1);
              end if;

              Fs_p = nParallel*{0.5*(crossAreas[i]+crossAreas[i+1])*(Medium.pressure(states[i+1])-Medium.pressure(states[i])) for i in 1:n-1};

              // Note: the equation is written for dps_fg instead of Fs_fg to help the translator
              dps_fg = {Fs_fg[i]/nParallel*2/(crossAreas[i]+crossAreas[i+1]) for i in 1:n-1};

              annotation (Documentation(info="<html>
<p>
This partial model defines a common interface for <code>m=n-1</code> flow models between <code>n</code> device segments.
The flow models provide a steady-state or dynamic momentum balance using an upwind discretization scheme per default.
Extending models must add pressure loss terms for friction and gravity.
</p>
<p>
The fluid is specified in the interface with the thermodynamic <code>states[n]</code> for a given <code>Medium</code> model.
The geometry is specified with the <code>pathLengths[n-1]</code> between the device segments as well as
with the <code>crossAreas[n]</code> and the <code>roughnesses[n]</code> of the device segments.
Moreover the fluid flow is characterized for different types of devices by the characteristic <code>dimensions[n]</code>
and the average velocities <code>vs[n]</code> of fluid flow in the device segments.
See <a href=\"modelica://Modelica_Fluid.Pipes.BaseClasses.CharacteristicNumbers.ReynoldsNumber\">Pipes.BaseClasses.CharacteristicNumbers.ReynoldsNumber</a>
for example definitions.
</p>
<p>
The parameter <code>Re_turbulent</code> can be specified for the least mass flow rate of the turbulent regime.
It defaults to 4000, which is appropriate for pipe flow.
The <code>m_flows_turbulent[n-1]</code> resulting from <code>Re_turbulent</code> can optionally be calculated together with the Reynolds numbers
<code>Res[n]</code> of the device segments (<code>show_Res=true</code>).
</p>
<p>
Using the thermodynamic states[n] of the device segments, the densities rhos[n] and the dynamic viscosities mus[n]
of the segments as well as the actual densities rhos_act[n-1] and the actual viscosities mus_act[n-1] of the flows are predefined
in this base model. Note that no events are raised on flow reversal. This needs to be treated by an extending model,
e.g., with numerical smoothing or by raising events as appropriate.
</p>
</html>"),       Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={Line(
                  points={{-80,-50},{-80,50},{80,-50},{80,50}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  thickness=1), Text(
                  extent={{-40,-50},{40,-90}},
                  lineColor={0,0,0},
                  textString="%name")}));
            end PartialStaggeredFlowModel;

        model NominalLaminarFlow
          "NominalLaminarFlow: Linear pressure loss for nominal values"
          extends PartialStaggeredFlowModel(use_mu_nominal=not show_Res);

          // Operational conditions
          parameter SI.AbsolutePressure dp_nominal "Nominal pressure loss";
          parameter SI.MassFlowRate m_flow_nominal
            "Mass flow rate for dp_nominal";

          // Inverse parameterization assuming pipe flow and WallFriction.Laminar
          // Laminar.massFlowRate_dp:
          //   m_flow = dp*pi*diameter^4*d/(128*length*mu);
          SI.Length[n - 1] pathLengths_nominal={(dp_nominal/(n - 1) - g*
              dheights[i])*Modelica_Constants.pi*((dimensions[i] + dimensions[i
               + 1])/2)^4*rhos_act[i]/(128*mus_act[i])/(m_flow_nominal/
              nParallel) for i in 1:n - 1} if show_Res;

        equation
          // linear pressure loss
          if  not allowFlowReversal or use_rho_nominal or not useUpstreamScheme then
            dps_fg = {g*dheights[i]*rhos_act[i] for i in 1:n-1} + dp_nominal/(n-1)/m_flow_nominal*m_flows;
          else
            dps_fg = {g*dheights[i]*(if m_flows[i] > 0 then rhos[i] else rhos[i+1]) for i in 1:n-1} + dp_nominal/(n-1)/m_flow_nominal*m_flows;
          end if;

          annotation (Documentation(info="<html>
<p>
This model defines a simple linear pressure loss assuming laminar flow for
specified <code>dp_nominal</code> and <code>m_flow_nominal</code>.
</p>
<p>
Select <code>show_Res = true</code> to analyze the actual flow and the lengths of a pipe that would fulfill the
specified nominal values for given geometry parameters <code>crossAreas</code>, <code>dimensions</code> and <code>roughnesses</code>.
</p>
</html>"));
        end NominalLaminarFlow;

            partial model PartialGenericPipeFlow
          "GenericPipeFlow: Pipe flow pressure loss and gravity with replaceable WallFriction package"
          import Modelica_Fluid;

              parameter Boolean from_dp = momentumDynamics >= Types.Dynamics.SteadyStateInitial
            "= true, use m_flow = f(dp), otherwise dp = f(m_flow)"
                annotation (Dialog(group="Advanced"), Evaluate=true);

              extends PartialStaggeredFlowModel(final Re_turbulent=4000);

              replaceable package WallFriction =
                Modelica_Fluid.Pipes.BaseClasses.WallFriction.Detailed
            constrainedby
            Modelica_Fluid.Pipes.BaseClasses.WallFriction.PartialWallFriction
            "Wall friction model"
                  annotation(Dialog(group="Wall friction"), choicesAllMatching=true);

          input SI.Length[n - 1] pathLengths_internal
            "pathLengths used internally; to be defined by extending class";
          input SI.ReynoldsNumber[n - 1] Res_turbulent_internal=Re_turbulent*
              ones(n - 1)
            "Re_turbulent used internally; to be defined by extending class";

              // Parameters
          parameter SI.AbsolutePressure dp_nominal
            "Nominal pressure loss (only for nominal models)";
          parameter SI.MassFlowRate m_flow_nominal "Nominal mass flow rate";
          parameter SI.MassFlowRate m_flow_small=if system.use_eps_Re then
              system.eps_m_flow*m_flow_nominal else system.m_flow_small
            "Within regularization if |m_flows| < m_flow_small (may be wider for large discontinuities in static head)"
            annotation (Dialog(enable=not from_dp and WallFriction.use_m_flow_small));

        protected
          parameter SI.AbsolutePressure dp_small(start=1, fixed=false)
            "Within regularization if |dp| < dp_small (may be wider for large discontinuities in static head)"
            annotation (Dialog(enable=from_dp and WallFriction.use_dp_small));
              final parameter Boolean constantPressureLossCoefficient=
                 use_rho_nominal and (use_mu_nominal or not WallFriction.use_mu)
            "= true if the pressure loss does not depend on fluid states"
                 annotation(Evaluate=true);
              final parameter Boolean continuousFlowReversal=
                 (not useUpstreamScheme)
                 or constantPressureLossCoefficient
                 or not allowFlowReversal
            "= true if the pressure loss is continuous around zero flow"
                 annotation(Evaluate=true);

          SI.Length[n - 1] diameters=0.5*(dimensions[1:n - 1] + dimensions[2:n])
            "mean diameters between segments";
          SI.AbsolutePressure dp_fric_nominal=sum(
              WallFriction.pressureLoss_m_flow(
                          m_flow_nominal/nParallel,
                          rho_nominal,
                          rho_nominal,
                          mu_nominal,
                          mu_nominal,
                          pathLengths_internal,
                          diameters,
                          (roughnesses[1:n - 1] + roughnesses[2:n])/2,
                          m_flow_small/nParallel,
                          Res_turbulent_internal))
            "pressure loss for nominal conditions";

            initial equation
              // initialize dp_small from flow model
              if system.use_eps_Re then
                dp_small = dp_fric_nominal/m_flow_nominal*m_flow_small;
              else
                dp_small = system.dp_small;
              end if;

            equation
              for i in 1:n-1 loop
                assert(m_flows[i] > -m_flow_small or allowFlowReversal, "Reverting flow occurs even though allowFlowReversal is false");
              end for;

              if continuousFlowReversal then
                // simple regularization
            if from_dp and not WallFriction.dp_is_zero then
              m_flows = homotopy(actual=WallFriction.massFlowRate_dp(
                            dps_fg - {g*dheights[i]*rhos_act[i] for i in 1:n -
                  1},       rhos_act,
                            rhos_act,
                            mus_act,
                            mus_act,
                            pathLengths_internal,
                            diameters,
                            (roughnesses[1:n - 1] + roughnesses[2:n])/2,
                            dp_small/(n - 1),
                            Res_turbulent_internal)*nParallel, simplified=
                m_flow_nominal/dp_nominal*(dps_fg - g*dheights*rho_nominal));
                else
              dps_fg = homotopy(actual=WallFriction.pressureLoss_m_flow(
                            m_flows/nParallel,
                            rhos_act,
                            rhos_act,
                            mus_act,
                            mus_act,
                            pathLengths_internal,
                            diameters,
                            (roughnesses[1:n - 1] + roughnesses[2:n])/2,
                            m_flow_small/nParallel,
                            Res_turbulent_internal) + {g*dheights[i]*rhos_act[i]
                for i in 1:n - 1}, simplified=dp_nominal/m_flow_nominal*m_flows
                 + g*dheights*rho_nominal);
                end if;
              else
                // regularization for discontinuous flow reversal and static head
            if from_dp and not WallFriction.dp_is_zero then
              m_flows = homotopy(actual=WallFriction.massFlowRate_dp_staticHead(
                            dps_fg,
                            rhos[1:n - 1],
                            rhos[2:n],
                            mus[1:n - 1],
                            mus[2:n],
                            pathLengths_internal,
                            diameters,
                            g*dheights,
                            (roughnesses[1:n - 1] + roughnesses[2:n])/2,
                            dp_small/(n - 1),
                            Res_turbulent_internal)*nParallel, simplified=
                m_flow_nominal/dp_nominal*(dps_fg - g*dheights*rho_nominal));
                else
              dps_fg = homotopy(actual=
                WallFriction.pressureLoss_m_flow_staticHead(
                            m_flows/nParallel,
                            rhos[1:n - 1],
                            rhos[2:n],
                            mus[1:n - 1],
                            mus[2:n],
                            pathLengths_internal,
                            diameters,
                            g*dheights,
                            (roughnesses[1:n - 1] + roughnesses[2:n])/2,
                            m_flow_small/nParallel,
                            Res_turbulent_internal), simplified=dp_nominal/
                m_flow_nominal*m_flows + g*dheights*rho_nominal);
                end if;
              end if;

                annotation (Documentation(info="<html>
<p>
This model describes pressure losses due to <b>wall friction</b> in a pipe
and due to <b>gravity</b>.
Correlations of different complexity and validity can be
selected via the replaceable package <b>WallFriction</b> (see parameter menu below).
The details of the pipe wall friction model are described in the
<a href=\"modelica://Modelica_Fluid.UsersGuide.ComponentDefinition.WallFriction\">UsersGuide</a>.
Basically, different variants of the equation
</p>

<pre>
   dp = &lambda;(Re,<font face=\"Symbol\">D</font>)*(L/D)*&rho;*v*|v|/2.
</pre>

<p>

By default, the correlations are computed with media data at the actual time instant.
In order to reduce non-linear equation systems, the parameters
<b>use_mu_nominal</b> and <b>use_rho_nominal</b> provide the option
to compute the correlations with constant media values
at the desired operating point. This might speed-up the
simulation and/or might give a more robust simulation.
</p>
</html>"),      Diagram(coordinateSystem(
                    preserveAspectRatio=false,
                    extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,64},{100,-64}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Backward),
                Rectangle(
                  extent={{-100,50},{100,-49}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-60,-49},{-60,50}},
                  color={0,0,255},
                  arrow={Arrow.Filled,Arrow.Filled}),
                Text(
                  extent={{-50,16},{6,-10}},
                  lineColor={0,0,255},
                  textString="diameters"),
                Line(
                  points={{-100,74},{100,74}},
                  color={0,0,255},
                  arrow={Arrow.Filled,Arrow.Filled}),
                Text(
                  extent={{-32,93},{32,74}},
                  lineColor={0,0,255},
                  textString="pathLengths")}));
            end PartialGenericPipeFlow;

            model NominalTurbulentPipeFlow
          "NominalTurbulentPipeFlow: Quadratic turbulent pressure loss for nominal values"
          import Modelica_Fluid;
              extends
            Modelica_Fluid.Pipes.BaseClasses.FlowModels.PartialGenericPipeFlow(
            redeclare package WallFriction =
                Modelica_Fluid.Pipes.BaseClasses.WallFriction.LaminarAndQuadraticTurbulent,

            use_mu_nominal=not show_Res,
            pathLengths_internal=pathLengths_nominal,
            useUpstreamScheme=false,
            Res_turbulent_internal=Res_turbulent_nominal);

              import Modelica_Constants.pi;

          parameter SI.MassFlowRate m_flow_turbulent(min=0) = if system.use_eps_Re
             then 0.1*m_flow_nominal else system.m_flow_small
            "Turbulent flow starting from |m_flows| > m_flow_turbulent (may be wider for large discontinuities in static head)"
            annotation (Dialog(enable=not from_dp and WallFriction.use_m_flow_small));

              // variables for nominal pressure loss
          SI.Length[n - 1] pathLengths_nominal
            "pathLengths resulting from nominal pressure loss and geometry";
          SI.ReynoldsNumber[n - 1] Res_turbulent_nominal
            "Re_turbulent resulting from nominal turbulent flow and geometry";
              Real[n-1] ks_inv "coefficient for quadratic flow";
              Real[n-1] zetas "coefficient for quadratic flow";

              // Reynolds Number

            Modelica_Fluid.Pipes.BaseClasses.FlowModels.PartialStaggeredFlowModel.Medium.AbsolutePressure[
            n - 1] dps_fg_turbulent={(mus_act[i]*diameters[i]*pi/4)^2*
              Re_turbulent^2/(ks_inv[i]*rhos_act[i]) for i in 1:n - 1} if
            show_Res "Start of turbulent flow";

            equation
              // Inverse parameterization for WallFriction.QuadraticTurbulent
              // Note: the code should be shared with the WallFriction.QuadraticTurbulent model,
              //       but this required a re-design of the WallFriction interfaces ...
              //   zeta = (length_nominal/diameter)/(2*Math.log10(3.7 /(roughness/diameter)))^2;
              //   k_inv = (pi*diameter*diameter)^2/(8*zeta);
              //   k = rho*k_inv "Factor in m_flow = sqrt(k*dp)";
              //   m_flow_turbulent = pi/4*diameter*mu*Re_turbulent;
              for i in 1:n-1 loop
                ks_inv[i] = (m_flow_nominal/nParallel)^2/((dp_nominal/(n-1)-g*dheights[i]*rhos_act[i]))/rhos_act[i];
                zetas[i] = (pi*diameters[i]*diameters[i])^2/(8*ks_inv[i]);
            pathLengths_nominal[i] = zetas[i]*diameters[i]*(2*
              Modelica_Math.log10(3.7/((roughnesses[i] + roughnesses[i + 1])/2/
              diameters[i])))^2;
                Res_turbulent_nominal[i] = m_flow_turbulent/nParallel / (pi/4*diameters[i]*mus_act[i]);
              end for;

              annotation (Documentation(info="<html>
<p>
This model defines the pressure loss assuming turbulent flow for
specified <code>dp_nominal</code> and <code>m_flow_nominal</code>.
It takes into account the fluid density of each flow segment and
obtains appropriate <code>pathLengths_nominal</code> values
for an inverse parameterization of the
<a href=\"modelica://Modelica_Fluid.Pipes.BaseClasses.FlowModels.TurbulentPipeFlow\">
          TurbulentPipeFlow</a>
model. Per default the upstream and downstream densities are averaged with the setting <code>useUpstreamScheme = false</code>,
in order to avoid discontinuous <code>pathLengths_nominal</code> values in the case of flow reversal.
</p>
<p>
The geometry parameters <code>crossAreas</code>, <code>diameters</code> and <code>roughnesses</code> do
not effect simulation results of this nominal pressure loss model.
As the geometry is specified however, the optionally calculated Reynolds number as well as
<code>m_flows_turbulent</code> and <code>dps_fg_turbulent</code> become meaningful
and can be related to <code>m_flow_small</code> and <code>dp_small</code>.
</p>
<p>
<b>Optional Variables if show_Res</b>
</p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Type</b></th><th><b>Name</b></th><th><b>Description</b></th></tr>
<tr><td>ReynoldsNumber</td><td>Res[n]</td>
    <td>Reynolds numbers of pipe flow per flow segment</td></tr>
<tr><td>MassFlowRate</td><td>m_flows_turbulent[n-1]</td>
    <td>mass flow rates at start of turbulent region for Re_turbulent=4000</td></tr>
<tr><td>AbsolutePressure</td><td>dps_fg_turbulent[n-1]</td>
    <td>pressure losses due to friction and gravity corresponding to m_flows_turbulent</td></tr>
</table>
</html>",   revisions="<html>
<ul>
<li><i>6 Dec 2008</i>
    by Ruediger Franke:<br />
       Model added to the Fluid library</li>
</ul>
</html>"));
            end NominalTurbulentPipeFlow;

            model TurbulentPipeFlow
          "TurbulentPipeFlow: Pipe wall friction in the quadratic turbulent regime (using mu to regularize laminar region)"
          import Modelica_Fluid;
              extends
            Modelica_Fluid.Pipes.BaseClasses.FlowModels.PartialGenericPipeFlow(
            redeclare package WallFriction =
                Modelica_Fluid.Pipes.BaseClasses.WallFriction.LaminarAndQuadraticTurbulent,

            use_mu_nominal=not show_Res,
            pathLengths_internal=pathLengths,
            dp_nominal(start=if system.use_eps_Re then 1 else 1e3*dp_small,
                fixed=not system.use_eps_Re),
            m_flow_nominal=if system.use_eps_Re then system.m_flow_nominal
                 else 1e2*m_flow_small,
            Res_turbulent_internal=if use_Re then Re_turbulent*ones(n - 1)
                 else zeros(n - 1));

              parameter Boolean use_Re = system.use_eps_Re
            "= true, if turbulent region is defined by Re, otherwise by m_flow_small"
                annotation(Evaluate=true);

            initial equation
              // initialize dp_nominal from flow model
              if system.use_eps_Re then
                dp_nominal = dp_fric_nominal + g*sum(dheights)*rho_nominal;
              end if;

              annotation (Documentation(info="<html>
<p>
This model defines only the quadratic turbulent regime of wall friction:
dp = k*m_flow*|m_flow|, where \"k\" depends on density and the roughness
of the pipe and is not a function of the Reynolds number.
This relationship is only valid for large Reynolds numbers.
The turbulent pressure loss correlation might be useful to optimize models that are only facing turbulent flow.
</p>

</html>"));
            end TurbulentPipeFlow;

            model DetailedPipeFlow
          "DetailedPipeFlow: Pipe wall friction in the laminar and turbulent regime (detailed characteristic)"
          import Modelica_Fluid;
              extends
            Modelica_Fluid.Pipes.BaseClasses.FlowModels.PartialGenericPipeFlow(
            redeclare package WallFriction =
                Modelica_Fluid.Pipes.BaseClasses.WallFriction.Detailed,
            pathLengths_internal=pathLengths,
            dp_nominal(start=1, fixed=false),
            m_flow_nominal=if system.use_eps_Re then system.m_flow_nominal
                 else 1e2*m_flow_small,
            Res_turbulent_internal=Re_turbulent*ones(n - 1));

            initial equation
              // initialize dp_nominal from flow model
              if system.use_eps_Re then
                dp_nominal = dp_fric_nominal + g*sum(dheights)*rho_nominal;
              else
                dp_nominal = 1e3*dp_small;
              end if;

                annotation (Documentation(info="<html>
<p>
This component defines the complete regime of wall friction.
The details are described in the
<a href=\"modelica://Modelica_Fluid.UsersGuide.ComponentDefinition.WallFriction\">UsersGuide</a>.
The functional relationship of the friction loss factor &lambda; is
displayed in the next figure. Function massFlowRate_dp() defines the \"red curve\"
(\"Swamee and Jain\"), where as function pressureLoss_m_flow() defines the
\"blue curve\" (\"Colebrook-White\"). The two functions are inverses from
each other and give slightly different results in the transition region
between Re = 1500 .. 4000, in order to get explicit equations without
solving a non-linear equation.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFriction1.png\"
     alt=\"PipeFriction1.png\">
</p>

<p>
Additionally to wall friction, this component properly implements static
head. With respect to the latter, two cases can be distinguished. In the case
shown next, the change of elevation with the path from a to b has the opposite
sign of the change of density.</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFrictionStaticHead_case-a.png\"
     alt=\"PipeFrictionStaticHead_case-a.png\">
</p>

<p>
In the case illustrated second, the change of elevation with the path from a to
b has the same sign of the change of density.</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFrictionStaticHead_case-b.png\"
     alt=\"PipeFrictionStaticHead_case-b.png\">
</p>
</html>"),      Diagram(coordinateSystem(
                    preserveAspectRatio=false,
                    extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,64},{100,-64}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Backward),
                Rectangle(
                  extent={{-100,50},{100,-49}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-60,-49},{-60,50}},
                  color={0,0,255},
                  arrow={Arrow.Filled,Arrow.Filled}),
                Text(
                  extent={{-50,16},{6,-10}},
                  lineColor={0,0,255},
                  textString="diameters"),
                Line(
                  points={{-100,74},{100,74}},
                  color={0,0,255},
                  arrow={Arrow.Filled,Arrow.Filled})}));
            end DetailedPipeFlow;

      end FlowModels;

    package HeatTransfer "Heat transfer for flow models"
      extends Modelica_Icons.Package;
      partial model PartialFlowHeatTransfer
          "base class for any pipe heat transfer correlation"
        extends Modelica_Fluid_Interfaces.PartialHeatTransfer;

        // Additional inputs provided to flow heat transfer model
          input SI.Velocity[n] vs "Mean velocities of fluid flow in segments";

        // Geometry parameters and inputs for flow heat transfer
        parameter Real nParallel "number of identical parallel flow devices"
           annotation(Dialog(tab="Internal Interface",enable=false,group="Geometry"));
          input SI.Length[n] lengths "Lengths along flow path";
          input SI.Length[n] dimensions
            "Characteristic dimensions for fluid flow (diameter for pipe flow)";
          input SI.Height[n] roughnesses
            "Average heights of surface asperities";

        annotation (Documentation(info="<html>
Base class for heat transfer models of flow devices.
<p>
The geometry is specified in the interface with the <code>surfaceAreas[n]</code>, the <code>roughnesses[n]</code>
and the lengths[n] along the flow path.
Moreover the fluid flow is characterized for different types of devices by the characteristic <code>dimensions[n+1]</code>
and the average velocities <code>vs[n+1]</code> of fluid flow.
See <a href=\"modelica://Modelica_Fluid.Pipes.BaseClasses.CharacteristicNumbers.ReynoldsNumber\">Pipes.BaseClasses.CharacteristicNumbers.ReynoldsNumber</a>
for example definitions.
</p>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-80,60},{80,-60}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.HorizontalCylinder), Text(
                  extent={{-40,22},{38,-18}},
                  lineColor={0,0,0},
                  textString="%name")}));
      end PartialFlowHeatTransfer;

      model IdealFlowHeatTransfer
          "IdealHeatTransfer: Ideal heat transfer without thermal resistance"
        extends PartialFlowHeatTransfer;
      equation
        Ts = heatPorts.T;
        annotation(Documentation(info="<html>
Ideal heat transfer without thermal resistance.
</html>"));
      end IdealFlowHeatTransfer;

      model ConstantFlowHeatTransfer
          "ConstantHeatTransfer: Constant heat transfer coefficient"
        extends PartialFlowHeatTransfer;
          parameter SI.CoefficientOfHeatTransfer alpha0
            "heat transfer coefficient";
      equation
        Q_flows = {alpha0*surfaceAreas[i]*(heatPorts[i].T - Ts[i])*nParallel for i in 1:n};
        annotation(Documentation(info="<html>
<p>
Simple heat transfer correlation with constant heat transfer coefficient, used as default component in distributed pipe models.
</p>
</html>"));
      end ConstantFlowHeatTransfer;

      partial model PartialPipeFlowHeatTransfer
          "Base class for pipe heat transfer correlation in terms of Nusselt number heat transfer in a circular pipe for laminar and turbulent one-phase flow"
        extends PartialFlowHeatTransfer;
          parameter SI.CoefficientOfHeatTransfer alpha0=100
            "guess value for heat transfer coefficients";
          SI.CoefficientOfHeatTransfer[n] alphas(each start=alpha0)
            "CoefficientOfHeatTransfer";
        Real[n] Res "Reynolds numbers";
        Real[n] Prs "Prandtl numbers";
        Real[n] Nus "Nusselt numbers";
        Medium.Density[n] ds "Densities";
        Medium.DynamicViscosity[n] mus "Dynamic viscosities";
        Medium.ThermalConductivity[n] lambdas "Thermal conductivity";
          SI.Length[n] diameters=dimensions "Hydraulic diameters for pipe flow";
      equation
        ds=Medium.density(states);
        mus=Medium.dynamicViscosity(states);
        lambdas=Medium.thermalConductivity(states);
        Prs = Medium.prandtlNumber(states);
        Res = CharacteristicNumbers.ReynoldsNumber(vs, ds, mus, diameters);
        Nus = CharacteristicNumbers.NusseltNumber(alphas, diameters, lambdas);
        Q_flows={alphas[i]*surfaceAreas[i]*(heatPorts[i].T - Ts[i])*nParallel for i in 1:n};
          annotation (Documentation(info="<html>
<p>
Base class for heat transfer models that are expressed in terms of the Nusselt number and which can be used in distributed pipe models.
</p>
</html>"));
      end PartialPipeFlowHeatTransfer;

      model LocalPipeFlowHeatTransfer
          "LocalPipeFlowHeatTransfer: Laminar and turbulent forced convection in pipes, local coefficients"
        extends PartialPipeFlowHeatTransfer;
        protected
        Real[n] Nus_turb "Nusselt number for turbulent flow";
        Real[n] Nus_lam "Nusselt number for laminar flow";
        Real Nu_1;
        Real[n] Nus_2;
        Real[n] Xis;
      equation
        Nu_1=3.66;
        for i in 1:n loop
         Nus_turb[i]=smooth(0,(Xis[i]/8)*abs(Res[i])*Prs[i]/(1+12.7*(Xis[i]/8)^0.5*(Prs[i]^(2/3)-1))*(1+1/3*(diameters[i]/lengths[i]/(if vs[i]>=0 then (i-0.5) else (n-i+0.5)))^(2/3)));
         Xis[i]=(1.8*Modelica_Math.log10(max(1e-10,Res[i]))-1.5)^(-2);
         Nus_lam[i]=(Nu_1^3+0.7^3+(Nus_2[i]-0.7)^3)^(1/3);
         Nus_2[i]=smooth(0,1.077*(abs(Res[i])*Prs[i]*diameters[i]/lengths[i]/(if vs[i]>=0 then (i-0.5) else (n-i+0.5)))^(1/3));
            Nus[i] = Modelica_Media.Air.MoistAir.Utilities.spliceFunction(
                    Nus_turb[i],
                    Nus_lam[i],
                    Res[i] - 6150,
                    3850);
        end for;
        annotation (Documentation(info="<html>
<p>
Heat transfer model for laminar and turbulent flow in pipes. Range of validity:
</p>
<ul>
<li>fully developed pipe flow</li>
<li>forced convection</li>
<li>one phase Newtonian fluid</li>
<li>(spatial) constant wall temperature in the laminar region</li>
<li>0 &le; Re &le; 1e6, 0.6 &le; Pr &le; 100, d/L &le; 1</li>
<li>The correlation holds for non-circular pipes only in the turbulent region. Use diameter=4*crossArea/perimeter as characteristic length.</li>
</ul>
<p>
The correlation takes into account the spatial position along the pipe flow, which changes discontinuously at flow reversal. However, the heat transfer coefficient itself is continuous around zero flow rate, but not its derivative.
</p>
<h4>References</h4>
<dl><dt>Verein Deutscher Ingenieure (1997):</dt>
    <dd><b>VDI W&auml;rmeatlas</b>.
         Springer Verlag, Ed. 8, 1997.</dd>
</dl>
</html>"));
      end LocalPipeFlowHeatTransfer;
      annotation (Documentation(info="<html>
<p>
Heat transfer correlations for pipe models
</p>
</html>"));
    end HeatTransfer;

      package CharacteristicNumbers
        "Functions to compute characteristic numbers"
        extends Modelica_Icons.Package;
        function ReynoldsNumber "Return Reynolds number from v, rho, mu, D"
          extends Modelica_Icons.Function;

          input SI.Velocity v "Mean velocity of fluid flow";
          input SI.Density rho "Fluid density";
          input SI.DynamicViscosity mu "Dynamic (absolute) viscosity";
          input SI.Length D
            "Characteristic dimension (hydraulic diameter of pipes)";
          output SI.ReynoldsNumber Re "Reynolds number";
        algorithm
          Re := abs(v)*rho*D/mu;
          annotation (Documentation(info="<html>
<p>
Calculation of Reynolds Number
</p>
<pre>
   Re = |v|&rho;D/&mu;
</pre>
<p>
a measure of the relationship between inertial forces (v&rho;) and viscous forces (D/&mu;).
</p>
<p>
The following table gives examples for the characteristic dimension D and the velocity v for different fluid flow devices:
</p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Device Type</b></th><th><b>Characteristic Dimension D</b></th><th><b>Velocity v</b></th></tr>
<tr><td>Circular Pipe</td><td>diameter</td>
    <td>m_flow/&rho;/crossArea</td></tr>
<tr><td>Rectangular Duct</td><td>4*crossArea/perimeter</td>
    <td>m_flow/&rho;/crossArea</td></tr>
<tr><td>Wide Duct</td><td>distance between narrow, parallel walls</td>
    <td>m_flow/&rho;/crossArea</td></tr>
<tr><td>Packed Bed</td><td>diameterOfSpericalParticles/(1-fluidFractionOfTotalVolume)</td>
    <td>m_flow/&rho;/crossArea (without particles)</td></tr>
<tr><td>Device with rotating agitator</td><td>diameterOfRotor</td>
    <td>RotationalSpeed*diameterOfRotor</td></tr>
</table>
</html>"));
        end ReynoldsNumber;

        function ReynoldsNumber_m_flow
          "Return Reynolds number from m_flow, mu, D, A"
          extends Modelica_Icons.Function;

          input SI.MassFlowRate m_flow "Mass flow rate";
          input SI.DynamicViscosity mu "Dynamic viscosity";
          input SI.Length D
            "Characteristic dimension (hydraulic diameter of pipes or orifices)";
          input SI.Area A=Modelica_Constants.pi/4*D*D
            "Cross sectional area of fluid flow";
          output SI.ReynoldsNumber Re "Reynolds number";
        algorithm
          Re := abs(m_flow)*D/A/mu;
          annotation (Documentation(info="<html>Simplified calculation of Reynolds Number for flow through pipes or orifices;
              using the mass flow rate <code>m_flow</code> instead of the velocity <code>v</code> to express inertial forces.
<pre>
  Re = |m_flow|*diameter/A/&mu;
with
  m_flow = v*&rho;*A
</pre>
See also <a href=\"modelica://Modelica_Fluid.Pipes.BaseClasses.CharacteristicNumbers.ReynoldsNumber\">
          Pipes.BaseClasses.CharacteristicNumbers.ReynoldsNumber</a>.
</html>"));
        end ReynoldsNumber_m_flow;

        function NusseltNumber "Return Nusselt number"
          extends Modelica_Icons.Function;

          input SI.CoefficientOfHeatTransfer alpha
            "Coefficient of heat transfer";
          input SI.Length D "Characteristic dimension";
          input SI.ThermalConductivity lambda "Thermal conductivity";
          output SI.NusseltNumber Nu "Nusselt number";
        algorithm
          Nu := alpha*D/lambda;
          annotation (Documentation(info="Nusselt number Nu = alpha*D/lambda"));
        end NusseltNumber;
      end CharacteristicNumbers;

      package WallFriction
        "Different variants for pressure drops due to pipe wall friction"
        extends Modelica_Icons.Package;
        partial package PartialWallFriction
          "Partial wall friction characteristic (base package of all wall friction characteristics)"
          extends Modelica_Icons.Package;

        // Constants to be set in subpackages
          constant Boolean use_mu = true
            "= true, if mu_a/mu_b are used in function, otherwise value is not used";
          constant Boolean use_roughness = true
            "= true, if roughness is used in function, otherwise value is not used";
          constant Boolean use_dp_small = true
            "= true, if dp_small is used in function, otherwise value is not used";
          constant Boolean use_m_flow_small = true
            "= true, if m_flow_small is used in function, otherwise value is not used";
          constant Boolean dp_is_zero = false
            "= true, if no wall friction is present, i.e., dp = 0 (function massFlowRate_dp() cannot be used)";
          constant Boolean use_Re_turbulent = true
            "= true, if Re_turbulent input is used in function, otherwise value is not used";

        // pressure loss characteristic functions
          replaceable partial function massFlowRate_dp
            "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction"
            extends Modelica_Icons.Function;

            input SI.Pressure dp "Pressure loss (dp = port_a.p - port_b.p)";
            input SI.Density rho_a "Density at port_a";
            input SI.Density rho_b "Density at port_b";
            input SI.DynamicViscosity mu_a
              "Dynamic viscosity at port_a (dummy if use_mu = false)";
            input SI.DynamicViscosity mu_b
              "Dynamic viscosity at port_b (dummy if use_mu = false)";
            input SI.Length length "Length of pipe";
            input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
            input SI.Length roughness(min=0)=2.5e-5
              "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
            input SI.AbsolutePressure dp_small=1
              "Regularization of zero flow if |dp| < dp_small (dummy if use_dp_small = false)";
            input SI.ReynoldsNumber Re_turbulent=4000
              "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";

            output SI.MassFlowRate m_flow
              "Mass flow rate from port_a to port_b";
          annotation (Documentation(info="<html>

</html>"));
          end massFlowRate_dp;

          replaceable partial function massFlowRate_dp_staticHead
            "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction and static head"
            extends Modelica_Icons.Function;

            input SI.Pressure dp "Pressure loss (dp = port_a.p - port_b.p)";
            input SI.Density rho_a "Density at port_a";
            input SI.Density rho_b "Density at port_b";
            input SI.DynamicViscosity mu_a
              "Dynamic viscosity at port_a (dummy if use_mu = false)";
            input SI.DynamicViscosity mu_b
              "Dynamic viscosity at port_b (dummy if use_mu = false)";
            input SI.Length length "Length of pipe";
            input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
            input Real g_times_height_ab
              "Gravity times (Height(port_b) - Height(port_a))";
            input SI.Length roughness(min=0)=2.5e-5
              "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
            input SI.AbsolutePressure dp_small=1
              "Regularization of zero flow if |dp| < dp_small (dummy if use_dp_small = false)";
            input SI.ReynoldsNumber Re_turbulent=4000
              "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";

            output SI.MassFlowRate m_flow
              "Mass flow rate from port_a to port_b";
            annotation (Documentation(info="<html>

</html>"));
          end massFlowRate_dp_staticHead;

          replaceable partial function pressureLoss_m_flow
            "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction"
            extends Modelica_Icons.Function;

            input SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
            input SI.Density rho_a "Density at port_a";
            input SI.Density rho_b "Density at port_b";
            input SI.DynamicViscosity mu_a
              "Dynamic viscosity at port_a (dummy if use_mu = false)";
            input SI.DynamicViscosity mu_b
              "Dynamic viscosity at port_b (dummy if use_mu = false)";
            input SI.Length length "Length of pipe";
            input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
            input SI.Length roughness(min=0)=2.5e-5
              "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
            input SI.MassFlowRate m_flow_small=0.01
              "Regularization of zero flow if |m_flow| < m_flow_small (dummy if use_m_flow_small = false)";
            input SI.ReynoldsNumber Re_turbulent=4000
              "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";

            output SI.Pressure dp "Pressure loss (dp = port_a.p - port_b.p)";

          annotation (Documentation(info="<html>

</html>"));
          end pressureLoss_m_flow;

          replaceable partial function pressureLoss_m_flow_staticHead
            "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction and static head"
                    extends Modelica_Icons.Function;

            input SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
            input SI.Density rho_a "Density at port_a";
            input SI.Density rho_b "Density at port_b";
            input SI.DynamicViscosity mu_a
              "Dynamic viscosity at port_a (dummy if use_mu = false)";
            input SI.DynamicViscosity mu_b
              "Dynamic viscosity at port_b (dummy if use_mu = false)";
            input SI.Length length "Length of pipe";
            input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
            input Real g_times_height_ab
              "Gravity times (Height(port_b) - Height(port_a))";
            input SI.Length roughness(min=0)=2.5e-5
              "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
            input SI.MassFlowRate m_flow_small=0.01
              "Regularization of zero flow if |m_flow| < m_flow_small (dummy if use_m_flow_small = false)";
            input SI.ReynoldsNumber Re_turbulent=4000
              "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";

            output SI.Pressure dp "Pressure loss (dp = port_a.p - port_b.p)";

          annotation (Documentation(info="<html>

</html>"));
          end pressureLoss_m_flow_staticHead;
          annotation (Documentation(info="<html>

</html>"));
        end PartialWallFriction;

        package NoFriction "No pipe wall friction, no static head"
          extends Modelica_Icons.Package;

          extends PartialWallFriction(
                    final use_mu = false,
                    final use_roughness = false,
                    final use_dp_small = false,
                    final use_m_flow_small = false,
                    final dp_is_zero = true,
                    final use_Re_turbulent = false);

          redeclare function extends massFlowRate_dp
            "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction"

          algorithm
            assert(false, "function massFlowRate_dp (option: from_dp=true)
cannot be used for WallFriction.NoFriction. Use instead
function pressureLoss_m_flow (option: from_dp=false)");
            annotation (Documentation(info="<html>

</html>"));
          end massFlowRate_dp;

          redeclare function extends pressureLoss_m_flow
            "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction"

          algorithm
            dp := 0;
            annotation (Documentation(info="<html>

</html>"));
          end pressureLoss_m_flow;

          redeclare function extends massFlowRate_dp_staticHead
            "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction and static head"

          algorithm
            assert(false, "function massFlowRate_dp (option: from_dp=true)
cannot be used for WallFriction.NoFriction. Use instead
function pressureLoss_m_flow (option: from_dp=false)");
            annotation (Documentation(info="<html>

</html>"));
          end massFlowRate_dp_staticHead;

          redeclare function extends pressureLoss_m_flow_staticHead
            "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction and static head"

          /* To include only static head:
protected
  Real dp_grav_a = g_times_height_ab*rho_a
    "Static head if mass flows in design direction (a to b)";
  Real dp_grav_b = g_times_height_ab*rho_b
    "Static head if mass flows against design direction (b to a)";
*/
          algorithm
          //  dp := Utilities.regStep(m_flow, dp_grav_a, dp_grav_a, m_flow_small);
            dp := 0;
            assert(abs(g_times_height_ab) <Modelica_Constants.small,
             "WallFriction.NoFriction does not consider static head and cannot be used with height_ab<>0!");
            annotation (Documentation(info="<html>

</html>"));
          end pressureLoss_m_flow_staticHead;
          annotation (Documentation(info="<html>
<p>
This component sets the pressure loss due to wall friction
to zero, i.e., it allows to switch off pipe wall friction.
</p>
</html>"));
        end NoFriction;

        package Laminar
          "Pipe wall friction in the laminar regime (linear correlation)"

          extends PartialWallFriction(
                    final use_mu = true,
                    final use_roughness = false,
                    final use_dp_small = false,
                    final use_m_flow_small = false,
                    final use_Re_turbulent = false);

          redeclare function extends massFlowRate_dp
            "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction"

          algorithm
            m_flow :=dp*Modelica_Constants.pi*diameter^4*(rho_a + rho_b)/(128*length*(mu_a + mu_b));
            annotation (Documentation(info="<html>

</html>"));
          end massFlowRate_dp;

          redeclare function extends pressureLoss_m_flow
            "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction"

          algorithm
            dp := m_flow*128*length*(mu_a + mu_b)/(Modelica_Constants.pi*diameter^4*(rho_a + rho_b));
            annotation (Documentation(info="<html>

</html>"));
          end pressureLoss_m_flow;

          redeclare function extends massFlowRate_dp_staticHead
            "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction and static head"

          protected
            Real k0inv=Modelica_Constants.pi  *diameter^4/(128*length)
              "Constant factor";

            Real dp_grav_a = g_times_height_ab*rho_a
              "Static head if mass flows in design direction (a to b)";
            Real dp_grav_b = g_times_height_ab*rho_b
              "Static head if mass flows against design direction (b to a)";

            Real dm_flow_ddp_fric_a = k0inv*rho_a/mu_a
              "Slope of mass flow rate over dp if flow in design direction (a to b)";
            Real dm_flow_ddp_fric_b = k0inv*rho_b/mu_b
              "Slope of mass flow rate over dp if flow against design direction (b to a)";

            Real dp_a=max(dp_grav_a,dp_grav_b)+dp_small
              "Upper end of regularization domain of the m_flow(dp) relation";
            Real dp_b=min(dp_grav_a,dp_grav_b)-dp_small
              "Lower end of regularization domain of the m_flow(dp) relation";

            SI.MassFlowRate m_flow_a
              "Value at upper end of regularization domain";
            SI.MassFlowRate m_flow_b
              "Value at lower end of regularization domain";

            // Properly define zero mass flow conditions
            SI.MassFlowRate m_flow_zero=0;
            SI.Pressure dp_zero=(dp_grav_a + dp_grav_b)/2;
            Real dm_flow_ddp_fric_zero;
          algorithm
          /*
  dp = 0.5*zeta/(A^2*d) * m_flow * |m_flow|
     = 0.5 * c0/(|m_flow|*(4/pi)/(D_Re*mu)) / ((pi*(D_Re/2)^2)^2*d) * m_flow*|m_flow|
     = 0.5 * c0*(pi/4)*(D_Re*mu) * 16/(pi^2*D_Re^4*d) * m_flow*|m_flow|
     = 2*c0/(pi*D_Re^3) * mu/d * m_flow
     = k0 * mu/d * m_flow
  k0 = 2*c0/(pi*D_Re^3)
*/

            if dp>=dp_a then
              // Positive flow outside regularization
              m_flow := dm_flow_ddp_fric_a*(dp-dp_grav_a);
            elseif dp<=dp_b then
              // Negative flow outside regularization
              m_flow := dm_flow_ddp_fric_b*(dp-dp_grav_b);
            else
              m_flow_a := dm_flow_ddp_fric_a*(dp_a - dp_grav_a);
              m_flow_b := dm_flow_ddp_fric_b*(dp_b - dp_grav_b);

              // Include a properly defined zero mass flow point
              // Obtain a suitable slope from the linear section slope c (value of m_flow is overwritten later)
              (m_flow, dm_flow_ddp_fric_zero) := Utilities.regFun3(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a);
              // Do regularization
              if dp>dp_zero then
                m_flow := Utilities.regFun3(dp, dp_zero, dp_a, m_flow_zero, m_flow_a, dm_flow_ddp_fric_zero, dm_flow_ddp_fric_a);
              else
                m_flow := Utilities.regFun3(dp, dp_b, dp_zero, m_flow_b, m_flow_zero, dm_flow_ddp_fric_b, dm_flow_ddp_fric_zero);
              end if;
            end if;
          /*
  m_flow := if dp<dp_b then dm_flow_ddp_b*(dp-dp_grav_b) else
              (if dp>dp_a then dm_flow_ddp_a*(dp-dp_grav_a) else
                Modelica_Fluid.Utilities.regFun3(dp, dp_b, dp_a, dm_flow_ddp_b*(dp_b - dp_grav_b), dm_flow_ddp_a*(dp_a - dp_grav_a), dm_flow_ddp_b, dm_flow_ddp_a));
*/
            annotation (Documentation(info="<html>

</html>"));
          end massFlowRate_dp_staticHead;

          redeclare function extends pressureLoss_m_flow_staticHead
            "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction and static head"

          protected
            Real k0 = 128*length/(Modelica_Constants.pi*diameter^4)
              "Constant factor";

            Real dp_grav_a = g_times_height_ab*rho_a
              "Static head if mass flows in design direction (a to b)";
            Real dp_grav_b = g_times_height_ab*rho_b
              "Static head if mass flows against design direction (b to a)";

            Real ddp_dm_flow_a = k0*mu_a/rho_a
              "Slope of dp over mass flow rate if flow in design direction (a to b)";
            Real ddp_dm_flow_b = k0*mu_b/rho_b
              "Slope of dp over mass flow rate if flow against design direction (b to a)";

            Real m_flow_a=if dp_grav_a >= dp_grav_b then m_flow_small else m_flow_small + (dp_grav_b-dp_grav_a)/ddp_dm_flow_a
              "Upper end of regularization domain of the dp(m_flow) relation";
            Real m_flow_b=if dp_grav_a >= dp_grav_b then -m_flow_small else -m_flow_small - (dp_grav_b - dp_grav_a)/ddp_dm_flow_b
              "Lower end of regularization domain of the dp(m_flow) relation";

            SI.Pressure dp_a "Value at upper end of regularization domain";
            SI.Pressure dp_b "Value at lower end of regularization domain";

            // Properly define zero mass flow conditions
            SI.MassFlowRate m_flow_zero=0;
            SI.Pressure dp_zero=(dp_grav_a + dp_grav_b)/2;
            Real ddp_dm_flow_zero;
          algorithm
          /*
  dp = 0.5*zeta/(A^2*d) * m_flow * |m_flow|
     = 0.5 * c0/(|m_flow|*(4/pi)/(D_Re*mu)) / ((pi*(D_Re/2)^2)^2*d) * m_flow*|m_flow|
     = 0.5 * c0*(pi/4)*(D_Re*mu) * 16/(pi^2*D_Re^4*d) * m_flow*|m_flow|
     = 2*c0/(pi*D_Re^3) * mu/d * m_flow
     = k0 * mu/d * m_flow
  k0 = 2*c0/(pi*D_Re^3)
*/

            if m_flow>=m_flow_a then
              // Positive flow outside regularization
              dp := (ddp_dm_flow_a*m_flow + dp_grav_a);
            elseif m_flow<=m_flow_b then
              // Negative flow outside regularization
              dp := (ddp_dm_flow_b*m_flow + dp_grav_b);
            else
              // Regularization parameters
              dp_a := ddp_dm_flow_a*m_flow_a + dp_grav_a;
              dp_b := ddp_dm_flow_b*m_flow_b + dp_grav_b;
              // Include a properly defined zero mass flow point
              // Obtain a suitable slope from the linear section slope c (value of dp is overwritten later)
              (dp, ddp_dm_flow_zero) := Utilities.regFun3(m_flow_zero, m_flow_b, m_flow_a, dp_b, dp_a, ddp_dm_flow_b, ddp_dm_flow_a);
              // Do regularization
              if m_flow>m_flow_zero then
                dp := Utilities.regFun3(m_flow, m_flow_zero, m_flow_a, dp_zero, dp_a, ddp_dm_flow_zero, ddp_dm_flow_a);
              else
                dp := Utilities.regFun3(m_flow, m_flow_b, m_flow_zero, dp_b, dp_zero, ddp_dm_flow_b, ddp_dm_flow_zero);
              end if;
            end if;
            annotation (Documentation(info="<html>

</html>"));
          end pressureLoss_m_flow_staticHead;
          annotation (Documentation(info="<html>
<p>
This component defines only the laminar region of wall friction:
dp = k*m_flow, where \"k\" depends on density and dynamic viscosity.
The roughness of the wall does not have an influence on the laminar
flow and therefore argument roughness is ignored.
Since this is a linear relationship, the occurring systems of equations
are usually much simpler (e.g., either linear instead of non-linear).
By using nominal values for density and dynamic viscosity, the
systems of equations can still further be reduced.
</p>

<p>
In <a href=\"modelica://Modelica_Fluid.UsersGuide.ComponentDefinition.WallFriction\">UsersGuide</a> the complete friction regime is illustrated.
This component describes only the <b>Hagen-Poiseuille</b> equation.
</p>
<br>

</html>"));
        end Laminar;

        package QuadraticTurbulent
          "Pipe wall friction in the quadratic turbulent regime (simple characteristic, mu not used)"

          extends PartialWallFriction(
                    final use_mu = false,
                    final use_roughness = true,
                    final use_dp_small = true,
                    final use_m_flow_small = true,
                    final use_Re_turbulent = false);

          redeclare function extends massFlowRate_dp
            "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction"
            import Math = Modelica_Math;
          protected
            constant Real pi=Modelica_Constants.pi;
            Real zeta;
            Real k_inv;
          algorithm
            /*
   dp = 0.5*zeta*d*v*|v|
      = 0.5*zeta*d*1/(d*A)^2 * m_flow * |m_flow|
      = 0.5*zeta/A^2 *1/d * m_flow * |m_flow|
      = k/d * m_flow * |m_flow|
   k  = 0.5*zeta/A^2
      = 0.5*zeta/(pi*(D/2)^2)^2
      = 8*zeta/(pi*D^2)^2
  */
            assert(roughness > 1e-10,
                   "roughness > 0 required for quadratic turbulent wall friction characteristic");
            zeta  := (length/diameter)/(2*Math.log10(3.7 /(roughness/diameter)))^2;
            k_inv := (pi*diameter*diameter)^2/(8*zeta);
            m_flow := Utilities.regRoot2(
                        dp,
                        dp_small,
                        rho_a*k_inv,
                        rho_b*k_inv);
            annotation (smoothOrder=1, Documentation(info="<html>

</html>"));
          end massFlowRate_dp;

          redeclare function extends pressureLoss_m_flow
            "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction"
            import Math = Modelica_Math;

          protected
            constant Real pi=Modelica_Constants.pi;
            Real zeta;
            Real k;
          algorithm
            /*
   dp = 0.5*zeta*d*v*|v|
      = 0.5*zeta*d*1/(d*A)^2 * m_flow * |m_flow|
      = 0.5*zeta/A^2 *1/d * m_flow * |m_flow|
      = k/d * m_flow * |m_flow|
   k  = 0.5*zeta/A^2
      = 0.5*zeta/(pi*(D/2)^2)^2
      = 8*zeta/(pi*D^2)^2
  */
            assert(roughness > 1e-10,
                   "roughness > 0 required for quadratic turbulent wall friction characteristic");
            zeta := (length/diameter)/(2*Math.log10(3.7 /(roughness/diameter)))^2;
            k    := 8*zeta/(pi*diameter*diameter)^2;
            dp := Utilities.regSquare2(
                        m_flow,
                        m_flow_small,
                        k/rho_a,
                        k/rho_b);
            annotation (smoothOrder=1, Documentation(info="<html>

</html>"));
          end pressureLoss_m_flow;

          redeclare function extends massFlowRate_dp_staticHead
            "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction and static head"
            import Math = Modelica_Math;
          protected
            constant Real pi=Modelica_Constants.pi;
            Real zeta = (length/diameter)/(2*Math.log10(3.7 /(roughness/diameter)))^2;
            Real k_inv = (pi*diameter*diameter)^2/(8*zeta);

            SI.Pressure dp_grav_a=g_times_height_ab*rho_a
              "Static head if mass flows in design direction (a to b)";
            SI.Pressure dp_grav_b=g_times_height_ab*rho_b
              "Static head if mass flows against design direction (b to a)";

            Real k1 = rho_a*k_inv "Factor in m_flow =  sqrt(k1*(dp-dp_grav_a))";
            Real k2 = rho_b*k_inv "Factor in m_flow = -sqrt(k2*|dp-dp_grav_b|)";

            Real dp_a=max(dp_grav_a,dp_grav_b)+dp_small
              "Upper end of regularization domain of the m_flow(dp) relation";
            Real dp_b=min(dp_grav_a,dp_grav_b)-dp_small
              "Lower end of regularization domain of the m_flow(dp) relation";

            SI.MassFlowRate m_flow_a
              "Value at upper end of regularization domain";
            SI.MassFlowRate m_flow_b
              "Value at lower end of regularization domain";

            SI.MassFlowRate dm_flow_ddp_fric_a
              "Derivative at upper end of regularization domain";
            SI.MassFlowRate dm_flow_ddp_fric_b
              "Derivative at lower end of regularization domain";

            // Properly define zero mass flow conditions
            SI.MassFlowRate m_flow_zero=0;
            SI.Pressure dp_zero=(dp_grav_a + dp_grav_b)/2;
            Real dm_flow_ddp_fric_zero;
          algorithm
            /*
   dp = 0.5*zeta*d*v*|v|
      = 0.5*zeta*d*1/(d*A)^2 * m_flow * |m_flow|
      = 0.5*zeta/A^2 *1/d * m_flow * |m_flow|
      = k/d * m_flow * |m_flow|
   k  = 0.5*zeta/A^2
      = 0.5*zeta/(pi*(D/2)^2)^2
      = 8*zeta/(pi*D^2)^2
  */
            assert(roughness > 1e-10,
                   "roughness > 0 required for quadratic turbulent wall friction characteristic");

            if dp>=dp_a then
              // Positive flow outside regularization
              m_flow := sqrt(k1*(dp-dp_grav_a));
            elseif dp<=dp_b then
              // Negative flow outside regularization
              m_flow := -sqrt(k2*abs(dp-dp_grav_b));
            else
              m_flow_a := sqrt(k1*(dp_a - dp_grav_a));
              m_flow_b := -sqrt(k2*abs(dp_b - dp_grav_b));

              dm_flow_ddp_fric_a := k1/(2*sqrt(k1*(dp_a - dp_grav_a)));
              dm_flow_ddp_fric_b := k2/(2*sqrt(k2*abs(dp_b - dp_grav_b)));
          /*  dm_flow_ddp_fric_a := if abs(dp_a - dp_grav_a)>0 then k1/(2*sqrt(k1*(dp_a - dp_grav_a))) else  Modelica_Constants.inf);
    dm_flow_ddp_fric_b := if abs(dp_b - dp_grav_b)>0 then k2/(2*sqrt(k2*abs(dp_b - dp_grav_b))) else Modelica_Constants.inf; */

              // Include a properly defined zero mass flow point
              // Obtain a suitable slope from the linear section slope c (value of m_flow is overwritten later)
              (m_flow, dm_flow_ddp_fric_zero) := Utilities.regFun3(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a);
              // Do regularization
              if dp>dp_zero then
                m_flow := Utilities.regFun3(dp, dp_zero, dp_a, m_flow_zero, m_flow_a, dm_flow_ddp_fric_zero, dm_flow_ddp_fric_a);
              else
                m_flow := Utilities.regFun3(dp, dp_b, dp_zero, m_flow_b, m_flow_zero, dm_flow_ddp_fric_b, dm_flow_ddp_fric_zero);
              end if;
            end if;
            annotation (smoothOrder=1, Documentation(info="<html>

</html>"));
          end massFlowRate_dp_staticHead;

          redeclare function extends pressureLoss_m_flow_staticHead
            "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction and static head"
            import Math = Modelica_Math;
          protected
            constant Real pi=Modelica_Constants.pi;
            Real zeta = (length/diameter)/(2*Math.log10(3.7 /(roughness/diameter)))^2;
            Real k = 8*zeta/(pi*diameter*diameter)^2;

            SI.Pressure dp_grav_a=g_times_height_ab*rho_a
              "Static head if mass flows in design direction (a to b)";
            SI.Pressure dp_grav_b=g_times_height_ab*rho_b
              "Static head if mass flows against design direction (b to a)";

            Real k1 = k/rho_a
              "If m_flow >= 0 then dp = k1*m_flow^2 + dp_grav_a";
            Real k2 = k/rho_b
              "If m_flow < 0 then dp = -k2*m_flow^2 + dp_grav_b";

            Real m_flow_a=if dp_grav_a >= dp_grav_b then m_flow_small else m_flow_small + sqrt((dp_grav_b - dp_grav_a)/k1)
              "Upper end of regularization domain of the dp(m_flow) relation";
            Real m_flow_b=if dp_grav_a >= dp_grav_b then -m_flow_small else -m_flow_small - sqrt((dp_grav_b - dp_grav_a)/k2)
              "Lower end of regularization domain of the dp(m_flow) relation";

            SI.Pressure dp_a "Value at upper end of regularization domain";
            SI.Pressure dp_b "Value at lower end of regularization domain";

            Real ddp_dm_flow_a
              "Derivative of pressure drop with mass flow rate at m_flow_a";
            Real ddp_dm_flow_b
              "Derivative of pressure drop with mass flow rate at m_flow_b";

            // Properly define zero mass flow conditions
            SI.MassFlowRate m_flow_zero=0;
            SI.Pressure dp_zero=(dp_grav_a + dp_grav_b)/2;
            Real ddp_dm_flow_zero;

          algorithm
            /*
   dp = 0.5*zeta*d*v*|v|
      = 0.5*zeta*d*1/(d*A)^2 * m_flow * |m_flow|
      = 0.5*zeta/A^2 *1/d * m_flow * |m_flow|
      = k/d * m_flow * |m_flow|
   k  = 0.5*zeta/A^2
      = 0.5*zeta/(pi*(D/2)^2)^2
      = 8*zeta/(pi*D^2)^2
  */
            assert(roughness > 1e-10,
                   "roughness > 0 required for quadratic turbulent wall friction characteristic");

            if m_flow>=m_flow_a then
              // Positive flow outside regularization
              dp := (k1*m_flow^2 + dp_grav_a);
            elseif m_flow<=m_flow_b then
              // Negative flow outside regularization
              dp := (-k2*m_flow^2 + dp_grav_b);
            else
              // Regularization parameters
              dp_a := k1*m_flow_a^2 + dp_grav_a;
              ddp_dm_flow_a := 2*k1*m_flow_a;
              dp_b := -k2*m_flow_b^2 + dp_grav_b;
              ddp_dm_flow_b := -2*k2*m_flow_b;
              // Include a properly defined zero mass flow point
              // Obtain a suitable slope from the linear section slope c (value of dp is overwritten later)
              (dp, ddp_dm_flow_zero) := Utilities.regFun3(m_flow_zero, m_flow_b, m_flow_a, dp_b, dp_a, ddp_dm_flow_b, ddp_dm_flow_a);
              // Do regularization
              if m_flow>m_flow_zero then
                dp := Utilities.regFun3(m_flow, m_flow_zero, m_flow_a, dp_zero, dp_a, ddp_dm_flow_zero, ddp_dm_flow_a);
              else
                dp := Utilities.regFun3(m_flow, m_flow_b, m_flow_zero, dp_b, dp_zero, ddp_dm_flow_b, ddp_dm_flow_zero);
              end if;
            end if;

            annotation (smoothOrder=1, Documentation(info="<html>

</html>"));
          end pressureLoss_m_flow_staticHead;
          annotation (Documentation(info="<html>
<p>
This component defines only the quadratic turbulent regime of wall friction:
dp = k*m_flow*|m_flow|, where \"k\" depends on density and the roughness
of the pipe and is no longer a function of the Reynolds number.
This relationship is only valid for large Reynolds numbers.
</p>

<p>
In <a href=\"modelica://Modelica_Fluid.UsersGuide.ComponentDefinition.WallFriction\">UsersGuide</a> the complete friction regime is illustrated.
This component describes only the asymptotic behaviour for large
Reynolds numbers, i.e., the values at the right ordinate where
&lambda; is constant.
</p>
<br>

</html>"));
        end QuadraticTurbulent;

        package LaminarAndQuadraticTurbulent
          "Pipe wall friction in the laminar and quadratic turbulent regime (simple characteristic)"

          extends PartialWallFriction(
                    final use_mu = true,
                    final use_roughness = true,
                    final use_dp_small = true,
                    final use_m_flow_small = true,
                    final use_Re_turbulent = true);

          import ln = Modelica_Math.log "Logarithm, base e";
          import Modelica_Math.log10 "Logarithm, base 10";
          import Modelica_Math.exp "Exponential function";
          import Modelica_Constants.pi;

          redeclare function extends massFlowRate_dp
            "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction"
            import Math = Modelica_Math;
          protected
            constant Real pi=Modelica_Constants.pi;
            Real zeta;
            Real k0;
            Real k_inv;
            Real yd0 "Derivative of m_flow=m_flow(dp) at zero";
            SI.AbsolutePressure dp_turbulent;
          algorithm
          /*
Turbulent region:
   Re = m_flow*(4/pi)/(D_Re*mu)
   dp = 0.5*zeta*rho*v*|v|
      = 0.5*zeta*rho*1/(rho*A)^2 * m_flow * |m_flow|
      = 0.5*zeta/A^2 *1/rho * m_flow * |m_flow|
      = k/rho * m_flow * |m_flow|
   k  = 0.5*zeta/A^2
      = 0.5*zeta/(pi*(D/2)^2)^2
      = 8*zeta/(pi*D^2)^2
   m_flow_turbulent = (pi/4)*D_Re*mu*Re_turbulent
   dp_turbulent     =  k/rho *(D_Re*mu*pi/4)^2 * Re_turbulent^2

   The start of the turbulent region is computed with mean values
   of dynamic viscosity mu and density rho. Otherwise, one has
   to introduce different "delta" values for both flow directions.
   In order to simplify the approach, only one delta is used.

Laminar region:
   dp = 0.5*zeta/(A^2*d) * m_flow * |m_flow|
      = 0.5 * c0/(|m_flow|*(4/pi)/(D_Re*mu)) / ((pi*(D_Re/2)^2)^2*d) * m_flow*|m_flow|
      = 0.5 * c0*(pi/4)*(D_Re*mu) * 16/(pi^2*D_Re^4*d) * m_flow*|m_flow|
      = 2*c0/(pi*D_Re^3) * mu/rho * m_flow
      = k0 * mu/rho * m_flow
   k0 = 2*c0/(pi*D_Re^3)

   In order that the derivative of dp=f(m_flow) is continuous
   at m_flow=0, the mean values of mu and d are used in the
   laminar region: mu/rho = (mu_a + mu_b)/(rho_a + rho_b)
   If data.zetaLaminarKnown = false then mu_a and mu_b are potentially zero
   (because dummy values) and therefore the division is only performed
   if zetaLaminarKnown = true.
*/
            assert(roughness > 1e-10,
                   "roughness > 0 required for quadratic turbulent wall friction characteristic");
            zeta   := (length/diameter)/(2*Math.log10(3.7 /(roughness/diameter)))^2;
            k0     := 128*length/(pi*diameter^4);
            k_inv  := (pi*diameter*diameter)^2/(8*zeta);
            yd0    := (rho_a + rho_b)/(k0*(mu_a + mu_b));
            dp_turbulent := max(((mu_a + mu_b)*diameter*pi/8)^2*Re_turbulent^2/(k_inv*(rho_a+rho_b)/2), dp_small);
            m_flow := Utilities.regRoot2(
                        dp,
                        dp_turbulent,
                        rho_a*k_inv,
                        rho_b*k_inv,
                        use_yd0=true,
                        yd0=yd0);
            annotation (smoothOrder=1, Documentation(info="<html>

</html>"));
          end massFlowRate_dp;

          redeclare function extends pressureLoss_m_flow
            "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction"
            import Math = Modelica_Math;

          protected
            constant Real pi=Modelica_Constants.pi;
            Real zeta;
            Real k0;
            Real k;
            Real yd0 "Derivative of dp = f(m_flow) at zero";
            SI.MassFlowRate m_flow_turbulent
              "The turbulent region is: |m_flow| >= m_flow_turbulent";

          algorithm
          /*
Turbulent region:
   Re = m_flow*(4/pi)/(D_Re*mu)
   dp = 0.5*zeta*rho*v*|v|
      = 0.5*zeta*rho*1/(rho*A)^2 * m_flow * |m_flow|
      = 0.5*zeta/A^2 *1/rho * m_flow * |m_flow|
      = k/rho * m_flow * |m_flow|
   k  = 0.5*zeta/A^2
      = 0.5*zeta/(pi*(D/2)^2)^2
      = 8*zeta/(pi*D^2)^2
   m_flow_turbulent = (pi/4)*D_Re*mu*Re_turbulent
   dp_turbulent     =  k/rho *(D_Re*mu*pi/4)^2 * Re_turbulent^2

   The start of the turbulent region is computed with mean values
   of dynamic viscosity mu and density rho. Otherwise, one has
   to introduce different "delta" values for both flow directions.
   In order to simplify the approach, only one delta is used.

Laminar region:
   dp = 0.5*zeta/(A^2*d) * m_flow * |m_flow|
      = 0.5 * c0/(|m_flow|*(4/pi)/(D_Re*mu)) / ((pi*(D_Re/2)^2)^2*d) * m_flow*|m_flow|
      = 0.5 * c0*(pi/4)*(D_Re*mu) * 16/(pi^2*D_Re^4*d) * m_flow*|m_flow|
      = 2*c0/(pi*D_Re^3) * mu/rho * m_flow
      = k0 * mu/rho * m_flow
   k0 = 2*c0/(pi*D_Re^3)

   In order that the derivative of dp=f(m_flow) is continuous
   at m_flow=0, the mean values of mu and d are used in the
   laminar region: mu/rho = (mu_a + mu_b)/(rho_a + rho_b)
*/
            assert(roughness > 1e-10,
                   "roughness > 0 required for quadratic turbulent wall friction characteristic");
            zeta := (length/diameter)/(2*Math.log10(3.7 /(roughness/diameter)))^2;
            k0   := 128*length/(pi*diameter^4);
            k    := 8*zeta/(pi*diameter*diameter)^2;
            yd0  := k0*(mu_a + mu_b)/(rho_a + rho_b);
            m_flow_turbulent := max((pi/8)*diameter*(mu_a + mu_b)*Re_turbulent, m_flow_small);
            dp := Utilities.regSquare2(
                        m_flow,
                        m_flow_turbulent,
                        k/rho_a,
                        k/rho_b,
                        use_yd0=true,
                        yd0=yd0);
            annotation (smoothOrder=1, Documentation(info="<html>

</html>"));
          end pressureLoss_m_flow;

          redeclare function extends massFlowRate_dp_staticHead
            "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction and static head"
            import Math = Modelica_Math;

          protected
            Real Delta = roughness/diameter "Relative roughness";
            SI.ReynoldsNumber Re1=min(745*exp(if Delta <= 0.0065 then 1 else
                0.0065/Delta), Re_turbulent)
              "Boundary between laminar regime and transition";
            SI.ReynoldsNumber Re2=Re_turbulent
              "Boundary between transition and turbulent regime";

            SI.Pressure dp_a
              "Upper end of regularization domain of the m_flow(dp) relation";
            SI.Pressure dp_b
              "Lower end of regularization domain of the m_flow(dp) relation";

            SI.MassFlowRate m_flow_a
              "Value at upper end of regularization domain";
            SI.MassFlowRate m_flow_b
              "Value at lower end of regularization domain";

            SI.MassFlowRate dm_flow_ddp_fric_a
              "Derivative at upper end of regularization domain";
            SI.MassFlowRate dm_flow_ddp_fric_b
              "Derivative at lower end of regularization domain";

            SI.Pressure dp_grav_a=g_times_height_ab*rho_a
              "Static head if mass flows in design direction (a to b)";
            SI.Pressure dp_grav_b=g_times_height_ab*rho_b
              "Static head if mass flows against design direction (b to a)";

            // Properly define zero mass flow conditions
            SI.MassFlowRate m_flow_zero=0;
            SI.Pressure dp_zero=(dp_grav_a + dp_grav_b)/2;
            Real dm_flow_ddp_fric_zero;
          algorithm
            assert(roughness > 1e-10,
              "roughness > 0 required for quadratic turbulent wall friction characteristic");

            dp_a := max(dp_grav_a, dp_grav_b)+dp_small;
            dp_b := min(dp_grav_a, dp_grav_b)-dp_small;

            if dp>=dp_a then
              // Positive flow outside regularization
              m_flow := Internal.m_flow_of_dp_fric(dp - dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta);
            elseif dp<=dp_b then
              // Negative flow outside regularization
              m_flow := Internal.m_flow_of_dp_fric(dp-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta);
            else
              // Regularization parameters
              (m_flow_a, dm_flow_ddp_fric_a) := Internal.m_flow_of_dp_fric(dp_a-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta);
              (m_flow_b, dm_flow_ddp_fric_b) := Internal.m_flow_of_dp_fric(dp_b-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta);
              // Include a properly defined zero mass flow point
              // Obtain a suitable slope from the linear section slope c (value of m_flow is overwritten later)
              (m_flow, dm_flow_ddp_fric_zero) := Utilities.regFun3(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a);
              // Do regularization
              if dp>dp_zero then
                m_flow := Utilities.regFun3(dp, dp_zero, dp_a, m_flow_zero, m_flow_a, dm_flow_ddp_fric_zero, dm_flow_ddp_fric_a);
              else
                m_flow := Utilities.regFun3(dp, dp_b, dp_zero, m_flow_b, m_flow_zero, dm_flow_ddp_fric_b, dm_flow_ddp_fric_zero);
              end if;
            end if;
            annotation (smoothOrder=1, Documentation(info="<html>

</html>"));
          end massFlowRate_dp_staticHead;

          redeclare function extends pressureLoss_m_flow_staticHead
            "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction and static head"
            import Math = Modelica_Math;

          protected
            Real Delta = roughness/diameter "Relative roughness";
            SI.ReynoldsNumber Re1=min(745*exp(if Delta <= 0.0065 then 1 else
                0.0065/Delta), Re_turbulent)
              "Boundary between laminar regime and transition";
            SI.ReynoldsNumber Re2=Re_turbulent
              "Boundary between transition and turbulent regime";

            SI.MassFlowRate m_flow_a
              "Upper end of regularization domain of the dp(m_flow) relation";
            SI.MassFlowRate m_flow_b
              "Lower end of regularization domain of the dp(m_flow) relation";

            SI.Pressure dp_a "Value at upper end of regularization domain";
            SI.Pressure dp_b "Value at lower end of regularization domain";

            SI.Pressure dp_grav_a=g_times_height_ab*rho_a
              "Static head if mass flows in design direction (a to b)";
            SI.Pressure dp_grav_b=g_times_height_ab*rho_b
              "Static head if mass flows against design direction (b to a)";

            Real ddp_dm_flow_a
              "Derivative of pressure drop with mass flow rate at m_flow_a";
            Real ddp_dm_flow_b
              "Derivative of pressure drop with mass flow rate at m_flow_b";

            // Properly define zero mass flow conditions
            SI.MassFlowRate m_flow_zero=0;
            SI.Pressure dp_zero=(dp_grav_a + dp_grav_b)/2;
            Real ddp_dm_flow_zero;

          algorithm
            assert(roughness > 1e-10,
              "roughness > 0 required for quadratic turbulent wall friction characteristic");

            m_flow_a := if dp_grav_a<dp_grav_b then
              Internal.m_flow_of_dp_fric(dp_grav_b - dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter,  Re1, Re2, Delta)+m_flow_small else
              m_flow_small;
            m_flow_b := if dp_grav_a<dp_grav_b then
              Internal.m_flow_of_dp_fric(dp_grav_a - dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter,  Re1, Re2, Delta)-m_flow_small else
              -m_flow_small;

            if m_flow>=m_flow_a then
              // Positive flow outside regularization
              dp := Internal.dp_fric_of_m_flow(m_flow, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta) + dp_grav_a;
            elseif m_flow<=m_flow_b then
              // Negative flow outside regularization
              dp := Internal.dp_fric_of_m_flow(m_flow, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta) + dp_grav_b;
            else
              // Regularization parameters
              (dp_a, ddp_dm_flow_a) := Internal.dp_fric_of_m_flow(m_flow_a, rho_a, rho_b, mu_a, mu_b, length, diameter,  Re1, Re2, Delta);
              dp_a := dp_a + dp_grav_a "Adding dp_grav to dp_fric to get dp";
              (dp_b, ddp_dm_flow_b) := Internal.dp_fric_of_m_flow(m_flow_b, rho_a, rho_b, mu_a, mu_b, length, diameter,  Re1, Re2, Delta);
              dp_b := dp_b + dp_grav_b "Adding dp_grav to dp_fric to get dp";
              // Include a properly defined zero mass flow point
              // Obtain a suitable slope from the linear section slope c (value of dp is overwritten later)
              (dp, ddp_dm_flow_zero) := Utilities.regFun3(m_flow_zero, m_flow_b, m_flow_a, dp_b, dp_a, ddp_dm_flow_b, ddp_dm_flow_a);
              // Do regularization
              if m_flow>m_flow_zero then
                dp := Utilities.regFun3(m_flow, m_flow_zero, m_flow_a, dp_zero, dp_a, ddp_dm_flow_zero, ddp_dm_flow_a);
              else
                dp := Utilities.regFun3(m_flow, m_flow_b, m_flow_zero, dp_b, dp_zero, ddp_dm_flow_b, ddp_dm_flow_zero);
              end if;
            end if;
            annotation (smoothOrder=1, Documentation(info="<html>

</html>"));
          end pressureLoss_m_flow_staticHead;

          package Internal
            "Functions to calculate mass flow rate from friction pressure drop and vice versa"
            extends Modelica_Icons.InternalPackage;
            function m_flow_of_dp_fric
              "Calculate mass flow rate as function of pressure drop due to friction"
              extends Modelica_Icons.Function;

              input SI.Pressure dp_fric
                "Pressure loss due to friction (dp = port_a.p - port_b.p)";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input SI.ReynoldsNumber Re1
                "Boundary between laminar regime and transition";
              input SI.ReynoldsNumber Re2
                "Boundary between transition and turbulent regime";
              input Real Delta "Relative roughness";
              output SI.MassFlowRate m_flow
                "Mass flow rate from port_a to port_b";
              output Real dm_flow_ddp_fric
                "Derivative of mass flow rate with dp_fric";
            protected
              SI.DynamicViscosity mu "Upstream viscosity";
              SI.Density rho "Upstream density";

              Real zeta;
              Real k0;
              Real k_inv;
              Real dm_flow_ddp_laminar
                "Derivative of m_flow=m_flow(dp) in laminar regime";
              SI.AbsolutePressure dp_fric_turbulent
                "The turbulent region is: |dp_fric| >= dp_fric_turbulent, simple quadratic correlation";
              SI.AbsolutePressure dp_fric_laminar
                "The laminar region is: |dp_fric| <= dp_fric_laminar";
            algorithm
            /*
Turbulent region:
   Re = m_flow*(4/pi)/(D_Re*mu)
   dp = 0.5*zeta*rho*v*|v|
      = 0.5*zeta*rho*1/(rho*A)^2 * m_flow * |m_flow|
      = 0.5*zeta/A^2 *1/rho * m_flow * |m_flow|
      = k/rho * m_flow * |m_flow|
   k  = 0.5*zeta/A^2
      = 0.5*zeta/(pi*(D/2)^2)^2
      = 8*zeta/(pi*D^2)^2
   dp_fric_turbulent     =  k/rho *(D_Re*mu*pi/4)^2 * Re_turbulent^2

Laminar region:
   dp = 0.5*zeta/(A^2*d) * m_flow * |m_flow|
      = 0.5 * c0/(|m_flow|*(4/pi)/(D_Re*mu)) / ((pi*(D_Re/2)^2)^2*d) * m_flow*|m_flow|
      = 0.5 * c0*(pi/4)*(D_Re*mu) * 16/(pi^2*D_Re^4*d) * m_flow*|m_flow|
      = 2*c0/(pi*D_Re^3) * mu/rho * m_flow
      = k0 * mu/rho * m_flow
   k0 = 2*c0/(pi*D_Re^3)
*/
              // Determine upstream density and upstream viscosity
              if dp_fric >= 0 then
                rho := rho_a;
                mu  := mu_a;
              else
                rho := rho_b;
                mu  := mu_b;
              end if;
              // Quadratic turbulent
              zeta := (length/diameter)/(2*log10(3.7/(Delta)))^2;
              k_inv := (pi*diameter*diameter)^2/(8*zeta);
              dp_fric_turbulent := sign(dp_fric)*(mu*diameter*pi/4)^2*Re2^2/(k_inv*rho);

              // Laminar
              k0 := 128*length/(pi*diameter^4);
              dm_flow_ddp_laminar := rho/(k0*mu);
              dp_fric_laminar := sign(dp_fric)*pi*k0*mu^2/rho*diameter/4*Re1;

              if abs(dp_fric) > abs(dp_fric_turbulent) then
                m_flow := sign(dp_fric)*sqrt(rho*k_inv*abs(dp_fric));
                dm_flow_ddp_fric := 0.5*rho*k_inv*(rho*k_inv*abs(dp_fric))^(-0.5);
              elseif abs(dp_fric) < abs(dp_fric_laminar) then
                m_flow := dm_flow_ddp_laminar*dp_fric;
                dm_flow_ddp_fric := dm_flow_ddp_laminar;
              else
                // Preliminary testing seems to indicate that the log-log transform is not required here
                (m_flow,dm_flow_ddp_fric) := Utilities.cubicHermite_withDerivative(
                  dp_fric, dp_fric_laminar, dp_fric_turbulent, dm_flow_ddp_laminar*dp_fric_laminar,
                  sign(dp_fric_turbulent)*sqrt(rho*k_inv*abs(dp_fric_turbulent)), dm_flow_ddp_laminar,
                  if abs(dp_fric_turbulent)>0 then 0.5*rho*k_inv*(rho*k_inv*abs(dp_fric_turbulent))^(-0.5) else
                  Modelica_Constants.inf);
              end if;
              annotation (smoothOrder=1);
            end m_flow_of_dp_fric;

            function dp_fric_of_m_flow
              "Calculate pressure drop due to friction as function of mass flow rate"
              extends Modelica_Icons.Function;

              input SI.MassFlowRate m_flow
                "Mass flow rate from port_a to port_b";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input SI.ReynoldsNumber Re1
                "Boundary between laminar regime and transition";
              input SI.ReynoldsNumber Re2
                "Boundary between transition and turbulent regime";
              input Real Delta "Relative roughness";
              output SI.Pressure dp_fric
                "Pressure loss due to friction (dp_fric = port_a.p - port_b.p - dp_grav)";
              output Real ddp_fric_dm_flow
                "Derivative of pressure drop with mass flow rate";
            protected
              SI.DynamicViscosity mu "Upstream viscosity";
              SI.Density rho "Upstream density";
              Real zeta;
              Real k0;
              Real k;
              Real ddp_fric_dm_flow_laminar
                "Derivative of dp_fric = f(m_flow) at zero";
              SI.MassFlowRate m_flow_turbulent
                "The turbulent region is: |m_flow| >= m_flow_turbulent";
              SI.MassFlowRate m_flow_laminar
                "The laminar region is: |m_flow| <= m_flow_laminar";
            algorithm
            /*
Turbulent region:
   Re = m_flow*(4/pi)/(D_Re*mu)
   dp = 0.5*zeta*rho*v*|v|
      = 0.5*zeta*rho*1/(rho*A)^2 * m_flow * |m_flow|
      = 0.5*zeta/A^2 *1/rho * m_flow * |m_flow|
      = k/rho * m_flow * |m_flow|
   k  = 0.5*zeta/A^2
      = 0.5*zeta/(pi*(D/2)^2)^2
      = 8*zeta/(pi*D^2)^2
   m_flow_turbulent = (pi/4)*D_Re*mu*Re_turbulent

Laminar region:
   dp = 0.5*zeta/(A^2*d) * m_flow * |m_flow|
      = 0.5 * c0/(|m_flow|*(4/pi)/(D_Re*mu)) / ((pi*(D_Re/2)^2)^2*d) * m_flow*|m_flow|
      = 0.5 * c0*(pi/4)*(D_Re*mu) * 16/(pi^2*D_Re^4*d) * m_flow*|m_flow|
      = 2*c0/(pi*D_Re^3) * mu/rho * m_flow
      = k0 * mu/rho * m_flow
   k0 = 2*c0/(pi*D_Re^3)
*/
              // Determine upstream density and upstream viscosity
              if m_flow >= 0 then
                rho := rho_a;
                mu  := mu_a;
              else
                rho := rho_b;
                mu  := mu_b;
              end if;

              // Turbulent
              zeta := (length/diameter)/(2*log10(3.7/(Delta)))^2;
              k := 8*zeta/(pi*diameter*diameter)^2;
              m_flow_turbulent := sign(m_flow)*(pi/4)*diameter*mu*Re2;

              // Laminar
              k0 := 128*length/(pi*diameter^4);
              ddp_fric_dm_flow_laminar := k0*mu/rho;
              m_flow_laminar := sign(m_flow)*(pi/4)*diameter*mu*Re1;

              if abs(m_flow) > abs(m_flow_turbulent) then
                dp_fric := k/rho*m_flow*abs(m_flow);
                ddp_fric_dm_flow := 2*k/rho*abs(m_flow);
              elseif abs(m_flow) < abs(m_flow_laminar) then
                dp_fric := ddp_fric_dm_flow_laminar*m_flow;
                ddp_fric_dm_flow := ddp_fric_dm_flow_laminar;
              else
                // Preliminary testing seems to indicate that the log-log transform is not required here
                (dp_fric,ddp_fric_dm_flow) := Utilities.cubicHermite_withDerivative(
                  m_flow, m_flow_laminar, m_flow_turbulent, ddp_fric_dm_flow_laminar*m_flow_laminar,
                  k/rho*m_flow_turbulent*abs(m_flow_turbulent), ddp_fric_dm_flow_laminar, 2*k/rho*abs(m_flow_turbulent));
              end if;
              annotation (smoothOrder=1);
            end dp_fric_of_m_flow;
          end Internal;
          annotation (Documentation(info="<html>
<p>
This component defines the quadratic turbulent regime of wall friction:
dp = k*m_flow*|m_flow|, where \"k\" depends on density and the roughness
of the pipe and is no longer a function of the Reynolds number.
This relationship is only valid for large Reynolds numbers.
At Re=4000, a polynomial is constructed that approaches
the constant &lambda; (for large Reynolds-numbers) at Re=4000
smoothly and has a derivative at zero mass flow rate that is
identical to laminar wall friction.
</p>
</html>"));
        end LaminarAndQuadraticTurbulent;

        package Detailed
          "Pipe wall friction in the whole regime (detailed characteristic)"

          extends PartialWallFriction(
                    final use_mu = true,
                    final use_roughness = true,
                    final use_dp_small = true,
                    final use_m_flow_small = true,
                    final use_Re_turbulent = true);

          import ln = Modelica_Math.log "Logarithm, base e";
          import Modelica_Math.log10 "Logarithm, base 10";
          import Modelica_Math.exp "Exponential function";
          import Modelica_Constants.pi;

          redeclare function extends massFlowRate_dp
            "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction"
            import Math = Modelica_Math;
          protected
            constant Real pi=Modelica_Constants.pi;
            Real Delta = roughness/diameter "Relative roughness";
            SI.ReynoldsNumber Re1=min((745*Modelica_Math.exp(if Delta <= 0.0065
                 then 1 else 0.0065/Delta))^0.97, Re_turbulent)
              "Re leaving laminar curve";
            SI.ReynoldsNumber Re2=Re_turbulent "Re entering turbulent curve";
            SI.DynamicViscosity mu "Upstream viscosity";
            SI.Density rho "Upstream density";
            SI.ReynoldsNumber Re "Reynolds number";
            Real lambda2 "Modified friction coefficient (= lambda*Re^2)";

            function interpolateInRegion2
               input Real Re_turbulent;
              input SI.ReynoldsNumber Re1;
              input SI.ReynoldsNumber Re2;
               input Real Delta;
               input Real lambda2;
              output SI.ReynoldsNumber Re;
              // point lg(lambda2(Re1)) with derivative at lg(Re1)
            protected
              Real x1=Modelica_Math.log10(64*Re1);
              Real y1=Modelica_Math.log10(Re1);
              Real yd1=1;

              // Point lg(lambda2(Re2)) with derivative at lg(Re2)
              Real aux1=(0.5/Modelica_Math.log(10))*5.74*0.9;
              Real aux2=Delta/3.7 + 5.74/Re2^0.9;
              Real aux3=Modelica_Math.log10(aux2);
              Real L2=0.25*(Re2/aux3)^2;
              Real aux4=2.51/sqrt(L2) + 0.27*Delta;
              Real aux5=-2*sqrt(L2)*Modelica_Math.log10(aux4);
              Real x2=Modelica_Math.log10(L2);
              Real y2=Modelica_Math.log10(aux5);
              Real yd2=0.5 + (2.51/Modelica_Math.log(10))/(aux5*aux4);

              // Constants: Cubic polynomial between lg(Re1) and lg(Re2)
              Real diff_x=x2 - x1;
              Real m=(y2 - y1)/diff_x;
              Real c2=(3*m - 2*yd1 - yd2)/diff_x;
              Real c3=(yd1 + yd2 - 2*m)/(diff_x*diff_x);
              Real lambda2_1=64*Re1;
              Real dx;
            algorithm
               dx :=Modelica_Math.log10(lambda2/lambda2_1);
               Re := Re1*(lambda2/lambda2_1)^(1 + dx*(c2 + dx*c3));
               annotation(smoothOrder=1);
            end interpolateInRegion2;

          algorithm
            // Determine upstream density, upstream viscosity, and lambda2
            rho     := if dp >= 0 then rho_a else rho_b;
            mu      := if dp >= 0 then mu_a else mu_b;
            lambda2 := abs(dp)*2*diameter^3*rho/(length*mu*mu);

            // Determine Re under the assumption of laminar flow
            Re := lambda2/64;

            // Modify Re, if turbulent flow
            if Re > Re1 then
               Re :=-2*sqrt(lambda2)*Math.log10(2.51/sqrt(lambda2) + 0.27*Delta);
               if Re < Re2 then
                  Re := interpolateInRegion2(Re, Re1, Re2, Delta, lambda2);
               end if;
            end if;

            // Determine mass flow rate
            m_flow := (pi*diameter/4)*mu*(if dp >= 0 then Re else -Re);
                    annotation (smoothOrder=1, Documentation(info="<html>

</html>"));
          end massFlowRate_dp;

          redeclare function extends pressureLoss_m_flow
            "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction"
            import Math = Modelica_Math;
          protected
            constant Real pi=Modelica_Constants.pi;
            Real Delta = roughness/diameter "Relative roughness";
            SI.ReynoldsNumber Re1=min(745*Modelica_Math.exp(if Delta <= 0.0065
                 then 1 else 0.0065/Delta), Re_turbulent)
              "Re leaving laminar curve";
            SI.ReynoldsNumber Re2=Re_turbulent "Re entering turbulent curve";
            SI.DynamicViscosity mu "Upstream viscosity";
            SI.Density rho "Upstream density";
            SI.ReynoldsNumber Re "Reynolds number";
            Real lambda2 "Modified friction coefficient (= lambda*Re^2)";

            function interpolateInRegion2
              input SI.ReynoldsNumber Re;
              input SI.ReynoldsNumber Re1;
              input SI.ReynoldsNumber Re2;
               input Real Delta;
               output Real lambda2;
              // point lg(lambda2(Re1)) with derivative at lg(Re1)
            protected
              Real x1=Modelica_Math.log10(Re1);
              Real y1=Modelica_Math.log10(64*Re1);
              Real yd1=1;

              // Point lg(lambda2(Re2)) with derivative at lg(Re2)
              Real aux1=(0.5/Modelica_Math.log(10))*5.74*0.9;
              Real aux2=Delta/3.7 + 5.74/Re2^0.9;
              Real aux3=Modelica_Math.log10(aux2);
              Real L2=0.25*(Re2/aux3)^2;
              Real aux4=2.51/sqrt(L2) + 0.27*Delta;
              Real aux5=-2*sqrt(L2)*Modelica_Math.log10(aux4);
              Real x2=Modelica_Math.log10(Re2);
              Real y2=Modelica_Math.log10(L2);
              Real yd2 = 2 + 4*aux1/(aux2*aux3*(Re2)^0.9);

              // Constants: Cubic polynomial between lg(Re1) and lg(Re2)
              Real diff_x=x2 - x1;
              Real m=(y2 - y1)/diff_x;
              Real c2=(3*m - 2*yd1 - yd2)/diff_x;
              Real c3=(yd1 + yd2 - 2*m)/(diff_x*diff_x);
              Real dx;
            algorithm
               dx :=Modelica_Math.log10(Re/Re1);
               lambda2 := 64*Re1*(Re/Re1)^(1 + dx*(c2 + dx*c3));
               annotation(smoothOrder=1);
            end interpolateInRegion2;
          algorithm
            // Determine upstream density and upstream viscosity
            rho     :=if m_flow >= 0 then rho_a else rho_b;
            mu      :=if m_flow >= 0 then mu_a else mu_b;

            // Determine Re, lambda2 and pressure drop
            Re :=(4/pi)*abs(m_flow)/(diameter*mu);
            lambda2 := if Re <= Re1 then 64*Re else
                      (if Re >= Re2 then 0.25*(Re/Math.log10(Delta/3.7 + 5.74/Re^0.9))^2 else
                       interpolateInRegion2(Re, Re1, Re2, Delta));
            dp :=length*mu*mu/(2*rho*diameter*diameter*diameter)*
                 (if m_flow >= 0 then lambda2 else -lambda2);
                    annotation (smoothOrder=1, Documentation(info="<html>

</html>"));
          end pressureLoss_m_flow;

          redeclare function extends massFlowRate_dp_staticHead
            "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction and static head"

          protected
            Real Delta = roughness/diameter "Relative roughness";
            SI.ReynoldsNumber Re "Reynolds number";
            SI.ReynoldsNumber Re1=min((745*exp(if Delta <= 0.0065 then 1 else
                0.0065/Delta))^0.97, Re_turbulent)
              "Boundary between laminar regime and transition";
            SI.ReynoldsNumber Re2=Re_turbulent
              "Boundary between transition and turbulent regime";
            SI.Pressure dp_a
              "Upper end of regularization domain of the m_flow(dp) relation";
            SI.Pressure dp_b
              "Lower end of regularization domain of the m_flow(dp) relation";
            SI.MassFlowRate m_flow_a
              "Value at upper end of regularization domain";
            SI.MassFlowRate m_flow_b
              "Value at lower end of regularization domain";

            SI.MassFlowRate dm_flow_ddp_fric_a
              "Derivative at upper end of regularization domain";
            SI.MassFlowRate dm_flow_ddp_fric_b
              "Derivative at lower end of regularization domain";

            SI.Pressure dp_grav_a=g_times_height_ab*rho_a
              "Static head if mass flows in design direction (a to b)";
            SI.Pressure dp_grav_b=g_times_height_ab*rho_b
              "Static head if mass flows against design direction (b to a)";

            // Properly define zero mass flow conditions
            SI.MassFlowRate m_flow_zero=0;
            SI.Pressure dp_zero=(dp_grav_a + dp_grav_b)/2;
            Real dm_flow_ddp_fric_zero;

          algorithm
            dp_a := max(dp_grav_a, dp_grav_b)+dp_small;
            dp_b := min(dp_grav_a, dp_grav_b)-dp_small;

            if dp>=dp_a then
              // Positive flow outside regularization
              m_flow := Internal.m_flow_of_dp_fric(dp-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta);
            elseif dp<=dp_b then
              // Negative flow outside regularization
              m_flow := Internal.m_flow_of_dp_fric(dp-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta);
            else
              // Regularization parameters
              (m_flow_a, dm_flow_ddp_fric_a) := Internal.m_flow_of_dp_fric(dp_a-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta);
              (m_flow_b, dm_flow_ddp_fric_b) := Internal.m_flow_of_dp_fric(dp_b-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta);
              // Include a properly defined zero mass flow point
              // Obtain a suitable slope from the linear section slope c (value of m_flow is overwritten later)
              (m_flow, dm_flow_ddp_fric_zero) := Utilities.regFun3(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a);
              // Do regularization
              if dp>dp_zero then
                m_flow := Utilities.regFun3(dp, dp_zero, dp_a, m_flow_zero, m_flow_a, dm_flow_ddp_fric_zero, dm_flow_ddp_fric_a);
              else
                m_flow := Utilities.regFun3(dp, dp_b, dp_zero, m_flow_b, m_flow_zero, dm_flow_ddp_fric_b, dm_flow_ddp_fric_zero);
              end if;
            end if;
            annotation (smoothOrder=1);
          end massFlowRate_dp_staticHead;

          redeclare function extends pressureLoss_m_flow_staticHead
            "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction and static head"

          protected
            Real Delta = roughness/diameter "Relative roughness";
            SI.ReynoldsNumber Re1=min(745*exp(if Delta <= 0.0065 then 1 else
                0.0065/Delta), Re_turbulent)
              "Boundary between laminar regime and transition";
            SI.ReynoldsNumber Re2=Re_turbulent
              "Boundary between transition and turbulent regime";

            SI.MassFlowRate m_flow_a
              "Upper end of regularization domain of the dp(m_flow) relation";
            SI.MassFlowRate m_flow_b
              "Lower end of regularization domain of the dp(m_flow) relation";

            SI.Pressure dp_a "Value at upper end of regularization domain";
            SI.Pressure dp_b "Value at lower end of regularization domain";

            SI.Pressure dp_grav_a=g_times_height_ab*rho_a
              "Static head if mass flows in design direction (a to b)";
            SI.Pressure dp_grav_b=g_times_height_ab*rho_b
              "Static head if mass flows against design direction (b to a)";

            Real ddp_dm_flow_a
              "Derivative of pressure drop with mass flow rate at m_flow_a";
            Real ddp_dm_flow_b
              "Derivative of pressure drop with mass flow rate at m_flow_b";

            // Properly define zero mass flow conditions
            SI.MassFlowRate m_flow_zero=0;
            SI.Pressure dp_zero=(dp_grav_a + dp_grav_b)/2;
            Real ddp_dm_flow_zero;

          algorithm
            m_flow_a := if dp_grav_a<dp_grav_b then
              Internal.m_flow_of_dp_fric(dp_grav_b - dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta)+m_flow_small else
              m_flow_small;
            m_flow_b := if dp_grav_a<dp_grav_b then
              Internal.m_flow_of_dp_fric(dp_grav_a - dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta)-m_flow_small else
              -m_flow_small;

            if m_flow>=m_flow_a then
              // Positive flow outside regularization
              dp := Internal.dp_fric_of_m_flow(m_flow, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta) + dp_grav_a;
            elseif m_flow<=m_flow_b then
              // Negative flow outside regularization
              dp := Internal.dp_fric_of_m_flow(m_flow, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta) + dp_grav_b;
            else
              // Regularization parameters
              (dp_a, ddp_dm_flow_a) := Internal.dp_fric_of_m_flow(m_flow_a, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta);
              dp_a := dp_a + dp_grav_a "Adding dp_grav to dp_fric to get dp";
              (dp_b, ddp_dm_flow_b) := Internal.dp_fric_of_m_flow(m_flow_b, rho_a, rho_b, mu_a, mu_b, length, diameter, Re1, Re2, Delta);
              dp_b := dp_b + dp_grav_b "Adding dp_grav to dp_fric to get dp";
              // Include a properly defined zero mass flow point
              // Obtain a suitable slope from the linear section slope c (value of dp is overwritten later)
              (dp, ddp_dm_flow_zero) := Utilities.regFun3(m_flow_zero, m_flow_b, m_flow_a, dp_b, dp_a, ddp_dm_flow_b, ddp_dm_flow_a);
              // Do regularization
              if m_flow>m_flow_zero then
                dp := Utilities.regFun3(m_flow, m_flow_zero, m_flow_a, dp_zero, dp_a, ddp_dm_flow_zero, ddp_dm_flow_a);
              else
                dp := Utilities.regFun3(m_flow, m_flow_b, m_flow_zero, dp_b, dp_zero, ddp_dm_flow_b, ddp_dm_flow_zero);
              end if;
            end if;
            annotation (smoothOrder=1);
          end pressureLoss_m_flow_staticHead;

        package Internal
            "Functions to calculate mass flow rate from friction pressure drop and vice versa"
          extends Modelica_Icons.InternalPackage;
          function m_flow_of_dp_fric
              "Calculate mass flow rate as function of pressure drop due to friction"
            extends Modelica_Icons.Function;

              input SI.Pressure dp_fric
                "Pressure loss due to friction (dp = port_a.p - port_b.p)";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input SI.ReynoldsNumber Re1
                "Boundary between laminar regime and transition";
              input SI.ReynoldsNumber Re2
                "Boundary between transition and turbulent regime";
            input Real Delta "Relative roughness";
              output SI.MassFlowRate m_flow
                "Mass flow rate from port_a to port_b";
            output Real dm_flow_ddp_fric
                "Derivative of mass flow rate with dp_fric";

            protected
            function interpolateInRegion2_withDerivative
                "Interpolation in log-log space using a cubic Hermite polynomial, where x=log10(lambda2), y=log10(Re)"

              input Real lambda2 "Known independent variable";
                input SI.ReynoldsNumber Re1
                  "Boundary between laminar regime and transition";
                input SI.ReynoldsNumber Re2
                  "Boundary between transition and turbulent regime";
              input Real Delta "Relative roughness";
                input SI.Pressure dp_fric
                  "Pressure loss due to friction (dp = port_a.p - port_b.p)";
                output SI.ReynoldsNumber Re "Unknown return variable";
              output Real dRe_ddp "Derivative of return value";
              // point lg(lambda2(Re1)) with derivative at lg(Re1)
              protected
              Real x1=log10(64*Re1);
              Real y1=log10(Re1);
              Real y1d=1;

              // Point lg(lambda2(Re2)) with derivative at lg(Re2)
              Real aux2=Delta/3.7 + 5.74/Re2^0.9;
              Real aux3=log10(aux2);
              Real L2=0.25*(Re2/aux3)^2;
              Real aux4=2.51/sqrt(L2) + 0.27*Delta;
              Real aux5=-2*sqrt(L2)*log10(aux4);
              Real x2=log10(L2);
              Real y2=log10(aux5);
              Real y2d=0.5 + (2.51/log(10))/(aux5*aux4);

              // Point of interest in transformed space
              Real x=log10(lambda2);
              Real y;
              Real dy_dx "Derivative in transformed space";
            algorithm
              // Interpolation
              (y, dy_dx) := Utilities.cubicHermite_withDerivative(x, x1, x2, y1, y2, y1d, y2d);

              // Return value
              Re := 10^y;

              // Derivative of return value
              dRe_ddp := Re/abs(dp_fric)*dy_dx;
              annotation (smoothOrder=1);
            end interpolateInRegion2_withDerivative;

              SI.DynamicViscosity mu "Upstream viscosity";
              SI.Density rho "Upstream density";
            Real lambda2 "Modified friction coefficient (= lambda*Re^2)";
              SI.ReynoldsNumber Re "Reynolds number";
            Real dRe_ddp "dRe/ddp";
            Real aux1;
            Real aux2;

          algorithm
            // Determine upstream density and upstream viscosity
            if dp_fric >= 0 then
              rho := rho_a;
              mu  := mu_a;
            else
              rho := rho_b;
              mu  := mu_b;
            end if;

            // Positive mass flow rate
            lambda2 := abs(dp_fric)*2*diameter^3*rho/(length*mu*mu)
                "Known as lambda2=f(dp)";

            aux1:=(2*diameter^3*rho)/(length*mu^2);

            // Determine Re and dRe/ddp under the assumption of laminar flow
            Re := lambda2/64 "Hagen-Poiseuille";
            dRe_ddp := aux1/64 "Hagen-Poiseuille";

            // Modify Re, if turbulent flow
            if Re > Re1 then
              Re :=-2*sqrt(lambda2)*log10(2.51/sqrt(lambda2) + 0.27*Delta)
                  "Colebrook-White";
              aux2 := sqrt(aux1*abs(dp_fric));
              dRe_ddp := 1/log(10)*(-2*log(2.51/aux2+0.27*Delta)*aux1/(2*aux2)+2*2.51/(2*abs(dp_fric)*(2.51/aux2+0.27*Delta)));
              if Re < Re2 then
                (Re, dRe_ddp) := interpolateInRegion2_withDerivative(lambda2, Re1, Re2, Delta, dp_fric);
              end if;
            end if;

            // Determine mass flow rate
            m_flow := (pi*diameter/4)*mu*(if dp_fric >= 0 then Re else -Re);
            // Determine derivative of mass flow rate with dp_fric
            dm_flow_ddp_fric := (pi*diameter*mu)/4*dRe_ddp;
            annotation(smoothOrder=1);
          end m_flow_of_dp_fric;

          function dp_fric_of_m_flow
              "Calculate pressure drop due to friction as function of mass flow rate"
            extends Modelica_Icons.Function;

              input SI.MassFlowRate m_flow
                "Mass flow rate from port_a to port_b";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input SI.ReynoldsNumber Re1
                "Boundary between laminar regime and transition";
              input SI.ReynoldsNumber Re2
                "Boundary between transition and turbulent regime";
            input Real Delta "Relative roughness";
              output SI.Pressure dp_fric
                "Pressure loss due to friction (dp_fric = port_a.p - port_b.p - dp_grav)";
            output Real ddp_fric_dm_flow
                "Derivative of pressure drop with mass flow rate";

            protected
            function interpolateInRegion2
                "Interpolation in log-log space using a cubic Hermite polynomial, where x=log10(Re), y=log10(lambda2)"

                input SI.ReynoldsNumber Re "Known independent variable";
                input SI.ReynoldsNumber Re1
                  "Boundary between laminar regime and transition";
                input SI.ReynoldsNumber Re2
                  "Boundary between transition and turbulent regime";
              input Real Delta "Relative roughness";
                input SI.MassFlowRate m_flow
                  "Mass flow rate from port_a to port_b";
              output Real lambda2 "Unknown return value";
              output Real dlambda2_dm_flow "Derivative of return value";
              // point lg(lambda2(Re1)) with derivative at lg(Re1)
              protected
              Real x1 = log10(Re1);
              Real y1 = log10(64*Re1);
              Real y1d = 1;

              // Point lg(lambda2(Re2)) with derivative at lg(Re2)
              Real aux2 = Delta/3.7 + 5.74/Re2^0.9;
              Real aux3 = log10(aux2);
              Real L2 = 0.25*(Re2/aux3)^2;
              Real x2 = log10(Re2);
              Real y2 = log10(L2);
              Real y2d = 2+(2*5.74*0.9)/(log(aux2)*Re2^0.9*aux2);

              // Point of interest in transformed space
              Real x=log10(Re);
              Real y;
              Real dy_dx "Derivative in transformed space";
            algorithm
              // Interpolation
              (y, dy_dx) := Utilities.cubicHermite_withDerivative(x, x1, x2, y1, y2, y1d, y2d);

              // Return value
              lambda2 := 10^y;

              // Derivative of return value
              dlambda2_dm_flow := lambda2/abs(m_flow)*dy_dx;
              annotation(smoothOrder=1);
            end interpolateInRegion2;

              SI.DynamicViscosity mu "Upstream viscosity";
              SI.Density rho "Upstream density";
              SI.ReynoldsNumber Re "Reynolds number";
            Real lambda2 "Modified friction coefficient (= lambda*Re^2)";
            Real dlambda2_dm_flow "dlambda2/dm_flow";
            Real aux1;
            Real aux2;

          algorithm
            // Determine upstream density and upstream viscosity
            if m_flow >= 0 then
              rho := rho_a;
              mu  := mu_a;
            else
              rho := rho_b;
              mu  := mu_b;
            end if;

            // Determine Reynolds number
            Re :=(4/pi)*abs(m_flow)/(diameter*mu);

            aux1 := 4/(pi*diameter*mu);

            // Use correlation for lambda2 depending on actual conditions
            if Re <= Re1 then
              lambda2 := 64*Re "Hagen-Poiseuille";
              dlambda2_dm_flow := 64*aux1 "Hagen-Poiseuille";
            elseif Re >= Re2 then
              lambda2 := 0.25*(Re/log10(Delta/3.7 + 5.74/Re^0.9))^2
                  "Swamee-Jain";
              aux2 := Delta/3.7+5.74/((aux1*abs(m_flow))^0.9);
              dlambda2_dm_flow := 0.5*aux1*Re*log(10)^2*(1/(log(aux2)^2)+(5.74*0.9)/(log(aux2)^3*Re^0.9*aux2))
                  "Swamee-Jain";
            else
              (lambda2, dlambda2_dm_flow) := interpolateInRegion2(Re, Re1, Re2, Delta, m_flow);
            end if;

            // Compute pressure drop from lambda2
            dp_fric :=length*mu*mu/(2*rho*diameter*diameter*diameter)*
                 (if m_flow >= 0 then lambda2 else -lambda2);

            // Compute derivative from dlambda2/dm_flow
            ddp_fric_dm_flow := (length*mu^2)/(2*diameter^3*rho)*dlambda2_dm_flow;
            annotation(smoothOrder=1);
          end dp_fric_of_m_flow;
        end Internal;
          annotation (Documentation(info="<html>
<p>
This component defines the complete regime of wall friction.
The details are described in the
<a href=\"modelica://Modelica_Fluid.UsersGuide.ComponentDefinition.WallFriction\">UsersGuide</a>.
The functional relationship of the friction loss factor &lambda; is
displayed in the next figure. Function massFlowRate_dp() defines the \"red curve\"
(\"Swamee and Jain\"), where as function pressureLoss_m_flow() defines the
\"blue curve\" (\"Colebrook-White\"). The two functions are inverses from
each other and give slightly different results in the transition region
between Re = 1500 .. 4000, in order to get explicit equations without
solving a non-linear equation.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFriction1.png\"
     alt=\"PipeFriction1.png\">
</p>

<p>
Additionally to wall friction, this component properly implements static
head. With respect to the latter, two cases can be distinguished. In the case
shown next, the change of elevation with the path from a to b has the opposite
sign of the change of density.</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFrictionStaticHead_case-a.png\"
     alt=\"PipeFrictionStaticHead_case-a.png\">
</p>

<p>
In the case illustrated second, the change of elevation with the path from a to
b has the same sign of the change of density.</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFrictionStaticHead_case-b.png\"
     alt=\"PipeFrictionStaticHead_case-b.png\">
</p>

</html>"));
        end Detailed;

        model TestWallFrictionAndGravity
          "Pressure loss in pipe due to wall friction and gravity (only for test purposes; if needed use Pipes.StaticPipe instead)"
          extends Modelica_Fluid_Interfaces.PartialTwoPortTransport(dp_start=
                dp_fric_nominal + system.g*height_ab*rho_nominal, m_flow_small=
                if system.use_eps_Re then system.eps_m_flow*m_flow_nominal
                 else system.m_flow_small);

          replaceable package WallFriction =
            QuadraticTurbulent constrainedby PartialWallFriction
            "Characteristic of wall friction"  annotation(choicesAllMatching=true);

          parameter SI.Length length "Length of pipe";
          parameter SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
          parameter SI.Length height_ab=0.0 "Height(port_b) - Height(port_a)"
            annotation (Evaluate=true);
          parameter SI.Length roughness(min=0)=2.5e-5
            "Absolute roughness of pipe (default = smooth steel pipe)"
            annotation (Dialog(enable=WallFriction.use_roughness));

          parameter SI.MassFlowRate m_flow_nominal=if system.use_eps_Re then
              system.m_flow_nominal else 1e2*system.m_flow_small
            "Nominal mass flow rate"
            annotation (Dialog(group="Nominal operating point"));

          parameter Boolean use_nominal = false
            "= true, if mu_nominal and rho_nominal are used, otherwise computed from medium"
                                                                                                          annotation(Evaluate=true);
          parameter SI.DynamicViscosity mu_nominal=Medium.dynamicViscosity(
              Medium.setState_pTX(
                      Medium.p_default,
                      Medium.T_default,
                      Medium.X_default))
            "Nominal dynamic viscosity (e.g., mu_liquidWater = 1e-3, mu_air = 1.8e-5)"
            annotation (Dialog(enable=use_nominal));
          parameter SI.Density rho_nominal=Medium.density_pTX(
                      Medium.p_default,
                      Medium.T_default,
                      Medium.X_default)
            "Nominal density (e.g., rho_liquidWater = 995, rho_air = 1.2)"
            annotation (Dialog(enable=use_nominal));

          parameter Boolean show_Re = false
            "= true, if Reynolds number is included for plotting"
             annotation (Evaluate=true, Dialog(tab="Advanced"));
          parameter Boolean from_dp=true
            "= true, use m_flow = f(dp), otherwise dp = f(m_flow)"
            annotation (Evaluate=true, Dialog(tab="Advanced"));
        protected
          parameter Medium.AbsolutePressure dp_fric_nominal=
            WallFriction.pressureLoss_m_flow(
                           m_flow_nominal,
                           rho_nominal,
                           rho_nominal,
                           mu_nominal,
                           mu_nominal,
                           length,
                           diameter,
                           roughness,
                           m_flow_small)
            "Nominal pressure loss (excluding static head)";
          parameter Medium.AbsolutePressure dp_small = if system.use_eps_Re then dp_fric_nominal/m_flow_nominal*m_flow_small else system.dp_small
            "Within regularization if |dp| < dp_small (may be wider for large discontinuities in static head)"
            annotation(Dialog(tab="Advanced", enable=from_dp and WallFriction.use_dp_small));

        public
          SI.ReynoldsNumber Re=CharacteristicNumbers.ReynoldsNumber_m_flow(
                      m_flow,
                      noEvent(if m_flow > 0 then mu_a else mu_b),
                      diameter) if show_Re "Reynolds number of pipe flow";

        protected
          SI.DynamicViscosity mu_a=if not WallFriction.use_mu then 1.e-10 else
              (if use_nominal then mu_nominal else Medium.dynamicViscosity(
              state_a));
          SI.DynamicViscosity mu_b=if not WallFriction.use_mu then 1.e-10 else
              (if use_nominal then mu_nominal else Medium.dynamicViscosity(
              state_b));
          SI.Density rho_a=if use_nominal then rho_nominal else Medium.density(
              state_a);
          SI.Density rho_b=if use_nominal then rho_nominal else Medium.density(
              state_b);

          Real g_times_height_ab(final unit="m2/s2") = system.g*height_ab
            "Gravity times height_ab = dp_grav/d";

          // Currently not in use (means to widen the regularization domain in case of large difference in static head)
          final parameter Boolean use_x_small_staticHead = false
            "Use dp_/m_flow_small_staticHead only if static head actually exists"
                                                                                  annotation(Evaluate=true);
                                                                 /*abs(height_ab)>0*/
          SI.AbsolutePressure dp_small_staticHead=noEvent(max(dp_small, 0.015*
              abs(g_times_height_ab*(rho_a - rho_b))))
            "Heuristic for large discontinuities in static head";
          SI.MassFlowRate m_flow_small_staticHead=noEvent(max(m_flow_small, (-5.55e-7
              *(rho_a + rho_b)/2 + 5.5e-4)*abs(g_times_height_ab*(rho_a - rho_b))))
            "Heuristic for large discontinuities in static head";

        equation
          if from_dp and not WallFriction.dp_is_zero then
            m_flow = WallFriction.massFlowRate_dp_staticHead(dp, rho_a, rho_b, mu_a, mu_b, length, diameter,
              g_times_height_ab, roughness, if use_x_small_staticHead then dp_small_staticHead else dp_small);
          else
            dp = WallFriction.pressureLoss_m_flow_staticHead(m_flow, rho_a, rho_b, mu_a, mu_b, length, diameter,
              g_times_height_ab, roughness, if use_x_small_staticHead then m_flow_small_staticHead else m_flow_small);
          end if;

          // Energy balance, considering change of potential energy
          port_a.h_outflow = inStream(port_b.h_outflow) + system.g*height_ab;
          port_b.h_outflow = inStream(port_a.h_outflow) - system.g*height_ab;

            annotation (defaultComponentName="pipeFriction",Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,60},{100,-60}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-100,44},{100,-45}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255}),
                Text(
                  extent={{-150,80},{150,120}},
                  lineColor={0,0,255},
                  textString="%name")}),           Documentation(info="<html>
<p>
This model describes pressure losses due to <b>wall friction</b> in a pipe
and due to gravity.
It is assumed that no mass or energy is stored in the pipe.
Correlations of different complexity and validity can be
selected via the replaceable package <b>WallFriction</b> (see parameter menu below).
The details of the pipe wall friction model are described in the
<a href=\"modelica://Modelica_Fluid.UsersGuide.ComponentDefinition.WallFriction\">UsersGuide</a>.
Basically, different variants of the equation
</p>

<pre>
   dp = &lambda;(Re,<font face=\"Symbol\">D</font>)*(L/D)*&rho;*v*|v|/2
</pre>

<p>
are used, where the friction loss factor &lambda; is shown
in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFriction1.png\"
     alt=\"PipeFriction1.png\">
</p>

<p>
By default, the correlations are computed with media data
at the actual time instant.
In order to reduce non-linear equation systems, parameter
<b>use_nominal</b> provides the option
to compute the correlations with constant media values
at the desired operating point. This might speed-up the
simulation and/or might give a more robust simulation.
</p>
</html>"),  Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,64},{100,-64}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Backward),
                Rectangle(
                  extent={{-100,50},{100,-49}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-60,-49},{-60,50}},
                  color={0,0,255},
                  arrow={Arrow.Filled,Arrow.Filled}),
                Text(
                  extent={{-50,16},{6,-10}},
                  lineColor={0,0,255},
                  textString="diameter"),
                Line(
                  points={{-100,74},{100,74}},
                  color={0,0,255},
                  arrow={Arrow.Filled,Arrow.Filled}),
                Text(
                  extent={{-34,92},{34,74}},
                  lineColor={0,0,255},
                  textString="length")}));
        end TestWallFrictionAndGravity;
        annotation (Documentation(info="<html>
<p>
This package provides functions to compute
pressure losses due to <b>wall friction</b> in a pipe.
Every correlation is defined by a package that is derived
by inheritance from the package WallFriction.PartialWallFriction.
The details of the underlying pipe wall friction model are described in the
<a href=\"modelica://Modelica_Fluid.UsersGuide.ComponentDefinition.WallFriction\">UsersGuide</a>.
Basically, different variants of the equation
</p>

<pre>
   dp = &lambda;(Re,<font face=\"Symbol\">D</font>)*(L/D)*&rho;*v*|v|/2
</pre>

<p>
are used, where the friction loss factor &lambda; is shown
in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFriction1.png\"
     alt=\"PipeFriction1.png\">
</p>

</html>"));
      end WallFriction;
    end BaseClasses;

    annotation (Documentation(info="<html>

</html>"));
  end Pipes;

  package Machines
    "Devices for converting between energy held in a fluid and mechanical energy"
    extends Modelica_Icons.VariantsPackage;
    model SweptVolume
      "varying cylindric volume depending on the position of the piston"
      import Modelica_Constants.pi;

      parameter SI.Area pistonCrossArea "cross sectional area of piston";
      parameter SI.Volume clearance "remaining volume at zero piston stroke";

      SI.Volume V "fluid volume";

      // Mass and energy balance, ports
      extends Vessels.BaseClasses.PartialLumpedVessel(final fluidVolume=V,
          heatTransfer(surfaceAreas={pistonCrossArea + 2*sqrt(pistonCrossArea*
              pi)*(flange.s + clearance/pistonCrossArea)}));

      Modelica_Mechanics_Translational_Interfaces.Flange_b flange
        "translation flange for piston" annotation (Placement(transformation(
              extent={{-10,90},{10,110}}, rotation=0)));

    equation
      assert(flange.s >= 0, "Piston stroke (given by flange.s) must not be smaller than zero!");

      // volume size
      V = clearance + flange.s * pistonCrossArea;

      0 = flange.f + (medium.p - system.p_ambient) * pistonCrossArea;

      // energy balances
      Wb_flow = medium.p * pistonCrossArea * (-der(flange.s));

      // definition of port pressures
      for i in 1:nPorts loop
        vessel_ps_static[i] = medium.p;
      end for;

      annotation (                         Icon(coordinateSystem(preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-50,36},{50,-90}},
              lineColor={0,0,255},
              pattern=LinePattern.None,
              lineThickness=1,
              fillColor={170,213,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-52,62},{-48,62},{-48,-30},{-52,-30},{-52,62}},
              lineColor={95,95,95},
              smooth=Smooth.None,
              fillColor={135,135,135},
              fillPattern=FillPattern.Backward),
            Polygon(
              points={{48,60},{52,60},{52,-34},{48,-34},{48,60}},
              lineColor={95,95,95},
              smooth=Smooth.None,
              fillColor={135,135,135},
              fillPattern=FillPattern.Backward),
            Rectangle(
              extent={{-48,40},{48,30}},
              lineColor={95,95,95},
              fillColor={135,135,135},
              fillPattern=FillPattern.Forward),
            Rectangle(
              extent={{-6,92},{6,40}},
              lineColor={95,95,95},
              fillColor={135,135,135},
              fillPattern=FillPattern.Forward),
            Polygon(
              points={{-48,-90},{48,-90},{48,70},{52,70},{52,-94},{-52,-94},{-52,
                  70},{-48,70},{-48,-90}},
              lineColor={95,95,95},
              smooth=Smooth.None,
              fillColor={135,135,135},
              fillPattern=FillPattern.Backward),
            Line(
              visible=use_HeatTransfer,
              points={{-100,0},{-52,0}},
              smooth=Smooth.None,
              color={198,0,0})}),
        Documentation(info="<html>
<p> Mixing volume with varying size. The size of the volume is given by:</p>
<ul>
  <li>cross sectional piston area</li>
  <li>piston stroke given by the flange position s</li>
  <li>clearance (volume at flange position = 0)</li>
</ul>
<p>Losses are neglected. The shaft power is completely converted into mechanical work on the fluid.</p>

<p> The flange position has to be equal or greater than zero. Otherwise the simulation stops. The force of the flange results from the pressure difference between medium and ambient pressure and the cross sectional piston area. For using the component, a top level instance of the ambient model with the inner attribute is needed.</p>
<p> The pressure at both fluid ports equals the medium pressure in the volume. No suction nor discharge valve is included in the model.</p>
<p>The thermal port is directly connected to the medium. The temperature of the thermal port equals the medium temperature. The heat capacity of the cylinder and the piston are not includes in the model.</p>
</html>", revisions="<html>
<ul>
<li><i>29 Oct 2007</i>
    by Carsten Heinrich:<br>
       Model added to the Fluid library</li>
</ul>
</html>"));
    end SweptVolume;

    model Pump "Centrifugal pump with mechanical connector for the shaft"
      extends BaseClasses.PartialPump;
      SI.Angle phi "Shaft angle";
      SI.AngularVelocity omega "Shaft angular velocity";
      Modelica_Mechanics_Rotational_Interfaces.Flange_a shaft annotation (
          Placement(transformation(extent={{-10,90},{10,110}}, rotation=0)));
    equation
      phi = shaft.phi;
      omega = der(phi);
      N = Cv.to_rpm(omega);
      W_single = omega*shaft.tau;
    annotation (
      Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={Rectangle(
              extent={{-10,100},{10,78}},
              lineColor={0,0,0},
              fillPattern=FillPattern.VerticalCylinder,
              fillColor={95,95,95})}),
      Documentation(info="<HTML>
<p>This model describes a centrifugal pump (or a group of <code>nParallel</code> pumps) with a mechanical rotational connector for the shaft, to be used when the pump drive has to be modelled explicitly. In the case of <code>nParallel</code> pumps, the mechanical connector is relative to a single pump.
<p>The model extends <code>PartialPump</code>
 </HTML>",
         revisions="<html>
<ul>
<li><i>31 Oct 2005</i>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br>
       Model added to the Fluid library</li>
</ul>
</html>"));
    end Pump;

    model ControlledPump
      "Centrifugal pump with ideally controlled mass flow rate"
      import Modelica_SIunits.Conversions.NonSIunits.AngularVelocity_rpm;
      extends BaseClasses.PartialPump(
        N_nominal=1500,
        N(start=N_nominal),
        redeclare replaceable function flowCharacteristic =
            BaseClasses.PumpCharacteristics.quadraticFlow (V_flow_nominal={0,
                V_flow_op,1.5*V_flow_op}, head_nominal={2*head_op,head_op,0}));

      // nominal values
      parameter Medium.AbsolutePressure p_a_nominal
        "Nominal inlet pressure for predefined pump characteristics";
      parameter Medium.AbsolutePressure p_b_nominal
        "Nominal outlet pressure, fixed if not control_m_flow and not use_p_set";
      parameter Medium.MassFlowRate m_flow_nominal
        "Nominal mass flow rate, fixed if control_m_flow and not use_m_flow_set";

      // what to control
      parameter Boolean control_m_flow = true
        "= false to control outlet pressure port_b.p instead of m_flow"
        annotation(Evaluate = true);
      parameter Boolean use_m_flow_set = false
        "= true to use input signal m_flow_set instead of m_flow_nominal"
        annotation (Dialog(enable = control_m_flow));
      parameter Boolean use_p_set = false
        "= true to use input signal p_set instead of p_b_nominal"
        annotation (Dialog(enable = not control_m_flow));

      // exemplary characteristics
      final parameter SI.VolumeFlowRate V_flow_op=m_flow_nominal/rho_nominal
        "operational volume flow rate according to nominal values";
      final parameter SI.Height head_op=(p_b_nominal - p_a_nominal)/(
          rho_nominal*g) "operational pump head according to nominal values";

      Modelica_Blocks_Interfaces.RealInput m_flow_set if use_m_flow_set
        "Prescribed mass flow rate"
        annotation (Placement(transformation(
            extent={{-20,-20},{20,20}},
            rotation=-90,
            origin={-50,82})));
      Modelica_Blocks_Interfaces.RealInput p_set if use_p_set
        "Prescribed outlet pressure"
        annotation (Placement(transformation(
            extent={{-20,-20},{20,20}},
            rotation=-90,
            origin={50,82})));

    protected
      Modelica_Blocks_Interfaces.RealInput m_flow_set_internal
        "Needed to connect to conditional connector";
      Modelica_Blocks_Interfaces.RealInput p_set_internal
        "Needed to connect to conditional connector";
    equation
      // Ideal control
      if control_m_flow then
        m_flow = m_flow_set_internal;
      else
        dp_pump = p_set_internal - port_a.p;
      end if;

      // Internal connector value when use_m_flow_set = false
      if not use_m_flow_set then
        m_flow_set_internal = m_flow_nominal;
      end if;
      if not use_p_set then
        p_set_internal = p_b_nominal;
      end if;
      connect(m_flow_set, m_flow_set_internal);
      connect(p_set, p_set_internal);

      annotation (defaultComponentName="pump",
        Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                100}}), graphics={Text(
              visible=use_p_set,
              extent={{82,108},{176,92}},
              textString="p_set"), Text(
              visible=use_m_flow_set,
              extent={{-20,108},{170,92}},
              textString="m_flow_set")}),
        Documentation(info="<HTML>
<p>
This model describes a centrifugal pump (or a group of <code>nParallel</code> pumps)
with ideally controlled mass flow rate or pressure.
</p>
<p>
Nominal values are used to predefine an exemplary pump characteristics and to define the operation of the pump.
The input connectors <code>m_flow_set</code> or <code>p_set</code> can optionally be enabled to provide time varying set points.
</p>
<p>
Use this model if the pump characteristics is of secondary interest.
The actual characteristics can be configured later on for the appropriate rotational speed N.
Then the model can be replaced with a Pump with rotational shaft or with a PrescribedPump.
</p>
</HTML>", revisions="<html>
<ul>
<li><i>15 Dec 2008</i>
    by Ruediger Franke:<br />
       Model added to the Fluid library</li>
</ul>
</html>"));
    end ControlledPump;

    model PrescribedPump "Centrifugal pump with ideally controlled speed"
      extends BaseClasses.PartialPump;
      parameter Boolean use_N_in = false
        "Get the rotational speed from the input connector";
      parameter Cv.NonSIunits.AngularVelocity_rpm N_const=N_nominal
        "Constant rotational speed" annotation (Dialog(enable=not use_N_in));
      Modelica_Blocks_Interfaces.RealInput N_in(unit="1/min") if use_N_in
        "Prescribed rotational speed"
        annotation (Placement(transformation(
            extent={{-20,-20},{20,20}},
            rotation=-90,
            origin={0,100}), iconTransformation(
            extent={{-20,-20},{20,20}},
            rotation=-90,
            origin={0,100})));

    protected
      Modelica_Blocks_Interfaces.RealInput N_in_internal(unit="1/min")
        "Needed to connect to conditional connector";
    equation
      // Connect statement active only if use_p_in = true
      connect(N_in, N_in_internal);
      // Internal connector value when use_p_in = false
      if not use_N_in then
        N_in_internal = N_const;
      end if;
      // Set N with a lower limit to avoid singularities at zero speed
      N = max(N_in_internal,1e-3) "Rotational speed";

      annotation (defaultComponentName="pump",
        Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                100}}), graphics={Text(
              visible=use_N_in,
              extent={{14,98},{178,82}},
              textString="N_in [rpm]")}),
        Documentation(info="<HTML>
<p>This model describes a centrifugal pump (or a group of <code>nParallel</code> pumps) with prescribed speed, either fixed or provided by an external signal.
<p>The model extends <code>PartialPump</code>
<p>If the <code>N_in</code> input connector is wired, it provides rotational speed of the pumps (rpm); otherwise, a constant rotational speed equal to <code>n_const</code> (which can be different from <code>N_nominal</code>) is assumed.</p>
</HTML>", revisions="<html>
<ul>
<li><i>31 Oct 2005</i>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br>
       Model added to the Fluid library</li>
</ul>
</html>"));
    end PrescribedPump;

    package BaseClasses
      "Base classes used in the Machines package (only of interest to build new component models)"
      extends Modelica_Icons.BasesPackage;

    partial model PartialPump "Base model for centrifugal pumps"
        import NonSI = Modelica_SIunits.Conversions.NonSIunits;
        import Constants = Modelica_Constants;

      extends Modelica_Fluid_Interfaces.PartialTwoPort(
          port_b_exposesState=energyDynamics <> Types.Dynamics.SteadyState or
              massDynamics <> Types.Dynamics.SteadyState,
          port_a(p(start=p_a_start), m_flow(start=m_flow_start, min=if
                  allowFlowReversal and not checkValve then -Constants.inf
                   else 0)),
          port_b(p(start=p_b_start), m_flow(start=-m_flow_start, max=if
                  allowFlowReversal and not checkValve then +Constants.inf
                   else 0)));

      // Initialization
      parameter Medium.AbsolutePressure p_a_start=system.p_start
          "Guess value for inlet pressure"
        annotation(Dialog(tab="Initialization"));
      parameter Medium.AbsolutePressure p_b_start=p_a_start
          "Guess value for outlet pressure"
        annotation(Dialog(tab="Initialization"));
      parameter Medium.MassFlowRate m_flow_start = system.m_flow_start
          "Guess value of m_flow = port_a.m_flow"
        annotation(Dialog(tab = "Initialization"));
        final parameter SI.VolumeFlowRate V_flow_single_init=m_flow_start/
            rho_nominal/nParallel "Used for simplified initialization model";
        final parameter SI.Height delta_head_init=flowCharacteristic(
            V_flow_single_init) - flowCharacteristic(0)
          "Used for simplified initialization model";

      // Characteristic curves
      parameter Integer nParallel(min=1) = 1 "Number of pumps in parallel"
        annotation(Dialog(group="Characteristics"));
      replaceable function flowCharacteristic =
          PumpCharacteristics.baseFlow
          "Head vs. V_flow characteristic at nominal speed and density"
        annotation(Dialog(group="Characteristics"), choicesAllMatching=true);
      parameter NonSI.AngularVelocity_rpm N_nominal
          "Nominal rotational speed for flow characteristic"
        annotation(Dialog(group="Characteristics"));
      parameter Medium.Density rho_nominal = Medium.density_pTX(Medium.p_default, Medium.T_default, Medium.X_default)
          "Nominal fluid density for characteristic"
        annotation(Dialog(group="Characteristics"));
      parameter Boolean use_powerCharacteristic = false
          "Use powerCharacteristic (vs. efficiencyCharacteristic)"
         annotation(Evaluate=true,Dialog(group="Characteristics"));
      replaceable function powerCharacteristic =
            PumpCharacteristics.quadraticPower (
           V_flow_nominal={0,0,0},W_nominal={0,0,0})
          "Power consumption vs. V_flow at nominal speed and density"
        annotation(Dialog(group="Characteristics", enable = use_powerCharacteristic),
                   choicesAllMatching=true);
      replaceable function efficiencyCharacteristic =
        PumpCharacteristics.constantEfficiency(eta_nominal = 0.8) constrainedby
          PumpCharacteristics.baseEfficiency
          "Efficiency vs. V_flow at nominal speed and density"
        annotation(Dialog(group="Characteristics",enable = not use_powerCharacteristic),
                   choicesAllMatching=true);

      // Assumptions
      parameter Boolean checkValve=false "= true to prevent reverse flow"
        annotation(Dialog(tab="Assumptions"), Evaluate=true);

        parameter SI.Volume V=0 "Volume inside the pump"
          annotation (Dialog(tab="Assumptions"), Evaluate=true);

      // Energy and mass balance
      extends Modelica_Fluid_Interfaces.PartialLumpedVolume(
          final fluidVolume=V,
          energyDynamics=Types.Dynamics.SteadyState,
          massDynamics=Types.Dynamics.SteadyState,
          final p_start=p_b_start);

      // Heat transfer through boundary, e.g., to add a housing
      parameter Boolean use_HeatTransfer = false
          "= true to use a HeatTransfer model, e.g., for a housing"
          annotation (Dialog(tab="Assumptions",group="Heat transfer"));
      replaceable model HeatTransfer =
          Vessels.BaseClasses.HeatTransfer.IdealHeatTransfer constrainedby
          Vessels.BaseClasses.HeatTransfer.PartialVesselHeatTransfer
          "Wall heat transfer"
          annotation (Dialog(tab="Assumptions",group="Heat transfer",enable=use_HeatTransfer),choicesAllMatching=true);
      HeatTransfer heatTransfer(
        redeclare final package Medium = Medium,
        final n=1,
        surfaceAreas={4*Modelica_Constants.pi*(3/4*V/Modelica_Constants.pi)^(2/3)},
        final states = {medium.state},
        final use_k = use_HeatTransfer)
          annotation (Placement(transformation(
            extent={{-10,-10},{30,30}},
            rotation=180,
            origin={50,-10})));
      Modelica_Thermal_HeatTransfer_Interfaces.HeatPort_a heatPort if use_HeatTransfer
        annotation (Placement(transformation(extent={{30,-70},{50,-50}})));

      // Variables
        final parameter SI.Acceleration g=system.g;
      Medium.Density rho = medium.d;
        SI.Pressure dp_pump=port_b.p - port_a.p "Pressure increase";
        SI.Height head=dp_pump/(rho*g) "Pump head";
        SI.MassFlowRate m_flow=port_a.m_flow "Mass flow rate (total)";
        SI.MassFlowRate m_flow_single=m_flow/nParallel
          "Mass flow rate (single pump)";
        SI.VolumeFlowRate V_flow "Volume flow rate (total)";
        SI.VolumeFlowRate V_flow_single(start=m_flow_start/rho_nominal/
              nParallel) "Volume flow rate (single pump)";
      NonSI.AngularVelocity_rpm N(start = N_nominal) "Shaft rotational speed";
        SI.Power W_single "Power Consumption (single pump)";
        SI.Power W_total=W_single*nParallel "Power Consumption (total)";
      Real eta "Global Efficiency";
      final constant Medium.MassFlowRate unit_m_flow=1 annotation (HideResult=true);
      Real s(start = m_flow_start/unit_m_flow)
          "Curvilinear abscissa for the flow curve in parametric form (either mass flow rate or head)";

      // Diagnostics
      replaceable model Monitoring =
        PumpMonitoring.PumpMonitoringBase constrainedby
          PumpMonitoring.PumpMonitoringBase "Optional pump monitoring"
          annotation(Dialog(tab="Advanced", group="Diagnostics"), choicesAllMatching=true);
      final parameter Boolean show_NPSHa = false
          "obsolete -- remove modifier and specify Monitoring for NPSH instead"
        annotation(Dialog(tab="Advanced", group="Obsolete"));
      Monitoring monitoring(
              redeclare final package Medium = Medium,
              final state_in = Medium.setState_phX(port_a.p, inStream(port_a.h_outflow), inStream(port_a.Xi_outflow)),
              final state = medium.state) "Monitoring model"
         annotation (Placement(transformation(extent={{-64,-42},{-20,0}}, rotation=0)));
      protected
        constant SI.Height unitHead=1;
        constant SI.MassFlowRate unitMassFlowRate=1;

    equation
      // Flow equations
       V_flow = homotopy(m_flow/rho,
                         m_flow/rho_nominal);
       V_flow_single = V_flow/nParallel;
      if not checkValve then
        // Regular flow characteristics without check valve
        head = homotopy((N/N_nominal)^2*flowCharacteristic(V_flow_single*N_nominal/N),
                         N/N_nominal*(flowCharacteristic(0)+delta_head_init*V_flow_single));
        s = 0;
      else
        // Flow characteristics when check valve is open
        head = homotopy(if s > 0 then (N/N_nominal)^2*flowCharacteristic(V_flow_single*N_nominal/N)
                                 else (N/N_nominal)^2*flowCharacteristic(0) - s*unitHead,
                        N/N_nominal*(flowCharacteristic(0)+delta_head_init*V_flow_single));
        V_flow_single = homotopy(if s > 0 then s*unitMassFlowRate/rho else 0,
                                 s*unitMassFlowRate/rho_nominal);
      end if;
      // Power consumption
      if use_powerCharacteristic then
        W_single = homotopy((N/N_nominal)^3*(rho/rho_nominal)*powerCharacteristic(V_flow_single*N_nominal/N),
                            N/N_nominal*V_flow_single/V_flow_single_init*powerCharacteristic(V_flow_single_init));
        eta = dp_pump*V_flow_single/W_single;
      else
        eta = homotopy(efficiencyCharacteristic(V_flow_single*(N_nominal/N)),
                       efficiencyCharacteristic(V_flow_single_init));
        W_single = homotopy(dp_pump*V_flow_single/eta,
                            dp_pump*V_flow_single_init/eta);
      end if;

      // Energy balance
      Wb_flow = W_total;
      Qb_flow = heatTransfer.Q_flows[1];
      Hb_flow = port_a.m_flow*actualStream(port_a.h_outflow) +
                port_b.m_flow*actualStream(port_b.h_outflow);

      // Ports
      port_a.h_outflow = medium.h;
      port_b.h_outflow = medium.h;
      port_b.p = medium.p
          "outlet pressure is equal to medium pressure, which includes Wb_flow";

      // Mass balance
      mb_flow = port_a.m_flow + port_b.m_flow;

      mbXi_flow = port_a.m_flow*actualStream(port_a.Xi_outflow) +
                  port_b.m_flow*actualStream(port_b.Xi_outflow);
      port_a.Xi_outflow = medium.Xi;
      port_b.Xi_outflow = medium.Xi;

      mbC_flow = port_a.m_flow*actualStream(port_a.C_outflow) +
                 port_b.m_flow*actualStream(port_b.C_outflow);
      port_a.C_outflow = C;
      port_b.C_outflow = C;

      connect(heatTransfer.heatPorts[1], heatPort) annotation (Line(
          points={{40,-34},{40,-60}},
          color={127,0,0},
          smooth=Smooth.None));
      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={
              Rectangle(
                extent={{-100,46},{100,-46}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.HorizontalCylinder),
              Polygon(
                points={{-48,-60},{-72,-100},{72,-100},{48,-60},{-48,-60}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.VerticalCylinder),
              Ellipse(
                extent={{-80,80},{80,-80}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={0,100,199}),
              Polygon(
                points={{-28,30},{-28,-30},{50,-2},{-28,30}},
                lineColor={0,0,0},
                pattern=LinePattern.None,
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={255,255,255})}),
        Documentation(info="<HTML>
<p>This is the base model for pumps.
<p>The model describes a centrifugal pump, or a group of <code>nParallel</code> identical pumps. The pump model is based on the theory of kinematic similarity: the pump characteristics are given for nominal operating conditions (rotational speed and fluid density), and then adapted to actual operating condition, according to the similarity equations.

<p><b>Pump characteristics</b></p>
<p> The nominal hydraulic characteristic (head vs. volume flow rate) is given by the the replaceable function <code>flowCharacteristic</code>.
<p> The pump energy balance can be specified in two alternative ways:
<ul>
<li><code>use_powerCharacteristic = false</code> (default option): the replaceable function <code>efficiencyCharacteristic</code> (efficiency vs. volume flow rate in nominal conditions) is used to determine the efficiency, and then the power consumption.
    The default is a constant efficiency of 0.8.</li>
<li><code>use_powerCharacteristic = true</code>: the replaceable function <code>powerCharacteristic</code> (power consumption vs. volume flow rate in nominal conditions) is used to determine the power consumption, and then the efficiency.
    Use <code>powerCharacteristic</code> to specify a non-zero power consumption for zero flow rate.
</ul>
<p>
Several functions are provided in the package <code>PumpCharacteristics</code> to specify the characteristics as a function of some operating points at nominal conditions.
<p>Depending on the value of the <code>checkValve</code> parameter, the model either supports reverse flow conditions, or includes a built-in check valve to avoid flow reversal.
</p>
<p>It is possible to take into account the mass and energy storage of the fluid inside the pump by specifying its volume <code>V</code>, and by selecting appropriate dynamic mass and energy balance assumptions (see below);
this is recommended to avoid singularities in the computation of the outlet enthalpy in case of zero flow rate.
If zero flow rate conditions are always avoided, this dynamic effect can be neglected by leaving the default value <code>V = 0</code>, thus avoiding fast state variables in the model.
</p>

<p><b>Dynamics options</b></p>
<p>
Steady-state mass and energy balances are assumed per default, neglecting the holdup of fluid in the pump; this configuration works well if the flow rate is always positive.
Dynamic mass and energy balance can be used by setting the corresponding dynamic parameters. This is recommended to avoid singularities at zero or reversing mass flow rate. If the initial conditions imply non-zero mass flow rate, it is possible to use the <code>SteadyStateInitial</code> condition, otherwise it is recommended to use <code>FixedInitial</code> in order to avoid undetermined initial conditions.
</p>

<p><b>Heat transfer</b></p>
<p>
The Boolean parameter <code>use_HeatTransfer</code> can be set to true if heat exchanged with the environment
should be taken into account or to model a housing. This might be desirable if a pump with realistic
<code>powerCharacteristic</code> for zero flow operates while a valve prevents fluid flow.
</p>

<p><b>Diagnostics of Cavitation</b></p>
<p>The replaceable Monitoring submodel can be configured to PumpMonitoringNPSH,
in order to compute the Net Positive Suction Head available and check for cavitation,
provided a two-phase medium model is used (see Advanced tab).
</p>
</HTML>", revisions="<html>
<ul>
<li><i>8 Jan 2013</i>
    by R&uuml;diger Franke:<br>
    moved NPSH diagnostics from PartialPump to replaceable sub-model PumpMonitoring.PumpMonitoringNPSH (see ticket #646)</li>
<li><i>Dec 2008</i>
    by R&uuml;diger Franke:<br>
    <ul>
    <li>Replaced simplified mass and energy balances with rigorous formulation (base class PartialLumpedVolume)</li>
    <li>Introduced optional HeatTransfer model defining Qb_flow</li>
    <li>Enabled events when the checkValve is operating to support the opening of a discrete valve before port_a</li>
    </ul></li>
<li><i>31 Oct 2005</i>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br>
       Model added to the Fluid library</li>
</ul>
</html>"));
    end PartialPump;

    package PumpCharacteristics "Functions for pump characteristics"
      extends Modelica_Icons.Package;
      import NonSI = Modelica_SIunits.Conversions.NonSIunits;

      partial function baseFlow "Base class for pump flow characteristics"
        extends Modelica_Icons.Function;
          input SI.VolumeFlowRate V_flow "Volumetric flow rate";
          output SI.Height head "Pump head";
      end baseFlow;

      partial function basePower
          "Base class for pump power consumption characteristics"
        extends Modelica_Icons.Function;
          input SI.VolumeFlowRate V_flow "Volumetric flow rate";
          output SI.Power consumption "Power consumption";
      end basePower;

      partial function baseEfficiency
          "Base class for efficiency characteristics"
        extends Modelica_Icons.Function;
          input SI.VolumeFlowRate V_flow "Volumetric flow rate";
        output Real eta "Efficiency";
      end baseEfficiency;

      function linearFlow "Linear flow characteristic"
        extends baseFlow;
          input SI.VolumeFlowRate V_flow_nominal[2]
            "Volume flow rate for two operating points (single pump)"
            annotation (Dialog);
          input SI.Height head_nominal[2] "Pump head for two operating points"
            annotation (Dialog);
        /* Linear system to determine the coefficients:
  head_nominal[1] = c[1] + V_flow_nominal[1]*c[2];
  head_nominal[2] = c[1] + V_flow_nominal[2]*c[2];
  */
        protected
        Real c[2] = Modelica_Math.Matrices.solve([ones(2),V_flow_nominal],head_nominal)
            "Coefficients of linear head curve";
      algorithm
        assert(c[2] <= -Modelica_Constants.small,
               "Wrong pump curve -- head_nominal must be monotonically decreasing with increasing V_flow_nominal",
               level=AssertionLevel.warning);
        // Flow equation: head = q*c[1] + c[2];
        head := c[1] + V_flow*c[2];
      end linearFlow;

      function quadraticFlow
          "Quadratic flow characteristic, including linear extrapolation"
        extends baseFlow;
          input SI.VolumeFlowRate V_flow_nominal[3]
            "Volume flow rate for three operating points (single pump)"
            annotation (Dialog);
          input SI.Height head_nominal[3]
            "Pump head for three operating points" annotation (Dialog);
        protected
        Real V_flow_nominal2[3] = {V_flow_nominal[1]^2,V_flow_nominal[2]^2, V_flow_nominal[3]^2}
            "Squared nominal flow rates";
        /* Linear system to determine the coefficients:
  head_nominal[1] = c[1] + V_flow_nominal[1]*c[2] + V_flow_nominal[1]^2*c[3];
  head_nominal[2] = c[1] + V_flow_nominal[2]*c[2] + V_flow_nominal[2]^2*c[3];
  head_nominal[3] = c[1] + V_flow_nominal[3]*c[2] + V_flow_nominal[3]^2*c[3];
  */
        Real c[3] = Modelica_Math.Matrices.solve([ones(3), V_flow_nominal, V_flow_nominal2],head_nominal)
            "Coefficients of quadratic head curve";
          SI.VolumeFlowRate V_flow_min=min(V_flow_nominal);
          SI.VolumeFlowRate V_flow_max=max(V_flow_nominal);
      algorithm
        assert(max(c[2].+2*c[3]*V_flow_nominal) <= -Modelica_Constants.small,
               "Wrong pump curve -- head_nominal must be monotonically decreasing with increasing V_flow_nominal",
               level=AssertionLevel.warning);
        if V_flow < V_flow_min then
          head := max(head_nominal) + (V_flow-V_flow_min)*(c[2]+2*c[3]*V_flow_min);
        elseif V_flow > V_flow_max then
          head := min(head_nominal) + (V_flow-V_flow_max)*(c[2]+2*c[3]*V_flow_max);
        else
          // Flow equation: head  = c[1] + V_flow*c[2] + V_flow^2*c[3];
          head := c[1] + V_flow*(c[2] + V_flow*c[3]);
        end if;

        annotation(Documentation(revisions="<html>
<ul>
<li><i>Jan 2013</i>
    by R&uuml;diger Franke:<br>
    Extended with linear extrapolation outside specified points</li>
</ul>
</html>"));
      end quadraticFlow;

      function polynomialFlow
          "Polynomial flow characteristic, including linear extrapolation"
        extends baseFlow;
          input SI.VolumeFlowRate V_flow_nominal[:]
            "Volume flow rate for N operating points (single pump)"
            annotation (Dialog);
          input SI.Height head_nominal[:] "Pump head for N operating points"
            annotation (Dialog);
        protected
        Integer N = size(V_flow_nominal,1) "Number of nominal operating points";
        Real V_flow_nominal_pow[N,N] = {{if j > 1 then V_flow_nominal[i]^(j-1) else 1 for j in 1:N} for i in 1:N}
            "Rows: different operating points; columns: increasing powers";
        /* Linear system to determine the coefficients (example N=3):
  head_nominal[1] = c[1] + V_flow_nominal[1]*c[2] + V_flow_nominal[1]^2*c[3];
  head_nominal[2] = c[1] + V_flow_nominal[2]*c[2] + V_flow_nominal[2]^2*c[3];
  head_nominal[3] = c[1] + V_flow_nominal[3]*c[2] + V_flow_nominal[3]^2*c[3];
  */
        Real c[size(V_flow_nominal,1)] = Modelica_Math.Matrices.solve(V_flow_nominal_pow,head_nominal)
            "Coefficients of polynomial head curve";
          SI.VolumeFlowRate V_flow_min=min(V_flow_nominal);
          SI.VolumeFlowRate V_flow_max=max(V_flow_nominal);
        Real max_dhdV = max({c[2] .+ sum((i-1)*V_flow_nominal.^(i-2)*c[i] for i in 3:N)});
        Real poly;
      algorithm
        assert(max_dhdV <= -Modelica_Constants.small,
               "Wrong pump curve -- head_nominal must be monotonically decreasing with increasing V_flow_nominal",
               level=AssertionLevel.warning);
        if V_flow < V_flow_min then
          //head := max(head_nominal) + (V_flow-V_flow_min)*(c[2]+sum((i-1)*V_flow_min^(i-2)*c[i] for i in 3:N));
          poly := c[N]*(N-1);
          for i in 1:N-2 loop
            poly := V_flow_min*poly + c[N-i]*(N-i-1);
          end for;
          head := max(head_nominal) + (V_flow-V_flow_min)*poly;
        elseif V_flow > V_flow_max then
          //head := min(head_nominal) + (V_flow-V_flow_max)*(c[2]+sum((i-1)*V_flow_max^(i-2)*c[i] for i in 3:N));
          poly := c[N]*(N-1);
          for i in 1:N-2 loop
            poly := V_flow_max*poly + c[N-i]*(N-i-1);
          end for;
          head := min(head_nominal) + (V_flow-V_flow_max)*poly;
        else
          // Flow equation (example N=3): head  = c[1] + V_flow*c[2] + V_flow^2*c[3];
          // Note: the implementation is numerically efficient only for low values of Na
          //head := sum(V_flow^(i-1)*c[i] for i in 1:N);
          poly := c[N];
          for i in 1:N-1 loop
            poly := V_flow*poly + c[N-i];
           end for;
          head := poly;
        end if;

        annotation(Documentation(revisions="<html>
<ul>
<li><i>Jan 2013</i>
    by R&uuml;diger Franke:<br>
    Extended with linear extrapolation outside specified points and reformulated polynomial evaluation</li>
</ul>
</html>"));
      end polynomialFlow;

      function constantEfficiency "Constant efficiency characteristic"
         extends baseEfficiency;
         input Real eta_nominal "Nominal efficiency" annotation(Dialog);
      algorithm
        eta := eta_nominal;
      end constantEfficiency;

      function linearPower "Linear power consumption characteristic"
        extends basePower;
          input SI.VolumeFlowRate V_flow_nominal[2]
            "Volume flow rate for two operating points (single pump)"
            annotation (Dialog);
          input SI.Power W_nominal[2]
            "Power consumption for two operating points" annotation (Dialog);
        /* Linear system to determine the coefficients:
  W_nominal[1] = c[1] + V_flow_nominal[1]*c[2];
  W_nominal[2] = c[1] + V_flow_nominal[2]*c[2];
  */
        protected
        Real c[2] = Modelica_Math.Matrices.solve([ones(3),V_flow_nominal],W_nominal)
            "Coefficients of linear power consumption curve";
      algorithm
        consumption := c[1] + V_flow*c[2];
      end linearPower;

      function quadraticPower "Quadratic power consumption characteristic"
        extends basePower;
          input SI.VolumeFlowRate V_flow_nominal[3]
            "Volume flow rate for three operating points (single pump)"
            annotation (Dialog);
          input SI.Power W_nominal[3]
            "Power consumption for three operating points" annotation (Dialog);
        protected
        Real V_flow_nominal2[3] = {V_flow_nominal[1]^2,V_flow_nominal[2]^2, V_flow_nominal[3]^2}
            "Squared nominal flow rates";
        /* Linear system to determine the coefficients:
  W_nominal[1] = c[1] + V_flow_nominal[1]*c[2] + V_flow_nominal[1]^2*c[3];
  W_nominal[2] = c[1] + V_flow_nominal[2]*c[2] + V_flow_nominal[2]^2*c[3];
  W_nominal[3] = c[1] + V_flow_nominal[3]*c[2] + V_flow_nominal[3]^2*c[3];
  */
        Real c[3] = Modelica_Math.Matrices.solve([ones(3),V_flow_nominal,V_flow_nominal2],W_nominal)
            "Coefficients of quadratic power consumption curve";
      algorithm
        consumption := c[1] + V_flow*c[2] + V_flow^2*c[3];
      end quadraticPower;

    end PumpCharacteristics;

      package PumpMonitoring "Monitoring of pump operation"
        extends Modelica_Icons.Package;
        model PumpMonitoringBase "Interface for pump monitoring"
          outer System system "System wide properties";
          //
          // Internal interface
          // (not exposed to GUI; needs to be hard coded when using this model
          //
          replaceable package Medium =
            Modelica_Media_Interfaces.PartialMedium "Medium in the component"
              annotation(Dialog(tab="Internal Interface",enable=false));

          // Inputs
          input Medium.ThermodynamicState state_in
            "Thermodynamic state of inflow";
          input Medium.ThermodynamicState state
            "Thermodynamic state in the pump";

        end PumpMonitoringBase;

        model PumpMonitoringNPSH "Monitor Net Positive Suction Head (NPSH)"
          extends PumpMonitoringBase(redeclare replaceable package Medium =
            Modelica_Media_Interfaces.PartialTwoPhaseMedium);
          Medium.Density rho_in = Medium.density(state_in)
            "Liquid density at the inlet port_a";
          SI.Length NPSHa=NPSPa/(rho_in*system.g)
            "Net Positive Suction Head available";
          SI.Pressure NPSPa=assertPositiveDifference(
                      Medium.pressure(state_in),
                      Medium.saturationPressure(Medium.temperature(state_in)),
                      "Cavitation occurs at the pump inlet")
            "Net Positive Suction Pressure available";
          SI.Pressure NPDPa=assertPositiveDifference(
                      Medium.pressure(state),
                      Medium.saturationPressure(Medium.temperature(state)),
                      "Cavitation occurs in the pump")
            "Net Positive Discharge Pressure available";
        end PumpMonitoringNPSH;

        function assertPositiveDifference
          extends Modelica_Icons.Function;
          input SI.Pressure p;
          input SI.Pressure p_sat;
          input String message;
          output SI.Pressure dp;
        algorithm
          dp := p - p_sat;
          assert(p >= p_sat, message);
        end assertPositiveDifference;
      end PumpMonitoring;
    end BaseClasses;
    annotation (Documentation(info="<html>

</html>"));
  end Machines;

  package Valves "Components for the regulation and control of fluid flow"
      extends Modelica_Icons.VariantsPackage;

      model ValveIncompressible "Valve for (almost) incompressible fluids"
        extends BaseClasses.PartialValve;
        import Modelica_Fluid.Types.CvTypes;
        import Modelica_Constants.pi;

      constant SI.ReynoldsNumber Re_turbulent=4000
        "cf. straight pipe for fully open valve -- dp_turbulent increases for closing valve";
        parameter Boolean use_Re = system.use_eps_Re
        "= true, if turbulent region is defined by Re, otherwise by m_flow_small"
          annotation(Dialog(tab="Advanced"), Evaluate=true);
        //SI.MassFlowRate m_flow_turbulent=if not use_Re then m_flow_small else
        //  max(m_flow_small,
        //      (Modelica_Constants.pi/8)*sqrt(max(relativeFlowCoefficient,0.001)*Av*4/pi)*(Medium.dynamicViscosity(state_a) + Medium.dynamicViscosity(state_b))*Re_turbulent);
        //SI.AbsolutePressure dp_turbulent_=if not use_Re then dp_small else
        //  max(dp_small, m_flow_turbulent^2/(max(relativeFlowCoefficient,0.001)^2*Av^2*(Medium.density(state_a) + Medium.density(state_b))/2));
        // substitute m_flow_turbulent into dp_turbulent
      SI.AbsolutePressure dp_turbulent=if not use_Re then dp_small else max(
          dp_small, (Medium.dynamicViscosity(state_a) + Medium.dynamicViscosity(
          state_b))^2*pi/8*Re_turbulent^2/(max(relativeFlowCoefficient, 0.001)*
          Av*(Medium.density(state_a) + Medium.density(state_b))));

    protected
        Real relativeFlowCoefficient;
      initial equation
        if CvData == CvTypes.OpPoint then
            m_flow_nominal = valveCharacteristic(opening_nominal)*Av*sqrt(rho_nominal)*Utilities.regRoot(dp_nominal, dp_small)
          "Determination of Av by the operating point";
        end if;

      equation
        // m_flow = valveCharacteristic(opening)*Av*sqrt(d)*sqrt(dp);

        relativeFlowCoefficient = valveCharacteristic(opening_actual);
        if checkValve then
          m_flow = homotopy(relativeFlowCoefficient*Av*sqrt(Medium.density(state_a))*
                                 Utilities.regRoot2(dp,dp_turbulent,1.0,0.0,use_yd0=true,yd0=0.0),
                            relativeFlowCoefficient*m_flow_nominal*dp/dp_nominal);
          /* In Modelica 3.1 (Disadvantage: Unnecessary event at dp=0, and smooth=0, instead of smooth=2)
    m_flow = valveCharacteristic(opening)*Av*sqrt(Medium.density(state_a))*
                  (if dp>=0 then Utilities.regRoot(dp, dp_turbulent) else 0);
    */
        elseif not allowFlowReversal then
          m_flow = homotopy(relativeFlowCoefficient*Av*sqrt(Medium.density(state_a))*
                                 Utilities.regRoot(dp, dp_turbulent),
                            relativeFlowCoefficient*m_flow_nominal*dp/dp_nominal);
        else
          m_flow = homotopy(relativeFlowCoefficient*Av*
                                 Utilities.regRoot2(dp,dp_turbulent,Medium.density(state_a),Medium.density(state_b)),
                            relativeFlowCoefficient*m_flow_nominal*dp/dp_nominal);
          /* In Modelica 3.1 (Disadvantage: Unnecessary event at dp=0, and smooth=0, instead of smooth=2)
    m_flow = smooth(0, Utilities.regRoot(dp, dp_turbulent)*(if dp>=0 then sqrt(Medium.density(state_a)) else sqrt(Medium.density(state_b))));
    */
        end if;

      annotation (
      Documentation(info="<HTML>
<p>
Valve model according to the IEC 534/ISA S.75 standards for valve sizing, incompressible fluids.<
/p>

<p>
The parameters of this model are explained in detail in
<a href=\"modelica://Modelica_Fluid.Valves.BaseClasses.PartialValve\">PartialValve</a>
(the base model for valves).
</p>

<p>
This model assumes that the fluid has a low compressibility, which is always the case for liquids.
It can also be used with gases, provided that the pressure drop is lower than 0.2 times the absolute pressure at the inlet, so that the fluid density does not change much inside the valve.</p>

<p>
If <code>checkValve</code> is false, the valve supports reverse flow, with a symmetric flow characteristic curve. Otherwise, reverse flow is stopped (check valve behaviour).
</p>

<p>
The treatment of parameters <b>Kv</b> and <b>Cv</b> is
explained in detail in the
<a href=\"modelica://Modelica_Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">User's Guide</a>.
</p>

</html>",
        revisions="<html>
<ul>
<li><i>2 Nov 2005</i>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br>
       Adapted from the ThermoPower library.</li>
</ul>
</html>"));
      end ValveIncompressible;

    model ValveVaporizing
      "Valve for possibly vaporizing (almost) incompressible fluids, accounts for choked flow conditions"
      import Modelica_Fluid.Types.CvTypes;
      import Modelica_Constants.pi;
      extends BaseClasses.PartialValve(
        redeclare replaceable package Medium =
            Modelica_Media.Water.WaterIF97_ph                                    constrainedby
          Modelica_Media.Interfaces.PartialTwoPhaseMedium);
      parameter Real Fl_nominal=0.9 "Liquid pressure recovery factor";
      replaceable function FlCharacteristic =
          BaseClasses.ValveCharacteristics.one constrainedby
        BaseClasses.ValveCharacteristics.baseFun
        "Pressure recovery characteristic";
      Real Ff "Ff coefficient (see IEC/ISA standard)";
      Real Fl "Pressure recovery coefficient Fl (see IEC/ISA standard)";
      SI.Pressure dpEff "Effective pressure drop";
      Medium.Temperature T_in "Inlet temperature";
      Medium.AbsolutePressure p_sat "Saturation pressure";
      Medium.AbsolutePressure p_in "Inlet pressure";
      Medium.AbsolutePressure p_out "Outlet pressure";

      constant SI.ReynoldsNumber Re_turbulent=4000
        "cf. straight pipe for fully open valve -- dp_turbulent increases for closing valve";
      parameter Boolean use_Re = system.use_eps_Re
        "= true, if turbulent region is defined by Re, otherwise by m_flow_small"
        annotation(Dialog(tab="Advanced"), Evaluate=true);
      //SI.Diameter diameter = Utilities.regRoot(4/pi*valveCharacteristic(opening_actual)*Av, 0.04/pi*valveCharacteristic(opening_nominal)*Av);
      SI.AbsolutePressure dp_turbulent=if not use_Re then dp_small else max(
          dp_small, (Medium.dynamicViscosity(state_a) + Medium.dynamicViscosity(
          state_b))^2*pi/8*Re_turbulent^2/(valveCharacteristic(opening_actual)*
          Av*(Medium.density(state_a) + Medium.density(state_b))));
    initial equation
      assert(not CvData == CvTypes.OpPoint, "OpPoint option not supported for vaporizing valve");
    equation
      p_in = port_a.p;
      p_out = port_b.p;
      T_in = Medium.temperature(state_a);
      p_sat = Medium.saturationPressure(T_in);
      Ff = 0.96 - 0.28*sqrt(p_sat/Medium.fluidConstants[1].criticalPressure);
      Fl = Fl_nominal*FlCharacteristic(opening_actual);
      dpEff = if p_out < (1 - Fl^2)*p_in + Ff*Fl^2*p_sat then
                Fl^2*(p_in - Ff*p_sat) else dp
        "Effective pressure drop, accounting for possible choked conditions";
      // m_flow = valveCharacteristic(opening)*Av*sqrt(d)*sqrt(dpEff);
      if checkValve then
        m_flow = homotopy(valveCharacteristic(opening_actual)*Av*sqrt(Medium.density(state_a))*
                               Utilities.regRoot2(dpEff,dp_turbulent,1.0,0.0,use_yd0=true,yd0=0.0),
                          valveCharacteristic(opening_actual)*m_flow_nominal*dp/dp_nominal);
       /* In Modelica 3.1 (Disadvantage: Unnecessary event at dpEff=0, and smooth=0, instead of smooth=2)
    m_flow = valveCharacteristic(opening)*Av*sqrt(Medium.density(state_a))*
                  (if dpEff>=0 then Utilities.regRoot(dpEff, dp_turbulent) else 0);
   */
      elseif not allowFlowReversal then
        m_flow = homotopy(valveCharacteristic(opening_actual)*Av*sqrt(Medium.density(state_a))*
                               Utilities.regRoot(dpEff, dp_turbulent),
                          valveCharacteristic(opening_actual)*m_flow_nominal*dp/dp_nominal);
      else
        m_flow = homotopy(valveCharacteristic(opening_actual)*Av*
                               Utilities.regRoot2(dpEff,dp_turbulent,Medium.density(state_a),Medium.density(state_b)),
                          valveCharacteristic(opening_actual)*m_flow_nominal*dp/dp_nominal);
        /* In Modelica 3.1 (Disadvantage: Unnecessary event at dp=0, and smooth=0, instead of smooth=2)
     m_flow = valveCharacteristic(opening)*Av*
      smooth(0, Utilities.regRoot(dpEff, dp_turbulent)*(if dpEff>=0 then sqrt(Medium.density(state_a)) else sqrt(Medium.density(state_b))));
   */
      end if;

      annotation (
        Documentation(info="<HTML>
<p>Valve model according to the IEC 534/ISA S.75 standards for valve sizing, incompressible fluid at the inlet, and possibly two-phase fluid at the outlet, including choked flow conditions.</p>

<p>
The parameters of this model are explained in detail in
<a href=\"modelica://Modelica_Fluid.Valves.BaseClasses.PartialValve\">PartialValve</a>
(the base model for valves).
</p>

<p>The model operating range includes choked flow operation, which takes place for low outlet pressures due to flashing in the vena contracta; otherwise, non-choking conditions are assumed.
<p>This model requires a two-phase medium model, to describe the liquid and (possible) two-phase conditions.
<p>The default liquid pressure recovery coefficient <code>Fl</code> is constant and given by the parameter <code>Fl_nominal</code>. The relative change (per unit) of the recovery coefficient can be specified as a given function of the valve opening by replacing the <code>FlCharacteristic</code> function.
<p>If <code>checkValve</code> is false, the valve supports reverse flow, with a symmetric flow characteristic curve. Otherwise, reverse flow is stopped (check valve behaviour).</p>

<p>
The treatment of parameters <b>Kv</b> and <b>Cv</b> is
explained in detail in the
<a href=\"modelica://Modelica_Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">User's Guide</a>.
</p>

</HTML>", revisions="<html>
<ul>
<li><i>2 Nov 2005</i>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br>
       Adapted from the ThermoPower library.</li>
</ul>
</html>"));
    end ValveVaporizing;

    model ValveCompressible
      "Valve for compressible fluids, accounts for choked flow conditions"
      extends BaseClasses.PartialValve;
      import Modelica_Fluid.Types.CvTypes;
      import Modelica_Constants.pi;
      parameter Medium.AbsolutePressure p_nominal "Nominal inlet pressure"
      annotation(Dialog(group="Nominal operating point"));
      parameter Real Fxt_full=0.5 "Fk*xt critical ratio at full opening";
      replaceable function xtCharacteristic =
          BaseClasses.ValveCharacteristics.one constrainedby
        BaseClasses.ValveCharacteristics.baseFun
        "Critical ratio characteristic";
      Real Fxt;
      Real x "Pressure drop ratio";
      Real xs "Saturated pressure drop ratio";
      Real Y "Compressibility factor";
      Medium.AbsolutePressure p "Inlet pressure";

      constant SI.ReynoldsNumber Re_turbulent=4000
        "cf. straight pipe for fully open valve -- dp_turbulent increases for closing valve";
      parameter Boolean use_Re = system.use_eps_Re
        "= true, if turbulent region is defined by Re, otherwise by m_flow_small"
        annotation(Dialog(tab="Advanced"), Evaluate=true);
      SI.AbsolutePressure dp_turbulent=if not use_Re then dp_small else max(
          dp_small, (Medium.dynamicViscosity(state_a) + Medium.dynamicViscosity(
          state_b))^2*pi/8*Re_turbulent^2/(max(valveCharacteristic(
          opening_actual), 0.001)*Av*Y*(Medium.density(state_a) +
          Medium.density(state_b))));
    protected
      parameter Real Fxt_nominal(fixed=false) "Nominal Fxt";
      parameter Real x_nominal(fixed=false) "Nominal pressure drop ratio";
      parameter Real xs_nominal(fixed=false)
        "Nominal saturated pressure drop ratio";
      parameter Real Y_nominal(fixed=false) "Nominal compressibility factor";

    initial equation
      if CvData == CvTypes.OpPoint then
        // Determination of Av by the nominal operating point conditions
        Fxt_nominal = Fxt_full*xtCharacteristic(opening_nominal);
        x_nominal = dp_nominal/p_nominal;
        xs_nominal = smooth(0, if x_nominal > Fxt_nominal then Fxt_nominal else x_nominal);
        Y_nominal = 1 - abs(xs_nominal)/(3*Fxt_nominal);
        m_flow_nominal = valveCharacteristic(opening_nominal)*Av*Y_nominal*sqrt(rho_nominal)*Utilities.regRoot(p_nominal*xs_nominal, dp_small);
      else
        // Dummy values
        Fxt_nominal = 0;
        x_nominal = 0;
        xs_nominal = 0;
        Y_nominal = 0;
      end if;

    equation
      p = max(port_a.p, port_b.p);
      Fxt = Fxt_full*xtCharacteristic(opening_actual);
      x = dp/p;
      xs = max(-Fxt, min(x, Fxt));
      Y = 1 - abs(xs)/(3*Fxt);
      // m_flow = valveCharacteristic(opening)*Av*Y*sqrt(d)*sqrt(p*xs);
      if checkValve then
        m_flow = homotopy(valveCharacteristic(opening_actual)*Av*Y*sqrt(Medium.density(state_a))*
                               (if xs>=0 then Utilities.regRoot(p*xs, dp_turbulent) else 0),
                          valveCharacteristic(opening_actual)*m_flow_nominal*dp/dp_nominal);
      elseif not allowFlowReversal then
        m_flow = homotopy(valveCharacteristic(opening_actual)*Av*Y*sqrt(Medium.density(state_a))*
                               Utilities.regRoot(p*xs, dp_turbulent),
                          valveCharacteristic(opening_actual)*m_flow_nominal*dp/dp_nominal);
      else
        m_flow = homotopy(valveCharacteristic(opening_actual)*Av*Y*
                               Utilities.regRoot2(p*xs, dp_turbulent, Medium.density(state_a), Medium.density(state_b)),
                          valveCharacteristic(opening_actual)*m_flow_nominal*dp/dp_nominal);
    /* alternative formulation using smooth(0, ...) -- should not be used as regRoot2 has continuous derivatives
   -- cf. ModelicaTest.Fluid.TestPipesAndValves.DynamicPipeInitialization --
    m_flow = homotopy(valveCharacteristic(opening_actual)*Av*Y*
                        smooth(0, Utilities.regRoot(p*xs, dp_turbulent)*
                        (if xs>=0 then sqrt(Medium.density(state_a)) else sqrt(Medium.density(state_b)))),
                      valveCharacteristic(opening_actual)*m_flow_nominal*dp/dp_nominal);
*/
      end if;

      annotation (
      Documentation(info="<HTML>
<p>Valve model according to the IEC 534/ISA S.75 standards for valve sizing, compressible fluid, no phase change, also covering choked-flow conditions.</p>

<p>
The parameters of this model are explained in detail in
<a href=\"modelica://Modelica_Fluid.Valves.BaseClasses.PartialValve\">PartialValve</a>
(the base model for valves).
</p>

<p>This model can be used with gases and vapours, with arbitrary pressure ratio between inlet and outlet.</p>

<p>The product Fk*xt is given by the parameter <code>Fxt_full</code>, and is assumed constant by default. The relative change (per unit) of the xt coefficient with the valve opening can be specified by replacing the <code>xtCharacteristic</code> function.
<p>If <code>checkValve</code> is false, the valve supports reverse flow, with a symmetric flow characteristic curve. Otherwise, reverse flow is stopped (check valve behaviour).</p>

<p>
The treatment of parameters <b>Kv</b> and <b>Cv</b> is
explained in detail in the
<a href=\"modelica://Modelica_Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">User's Guide</a>.
</p>

</HTML>",
        revisions="<html>
<ul>
<li><i>2 Nov 2005</i>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br>
       Adapted from the ThermoPower library.</li>
</ul>
</html>"));
    end ValveCompressible;

    model ValveLinear "Valve for water/steam flows with linear pressure drop"
      extends Modelica_Fluid_Interfaces.PartialTwoPortTransport;
      parameter SI.AbsolutePressure dp_nominal
        "Nominal pressure drop at full opening"
        annotation (Dialog(group="Nominal operating point"));
      parameter Medium.MassFlowRate m_flow_nominal
        "Nominal mass flowrate at full opening";
      final parameter Types.HydraulicConductance k = m_flow_nominal/dp_nominal
        "Hydraulic conductance at full opening";
      Modelica_Blocks_Interfaces.RealInput opening(min=0,max=1)
        "=1: completely open, =0: completely closed"
      annotation (Placement(transformation(
            origin={0,90},
            extent={{-20,-20},{20,20}},
            rotation=270), iconTransformation(
            extent={{-20,-20},{20,20}},
            rotation=270,
            origin={0,80})));

    equation
      m_flow = opening*k*dp;

      // Isenthalpic state transformation (no storage and no loss of energy)
      port_a.h_outflow = inStream(port_b.h_outflow);
      port_b.h_outflow = inStream(port_a.h_outflow);

    annotation (
      Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{0,50},{0,0}}, color={0,0,0}),
            Rectangle(
              extent={{-20,60},{20,50}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-100,50},{100,-50},{100,50},{0,0},{-100,-50},{-100,50}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points=DynamicSelect({{-100,0},{100,-0},{100,0},{0,0},{-100,-0},{-100,
                  0}}, {{-100,50*opening_actual},{-100,50*opening_actual},{100,-50*opening_actual},{
                  100,50*opening_actual},{0,0},{-100,-50*opening_actual},{-100,50*opening_actual}}),
              fillColor={0,255,0},
              lineColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Polygon(points={{-100,50},{100,-50},{100,50},{0,0},{-100,-50},{-100,
                  50}}, lineColor={0,0,0})}),
      Documentation(info="<HTML>
<p>This very simple model provides a pressure drop which is proportional to the flowrate and to the <code>opening</code> input, without computing any fluid property. It can be used for testing purposes, when
a simple model of a variable pressure loss is needed.</p>
<p>A medium model must be nevertheless be specified, so that the fluid ports can be connected to other components using the same medium model.</p>
<p>The model is adiabatic (no heat losses to the ambient) and neglects changes in kinetic energy from the inlet to the outlet.</p>
</HTML>",
        revisions="<html>
<ul>
<li><i>2 Nov 2005</i>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br>
       Adapted from the ThermoPower library.</li>
</ul>
</html>"));
    end ValveLinear;

    model ValveDiscrete "Valve for water/steam flows with linear pressure drop"
      extends Modelica_Fluid_Interfaces.PartialTwoPortTransport;
      parameter SI.AbsolutePressure dp_nominal
        "Nominal pressure drop at full opening=1"
        annotation (Dialog(group="Nominal operating point"));
      parameter Medium.MassFlowRate m_flow_nominal
        "Nominal mass flowrate at full opening=1";
      final parameter Types.HydraulicConductance k = m_flow_nominal/dp_nominal
        "Hydraulic conductance at full opening=1";
      Modelica_Blocks_Interfaces.BooleanInput open
      annotation (Placement(transformation(
            origin={0,80},
            extent={{-20,-20},{20,20}},
            rotation=270)));
      parameter Real opening_min(min=0)=0
        "Remaining opening if closed, causing small leakage flow";
    equation
      m_flow = if open then 1*k*dp else opening_min*k*dp;

      // Isenthalpic state transformation (no storage and no loss of energy)
      port_a.h_outflow = inStream(port_b.h_outflow);
      port_b.h_outflow = inStream(port_a.h_outflow);

    annotation (
      Icon(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{0,50},{0,0}}, color={0,0,0}),
            Rectangle(
              extent={{-20,60},{20,50}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-100,50},{100,-50},{100,50},{0,0},{-100,-50},{-100,50}},
              fillColor=DynamicSelect({255,255,255}, if open > 0.5 then {0,255,0} else
                        {255,255,255}),
              lineColor={0,0,0},
              fillPattern=FillPattern.Solid)}),
      Documentation(info="<HTML>
<p>
This very simple model provides a (small) pressure drop which is proportional to the flowrate if the Boolean open signal is <b>true</b>. Otherwise, the mass flow rate is zero. If opening_min > 0, a small leakage mass flow rate occurs when open = <b>false</b>.
</p>
<p>This model can be used for simplified modelling of on-off valves, when it is not important to accurately describe the pressure loss when the valve is open. Although the medium model is not used to determine the pressure loss, it must be nevertheless be specified, so that the fluid ports can be connected to other components using the same medium model.</p>
<p>The model is adiabatic (no heat losses to the ambient) and neglects changes in kinetic energy from the inlet to the outlet.</p>
<p>
In a diagram animation, the valve is shown in \"green\", when
it is open.
</p>
</HTML>",
        revisions="<html>
<ul>
<li><i>Nov 2005</i>
    by Katja Poschlad (based on ValveLinear).</li>
</ul>
</html>"));
    end ValveDiscrete;

    package BaseClasses
      "Base classes used in the Valves package (only of interest to build new component models)"
      extends Modelica_Icons.BasesPackage;
      partial model PartialValve "Base model for valves"

        import Modelica_Fluid.Types.CvTypes;
        extends Modelica_Fluid_Interfaces.PartialTwoPortTransport(
          dp_start=dp_nominal,
          m_flow_small=if system.use_eps_Re then system.eps_m_flow*
              m_flow_nominal else system.m_flow_small,
          m_flow_start=m_flow_nominal);

        parameter CvTypes CvData=CvTypes.OpPoint
          "Selection of flow coefficient"
          annotation (Dialog(group="Flow Coefficient"));
        parameter SI.Area Av(fixed=if CvData == CvTypes.Av then true else false,
            start=m_flow_nominal/(sqrt(rho_nominal*dp_nominal))*
              valveCharacteristic(opening_nominal))
          "Av (metric) flow coefficient" annotation (Dialog(group=
                "Flow Coefficient", enable=(CvData == Modelica_Fluid.Types.CvTypes.Av)));
        parameter Real Kv = 0 "Kv (metric) flow coefficient [m3/h]"
        annotation(Dialog(group = "Flow Coefficient",
                          enable = (CvData==Modelica_Fluid.Types.CvTypes.Kv)));
        parameter Real Cv = 0 "Cv (US) flow coefficient [USG/min]"
        annotation(Dialog(group = "Flow Coefficient",
                          enable = (CvData==Modelica_Fluid.Types.CvTypes.Cv)));
        parameter SI.Pressure dp_nominal "Nominal pressure drop"
          annotation (Dialog(group="Nominal operating point"));
        parameter Medium.MassFlowRate m_flow_nominal "Nominal mass flowrate"
        annotation(Dialog(group="Nominal operating point"));
        parameter Medium.Density rho_nominal=Medium.density_pTX(Medium.p_default, Medium.T_default, Medium.X_default)
          "Nominal inlet density"
        annotation(Dialog(group="Nominal operating point",
                          enable = (CvData==Modelica_Fluid.Types.CvTypes.OpPoint)));
        parameter Real opening_nominal(min=0,max=1)=1 "Nominal opening"
        annotation(Dialog(group="Nominal operating point",
                          enable = (CvData==Modelica_Fluid.Types.CvTypes.OpPoint)));

        parameter Boolean filteredOpening=false
          "= true, if opening is filtered with a 2nd order CriticalDamping filter"
          annotation(Dialog(group="Filtered opening"),choices(checkBox=true));
        parameter SI.Time riseTime=1
          "Rise time of the filter (time to reach 99.6 % of an opening step)"
          annotation (Dialog(group="Filtered opening", enable=filteredOpening));
        parameter Real leakageOpening(min=0,max=1)=1e-3
          "The opening signal is limited by leakageOpening (to improve the numerics)"
          annotation(Dialog(group="Filtered opening",enable=filteredOpening));
        parameter Boolean checkValve=false "Reverse flow stopped"
          annotation(Dialog(tab="Assumptions"));

        replaceable function valveCharacteristic =
            ValveCharacteristics.linear constrainedby
          ValveCharacteristics.baseFun "Inherent flow characteristic"
          annotation(choicesAllMatching=true);
      protected
        parameter SI.Pressure dp_small=if system.use_eps_Re then dp_nominal/
            m_flow_nominal*m_flow_small else system.dp_small
          "Regularisation of zero flow" annotation (Dialog(tab="Advanced"));

      public
        constant SI.Area Kv2Av=27.7e-6 "Conversion factor";
        constant SI.Area Cv2Av=24.0e-6 "Conversion factor";

        Modelica_Blocks_Interfaces.RealInput opening(min=0, max=1)
          "Valve position in the range 0..1"
                                         annotation (Placement(transformation(
              origin={0,90},
              extent={{-20,-20},{20,20}},
              rotation=270), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=270,
              origin={0,80})));

        Modelica_Blocks_Interfaces.RealOutput opening_filtered if filteredOpening
          "Filtered valve position in the range 0..1"
          annotation (Placement(transformation(extent={{60,40},{80,60}}),
              iconTransformation(extent={{60,50},{80,70}})));

        Modelica_Blocks.Continuous.Filter filter(order=2, f_cut=5/(2*
              Modelica_Constants.pi*riseTime)) if filteredOpening
          annotation (Placement(transformation(extent={{34,44},{48,58}})));

      protected
        Modelica_Blocks_Interfaces.RealOutput opening_actual
          annotation (Placement(transformation(extent={{60,10},{80,30}})));

      block MinLimiter "Limit the signal above a threshold"
       parameter Real uMin=0 "Lower limit of input signal";
        extends Modelica_Blocks_Interfaces.SISO;

      equation
        y = smooth(0, noEvent( if u < uMin then uMin else u));
        annotation (
          Documentation(info="<HTML>
<p>
The block passes its input signal as output signal
as long as the input is above uMin. If this is not the case,
y=uMin is passed as output.
</p>
</html>"),       Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{0,-90},{0,68}}, color={192,192,192}),
          Polygon(
            points={{0,90},{-8,68},{8,68},{0,90}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,-8},{68,8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-70},{-50,-70},{50,70},{64,90}}, color={0,0,0}),
          Text(
            extent={{-150,-150},{150,-110}},
            lineColor={0,0,0},
                  textString="uMin=%uMin"),
          Text(
            extent={{-150,150},{150,110}},
            textString="%name",
            lineColor={0,0,255})}),
          Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{0,-60},{0,50}}, color={192,192,192}),
          Polygon(
            points={{0,60},{-5,50},{5,50},{0,60}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-60,0},{50,0}}, color={192,192,192}),
          Polygon(
            points={{60,0},{50,-5},{50,5},{60,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-50,-40},{-30,-40},{30,40},{50,40}}, color={0,0,0}),
          Text(
            extent={{46,-6},{68,-18}},
            lineColor={128,128,128},
            textString="u"),
          Text(
            extent={{-30,70},{-5,50}},
            lineColor={128,128,128},
            textString="y"),
          Text(
            extent={{-58,-54},{-28,-42}},
            lineColor={128,128,128},
            textString="uMin"),
          Text(
            extent={{26,40},{66,56}},
            lineColor={128,128,128},
            textString="uMax")}));
      end MinLimiter;

        MinLimiter minLimiter(uMin=leakageOpening)
          annotation (Placement(transformation(extent={{10,44},{24,58}})));
      initial equation
        if CvData == CvTypes.Kv then
          Av = Kv*Kv2Av "Unit conversion";
        elseif CvData == CvTypes.Cv then
          Av = Cv*Cv2Av "Unit conversion";
        end if;

      equation
        // Isenthalpic state transformation (no storage and no loss of energy)
        port_a.h_outflow = inStream(port_b.h_outflow);
        port_b.h_outflow = inStream(port_a.h_outflow);

        connect(filter.y, opening_filtered) annotation (Line(
            points={{48.7,51},{60,51},{60,50},{70,50}},
            color={0,0,127},
            smooth=Smooth.None));

        if filteredOpening then
           connect(filter.y, opening_actual);
        else
           connect(opening, opening_actual);
        end if;

        connect(minLimiter.y, filter.u) annotation (Line(
            points={{24.7,51},{32.6,51}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(minLimiter.u, opening) annotation (Line(
            points={{8.6,51},{0,51},{0,90}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{0,52},{0,0}}, color={0,0,0}),
              Rectangle(
                extent={{-20,60},{20,52}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-100,50},{100,-50},{100,50},{0,0},{-100,-50},{-100,50}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points=DynamicSelect({{-100,0},{100,-0},{100,0},{0,0},{-100,-0},{
                    -100,0}}, {{-100,50*opening_actual},{-100,50*opening_actual},{100,-50*
                    opening},{100,50*opening_actual},{0,0},{-100,-50*opening_actual},{-100,50*
                    opening}}),
                fillColor={0,255,0},
                lineColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(points={{-100,50},{100,-50},{100,50},{0,0},{-100,-50},{-100,
                    50}}, lineColor={0,0,0}),
              Ellipse(visible=filteredOpening,
                extent={{-40,94},{40,14}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(visible=filteredOpening,
                points={{-20,25},{-20,63},{0,41},{20,63},{20,25}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(visible=filteredOpening,
                points={{40,60},{60,60}},
                color={0,0,127},
                smooth=Smooth.None)}),
          Documentation(info="<HTML>
<p>This is the base model for the <code>ValveIncompressible</code>, <code>ValveVaporizing</code>, and <code>ValveCompressible</code> valve models. The model is based on the IEC 534 / ISA S.75 standards for valve sizing.</p>
<p>The model optionally supports reverse flow conditions (assuming symmetrical behaviour) or check valve operation, and has been suitably regularized, compared to the equations in the standard, in order to avoid numerical singularities around zero pressure drop operating conditions.</p>
<p>The model assumes adiabatic operation (no heat losses to the ambient); changes in kinetic energy
from inlet to outlet are neglected in the energy balance.</p>
<p><b>Modelling options</b></p>
<p>The following options are available to specify the valve flow coefficient in fully open conditions:
<ul><li><code>CvData = Modelica_Fluid.Types.CvTypes.Av</code>: the flow coefficient is given by the metric <code>Av</code> coefficient (m^2).
<li><code>CvData = Modelica_Fluid.Types.CvTypes.Kv</code>: the flow coefficient is given by the metric <code>Kv</code> coefficient (m^3/h).
<li><code>CvData = Modelica_Fluid.Types.CvTypes.Cv</code>: the flow coefficient is given by the US <code>Cv</code> coefficient (USG/min).
<li><code>CvData = Modelica_Fluid.Types.CvTypes.OpPoint</code>: the flow is computed from the nominal operating point specified by <code>p_nominal</code>, <code>dp_nominal</code>, <code>m_flow_nominal</code>, <code>rho_nominal</code>, <code>opening_nominal</code>.
</ul>
<p>The nominal pressure drop <code>dp_nominal</code> must always be specified; to avoid numerical singularities, the flow characteristic is modified for pressure drops less than <code>b*dp_nominal</code> (the default value is 1% of the nominal pressure drop). Increase this parameter if numerical problems occur in valves with very low pressure drops.
<p>If <code>checkValve</code> is true, then the flow is stopped when the outlet pressure is higher than the inlet pressure; otherwise, reverse flow takes place. Use this option only when needed, as it increases the numerical complexity of the problem.
<p>The valve opening characteristic <code>valveCharacteristic</code>, linear by default, can be replaced by any user-defined function. Quadratic and equal percentage with customizable rangeability are already provided by the library. The characteristics for constant port_a.p and port_b.p pressures with continuously changing opening are shown in the next two figures:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/ValveCharacteristics1a.png\"
     alt=\"ValveCharacteristics1a.png\"><br>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/ValveCharacteristics1b.png\"
     alt=\"Components/ValveCharacteristics1b.png\">
</blockquote>

<p>
The treatment of parameters <b>Kv</b> and <b>Cv</b> is
explained in detail in the
<a href=\"modelica://Modelica_Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">User's Guide</a>.
</p>

<p>
With the optional parameter \"filteredOpening\", the opening can be filtered with a
<b>second order, criticalDamping</b> filter so that the
opening demand is delayed by parameter \"riseTime\". The filtered opening is then available
via the output signal \"opening_filtered\" and is used to control the valve equations.
This approach approximates the driving device of a valve. The \"riseTime\" parameter
is used to compute the cut-off frequency of the filter by the equation: f_cut = 5/(2*pi*riseTime).
It defines the time that is needed until opening_filtered reaches 99.6 % of
a step input of opening. The icon of a valve changes in the following way
(left image: filteredOpening=false, right image: filteredOpening=true):
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/FilteredValveIcon.png\"
     alt=\"FilteredValveIcon.png\">
</blockquote>

<p>
If \"filteredOpening = <b>true</b>\", the input signal \"opening\" is limited
by parameter <b>leakageOpening</b>, i.e., if \"opening\" becomes smaller as
\"leakageOpening\", then \"leakageOpening\" is used instead of \"opening\" as input
for the filter. The reason is that \"opening=0\" might structurally change the equations of the
fluid network leading to a singularity. If a small leakage flow is introduced
(which is often anyway present in reality), the singularity might be avoided.
</p>

<p>
In the next figure, \"opening\" and \"filtered_opening\" are shown in the case that
filteredOpening = <b>true</b>, riseTime = 1 s, and leakageOpening = 0.02.
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/ValveFilteredOpening.png\"
     alt=\"ValveFilteredOpening.png\">
</blockquote>

</HTML>",   revisions="<html>
<ul>
<li><i>Sept. 5, 2010</i>
    by <a href=\"mailto:martin.otter@dlr.de\">Martin Otter</a>:<br>
    Optional filtering of opening introduced, based on a proposal
    from Mike Barth (Universitaet der Bundeswehr Hamburg) +
    Documentation improved.</li>
<li><i>2 Nov 2005</i>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br>
       Adapted from the ThermoPower library.</li>
</ul>
</html>"));
      end PartialValve;

    package ValveCharacteristics "Functions for valve characteristics"
      extends Modelica_Icons.VariantsPackage;
      partial function baseFun "Base class for valve characteristics"
        extends Modelica_Icons.Function;
        input Real pos(min=0, max=1)
            "Opening position (0: closed, 1: fully open)";
        output Real rc "Relative flow coefficient (per unit)";
        annotation (Documentation(info="<html>
<p>
This is a partial function that defines the interface of valve
characteristics. The function returns \"rc = valveCharacteristic\" as function of the
opening \"pos\" (in the range 0..1):
</p>

<blockquote><pre>
    dp = (zeta_TOT/2) * rho * velocity^2
m_flow =    sqrt(2/zeta_TOT) * Av * sqrt(rho * dp)
m_flow = valveCharacteristic * Av * sqrt(rho * dp)
m_flow =                  rc * Av * sqrt(rho * dp)
</pre></blockquote>

</html>"));
      end baseFun;

      function linear "Linear characteristic"
        extends baseFun;
      algorithm
        rc := pos;
      end linear;

      function one "Constant characteristic"
        extends baseFun;
      algorithm
        rc := 1;
      end one;

      function quadratic "Quadratic characteristic"
        extends baseFun;
      algorithm
        rc := pos*pos;
      end quadratic;

      function equalPercentage "Equal percentage characteristic"
        extends baseFun;
        input Real rangeability = 20 "Rangeability" annotation(Dialog);
        input Real delta = 0.01 annotation(Dialog);
      algorithm
        rc := if pos > delta then rangeability^(pos-1) else
                pos/delta*rangeability^(delta-1);
        annotation (Documentation(info="<html>
This characteristic is such that the relative change of the flow coefficient is proportional to the change in the opening position:
<p> d(rc)/d(pos) = k d(pos).
<p> The constant k is expressed in terms of the rangeability, i.e., the ratio between the maximum and the minimum useful flow coefficient:
<p> rangeability = exp(k) = rc(1.0)/rc(0.0).
<p> The theoretical characteristic has a non-zero opening when pos = 0; the implemented characteristic is modified so that the valve closes linearly when pos &lt; delta.
</html>"));
      end equalPercentage;

    end ValveCharacteristics;
    end BaseClasses;
    annotation (Documentation(info="<html>

</html>"));
  end Valves;

  package Fittings
    "Adaptors for connections of fluid components and the regulation of fluid flow"
    package Bends "Flow models for bends"
      extends Modelica_Icons.VariantsPackage;
      model CurvedBend "Curved bend flow model"
        extends Dissipation.Utilities.Icons.PressureLoss.Bend_i;
        extends Modelica_Fluid_Interfaces.PartialPressureLoss;

        parameter BaseClasses.Bends.CurvedBend.Geometry geometry
          "Geometry of curved bend"
          annotation (Placement(transformation(extent={{-20,0},{0,20}})));

      protected
        parameter Medium.AbsolutePressure dp_small=
                   Dissipation.PressureLoss.Bend.dp_curvedOverall_DP(
                      geometry,
                      Dissipation.PressureLoss.Bend.dp_curvedOverall_IN_var(
                        rho=Medium.density(state_dp_small),
                        eta=Medium.dynamicViscosity(state_dp_small)),
                      m_flow_small)
          "Default small pressure drop for regularization of laminar and zero flow (calculated from m_flow_small)";

      equation
        if allowFlowReversal then
          m_flow = BaseClasses.Bends.CurvedBend.massFlowRate(
                  dp,
                  geometry,
                  d_a,
                  d_b,
                  eta_a,
                  eta_b,
                  dp_small,
                  m_flow_small);
        else
          m_flow = Dissipation.PressureLoss.Bend.dp_curvedOverall_MFLOW(
                  geometry,
                  Dissipation.PressureLoss.Bend.dp_curvedOverall_IN_var(rho=d_a,
              eta=eta_a),
                  dp);

        end if;

        annotation (Documentation(info="<html>
<p>
This component models a <b>curved bend</b> in the overall flow regime for incompressible and single-phase fluid flow through circular cross sectional area considering surface roughness. It is expected that also compressible fluid flow can be handled up to about Ma = 0.3. It is assumed that neither mass nor energy is stored in this component.
In the model basically a function is called to compute the mass flow rate as a function
of pressure loss for a curved bend. Also the inverse of this function is defined, and a tool
might use this inverse function instead, in order to avoid the solution of a nonlinear equation.
</p>

<p>
The details of the model are described in the
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Bend.dp_curvedOverall\">documentation of the underlying function</a>.
</p>
</html>"));
      end CurvedBend;

      model EdgedBend "Edged bend flow model"
        extends Dissipation.Utilities.Icons.PressureLoss.Bend_i;
        extends Modelica_Fluid_Interfaces.PartialPressureLoss;

        parameter BaseClasses.Bends.EdgedBend.Geometry geometry
          "Geometry of curved bend"
          annotation (Placement(transformation(extent={{-20,0},{0,20}})));

      protected
        parameter Medium.AbsolutePressure dp_small=
                   Dissipation.PressureLoss.Bend.dp_edgedOverall_DP(
                     Dissipation.PressureLoss.Bend.dp_edgedOverall_IN_con(
                         d_hyd=geometry.d_hyd,
                         delta=geometry.delta,
                         K=geometry.K),
                      Dissipation.PressureLoss.Bend.dp_edgedOverall_IN_var(
                        rho=Medium.density(state_dp_small),
                        eta=Medium.dynamicViscosity(state_dp_small)),
                      m_flow_small)
          "Default small pressure drop for regularization of laminar and zero flow (calculated from m_flow_small)";

      equation
        if allowFlowReversal then
          m_flow = BaseClasses.Bends.EdgedBend.massFlowRate(
                  dp,
                  geometry,
                  d_a,
                  d_b,
                  eta_a,
                  eta_b,
                  dp_small,
                  m_flow_small);
        else
          m_flow = Dissipation.PressureLoss.Bend.dp_edgedOverall_MFLOW(
                  Dissipation.PressureLoss.Bend.dp_edgedOverall_IN_con(
                    d_hyd=geometry.d_hyd,
                    delta=geometry.delta,
                    K=geometry.K),
                  Dissipation.PressureLoss.Bend.dp_edgedOverall_IN_var(rho=d_a,
              eta=eta_a),
                  dp);

        end if;

        annotation (Documentation(info="<html>
<p>
This component models an <b>edged bend</b> in the overall flow regime for incompressible and single-phase fluid flow through circular cross sectional area considering surface roughness. It is expected that also compressible fluid flow can be handled up to about Ma = 0.3. It is assumed that neither mass nor energy is stored in this component.
In the model basically a function is called to compute the mass flow rate as a function
of pressure loss for an edged bend. Also the inverse of this function is defined, and a tool
might use this inverse function instead, in order to avoid the solution of a nonlinear equation.
</p>

<p>
The details of the model are described in the
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Bend.dp_edgedOverall\">documentation of the underlying function</a>.
</p>

</html>"));
      end EdgedBend;
    end Bends;

    package Orifices "Flow models for orifices"
      extends Modelica_Icons.VariantsPackage;

      model ThickEdgedOrifice "Thicked edged orifice flow model"
        extends Dissipation.Utilities.Icons.PressureLoss.Orifice_i;
        extends Modelica_Fluid_Interfaces.PartialPressureLoss;

        parameter BaseClasses.Orifices.ThickEdgedOrifice.Geometry geometry
          "Geometry of thick edged orifice" annotation (Placement(
              transformation(extent={{-20,0},{0,20}})), choices(
            choice=
                Modelica_Fluid.Fittings.BaseClasses.Orifices.ThickEdgedOrifice.Choices.circular(),

            choice=
                Modelica_Fluid.Fittings.BaseClasses.Orifices.ThickEdgedOrifice.Choices.rectangular(),

            choice=
                Modelica_Fluid.Fittings.BaseClasses.Orifices.ThickEdgedOrifice.Choices.general()));

      protected
        parameter Medium.AbsolutePressure dp_small=
                   Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_DP(
                   Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_IN_con(
                         A_0=geometry.venaCrossArea,
                         A_1=geometry.crossArea,
                         C_0=geometry.venaPerimeter,
                         C_1=geometry.perimeter,
                         L=geometry.venaLength,
                         dp_smooth=1e-10),
                      Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_IN_var(
                        rho=Medium.density(state_dp_small),
                        eta=Medium.dynamicViscosity(state_dp_small)),
                      m_flow_small)
          "Default small pressure drop for regularization of laminar and zero flow (calculated from m_flow_small)";
      equation
        if allowFlowReversal then
          m_flow = BaseClasses.Orifices.ThickEdgedOrifice.massFlowRate(
                  dp,
                  geometry,
                  d_a,
                  d_b,
                  eta_a,
                  eta_b,
                  dp_small,
                  m_flow_small);
        else
          m_flow = Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_MFLOW(
                  Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_IN_con(
                    A_0=geometry.venaCrossArea,
                    A_1=geometry.crossArea,
                    C_0=geometry.venaPerimeter,
                    C_1=geometry.perimeter,
                    L=geometry.venaLength,
                    dp_smooth=dp_small),
                  Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_IN_var(
              rho=d_a, eta=eta_a),
                  dp);

        end if;

        annotation (Documentation(info="<html>
<p>
This component models a <b>thick edged orifice</b> with sharp corners in the overall flow regime for incompressible and single-phase fluid flow through an arbitrary shaped cross sectional area (square, circular, etc.) considering  influence of surface roughness. It is expected that also compressible fluid flow can be handled up to about Ma = 0.3. It is assumed that neither mass nor energy is stored in this component.
In the model basically a function is called to compute the mass flow rate as a function
of pressure loss for a thick edged orifice. Also the inverse of this function is defined, and a tool
might use this inverse function instead, in order to avoid the solution of a nonlinear equation.
</p>

<p>
The details of the model are described in the
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Orifice.dp_thickEdgedOverall\">documentation of the underlying function</a>.
</p>

</html>"));
      end ThickEdgedOrifice;

    end Orifices;

    package GenericResistances "Flow models for generic resistances"
    extends Modelica_Icons.VariantsPackage;

      model VolumeFlowRate
        "Flow model for generic resistance parameterized with the volume flow rate"

        extends Dissipation.Utilities.Icons.PressureLoss.General_i;
        extends Modelica_Fluid_Interfaces.PartialTwoPortTransport;

        parameter Real a(unit="(Pa.s2)/m6") "Coefficient for quadratic term"
          annotation(Dialog(group="dp = a*V_flow^2 + b*V_flow"));
        parameter Real b(unit="(Pa.s)/m3") "Coefficient for linear term"
          annotation(Dialog(group="dp = a*V_flow^2 + b*V_flow"));

      protected
        parameter Medium.ThermodynamicState state_dp_small=Medium.setState_pTX(
                             Medium.reference_p,
                             Medium.reference_T,
                             Medium.reference_X)
          "Medium state to compute dp_small"                                        annotation(HideResult=true);
        parameter Medium.AbsolutePressure dp_small=
                   Dissipation.PressureLoss.General.dp_volumeFlowRate_DP(
                     Dissipation.PressureLoss.General.dp_volumeFlowRate_IN_con(
                         a=a,
                         b=b,
                         dp_min=1e-10),
                      Dissipation.PressureLoss.General.dp_volumeFlowRate_IN_var(
                        rho=Medium.density(state_dp_small)),
                      m_flow_small)
          "Default small pressure drop for regularization of laminar and zero flow (calculated from m_flow_small)";
        Medium.Density d_a
          "Density at port_a when fluid is flowing from port_a to port_b";
        Medium.Density d_b
          "If allowFlowReversal=true then Density at port_b when fluid is flowing from port_b to port_a else d_a";

      equation
        // Isenthalpic state transformation (no storage and no loss of energy)
        port_a.h_outflow = inStream(port_b.h_outflow);
        port_b.h_outflow = inStream(port_a.h_outflow);

        // Medium properties
        d_a = Medium.density(state_a);
        if allowFlowReversal then
          d_b = Medium.density(state_b);
        else
          d_b = d_a;
        end if;

        if allowFlowReversal then
          m_flow = BaseClasses.GenericResistances.VolumeFlowRate.massFlowRate(
                  dp,
                  a,
                  b,
                  d_a,
                  d_b,
                  dp_small,
                  m_flow_small);
        else
          m_flow = Dissipation.PressureLoss.General.dp_volumeFlowRate_MFLOW(
                  Dissipation.PressureLoss.General.dp_volumeFlowRate_IN_con(
                    a=a,
                    b=b,
                    dp_min=dp_small),
                  Dissipation.PressureLoss.General.dp_volumeFlowRate_IN_var(rho
              =d_a),
                  dp);

        end if;

        annotation (Documentation(info="<html>
<p>
This component models a generic resistance parameterized
with the volume flow rate:
</p>

<pre>
    dp     = a*V_flow^2 + b*V_flow
    m_flow = rho*V_flow
</pre>

<p>
with
</p>

<table>
<tr><td><b> a              </b></td><td> as quadratic coefficient [Pa*s^2/m^6],</td></tr>
<tr><td><b> b              </b></td><td> as linear coefficient [Pa*s/m3],</td></tr>
<tr><td><b> dp             </b></td><td> as pressure loss [Pa],</td></tr>
<tr><td><b> m_flow         </b></td><td> as mass flow rate [kg/s],</td></tr>
<tr><td><b> rho            </b></td><td> as density of fluid [kg/m3],</td></tr>
<tr><td><b> V_flow         </b></td><td> as volume flow rate [m3/s].</td></tr>
</table>

<p>
The geometry parameters of energy devices necessary for the pressure loss calculations are often not exactly known. Therefore the modelling of the detailed pressure loss calculation has to be simplified. This components use a linear and a quadratic dependence of the pressure loss on the volume flow rate. It is assumed that neither mass nor energy is stored in this component.
In the model basically a function is called to compute the mass flow rate as a function
of pressure loss. Also the inverse of this function is defined, and a tool
might use this inverse function instead, in order to avoid the solution of a nonlinear equation.
</p>

<p>
The details of the model are described in the
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_volumeFlowRate\">documentation of the underlying function</a>.
</p>

</html>"));
      end VolumeFlowRate;
      annotation (Documentation(info="<html>
<p>
The geometry parameters of energy devices necessary for the pressure loss
calculations are often not exactly known. Therefore the modelling of the detailed
pressure loss calculation has to be simplified.
In this package components are present that provide different forms of
such approximations.
</p>
</html>"));
    end GenericResistances;

       extends Modelica_Icons.VariantsPackage;

  model SimpleGenericOrifice
      "Simple generic orifice defined by pressure loss coefficient and diameter (only for flow from port_a to port_b)"

    extends Modelica_Fluid_Interfaces.PartialTwoPortTransport(
        dp_start=dp_nominal,
        m_flow_small=if system.use_eps_Re then system.eps_m_flow*m_flow_nominal
             else system.m_flow_small,
        m_flow(stateSelect=if momentumDynamics == Types.Dynamics.SteadyState
               then StateSelect.default else StateSelect.prefer));

    extends Modelica_Fluid_Interfaces.PartialLumpedFlow(final pathLength=0,
          final momentumDynamics=Types.Dynamics.SteadyState);

      parameter SI.Diameter diameter "Diameter of orifice";
    parameter Real zeta "Loss factor for flow of port_a -> port_b"
      annotation(Dialog(enable=use_zeta));
    parameter Boolean use_zeta = true
        "= false to obtain zeta from dp_nominal and m_flow_nominal";

    // Operational conditions
      parameter SI.MassFlowRate m_flow_nominal=if system.use_eps_Re then system.m_flow_nominal
           else 1e2*system.m_flow_small "Mass flow rate for dp_nominal"
        annotation (Dialog(group="Nominal operating point"));
      parameter SI.Pressure dp_nominal=if not system.use_eps_Re then 1e3 else
          BaseClasses.lossConstant_D_zeta(diameter, zeta)/Medium.density_pTX(
            Medium.p_default,
            Medium.T_default,
            Medium.X_default)*m_flow_nominal^2 "Nominal pressure drop"
        annotation (Dialog(group="Nominal operating point"));

    parameter Boolean use_Re = system.use_eps_Re
        "= true, if turbulent region is defined by Re, otherwise by m_flow_small"
      annotation(Dialog(tab="Advanced"), Evaluate=true);

    parameter Boolean from_dp = true
        "= true, use m_flow = f(dp) else dp = f(m_flow)"
      annotation (Evaluate=true, Dialog(tab="Advanced"));

    protected
    parameter Medium.AbsolutePressure dp_small = if system.use_eps_Re then dp_nominal/m_flow_nominal*m_flow_small else system.dp_small
        "Regularization of zero flow if |dp| < dp_small"
      annotation(Dialog(tab="Advanced", enable=not use_Re and from_dp));

    // Variables
    public
    Real zeta_nominal(start = zeta);
    Medium.Density d = 0.5*(Medium.density(state_a) + Medium.density(state_b));
    SI.Pressure dp_fg(start=dp_start)
        "pressure loss due to friction and gravity";
    SI.Area A_mean=Modelica_Constants.pi/4*diameter^2 "mean cross flow area";

      constant SI.ReynoldsNumber Re_turbulent=10000 "cf. sharpEdgedOrifice";
      SI.MassFlowRate m_flow_turbulent=if not use_Re then m_flow_small else max(
          m_flow_small, (Modelica_Constants.pi/8)*diameter*(
          Medium.dynamicViscosity(state_a) + Medium.dynamicViscosity(state_b))*
          Re_turbulent);
      SI.AbsolutePressure dp_turbulent=if not use_Re then dp_small else max(
          dp_small, BaseClasses.lossConstant_D_zeta(diameter, zeta_nominal)/d*
          m_flow_turbulent^2);
  equation
    if use_zeta then
      zeta_nominal = zeta;
    else
      dp_nominal = BaseClasses.lossConstant_D_zeta(diameter, zeta_nominal)/d*m_flow_nominal^2;
    end if;

    Ib_flow = 0;
    F_p = A_mean*(Medium.pressure(state_b) - Medium.pressure(state_a));
    F_fg = A_mean*dp_fg;

    /*
   dp = 0.5*zeta*d*v*|v|
      = 0.5*zeta*d*1/(d*A)^2 * m_flow * |m_flow|
      = 0.5*zeta/A^2 *1/d * m_flow * |m_flow|
      = k/d * m_flow * |m_flow|
   k  = 0.5*zeta/A^2
      = 0.5*zeta/(pi*(D/2)^2)^2
      = 8*zeta/(pi*D^2)^2
  */
    if from_dp then
      m_flow = homotopy(Utilities.regRoot2(
                           dp_fg,
                           dp_turbulent,
                           Medium.density(state_a)/BaseClasses.lossConstant_D_zeta(diameter, zeta_nominal),
                           Medium.density(state_b)/BaseClasses.lossConstant_D_zeta(diameter, zeta_nominal)),
                         m_flow_nominal*dp_fg/dp_nominal);
    else
      dp_fg = homotopy(Utilities.regSquare2(
                           m_flow,
                           m_flow_turbulent,
                           BaseClasses.lossConstant_D_zeta(diameter, zeta_nominal)/Medium.density(state_a),
                           BaseClasses.lossConstant_D_zeta(diameter, zeta_nominal)/Medium.density(state_b)),
                       dp_nominal*m_flow/m_flow_nominal);
    end if;

    // Isenthalpic state transformation (no storage and no loss of energy)
    port_a.h_outflow = inStream(port_b.h_outflow);
    port_b.h_outflow = inStream(port_a.h_outflow);

    annotation (defaultComponentName="orifice",
      Icon(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}}), graphics={
            Line(
              points={{-60,-50},{-60,50},{60,-50},{60,50}},
              color={0,0,0},
              thickness=0.5),
            Line(points={{-60,0},{-100,0}}, color={0,127,255}),
            Line(points={{60,0},{100,0}}, color={0,127,255}),
            Text(
              extent={{-173,104},{175,62}},
              lineColor={0,0,0},
              textString="zeta=%zeta")}),
      Documentation(info="<html>
<p>
This pressure drop component defines a
simple, generic orifice, where the loss factor &zeta; is provided
for one flow direction (e.g., from loss table of a book):
</p>

<pre>   &Delta;p = 0.5*&zeta;*&rho;*v*|v|
      = 8*&zeta;/(&pi;^2*D^4*&rho;) * m_flow*|m_flow|
</pre>

<p>
where
</p>
<ul>
<li> &Delta;p is the pressure drop: &Delta;p = port_a.p - port_b.p</li>
<li> D is the diameter of the orifice at the position where
     &zeta; is defined (either at port_a or port_b). If the orifice has not a
     circular cross section, D = 4*A/P, where A is the cross section
     area and P is the wetted perimeter.</li>
<li> &zeta; is the loss factor with respect to D
     that depends on the geometry of
     the orifice. In the turbulent flow regime, it is assumed that
     &zeta; is constant.<br>
     For small mass flow rates, the flow is laminar and is approximated
     by a polynomial that has a finite derivative for m_flow=0.</li>
<li> v is the mean velocity.</li>
<li> &rho; is the upstream density.</li>
</ul>

<p>
Since the pressure loss factor zeta is provided only for a mass flow
from port_a to port_b, the pressure loss is not correct when the
flow is reversing. If reversing flow only occurs in a short time interval,
this is most likely uncritical. If significant reversing flow
can appear, this component should not be used.
</p>
</html>"));
  end SimpleGenericOrifice;

  model SharpEdgedOrifice
      "Pressure drop due to sharp edged orifice (for both flow directions)"
      import NonSI = Modelica_SIunits.Conversions.NonSIunits;
    extends BaseClasses.QuadraticTurbulent.BaseModel(final data=
            BaseClasses.QuadraticTurbulent.LossFactorData.sharpEdgedOrifice(
            diameter,
            leastDiameter,
            length,
            alpha));
      parameter SI.Length length "Length of orifice";
      parameter SI.Diameter diameter
        "Inner diameter of pipe (= same at port_a and port_b)";
      parameter SI.Diameter leastDiameter "Smallest diameter of orifice";
    parameter NonSI.Angle_deg alpha "Angle of orifice";
    annotation (defaultComponentName="orifice",
      Documentation(info="<html>
</html>"),
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,44},{100,-44}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={0,127,255}),
            Polygon(
              points={{-25,44},{-25,7},{35,37},{35,44},{-25,44}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Backward,
              fillColor={175,175,175}),
            Polygon(
              points={{-25,-7},{-25,-44},{35,-44},{35,-36},{-25,-7}},
              lineColor={0,0,0},
              fillColor={175,175,175},
              fillPattern=FillPattern.Backward)}),
      Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                100,100}}), graphics={
            Rectangle(
              extent={{-100,60},{100,-60}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-30,60},{-30,12},{30,50},{30,60},{-30,60}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Backward),
            Polygon(
              points={{-30,-10},{-30,-60},{30,-60},{30,-50},{-30,-10}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Backward),
            Line(
              points={{-82,-60},{-82,60}},
              color={0,0,255},
              arrow={Arrow.Filled,Arrow.Filled}),
            Text(
              extent={{-78,16},{-44,-8}},
              lineColor={0,0,255},
              textString="diameter"),
            Line(
              points={{-30,-10},{-30,12}},
              color={0,0,255},
              arrow={Arrow.Filled,Arrow.Filled}),
            Text(
              extent={{-24,14},{8,-10}},
              lineColor={0,0,255},
              textString="leastDiameter"),
            Text(
              extent={{-20,84},{18,70}},
              lineColor={0,0,255},
              textString="length"),
            Line(
              points={{30,68},{-30,68}},
              color={0,0,255},
              arrow={Arrow.Filled,Arrow.Filled}),
            Line(
              points={{16,40},{32,18},{36,-2},{34,-20},{20,-42}},
              color={0,0,255},
              arrow={Arrow.Filled,Arrow.Filled}),
            Text(
              extent={{38,8},{92,-6}},
              lineColor={0,0,255},
              textString="alpha")}));

  end SharpEdgedOrifice;

  model AbruptAdaptor
      "Pressure drop in pipe due to suddenly expanding or reducing area (for both flow directions)"
    extends BaseClasses.QuadraticTurbulent.BaseModelNonconstantCrossSectionArea(final data=
            BaseClasses.QuadraticTurbulent.LossFactorData.suddenExpansion(
            diameter_a, diameter_b));
      parameter SI.Diameter diameter_a "Inner diameter of pipe at port_a";
      parameter SI.Diameter diameter_b "Inner diameter of pipe at port_b";

    annotation (
      Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                100,100}}), graphics={
            Line(points={{0,40},{-100,40},{-100,-40},{0,-40},{0,-100},{100,-100},
                  {100,100},{0,100},{0,40}}, color={0,0,0}),
            Rectangle(
              extent={{-100,40},{0,-40}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{0,100},{100,-100}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(points={{0,40},{-100,40},{-100,-40},{0,-40},{0,-100},{100,-100},
                  {100,100},{0,100},{0,40}}, color={0,0,0}),
            Line(
              points={{-60,-40},{-60,40}},
              color={0,0,255},
              arrow={Arrow.Filled,Arrow.Filled}),
            Text(
              extent={{-50,16},{-26,-10}},
              lineColor={0,0,255},
              textString="diameter_a"),
            Line(
              points={{34,-100},{34,100}},
              color={0,0,255},
              arrow={Arrow.Filled,Arrow.Filled}),
            Text(
              extent={{54,16},{78,-10}},
              lineColor={0,0,255},
              textString="diameter_b")}),
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={Rectangle(
              extent=DynamicSelect({{-100,22},{0,-22}}, {{-100,max(0.1, min(1,
                  diameter_a/max(diameter_a, diameter_b)))*60},{0,-max(0.1, min(1,
                  diameter_a/max(diameter_a, diameter_b)))*60}}),
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={0,127,255}), Rectangle(
              extent=DynamicSelect({{0,60},{100,-60}}, {{0,max(0.1, min(1,
                  diameter_b/max(diameter_a, diameter_b)))*60},{100,-max(0.1, min(
                  1, diameter_b/max(diameter_a, diameter_b)))*60}}),
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={0,127,255})}),
        Documentation(info="<html>

</html>"));
  end AbruptAdaptor;

    model MultiPort
      "Multiply a port; useful if multiple connections shall be made to a port exposing a state"

      function positiveMax
        extends Modelica_Icons.Function;
        input Real x;
        output Real y;
      algorithm
        y :=max(x, 1e-10);
      end positiveMax;

      import Constants = Modelica_Constants;

      replaceable package Medium=Modelica_Media_Interfaces.PartialMedium annotation(choicesAllMatching);

      // Ports
      parameter Integer nPorts_b=0
        "Number of outlet ports (mass is distributed evenly between the outlet ports"
        annotation(Dialog(connectorSizing=true));

      Modelica_Fluid_Interfaces.FluidPort_a port_a(redeclare package Medium =
            Medium) annotation (Placement(transformation(extent={{-50,-10},{-30,
                10}}, rotation=0)));
      Modelica_Fluid_Interfaces.FluidPorts_b ports_b[nPorts_b](redeclare each
          package Medium = Medium) annotation (Placement(transformation(extent=
                {{30,40},{50,-40}}, rotation=0)));

      Medium.MassFraction ports_b_Xi_inStream[nPorts_b,Medium.nXi]
        "inStream mass fractions at ports_b";
      Medium.ExtraProperty ports_b_C_inStream[nPorts_b,Medium.nC]
        "inStream extra properties at ports_b";

    equation
      // Only one connection allowed to a port to avoid unwanted ideal mixing
      for i in 1:nPorts_b loop
        assert(cardinality(ports_b[i]) <= 1,"
each ports_b[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts_b to add an additional port.
");   end for;

      // mass and momentum balance
      0 = port_a.m_flow + sum(ports_b.m_flow);
      ports_b.p = fill(port_a.p, nPorts_b);

      // mixing at port_a
      port_a.h_outflow = sum({positiveMax(ports_b[j].m_flow)*inStream(ports_b[j].h_outflow) for j in 1:nPorts_b})
                           / sum({positiveMax(ports_b[j].m_flow) for j in 1:nPorts_b});
      for j in 1:nPorts_b loop
         // expose stream values from port_a to ports_b
         ports_b[j].h_outflow  = inStream(port_a.h_outflow);
         ports_b[j].Xi_outflow = inStream(port_a.Xi_outflow);
         ports_b[j].C_outflow  = inStream(port_a.C_outflow);

         ports_b_Xi_inStream[j,:] = inStream(ports_b[j].Xi_outflow);
         ports_b_C_inStream[j,:] = inStream(ports_b[j].C_outflow);
      end for;
      for i in 1:Medium.nXi loop
        port_a.Xi_outflow[i] = (positiveMax(ports_b.m_flow)*ports_b_Xi_inStream[:,i])
                             / sum(positiveMax(ports_b.m_flow));
      end for;
      for i in 1:Medium.nC loop
        port_a.C_outflow[i] = (positiveMax(ports_b.m_flow)*ports_b_C_inStream[:,i])
                             / sum(positiveMax(ports_b.m_flow));
      end for;
      annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-40,
                -100},{40,100}}), graphics={
            Line(
              points={{-40,0},{40,0}},
              color={0,128,255},
              thickness=1),
            Line(
              points={{-40,0},{40,26}},
              color={0,128,255},
              thickness=1),
            Line(
              points={{-40,0},{40,-26}},
              color={0,128,255},
              thickness=1),
            Text(
              extent={{-150,100},{150,60}},
              lineColor={0,0,255},
              textString="%name")}),
                              Documentation(info="<html>
<p>
This model is useful if multiple connections shall be made to a port of a volume model exposing a state,
like a pipe with ModelStructure av_vb.
The mixing is shifted into the volume connected to port_a and the result is propagated back to each ports_b.
</p>
<p>
If multiple connections were directly made to the volume,
then ideal mixing would take place in the connection set, outside the volume. This is normally not intended.
</p>
</html>"));
    end MultiPort;

    model TeeJunctionIdeal
      "Splitting/joining component with static balances for an infinitesimal control volume"
      extends BaseClasses.PartialTeeJunction;

    equation
      connect(port_1, port_2) annotation (Line(
          points={{-100,0},{100,0}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(port_1, port_3) annotation (Line(
          points={{-100,0},{0,0},{0,100}},
          color={0,127,255},
          smooth=Smooth.None));
      annotation(Documentation(info="<html>
  This model is the simplest implementation for a splitting/joining component for
  three flows. Its use is not required. It just formulates the balance
  equations in the same way that the connect semantics would formulate them anyways.
  The main advantage of using this component is, that the user does not get
  confused when looking at the specific enthalpy at each port which might be confusing
  when not using a splitting/joining component. The reason for the confusion is that one examines the mixing
  enthalpy of the infinitesimal control volume introduced with the connect statement when
  looking at the specific enthalpy in the connector which
  might not be equal to the specific enthalpy at the port in the \"real world\".</html>"));
    end TeeJunctionIdeal;

    model TeeJunctionVolume
      "Splitting/joining component with static balances for a dynamic control volume"
      extends BaseClasses.PartialTeeJunction;
      extends Modelica_Fluid_Interfaces.PartialLumpedVolume(final fluidVolume=V);

      parameter SI.Volume V "Mixing volume inside junction";

    equation
      // Only one connection allowed to a port to avoid unwanted ideal mixing
      assert(cardinality(port_1) <= 1,"
port_1 of volume can at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections which is usually not the intention
of the modeller.
");   assert(cardinality(port_2) <= 1,"
port_2 of volume can at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections which is usually not the intention
of the modeller.
");   assert(cardinality(port_3) <= 1,"
port_3 of volume can at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections which is usually not the intention
of the modeller.
");

      // Boundary conditions
      port_1.h_outflow = medium.h;
      port_2.h_outflow = medium.h;
      port_3.h_outflow = medium.h;

      port_1.Xi_outflow = medium.Xi;
      port_2.Xi_outflow = medium.Xi;
      port_3.Xi_outflow = medium.Xi;

      port_1.C_outflow = C;
      port_2.C_outflow = C;
      port_3.C_outflow = C;

      // Mass balances
      mb_flow = port_1.m_flow + port_2.m_flow + port_3.m_flow "Mass balance";
      mbXi_flow = port_1.m_flow*actualStream(port_1.Xi_outflow)
                  + port_2.m_flow*actualStream(port_2.Xi_outflow)
                  + port_3.m_flow*actualStream(port_3.Xi_outflow)
        "Component mass balances";

      mbC_flow  = port_1.m_flow*actualStream(port_1.C_outflow)
                + port_2.m_flow*actualStream(port_2.C_outflow)
                + port_3.m_flow*actualStream(port_3.C_outflow)
        "Trace substance mass balances";

      // Momentum balance (suitable for compressible media)
      port_1.p = medium.p;
      port_2.p = medium.p;
      port_3.p = medium.p;

      // Energy balance
      Hb_flow = port_1.m_flow*actualStream(port_1.h_outflow)
                + port_2.m_flow*actualStream(port_2.h_outflow)
                + port_3.m_flow*actualStream(port_3.h_outflow);
      Qb_flow = 0;
      Wb_flow = 0;

      annotation (Documentation(info="<html>
  This model introduces a mixing volume into a junction.
  This might be useful to examine the non-ideal mixing taking place in a real junction.</html>"),
    Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Ellipse(
              extent={{-9,10},{11,-10}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid)}));
    end TeeJunctionVolume;

    package BaseClasses
      "Base classes used in the Fittings package (only of interest to build new component models)"
      extends Modelica_Icons.BasesPackage;

      function lossConstant_D_zeta "Return the loss constant 8*zeta/(pi^2*D^4)"
            extends Modelica_Icons.Function;

        input SI.Diameter D "Diameter at port_a or port_b";
        input Real zeta
          "Constant pressure loss factor with respect to D (i.e., either port_a or port_b)";
        output Real k "Loss constant (= 8*zeta/(pi^2*D^4))";

      algorithm
        k :=8*zeta/(Modelica_Constants.pi*Modelica_Constants.pi*D*D*D*D);
        annotation (Documentation(info="<html>

</html>"));
      end lossConstant_D_zeta;

      package QuadraticTurbulent
        "Pressure loss components that are mainly defined by a quadratic turbulent regime with constant loss factor data"
        extends Modelica_Icons.Package;
       record LossFactorData
          "Data structure defining constant loss factor data for dp = zeta*rho*v*|v|/2 and functions providing the data for some loss types"

              extends Modelica_Icons.Record;

          SI.Diameter diameter_a "Diameter at port_a" annotation (Dialog);
          SI.Diameter diameter_b "Diameter at port_b" annotation (Dialog);
        Real zeta1 "Loss factor for flow port_a -> port_b" annotation(Dialog);
        Real zeta2 "Loss factor for flow port_b -> port_a" annotation(Dialog);
          SI.ReynoldsNumber Re_turbulent
            "Loss factors suited for Re >= Re_turbulent" annotation (Dialog);
          SI.Diameter D_Re "Diameter used to compute Re" annotation (Dialog);
        Boolean zeta1_at_a = true
            "dp = zeta1*(if zeta1_at_a then rho_a*v_a^2/2 else rho_b*v_b^2/2)"
                                                                          annotation(Dialog);
        Boolean zeta2_at_a = false
            "dp = -zeta2*(if zeta2_at_a then rho_a*v_a^2/2 else rho_b*v_b^2/2)"
                                                                           annotation(Dialog);
        Boolean zetaLaminarKnown = false
            "= true, if zeta = c0/Re in laminar region"                              annotation(Dialog);
        Real c0 = 1
            "zeta = c0/Re; dp = zeta*rho_Re*v_Re^2/2, Re=v_Re*D_Re*rho_Re/mu_Re)"
                                                                                          annotation(Dialog(enable=zetaLaminarKnown));

         encapsulated function wallFriction
            "Return pressure loss data due to friction in a straight pipe with walls of nonuniform roughness (not useful for smooth pipes, since zeta is no function of Re)"
            import
              Modelica_Fluid.Fittings.BaseClasses.QuadraticTurbulent.LossFactorData;
            import lg = Modelica_Math.log10;
            import SI = Modelica_SIunits;
            import Modelica_SIunits;

            input Modelica_SIunits.Length length "Length of pipe"
              annotation (Dialog);
            input Modelica_SIunits.Diameter diameter "Inner diameter of pipe"
              annotation (Dialog);
            input Modelica_SIunits.Length roughness(min=1e-10)
              "Absolute roughness of pipe (> 0 required, details see info layer)"
              annotation (Dialog);
           output LossFactorData data
              "Pressure loss factors for both flow directions";
          protected
           Real Delta = roughness/diameter "relative roughness";
         algorithm
           data.diameter_a          := diameter;
           data.diameter_b          := diameter;
           data.zeta1        := (length/diameter)/(2*lg(3.7 /Delta))^2;
           data.zeta2        := data.zeta1;
           data.Re_turbulent := 4000
              ">= 560/Delta flow does not depend on Re, but interpolation is bad";
           data.D_Re         := diameter;
           data.zeta1_at_a   := true;
           data.zeta2_at_a   := false;
           data.zetaLaminarKnown := true;
           data.c0               := 64*(length/diameter);
           annotation (Icon(coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}), graphics={Rectangle(
                    extent={{-100,50},{100,-50}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid)}),
                                     Diagram(coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}), graphics={
                  Rectangle(
                    extent={{-100,64},{100,-64}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Backward),
                  Rectangle(
                    extent={{-100,50},{100,-49}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-60,-49},{-60,50}},
                    color={0,0,255},
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Text(
                    extent={{-50,16},{6,-10}},
                    lineColor={0,0,255},
                    textString="diameter"),
                  Line(
                    points={{-100,74},{100,74}},
                    color={0,0,255},
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Text(
                    extent={{-34,92},{34,74}},
                    lineColor={0,0,255},
                    textString="length")}),
             Documentation(info="<html>
<p>
Friction in straight pipe with walls of nonuniform roughness
(commercial pipes) in the region that does not depend on the Reynolds-number
</p>
<p>
The loss factors are given for mass flow rates from
port_a to port_b as:
</p>
<pre>
  turbulent flow (Idelchik 1994, diagram 2-5, p. 117)
     zeta = (L/D)/(2*lg(3.7 / &Delta;))^2, for Re >= 560/&Delta;
&nbsp;
     for Re &ge; 560/&Delta; the loss factor does not depend on the
     Reynolds number. For Re &ge; 4000, the flow is turbulent,
     but depends both on &Delta; and slightly on Re.
&nbsp;
  laminar flow (Idelchick 1994, diagram 2-1, p. 110):
     zeta = 64*(L/D)/Re
</pre>
<p>
where
</p>
<ul>
<li> D is the inner pipe diameter</li>
<li> L is the lenght of the pipe</li>
<li> &Delta; = &delta;/D is the relative roughness where &delta; is
     the absolute \"roughness\", i.e., the averaged height of asperities in the pipe.
     (&delta; may change over time due to growth of surface asperities during
      service, see [Idelchick 1994, p. 85, Tables 2-1, 2-2]).</li>
</ul>

<p>
Since the LossFactorData record can only describe loss factors that depend
on geometry (but, e.g., not on the Reynolds number), only the region
with Re &ge; 560/&Delta; is described by this data. Still, the turbulent
region with the above zeta is defined to start at Re=4000, since otherwise
the approximation for Re &lt; 560/&Delta; is too bad.
</p>

<p>
The absolute roughness <font face=\"Symbol\">d</font> has usually to
be estimated. In <i>[Idelchik 1994, pp. 105-109,
Table 2-5; Miller 1990, p. 190, Table 8-1]</i> many examples are given.
As a short summary:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><b>Smooth pipes</b></td>
      <td>Drawn brass, copper, aluminium, glass, etc.</td>
      <td><font face=\"Symbol\">d</font> = 0.0025 mm</td>
  </tr>
  <tr><td rowspan=\"3\"><b>Steel pipes</b></td>
      <td>New smooth pipes</td>
      <td><font face=\"Symbol\">d</font> = 0.025 mm</td>
  </tr>
  <tr><td>Mortar lined, average finish</td>
      <td><font face=\"Symbol\">d</font> = 0.1 mm</td>
  </tr>
  <tr><td>Heavy rust</td>
      <td><font face=\"Symbol\">d</font> = 1 mm</td>
  </tr>
  <tr><td rowspan=\"3\"><b>Concrete pipes</b></td>
      <td>Steel forms, first class workmanship</td>
      <td><font face=\"Symbol\">d</font> = 0.025 mm</td>
  </tr>
  <tr><td>Steel forms, average workmanship</td>
      <td><font face=\"Symbol\">d</font> = 0.1 mm</td>
  </tr>
  <tr><td>Block linings</td>
      <td><font face=\"Symbol\">d</font> = 1 mm</td>
  </tr>
</table>
</html>"));
         end wallFriction;

         encapsulated function suddenExpansion
            "Return pressure loss data for sudden expansion or contraction in a pipe (for both flow directions)"
            import
              Modelica_Fluid.Fittings.BaseClasses.QuadraticTurbulent.LossFactorData;
            import SI = Modelica_SIunits;
            import Modelica_SIunits;
            input Modelica_SIunits.Diameter diameter_a
              "Inner diameter of pipe at port_a" annotation (Dialog);
            input Modelica_SIunits.Diameter diameter_b
              "Inner diameter of pipe at port_b" annotation (Dialog);
           output LossFactorData data
              "Pressure loss factors for both flow directions";
          protected
           Real A_rel;
         algorithm
           data.diameter_a          := diameter_a;
           data.diameter_b          := diameter_b;
           data.Re_turbulent := 100;
           data.zetaLaminarKnown := true;
           data.c0 := 30;

           if diameter_a <= diameter_b then
              A_rel :=(diameter_a/diameter_b)^2;
              data.zeta1 :=(1 - A_rel)^2;
              data.zeta2 :=0.5*(1 - A_rel)^0.75;
              data.zeta1_at_a :=true;
              data.zeta2_at_a :=true;
              data.D_Re := diameter_a;
           else
              A_rel :=(diameter_b/diameter_a)^2;
              data.zeta1 :=0.5*(1 - A_rel)^0.75;
              data.zeta2 :=(1 - A_rel)^2;
              data.zeta1_at_a :=false;
              data.zeta2_at_a :=false;
              data.D_Re := diameter_b;
           end if;
           annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics={
                  Rectangle(
                    extent={{-100,40},{0,-40}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{0,100},{100,-100}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(points={{0,40},{-100,40},{-100,-40},{0,-40},{0,-100},{100,
                        -100},{100,100},{0,100},{0,40}}, color={0,0,0})}),
                                     Diagram(coordinateSystem(
                    preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                  graphics={
                  Line(points={{0,40},{-100,40},{-100,-40},{0,-40},{0,-100},{100,
                        -100},{100,100},{0,100},{0,40}}, color={0,0,0}),
                  Rectangle(
                    extent={{-100,40},{0,-40}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{0,100},{100,-100}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(points={{0,40},{-100,40},{-100,-40},{0,-40},{0,-100},{100,
                        -100},{100,100},{0,100},{0,40}}, color={0,0,0}),
                  Line(
                    points={{-60,-40},{-60,40}},
                    color={0,0,255},
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Text(
                    extent={{-50,16},{-26,-10}},
                    lineColor={0,0,255},
                    textString="diameter_a"),
                  Line(
                    points={{34,-100},{34,100}},
                    color={0,0,255},
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Text(
                    extent={{54,16},{78,-10}},
                    lineColor={0,0,255},
                    textString="diameter_b")}),
             Documentation(info="<html>
<p>
The loss factors are given for mass flow rates from
port_a to port_b as:
</p>
<pre>
   A_a &lt; A_b (Idelchik 1994, diagram 4-1, p. 208):
      zeta = dp/(rho_a*v_a^2/2)
           = (1 - A_a/A_b)^2 for Re_a &ge; 3.3e3 (turbulent flow)
      zeta = 30/Re           for Re_a &lt; 10    (laminar flow)
&nbsp;
   A_a &gt; A_b (Idelchik 1994, diagram 4-9, p. 216 and diagram 4-10, p. 217)
      zeta = dp/(rho_b*v_b^2/2)
           = 0.5*(1 - A_b/A_a)^0.75 for Re_b &ge; 1e4 (turbulent flow)
      zeta = 30/Re                  for Re_a &lt; 10  (laminar flow)
</pre>
</html>"));
         end suddenExpansion;

         encapsulated function sharpEdgedOrifice
            "Return pressure loss data for sharp edged orifice (for both flow directions)"
            import NonSI = Modelica_SIunits.Conversions.NonSIunits;
            import
              Modelica_Fluid.Fittings.BaseClasses.QuadraticTurbulent.LossFactorData;
            import SI = Modelica_SIunits;
            import Modelica_SIunits;
            input Modelica_SIunits.Diameter diameter
              "Inner diameter of pipe (= same at port_a and port_b)"
              annotation (Dialog);
            input Modelica_SIunits.Diameter leastDiameter
              "Smallest diameter of orifice" annotation (Dialog);
            input Modelica_SIunits.Diameter length "Length of orifice"
              annotation (Dialog);
            input NonSI.Angle_deg alpha "Angle of orifice"
                                                          annotation(Dialog);
            output LossFactorData data
              "Pressure loss factors for both flow directions";
          protected
            Real D_rel=leastDiameter/diameter;
            Real LD=length/leastDiameter;
            Real k=0.13 + 0.34*10^(-(3.4*LD + 88.4*LD^2.3));
         algorithm
            data.diameter_a := diameter;
            data.diameter_b := diameter;
            data.zeta1 := ((1 - D_rel) + 0.707*(1 - D_rel)^0.375)^2*(1/D_rel)^2;
            data.zeta2 := k*(1 - D_rel)^0.75 + (1 - D_rel)^2 + 2*sqrt(k*(1 -
              D_rel)^0.375) + (1 - D_rel);
            data.Re_turbulent := 1e4;
            data.D_Re := leastDiameter;
            data.zeta1_at_a := true;
            data.zeta2_at_a := false;
            data.zetaLaminarKnown := false;
            data.c0 := 0;
            annotation (
              Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                      {100,100}}), graphics={
                  Rectangle(
                    extent={{-100,60},{100,-60}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-30,60},{-30,12},{30,50},{30,60},{-30,60}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Backward),
                  Polygon(
                    points={{-30,-10},{-30,-60},{30,-60},{30,-50},{-30,-10}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Backward)}),
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics={
                  Rectangle(
                    extent={{-100,60},{100,-60}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-30,60},{-30,12},{30,50},{30,60},{-30,60}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Backward),
                  Polygon(
                    points={{-30,-10},{-30,-60},{30,-60},{30,-50},{-30,-10}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Backward),
                  Line(
                    points={{-82,-60},{-82,60}},
                    color={0,0,255},
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Text(
                    extent={{-78,16},{-44,-8}},
                    lineColor={0,0,255},
                    textString="diameter"),
                  Line(
                    points={{-30,-10},{-30,12}},
                    color={0,0,255},
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Text(
                    extent={{-24,14},{8,-10}},
                    lineColor={0,0,255},
                    textString="leastDiameter"),
                  Text(
                    extent={{-20,84},{18,70}},
                    lineColor={0,0,255},
                    textString="length"),
                  Line(
                    points={{30,68},{-30,68}},
                    color={0,0,255},
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Line(
                    points={{16,40},{32,18},{36,-2},{34,-20},{20,-42}},
                    color={0,0,255},
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Text(
                    extent={{38,8},{92,-6}},
                    lineColor={0,0,255},
                    textString="alpha")}),
              Documentation(info="<html>
<p>
Loss factor for mass flow rate from port_a to port_b
(Idelchik 1994, diagram 4-14, p. 221):
</p>
<pre>
   zeta = [(1-A0/A1) + 0.707*(1-A0/A1)^0.375]^2*(A1/A0)^2
          for Re(A0) >= 1e5,  independent of alpha
</pre>
<p>
Loss factor for mass flow rate from port_b to port_a
(Idelchik 1994, diagram 4-13, p. 220, with A2=A1):
</p>
<pre>
   zeta = k*(1 - A0/A1)^0.75 + (1 - A0/A1)^2 + 2*sqrt(k*(1-A0/A1)^0.375) + (1- A0/A1)
          k  = 0.13 + 0.34*10^(-(3.4*LD+88.4*LD^2.3))
               (there is a typing error in the formula in diagram 4-13, the above
                equation corresponds to table (a) in diagram 4-12)
          LD = L/D0
          for Re(A0) >= 1e4, 40 deg &le; alpha &le; 60 deg
                             for other values of alpha, k is given as table
                             in diagram 3-7 (this is not yet included in the function)
</pre
</html>"));
         end sharpEdgedOrifice;

        annotation (preferredView="info", Documentation(info="<html>
<p>
This record defines the pressure loss factors of a pipe
segment (orifice, bending etc.) with a minimum amount of data.
If available, data should be provided for <b>both flow directions</b>,
i.e., flow from port_a to port_b and from port_b to port_a,
as well as for the <b>laminar</b> and the <b>turbulent</b> region.
It is also an option to provide the loss factor <b>only</b> for the
<b>turbulent</b> region for a flow from port_a to port_b.
</p>
<p>
The following equations are used:
</p>
<pre>   &Delta;p = 0.5*&zeta;*&rho;*v*|v|
      = 0.5*&zeta;/A^2 * (1/&rho;) * m_flow*|m_flow|
      = 8*&zeta;/(&pi;^2*D^4*&rho;) * m_flow*|m_flow|
        Re = |v|*D*&rho;/&mu;
</pre>
<table border=1 cellspacing=0 cellpadding=2>
<tr><td><b>flow type</b></td>
    <td><b>&zeta;</b> = </td>
    <td><b>flow region</b></td></tr>
<tr><td>turbulent</td>
    <td><b>zeta1</b> = const.</td>
    <td>Re &ge;  Re_turbulent, v &ge; 0</td></tr>
<tr><td></td>
    <td><b>zeta2</b> = const.</td>
    <td>Re &ge; Re_turbulent, v &lt; 0</td></tr>
<tr><td>laminar</td>
    <td><b>c0</b>/Re</td>
    <td>both flow directions, Re small; c0 = const.</td></tr>
</table>
<p>
where
</p>
<ul>
<li> &Delta;p is the pressure drop: &Delta;p = port_a.p - port_b.p</li>
<li> v is the mean velocity.</li>
<li> &rho; is the density.</li>
<li> &zeta; is the loss factor that depends on the geometry of
     the pipe. In the turbulent flow regime, it is assumed that
     &zeta; is constant and is given by \"zeta1\" and
     \"zeta2\" depending on the flow direction.<br>
     When the Reynolds number Re is below \"Re_turbulent\", the
     flow is laminar for small flow velocities. For higher
     velocities there is a transition region from
     laminar to turbulent flow. The loss factor for
     laminar flow at small velocities is defined by the often occurring
     approximation c0/Re. If c0 is different for the two
     flow directions, the mean value has to be used
     (c0 = (c0_ab + c0_ba)/2).</li>
<li> The equation \"&Delta;p = 0.5*&zeta;*&rho;*v*|v|\" is either with
     respect to port_a or to port_b, depending on the definition
     of the particular loss factor &zeta; (in some references loss
     factors are defined with respect to port_a, in other references
     with respect to port_b).</li>
<li> Re = |v|*D_Re*&rho;/&mu; = |m_flow|*D_Re/(A_Re*&mu;)
     is the Reynolds number at the smallest cross
     section area. This is often at port_a or at port_b, but can
     also be between the two ports. In the record, the diameter
     D_Re of this smallest cross section area has to be provided, as
     well, as Re_turbulent, the absolute value of the
     Reynolds number at which
     the turbulent flow starts. If Re_turbulent is different for
     the two flow directions, use the smaller value as Re_turbulent.</li>
<li> D is the diameter of the pipe. If the pipe has not a
     circular cross section, D = 4*A/P, where A is the cross section
     area and P is the wetted perimeter.</li>
<li> A is the cross section area with A = &pi;(D/2)^2.</li>
<li> &mu; is the dynamic viscosity.</li>
</ul>
<p>
The laminar and the transition region is usually of
not much technical interest because the operating point is
mostly in the turbulent regime. For simplification and for
numerical reasons, this whole region is described by two
polynomials of third order, one polynomial for m_flow &ge; 0
and one for m_flow &lt; 0. The polynomials start at
Re = |m_flow|*4/(&pi;*D_Re*&mu;), where D_Re is the
smallest diameter between port_a and port_b.
The common derivative
of the two polynomials at Re = 0 is
computed from the equation \"c0/Re\". Note, the pressure drop
equation above in the laminar region is always defined
with respect to the smallest diameter D_Re.
</p>
<p>
If no data for c0 is available, the derivative at Re = 0 is computed in such
a way, that the second derivatives of the two polynomials
are identical at Re = 0. The polynomials are constructed, such that
they smoothly touch the characteristic curves in the turbulent
regions. The whole characteristic is therefore <b>continuous</b>
and has a <b>finite</b>, <b>continuous first derivative everywhere</b>.
In some cases, the constructed polynomials would \"vibrate\". This is
avoided by reducing the derivative at Re=0 in such a way that
the polynomials are guaranteed to be monotonically increasing.
The used sufficient criteria for monotonicity follows from:
</p>

<dl>
<dt> Fritsch F.N. and Carlson R.E. (1980):</dt>
<dd> <b>Monotone piecewise cubic interpolation</b>.
     SIAM J. Numerc. Anal., Vol. 17, No. 2, April 1980, pp. 238-246</dd>
</dl>
</html>"));
       end LossFactorData;

        function massFlowRate_dp
          "Return mass flow rate from constant loss factor data and pressure drop (m_flow = f(dp))"
                //import Modelica_Fluid.PressureLosses.BaseClasses.lossConstant_D_zeta;
          extends Modelica_Icons.Function;

          input SI.Pressure dp "Pressure drop (dp = port_a.p - port_b.p)";
          input SI.Density rho_a "Density at port_a";
          input SI.Density rho_b "Density at port_b";
          input LossFactorData data
            "Constant loss factors for both flow directions" annotation (
              choices(
              choice=Modelica_Fluid.Fittings.Utilities.QuadraticTurbulent.LossFactorData.wallFriction(),
              choice=Modelica_Fluid.Fittings.Utilities.QuadraticTurbulent.LossFactorData.suddenExpansion(),
              choice=Modelica_Fluid.Fittings.Utilities.QuadraticTurbulent.LossFactorData.sharpEdgedOrifice()));
          input SI.AbsolutePressure dp_small=1
            "Turbulent flow if |dp| >= dp_small";
          output SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";

        protected
          Real k1 = lossConstant_D_zeta(if data.zeta1_at_a then data.diameter_a else data.diameter_b,data.zeta1);
          Real k2 = lossConstant_D_zeta(if data.zeta2_at_a then data.diameter_a else data.diameter_b,data.zeta2);
        algorithm
          /*
   dp = 0.5*zeta*rho*v*|v|
      = 0.5*zeta*rho*1/(rho*A)^2 * m_flow * |m_flow|
      = 0.5*zeta/A^2 *1/rho * m_flow * |m_flow|
      = k/rho * m_flow * |m_flow|
   k  = 0.5*zeta/A^2
      = 0.5*zeta/(pi*(D/2)^2)^2
      = 8*zeta/(pi*D^2)^2
  */
          m_flow :=Utilities.regRoot2(dp, dp_small, rho_a/k1, rho_b/k2);
          annotation (smoothOrder=1, Documentation(info="<html>
<p>
Compute mass flow rate from constant loss factor and pressure drop (m_flow = f(dp)).
For small pressure drops (dp &lt; dp_small), the characteristic is approximated by
a polynomial in order to have a finite derivative at zero mass flow rate.
</p>
</html>"));
        end massFlowRate_dp;

        function massFlowRate_dp_and_Re
          "Return mass flow rate from constant loss factor data, pressure drop and Re (m_flow = f(dp))"
                extends Modelica_Icons.Function;

          input SI.Pressure dp "Pressure drop (dp = port_a.p - port_b.p)";
          input SI.Density rho_a "Density at port_a";
          input SI.Density rho_b "Density at port_b";
          input SI.DynamicViscosity mu_a "Dynamic viscosity at port_a";
          input SI.DynamicViscosity mu_b "Dynamic viscosity at port_b";
          input LossFactorData data
            "Constant loss factors for both flow directions" annotation (
              choices(
              choice=BaseClasses.PressureLosses.QuadraticTurbulent.LossFactorData.wallFriction(),
              choice=BaseClasses.PressureLosses.QuadraticTurbulent.LossFactorData.suddenExpansion(),
              choice=BaseClasses.PressureLosses.QuadraticTurbulent.LossFactorData.sharpEdgedOrifice()));
          output SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";

        protected
          constant Real pi=Modelica_Constants.pi;
          Real k0=2*data.c0/(pi*data.D_Re^3);
          Real k1 = lossConstant_D_zeta(if data.zeta1_at_a then data.diameter_a else data.diameter_b,data.zeta1);
          Real k2 = lossConstant_D_zeta(if data.zeta2_at_a then data.diameter_a else data.diameter_b,data.zeta2);
          Real yd0
            "Derivative of m_flow=m_flow(dp) at zero, if data.zetaLaminarKnown";
          SI.AbsolutePressure dp_turbulent
            "The turbulent region is: |dp| >= dp_turbulent";
        algorithm
        /*
Turbulent region:
   Re = m_flow*(4/pi)/(D_Re*mu)
   dp = 0.5*zeta*rho*v*|v|
      = 0.5*zeta*rho*1/(rho*A)^2 * m_flow * |m_flow|
      = 0.5*zeta/A^2 *1/rho * m_flow * |m_flow|
      = k/rho * m_flow * |m_flow|
   k  = 0.5*zeta/A^2
      = 0.5*zeta/(pi*(D/2)^2)^2
      = 8*zeta/(pi*D^2)^2
   m_flow_turbulent = (pi/4)*D_Re*mu*Re_turbulent
   dp_turbulent     =  k/rho *(D_Re*mu*pi/4)^2 * Re_turbulent^2

   The start of the turbulent region is computed with mean values
   of dynamic viscosity mu and density rho. Otherwise, one has
   to introduce different "delta" values for both flow directions.
   In order to simplify the approach, only one delta is used.

Laminar region:
   dp = 0.5*zeta/(A^2*d) * m_flow * |m_flow|
      = 0.5 * c0/(|m_flow|*(4/pi)/(D_Re*mu)) / ((pi*(D_Re/2)^2)^2*d) * m_flow*|m_flow|
      = 0.5 * c0*(pi/4)*(D_Re*mu) * 16/(pi^2*D_Re^4*d) * m_flow*|m_flow|
      = 2*c0/(pi*D_Re^3) * mu/rho * m_flow
      = k0 * mu/rho * m_flow
   k0 = 2*c0/(pi*D_Re^3)

   In order that the derivative of dp=f(m_flow) is continuous
   at m_flow=0, the mean values of mu and d are used in the
   laminar region: mu/rho = (mu_a + mu_b)/(rho_a + rho_b)
   If data.zetaLaminarKnown = false then mu_a and mu_b are potentially zero
   (because dummy values) and therefore the division is only performed
   if zetaLaminarKnown = true.
*/
           dp_turbulent :=(k1 + k2)/(rho_a + rho_b)*
                          ((mu_a + mu_b)*data.D_Re*pi/8)^2*data.Re_turbulent^2;
           yd0 :=if data.zetaLaminarKnown then
                    (rho_a + rho_b)/(k0*(mu_a + mu_b)) else 0;
           m_flow := Utilities.regRoot2(dp, dp_turbulent, rho_a/k1, rho_b/k2,
                                                       data.zetaLaminarKnown, yd0);
          annotation (smoothOrder=1, Documentation(info="<html>
<p>
Compute mass flow rate from constant loss factor and pressure drop (m_flow = f(dp)).
If the Reynolds-number Re &ge; data.Re_turbulent, the flow
is treated as a turbulent flow with constant loss factor zeta.
If the Reynolds-number Re &lt; data.Re_turbulent, the flow
is laminar and/or in a transition region between laminar and
turbulent. This region is approximated by two
polynomials of third order, one polynomial for m_flow &ge; 0
and one for m_flow &lt; 0.
The common derivative
of the two polynomials at Re = 0 is
computed from the equation \"data.c0/Re\".
</p>
<p>
If no data for c0 is available, the derivative at Re = 0 is computed in such
a way, that the second derivatives of the two polynomials
are identical at Re = 0. The polynomials are constructed, such that
they smoothly touch the characteristic curves in the turbulent
regions. The whole characteristic is therefore <b>continuous</b>
and has a <b>finite</b>, <b>continuous first derivative everywhere</b>.
In some cases, the constructed polynomials would \"vibrate\". This is
avoided by reducing the derivative at Re=0 in such a way that
the polynomials are guaranteed to be monotonically increasing.
The used sufficient criteria for monotonicity follows from:
</p>

<dl>
<dt> Fritsch F.N. and Carlson R.E. (1980):</dt>
<dd> <b>Monotone piecewise cubic interpolation</b>.
     SIAM J. Numerc. Anal., Vol. 17, No. 2, April 1980, pp. 238-246</dd>
</dl>
</html>"));
        end massFlowRate_dp_and_Re;

        function pressureLoss_m_flow
          "Return pressure drop from constant loss factor and mass flow rate (dp = f(m_flow))"
                extends Modelica_Icons.Function;

          input SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
          input SI.Density rho_a "Density at port_a";
          input SI.Density rho_b "Density at port_b";
          input LossFactorData data
            "Constant loss factors for both flow directions" annotation (
              choices(
              choice=BaseClasses.PressureLosses.QuadraticTurbulent.LossFactorData.wallFriction(),
              choice=BaseClasses.PressureLosses.QuadraticTurbulent.LossFactorData.suddenExpansion(),
              choice=BaseClasses.PressureLosses.QuadraticTurbulent.LossFactorData.sharpEdgedOrifice()));
          input SI.MassFlowRate m_flow_small=0.01
            "Turbulent flow if |m_flow| >= m_flow_small";
          output SI.Pressure dp "Pressure drop (dp = port_a.p - port_b.p)";

        protected
          Real k1 = lossConstant_D_zeta(if data.zeta1_at_a then data.diameter_a else data.diameter_b,data.zeta1);
          Real k2 = lossConstant_D_zeta(if data.zeta2_at_a then data.diameter_a else data.diameter_b,data.zeta2);
        algorithm
          /*
   dp = 0.5*zeta*rho*v*|v|
      = 0.5*zeta*rho*1/(rho*A)^2 * m_flow * |m_flow|
      = 0.5*zeta/A^2 *1/rho * m_flow * |m_flow|
      = k/rho * m_flow * |m_flow|
   k  = 0.5*zeta/A^2
      = 0.5*zeta/(pi*(D/2)^2)^2
      = 8*zeta/(pi*D^2)^2
  */
          dp :=Utilities.regSquare2(m_flow, m_flow_small, k1/rho_a, k2/rho_b);
          annotation (smoothOrder=1, Documentation(info="<html>
<p>
Compute pressure drop from constant loss factor and mass flow rate (dp = f(m_flow)).
For small mass flow rates(|m_flow| &lt; m_flow_small), the characteristic is approximated by
a polynomial in order to have a finite derivative at zero mass flow rate.
</p>
</html>"));
        end pressureLoss_m_flow;

        function pressureLoss_m_flow_and_Re
          "Return pressure drop from constant loss factor, mass flow rate and Re (dp = f(m_flow))"
                extends Modelica_Icons.Function;

          input SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
          input SI.Density rho_a "Density at port_a";
          input SI.Density rho_b "Density at port_b";
          input SI.DynamicViscosity mu_a "Dynamic viscosity at port_a";
          input SI.DynamicViscosity mu_b "Dynamic viscosity at port_b";
          input LossFactorData data
            "Constant loss factors for both flow directions" annotation (
              choices(
              choice=BaseClasses.PressureLosses.QuadraticTurbulent.LossFactorData.wallFriction(),
              choice=BaseClasses.PressureLosses.QuadraticTurbulent.LossFactorData.suddenExpansion(),
              choice=BaseClasses.PressureLosses.QuadraticTurbulent.LossFactorData.sharpEdgedOrifice()));
          output SI.Pressure dp "Pressure drop (dp = port_a.p - port_b.p)";

        protected
          constant Real pi=Modelica_Constants.pi;
          Real k0 = 2*data.c0/(pi*data.D_Re^3);
          Real k1 = lossConstant_D_zeta(if data.zeta1_at_a then data.diameter_a else data.diameter_b,data.zeta1);
          Real k2 = lossConstant_D_zeta(if data.zeta2_at_a then data.diameter_a else data.diameter_b,data.zeta2);
          Real yd0
            "Derivative of dp = f(m_flow) at zero, if data.zetaLaminarKnown";
          SI.MassFlowRate m_flow_turbulent
            "The turbulent region is: |m_flow| >= m_flow_turbulent";
        algorithm
        /*
Turbulent region:
   Re = m_flow*(4/pi)/(D_Re*mu)
   dp = 0.5*zeta*rho*v*|v|
      = 0.5*zeta*rho*1/(rho*A)^2 * m_flow * |m_flow|
      = 0.5*zeta/A^2 *1/rho * m_flow * |m_flow|
      = k/rho * m_flow * |m_flow|
   k  = 0.5*zeta/A^2
      = 0.5*zeta/(pi*(D/2)^2)^2
      = 8*zeta/(pi*D^2)^2
   m_flow_turbulent = (pi/4)*D_Re*mu*Re_turbulent
   dp_turbulent     =  k/rho *(D_Re*mu*pi/4)^2 * Re_turbulent^2

   The start of the turbulent region is computed with mean values
   of dynamic viscosity mu and density rho. Otherwise, one has
   to introduce different "delta" values for both flow directions.
   In order to simplify the approach, only one delta is used.

Laminar region:
   dp = 0.5*zeta/(A^2*d) * m_flow * |m_flow|
      = 0.5 * c0/(|m_flow|*(4/pi)/(D_Re*mu)) / ((pi*(D_Re/2)^2)^2*d) * m_flow*|m_flow|
      = 0.5 * c0*(pi/4)*(D_Re*mu) * 16/(pi^2*D_Re^4*d) * m_flow*|m_flow|
      = 2*c0/(pi*D_Re^3) * mu/rho * m_flow
      = k0 * mu/rho * m_flow
   k0 = 2*c0/(pi*D_Re^3)

   In order that the derivative of dp=f(m_flow) is continuous
   at m_flow=0, the mean values of mu and d are used in the
   laminar region: mu/rho = (mu_a + mu_b)/(rho_a + rho_b)
   If data.zetaLaminarKnown = false then mu_a and mu_b are potentially zero
   (because dummy values) and therefore the division is only performed
   if zetaLaminarKnown = true.
*/
          m_flow_turbulent :=(pi/8)*data.D_Re*(mu_a + mu_b)*data.Re_turbulent;
          yd0 :=if data.zetaLaminarKnown then k0*(mu_a + mu_b)/(rho_a + rho_b) else 0;
          dp :=Utilities.regSquare2(m_flow, m_flow_turbulent, k1/rho_a, k2/rho_b,
                                                   data.zetaLaminarKnown, yd0);
          annotation (smoothOrder=1, Documentation(info="<html>
<p>
Compute pressure drop from constant loss factor and mass flow rate (dp = f(m_flow)).
If the Reynolds-number Re &ge; data.Re_turbulent, the flow
is treated as a turbulent flow with constant loss factor zeta.
If the Reynolds-number Re &lt; data.Re_turbulent, the flow
is laminar and/or in a transition region between laminar and
turbulent. This region is approximated by two
polynomials of third order, one polynomial for m_flow &ge; 0
and one for m_flow &lt; 0.
The common derivative
of the two polynomials at Re = 0 is
computed from the equation \"data.c0/Re\".
</p>
<p>
If no data for c0 is available, the derivative at Re = 0 is computed in such
a way, that the second derivatives of the two polynomials
are identical at Re = 0. The polynomials are constructed, such that
they smoothly touch the characteristic curves in the turbulent
regions. The whole characteristic is therefore <b>continuous</b>
and has a <b>finite</b>, <b>continuous first derivative everywhere</b>.
In some cases, the constructed polynomials would \"vibrate\". This is
avoided by reducing the derivative at Re=0 in such a way that
the polynomials are guaranteed to be monotonically increasing.
The used sufficient criteria for monotonicity follows from:
</p>

<dl>
<dt> Fritsch F.N. and Carlson R.E. (1980):</dt>
<dd> <b>Monotone piecewise cubic interpolation</b>.
     SIAM J. Numerc. Anal., Vol. 17, No. 2, April 1980, pp. 238-246</dd>
</dl>
</html>"));
        end pressureLoss_m_flow_and_Re;

        partial model BaseModel
          "Generic pressure drop component with constant turbulent loss factor data and without an icon"

          extends Modelica_Fluid_Interfaces.PartialTwoPortTransport(
            dp_start=dp_nominal,
            m_flow_small=if system.use_eps_Re then system.eps_m_flow*
                m_flow_nominal else system.m_flow_small,
            m_flow(stateSelect=if momentumDynamics == Types.Dynamics.SteadyState
                   then StateSelect.default else StateSelect.prefer));
          extends Modelica_Fluid_Interfaces.PartialLumpedFlow(final pathLength=
                0, final momentumDynamics=Types.Dynamics.SteadyState);

          parameter LossFactorData data "Loss factor data";
          parameter SI.MassFlowRate m_flow_nominal=if system.use_eps_Re then
              system.m_flow_nominal else 1e2*system.m_flow_small
            "Nominal mass flow rate"
            annotation (Dialog(group="Nominal operating point"));

          // Advanced
          parameter Boolean use_Re = system.use_eps_Re
            "= true, if turbulent region is defined by Re, otherwise by m_flow_small"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          parameter Boolean from_dp = true
            "= true, use m_flow = f(dp) else dp = f(m_flow)"
            annotation (Evaluate=true, Dialog(tab="Advanced"));
        protected
          parameter Medium.ThermodynamicState state_nominal=Medium.setState_pTX(
                               Medium.reference_p,
                               Medium.reference_T,
                               Medium.reference_X)
            "Medium state to compute nominal pressure drop"                                        annotation(HideResult=true);
          parameter SI.Pressure dp_nominal=pressureLoss_m_flow(
                      m_flow_nominal,
                      Medium.density(state_nominal),
                      Medium.density(state_nominal),
                      data,
                      m_flow_small) "Nominal pressure loss";
          parameter Medium.AbsolutePressure dp_small = if system.use_eps_Re then dp_nominal/m_flow_nominal*m_flow_small else system.dp_small
            "Regularization of zero flow if |dp| < dp_small"
            annotation(Dialog(tab="Advanced", enable=not use_Re and from_dp));
          //parameter Medium.MassFlowRate m_flow_small = system.m_flow_small
          //  "Turbulent flow if |m_flow| >= m_flow_small"
          //  annotation(Dialog(tab = "Advanced", enable=not from_dp));

          // Diagnostics
        public
          parameter Boolean show_Re = false
            "= true, if Reynolds number is included for plotting"
             annotation (Evaluate=true, Dialog(tab="Advanced", group="Diagnostics"));
          SI.ReynoldsNumber Re=
              Pipes.BaseClasses.CharacteristicNumbers.ReynoldsNumber_m_flow(
                      m_flow,
                      noEvent(if m_flow > 0 then Medium.dynamicViscosity(
                state_a) else Medium.dynamicViscosity(state_b)),
                      data.D_Re) if show_Re
            "Reynolds number at diameter data.D_Re";

          // Variables
          SI.Pressure dp_fg "pressure loss due to friction and gravity";
          SI.Area A_mean=Modelica_Constants.pi/4*(data.diameter_a^2 + data.diameter_b
              ^2)/2 "mean cross flow area";

        equation
          Ib_flow = 0;
          F_p = A_mean*(Medium.pressure(state_b) - Medium.pressure(state_a));
          F_fg = A_mean*dp_fg;
          if from_dp then
             m_flow = homotopy(if use_Re then
                                 massFlowRate_dp_and_Re(
                                   dp_fg, Medium.density(state_a), Medium.density(state_b),
                                   Medium.dynamicViscosity(state_a),
                                   Medium.dynamicViscosity(state_b),
                                   data) else
                                 massFlowRate_dp(dp_fg, Medium.density(state_a), Medium.density(state_b), data, dp_small),
                               m_flow_nominal*dp_fg/dp_nominal);
          else
             dp_fg = homotopy(if use_Re then
                                pressureLoss_m_flow_and_Re(
                                  m_flow, Medium.density(state_a), Medium.density(state_b),
                                  Medium.dynamicViscosity(state_a),
                                  Medium.dynamicViscosity(state_b),
                                data) else
                                pressureLoss_m_flow(m_flow, Medium.density(state_a), Medium.density(state_b), data, m_flow_small),
                              dp_nominal*m_flow/m_flow_nominal);
          end if;

          // Isenthalpic state transformation (no storage and no loss of energy)
          port_a.h_outflow = inStream(port_b.h_outflow);
          port_b.h_outflow = inStream(port_a.h_outflow);

          annotation (
            Documentation(info="<html>
<p>
This model computes the pressure loss of a pipe
segment (orifice, bending etc.) with a minimum amount of data
provided via parameter <b>data</b>.
If available, data should be provided for <b>both flow directions</b>,
i.e., flow from port_a to port_b and from port_b to port_a,
as well as for the <b>laminar</b> and the <b>turbulent</b> region.
It is also an option to provide the loss factor <b>only</b> for the
<b>turbulent</b> region for a flow from port_a to port_b.
</p>
<p>
The following equations are used:
</p>
<pre>   &Delta;p = 0.5*&zeta;*&rho;*v*|v|
      = 0.5*&zeta;/A^2 * (1/&rho;) * m_flow*|m_flow|
        Re = |v|*D*&rho;/&mu;
</pre>
<table border=1 cellspacing=0 cellpadding=2>
<tr><td><b>flow type</b></td>
    <td><b>&zeta;</b> = </td>
    <td><b>flow region</b></td></tr>
<tr><td>turbulent</td>
    <td><b>zeta1</b> = const.</td>
    <td>Re &ge;  Re_turbulent, v &ge; 0</td></tr>
<tr><td></td>
    <td><b>zeta2</b> = const.</td>
    <td>Re &ge; Re_turbulent, v &lt; 0</td></tr>
<tr><td>laminar</td>
    <td><b>c0</b>/Re</td>
    <td>both flow directions, Re small; c0 = const.</td></tr>
</table>
<p>
where
</p>
<ul>
<li> &Delta;p is the pressure drop: &Delta;p = port_a.p - port_b.p</li>
<li> v is the mean velocity.</li>
<li> &rho; is the density.</li>
<li> &zeta; is the loss factor that depends on the geometry of
     the pipe. In the turbulent flow regime, it is assumed that
     &zeta; is constant and is given by \"zeta1\" and
     \"zeta2\" depending on the flow direction.<br>
     When the Reynolds number Re is below \"Re_turbulent\", the
     flow is laminar for small flow velocities. For higher
     velocities there is a transition region from
     laminar to turbulent flow. The loss factor for
     laminar flow at small velocities is defined by the often occurring
     approximation c0/Re. If c0 is different for the two
     flow directions, the mean value has to be used
     (c0 = (c0_ab + c0_ba)/2).</li>
<li> The equation \"&Delta;p = 0.5*&zeta;*&rho;*v*|v|\" is either with
     respect to port_a or to port_b, depending on the definition
     of the particular loss factor &zeta; (in some references loss
     factors are defined with respect to port_a, in other references
     with respect to port_b).</li>
<li> Re = |v|*D_Re*&rho;/&mu; = |m_flow|*D_Re/(A_Re*&mu;)
     is the Reynolds number at the smallest cross
     section area. This is often at port_a or at port_b, but can
     also be between the two ports. In the record, the diameter
     D_Re of this smallest cross section area has to be provided, as
     well, as Re_turbulent, the absolute value of the
     Reynolds number at which
     the turbulent flow starts. If Re_turbulent is different for
     the two flow directions, use the smaller value as Re_turbulent.</li>
<li> D is the diameter of the pipe. If the pipe has not a
     circular cross section, D = 4*A/P, where A is the cross section
     area and P is the wetted perimeter.</li>
<li> A is the cross section area with A = &pi;(D/2)^2.</li>
<li> &mu; is the dynamic viscosity.</li>
</ul>
<p>
The laminar and the transition region is usually of
not much technical interest because the operating point is
mostly in the turbulent regime. For simplification and for
numerical reasons, this whole region is described by two
polynomials of third order, one polynomial for m_flow &ge; 0
and one for m_flow &lt; 0. The polynomials start at
Re = |m_flow|*4/(&pi;*D_Re*&mu;), where D_Re is the
smallest diameter between port_a and port_b.
The common derivative
of the two polynomials at Re = 0 is
computed from the equation \"c0/Re\". Note, the pressure drop
equation above in the laminar region is always defined
with respect to the smallest diameter D_Re.
</p>
<p>
If no data for c0 is available, the derivative at Re = 0 is computed in such
a way, that the second derivatives of the two polynomials
are identical at Re = 0. The polynomials are constructed, such that
they smoothly touch the characteristic curves in the turbulent
regions. The whole characteristic is therefore <b>continuous</b>
and has a <b>finite</b>, <b>continuous first derivative everywhere</b>.
In some cases, the constructed polynomials would \"vibrate\". This is
avoided by reducing the derivative at Re=0 in such a way that
the polynomials are guaranteed to be monotonically increasing.
The used sufficient criteria for monotonicity follows from:
</p>

<dl>
<dt> Fritsch F.N. and Carlson R.E. (1980):</dt>
<dd> <b>Monotone piecewise cubic interpolation</b>.
     SIAM J. Numerc. Anal., Vol. 17, No. 2, April 1980, pp. 238-246</dd>
</dl>
</html>"));
        end BaseModel;

      model TestWallFriction
          "Pressure drop in pipe due to wall friction (only for test purposes; if needed use Pipes.StaticPipe instead)"
              extends BaseModel(final data=
                LossFactorData.wallFriction(
                length,
                diameter,
                roughness));
          parameter SI.Length length "Length of pipe";
          parameter SI.Diameter diameter "Inner diameter of pipe";
          parameter SI.Length roughness(min=1e-10)
            "Absolute roughness of pipe (> 0 required, details see info layer)";
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{-150,80},{150,120}},
                  lineColor={0,0,0},
                  textString="%name"),
                Rectangle(
                  extent={{-100,60},{100,-60}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-100,34},{100,-36}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255}),
                Text(
                  extent={{-134,-66},{130,-92}},
                  lineColor={0,0,0},
                  textString="quad. turbulent")}),
            Documentation(info="<html>

</html>"));
      end TestWallFriction;

        partial model BaseModelNonconstantCrossSectionArea
          "Generic pressure drop component with constant turbulent loss factor data and without an icon, for non-constant cross section area"

          extends Modelica_Fluid_Interfaces.PartialTwoPortTransport(
            final dp_start=dp_nominal,
            m_flow_small=if system.use_eps_Re then system.eps_m_flow*
                m_flow_nominal else system.m_flow_small,
            m_flow(stateSelect=if momentumDynamics == Types.Dynamics.SteadyState
                   then StateSelect.default else StateSelect.prefer));
          extends Modelica_Fluid_Interfaces.PartialLumpedFlow(final pathLength=
                0, final momentumDynamics=Types.Dynamics.SteadyState);

          parameter LossFactorData data "Loss factor data";
          parameter SI.MassFlowRate m_flow_nominal=if system.use_eps_Re then
              system.m_flow_nominal else 1e2*system.m_flow_small
            "Nominal mass flow rate"
            annotation (Dialog(group="Nominal operating point"));

          // Advanced
          /// Other settings than the final values are not yet implemented ///
          final parameter Boolean use_Re = false
            "= true, if turbulent region is defined by Re, otherwise by m_flow_small"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          final parameter Boolean from_dp = false
            "= true, use m_flow = f(dp) else dp = f(m_flow)"
            annotation (Evaluate=true, Dialog(tab="Advanced"));
          // End not yet implemented /////////////////////////////////////////
        protected
          parameter Medium.ThermodynamicState state_nominal=Medium.setState_pTX(
                               Medium.reference_p,
                               Medium.reference_T,
                               Medium.reference_X)
            "Medium state to compute nominal pressure drop"                                        annotation(HideResult=true);
          parameter SI.Pressure dp_nominal=pressureLoss_m_flow(
                      m_flow_nominal,
                      Medium.density(state_nominal),
                      Medium.density(state_nominal),
                      data,
                      m_flow_small) "Nominal pressure loss";
          parameter Medium.AbsolutePressure dp_small = if system.use_eps_Re then dp_nominal/m_flow_nominal*m_flow_small else system.dp_small
            "Regularization of zero flow if |dp| < dp_small"
            annotation(Dialog(tab="Advanced", enable=not use_Re and from_dp));
          //parameter Medium.MassFlowRate m_flow_small = system.m_flow_small
          //  "Turbulent flow if |m_flow| >= m_flow_small"
          //  annotation(Dialog(tab = "Advanced", enable=not from_dp));

          // Diagnostics
        public
          parameter Boolean show_Re = false
            "= true, if Reynolds number is included for plotting"
             annotation (Evaluate=true, Dialog(tab="Advanced", group="Diagnostics"));
          SI.ReynoldsNumber Re=
              Pipes.BaseClasses.CharacteristicNumbers.ReynoldsNumber_m_flow(
                      m_flow,
                      noEvent(if m_flow > 0 then Medium.dynamicViscosity(
                state_a) else Medium.dynamicViscosity(state_b)),
                      data.D_Re) if show_Re
            "Reynolds number at diameter data.D_Re";
          parameter Boolean show_totalPressures = false
            "= true, if total pressures are included for plotting"
             annotation (Evaluate=true, Dialog(tab="Advanced", group="Diagnostics"));
          SI.AbsolutePressure p_total_a=port_a.p + 0.5*m_flow^2/((
              Modelica_Constants.pi/4*data.diameter_a^2)^2*noEvent(if port_a.m_flow
               > 0 then Medium.density(state_a) else Medium.density(state_b)))
            if show_totalPressures "Total pressure at port_a";
          SI.AbsolutePressure p_total_b=port_b.p + 0.5*m_flow^2/((
              Modelica_Constants.pi/4*data.diameter_b^2)^2*noEvent(if port_b.m_flow
               > 0 then Medium.density(state_b) else Medium.density(state_a)))
            if show_totalPressures "Total pressure at port_a";
          parameter Boolean show_portVelocities = false
            "= true, if port velocities are included for plotting"
             annotation (Evaluate=true, Dialog(tab="Advanced", group="Diagnostics"));
          SI.Velocity v_a=port_a.m_flow/(Modelica_Constants.pi/4*data.diameter_a
              ^2*noEvent(if port_a.m_flow > 0 then Medium.density(state_a)
               else Medium.density(state_b))) if show_portVelocities
            "Fluid velocity into port_a";
          SI.Velocity v_b=port_b.m_flow/(Modelica_Constants.pi/4*data.diameter_b
              ^2*noEvent(if port_b.m_flow > 0 then Medium.density(state_b)
               else Medium.density(state_a))) if show_portVelocities
            "Fluid velocity into port_b";

          // Variables
          SI.Pressure dp_fg "pressure loss due to friction and gravity";
          SI.Area A_mean=Modelica_Constants.pi/4*(data.diameter_a^2 + data.diameter_b
              ^2)/2 "mean cross flow area";

          Medium.ThermodynamicState state_b_des
            "Thermodynamic state at port b for flow a -> b";
          Medium.ThermodynamicState state_a_nondes
            "Thermodynamic state at port a for flow a <- b";

        equation
          Ib_flow = 0;
          F_p = A_mean*(Medium.pressure(state_b) - Medium.pressure(state_a));
          F_fg = A_mean*dp_fg;
          if from_dp then
             m_flow = if use_Re then
                         massFlowRate_dp_and_Re(
                            dp_fg, Medium.density(state_a), Medium.density(state_b),
                            Medium.dynamicViscosity(state_a),
                            Medium.dynamicViscosity(state_b),
                            data) else
                         massFlowRate_dp(dp_fg, Medium.density(state_a), Medium.density(state_b), data, dp_small);
          else
             dp_fg = if use_Re then
                     pressureLoss_m_flow_and_Re(
                         m_flow, Medium.density(state_a), Medium.density(state_b),
                         Medium.dynamicViscosity(state_a),
                         Medium.dynamicViscosity(state_b),
                         data) else
                     pressureLoss_m_flow_totalPressure(m_flow,
                       Medium.density(state_a),
                       Medium.density(state_b_des),
                       Medium.density(state_b),
                       Medium.density(state_a_nondes),
                       data, m_flow_small);
          end if;

          // Isenthalpic state transformation (no storage and no loss of energy)
          port_a.h_outflow = inStream(port_b.h_outflow);
          port_b.h_outflow = inStream(port_a.h_outflow);

          // medium states for downstream properties, may want to change this neglecting the only difference from state_a, state_b, which is in pressure
          // This will remove the extra interaction variables
          state_b_des = Medium.setState_phX(port_b.p, inStream(port_a.h_outflow), inStream(port_a.Xi_outflow));
          state_a_nondes = Medium.setState_phX(port_a.p, inStream(port_b.h_outflow), inStream(port_b.Xi_outflow));

          annotation (
            Documentation(info="<html>
<p>
This model computes the pressure loss of a pipe
segment (orifice, bending etc.) with a minimum amount of data
provided via parameter <b>data</b>.
If available, data should be provided for <b>both flow directions</b>,
i.e., flow from port_a to port_b and from port_b to port_a,
as well as for the <b>laminar</b> and the <b>turbulent</b> region.
It is also an option to provide the loss factor <b>only</b> for the
<b>turbulent</b> region for a flow from port_a to port_b.
</p>
<p>
The following equations are used:
</p>
<pre>   &Delta;p = 0.5*&zeta;*&rho;*v*|v|
      = 0.5*&zeta;/A^2 * (1/&rho;) * m_flow*|m_flow|
        Re = |v|*D*&rho;/&mu;
</pre>
<table border=1 cellspacing=0 cellpadding=2>
<tr><td><b>flow type</b></td>
    <td><b>&zeta;</b> = </td>
    <td><b>flow region</b></td></tr>
<tr><td>turbulent</td>
    <td><b>zeta1</b> = const.</td>
    <td>Re &ge;  Re_turbulent, v &ge; 0</td></tr>
<tr><td></td>
    <td><b>zeta2</b> = const.</td>
    <td>Re &ge; Re_turbulent, v &lt; 0</td></tr>
<tr><td>laminar</td>
    <td><b>c0</b>/Re</td>
    <td>both flow directions, Re small; c0 = const.</td></tr>
</table>
<p>
where
</p>
<ul>
<li> &Delta;p is the pressure drop: &Delta;p = port_a.p - port_b.p</li>
<li> v is the mean velocity.</li>
<li> &rho; is the density.</li>
<li> &zeta; is the loss factor that depends on the geometry of
     the pipe. In the turbulent flow regime, it is assumed that
     &zeta; is constant and is given by \"zeta1\" and
     \"zeta2\" depending on the flow direction.<br>
     When the Reynolds number Re is below \"Re_turbulent\", the
     flow is laminar for small flow velocities. For higher
     velocities there is a transition region from
     laminar to turbulent flow. The loss factor for
     laminar flow at small velocities is defined by the often occurring
     approximation c0/Re. If c0 is different for the two
     flow directions, the mean value has to be used
     (c0 = (c0_ab + c0_ba)/2).</li>
<li> The equation \"&Delta;p = 0.5*&zeta;*&rho;*v*|v|\" is either with
     respect to port_a or to port_b, depending on the definition
     of the particular loss factor &zeta; (in some references loss
     factors are defined with respect to port_a, in other references
     with respect to port_b).</li>

<li> Re = |v|*D_Re*&rho;/&mu; = |m_flow|*D_Re/(A_Re*&mu;)
     is the Reynolds number at the smallest cross
     section area. This is often at port_a or at port_b, but can
     also be between the two ports. In the record, the diameter
     D_Re of this smallest cross section area has to be provided, as
     well, as Re_turbulent, the absolute value of the
     Reynolds number at which
     the turbulent flow starts. If Re_turbulent is different for
     the two flow directions, use the smaller value as Re_turbulent.</li>
<li> D is the diameter of the pipe. If the pipe has not a
     circular cross section, D = 4*A/P, where A is the cross section
     area and P is the wetted perimeter.</li>
<li> A is the cross section area with A = &pi;(D/2)^2.</li>
<li> &mu; is the dynamic viscosity.</li>
</ul>
<p>
The laminar and the transition region is usually of
not much technical interest because the operating point is
mostly in the turbulent regime. For simplification and for
numerical reasons, this whole region is described by two
polynomials of third order, one polynomial for m_flow &ge; 0
and one for m_flow &lt; 0. The polynomials start at
Re = |m_flow|*4/(&pi;*D_Re*&mu;), where D_Re is the
smallest diameter between port_a and port_b.
The common derivative
of the two polynomials at Re = 0 is
computed from the equation \"c0/Re\". Note, the pressure drop
equation above in the laminar region is always defined
with respect to the smallest diameter D_Re.
</p>
<p>
If no data for c0 is available, the derivative at Re = 0 is computed in such
a way, that the second derivatives of the two polynomials
are identical at Re = 0. The polynomials are constructed, such that
they smoothly touch the characteristic curves in the turbulent
regions. The whole characteristic is therefore <b>continuous</b>
and has a <b>finite</b>, <b>continuous first derivative everywhere</b>.
In some cases, the constructed polynomials would \"vibrate\". This is
avoided by reducing the derivative at Re=0 in such a way that
the polynomials are guaranteed to be monotonically increasing.
The used sufficient criteria for monotonicity follows from:
</p>

<dl>
<dt> Fritsch F.N. and Carlson R.E. (1980):</dt>
<dd> <b>Monotone piecewise cubic interpolation</b>.
     SIAM J. Numerc. Anal., Vol. 17, No. 2, April 1980, pp. 238-246</dd>
</dl>
</html>"));
        end BaseModelNonconstantCrossSectionArea;

        function pressureLoss_m_flow_totalPressure
          "Return pressure drop from constant loss factor and mass flow rate (dp = f(m_flow))"
                extends Modelica_Icons.Function;

          input SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
          input SI.Density rho_a_des
            "Density at port_a, mass flow in design direction a -> b";
          input SI.Density rho_b_des
            "Density at port_b, mass flow in design direction a -> b";
          input SI.Density rho_b_nondes
            "Density at port_b, mass flow against design direction a <- b";
          input SI.Density rho_a_nondes
            "Density at port_a, mass flow against design direction a <- b";
          input LossFactorData data
            "Constant loss factors for both flow directions" annotation (
              choices(
              choice=BaseClasses.PressureLosses.QuadraticTurbulent.LossFactorData.wallFriction(),
              choice=BaseClasses.PressureLosses.QuadraticTurbulent.LossFactorData.suddenExpansion(),
              choice=BaseClasses.PressureLosses.QuadraticTurbulent.LossFactorData.sharpEdgedOrifice()));
          input SI.MassFlowRate m_flow_small=0.01
            "Turbulent flow if |m_flow| >= m_flow_small";
          output SI.Pressure dp "Pressure drop (dp = port_a.p - port_b.p)";

        protected
          SI.Area A_a=Modelica_Constants.pi*data.diameter_a^2/4
            "Cross section area at port_a";
          SI.Area A_b=Modelica_Constants.pi*data.diameter_b^2/4
            "Cross section area at port_b";
        algorithm
            dp := 1/2 * m_flow^2 *( if m_flow > 0 then
              data.zeta1/(if data.zeta1_at_a then rho_a_des    * A_a^2 else    rho_b_des * A_b^2) - 1/(rho_a_des    * A_a^2) + 1/(rho_b_des    * A_b^2) else
              -data.zeta2/(if data.zeta2_at_a then rho_a_nondes * A_a^2 else rho_b_nondes * A_b^2) - 1/(rho_a_nondes * A_a^2) + 1/(rho_b_nondes * A_b^2));
          annotation (smoothOrder=1, Documentation(info="<html>
<p>
Compute pressure drop from constant loss factor and mass flow rate (dp = f(m_flow)).
For small mass flow rates(|m_flow| &lt; m_flow_small), the characteristic is approximated by
a polynomial in order to have a finite derivative at zero mass flow rate.
</p>
</html>"));
        end pressureLoss_m_flow_totalPressure;
        annotation (Documentation(info="<html>
<p>
This library provides pressure loss factors of a pipe
segment (orifice, bending etc.) with a minimum amount of data.
If available, data can be provided for <b>both flow directions</b>,
i.e., flow from port_a to port_b and from port_b to port_a,
as well as for the <b>laminar</b> and the <b>turbulent</b> region.
It is also an option to provide the loss factor <b>only</b> for the
<b>turbulent</b> region for a flow from port_a to port_b.
Basically, the pressure drop is defined by the following
equation:
</p>
<pre>   &Delta;p = 0.5*&zeta;*&rho;*v*|v|
      = 0.5*&zeta;/A^2 * (1/&rho;) * m_flow*|m_flow|
      = 8*&zeta;/(&pi;^2*D^4*&rho;) * m_flow*|m_flow|
</pre>
<p>
where
</p>
<ul>
<li> &Delta;p is the pressure drop: &Delta;p = port_a.p - port_b.p</li>
<li> v is the mean velocity.</li>
<li> &rho; is the density.</li>
<li> &zeta; is the loss factor that depends on the geometry of
     the pipe. In the turbulent flow regime, it is assumed that
     &zeta; is constant and is given by \"zeta1\" and
     \"zeta2\" depending on the flow direction.</li>
<li> D is the diameter of the pipe segment. If this is not a
     circular cross section, D = 4*A/P, where A is the cross section
     area and P is the wetted perimeter.</li>
</ul>

</html>"));
      end QuadraticTurbulent;

      partial model PartialTeeJunction
        "Base class for a splitting/joining component with three ports"
        import Modelica_Fluid.Types;
        import Modelica_Fluid.Types.PortFlowDirection;

        replaceable package Medium=Modelica_Media_Interfaces.PartialMedium
          "Medium in the component"
          annotation (choicesAllMatching=true);

        Modelica_Fluid_Interfaces.FluidPort_a port_1(redeclare package Medium
            = Medium, m_flow(min=if (portFlowDirection_1 == PortFlowDirection.Entering)
                 then 0.0 else -Modelica_Constants.inf, max=if (
                portFlowDirection_1 == PortFlowDirection.Leaving) then 0.0
                 else Modelica_Constants.inf)) annotation (Placement(
              transformation(extent={{-110,-10},{-90,10}}, rotation=0)));
        Modelica_Fluid_Interfaces.FluidPort_b port_2(redeclare package Medium
            = Medium, m_flow(min=if (portFlowDirection_2 == PortFlowDirection.Entering)
                 then 0.0 else -Modelica_Constants.inf, max=if (
                portFlowDirection_2 == PortFlowDirection.Leaving) then 0.0
                 else Modelica_Constants.inf)) annotation (Placement(
              transformation(extent={{90,-10},{110,10}}, rotation=0)));
        Modelica_Fluid_Interfaces.FluidPort_a port_3(redeclare package Medium
            = Medium, m_flow(min=if (portFlowDirection_3 == PortFlowDirection.Entering)
                 then 0.0 else -Modelica_Constants.inf, max=if (
                portFlowDirection_3 == PortFlowDirection.Leaving) then 0.0
                 else Modelica_Constants.inf)) annotation (Placement(
              transformation(extent={{-10,90},{10,110}}, rotation=0)));

      protected
        parameter PortFlowDirection portFlowDirection_1=PortFlowDirection.Bidirectional
          "Flow direction for port_1" annotation (Dialog(tab="Advanced"));
        parameter PortFlowDirection portFlowDirection_2=PortFlowDirection.Bidirectional
          "Flow direction for port_2" annotation (Dialog(tab="Advanced"));
        parameter PortFlowDirection portFlowDirection_3=PortFlowDirection.Bidirectional
          "Flow direction for port_3" annotation (Dialog(tab="Advanced"));

        annotation(Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,44},{100,-44}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255}),
              Text(
                extent={{-150,-89},{150,-129}},
                lineColor={0,0,255},
                textString="%name"),
              Rectangle(
                extent={{-44,100},{44,44}},
                lineColor={0,0,0},
                fillPattern=FillPattern.VerticalCylinder,
                fillColor={0,127,255}),
              Rectangle(
                extent={{-22,82},{21,-4}},
                fillPattern=FillPattern.Solid,
                fillColor={0,128,255},
                pattern=LinePattern.None,
                lineColor={0,0,0})}));
      end PartialTeeJunction;

      package Bends "Pressure loss functions for bends"
        extends Modelica_Icons.VariantsPackage;

        package CurvedBend "Pressure loss functions for curved bends"
            extends Modelica_Icons.Package;

        function massFlowRate
            "Return mass flow rate m_flow as function of pressure loss dp for a curved bend"
          extends Modelica_Icons.Function;
            input SI.Pressure dp "Pressure loss";
          input Geometry geometry "Geometry of bend";
            input SI.Density d_a
              "Density at port_a when fluid is flowing from port_a to port_b";
            input SI.Density d_b
              "Density at port_b when fluid is flowing from port_b to port_a";
            input SI.DynamicViscosity eta_a
              "Dynamic viscosity at port_a when fluid is flowing from port_a to port_b";
            input SI.DynamicViscosity eta_b
              "Dynamic viscosity at port_b when fluid is flowing from port_b to port_a";
            input SI.AbsolutePressure dp_small
              "Small pressure drop used for regularization if m_flow=f(...,dp_small,..,dp)";
            input SI.MassFlowRate m_flow_small
              "Small mass flow rate used for regularization if dp=f_inv(...,m_flow_small,m_flow)";
            output SI.MassFlowRate m_flow "Mass flow rate (= port_a.m_flow)";
        algorithm
            m_flow := Dissipation.PressureLoss.Bend.dp_curvedOverall_MFLOW(
                      geometry,
                      Dissipation.PressureLoss.Bend.dp_curvedOverall_IN_var(rho
                =Utilities.regStep(
                        dp,
                        d_a,
                        d_b,
                        dp_small), eta=Utilities.regStep(
                        dp,
                        eta_a,
                        eta_b,
                        dp_small)),
                      dp);

           annotation(Inline=false, LateInline=true,
                      inverse(dp=Modelica_Fluid.Fittings.BaseClasses.Bends.CurvedBend.pressureLoss(
                                    m_flow, geometry, d_a, d_b, eta_a, eta_b, dp_small, m_flow_small)),
              Documentation(info="<html>
<p>
This function returns the mass flow rate m_flow as function of pressure loss dp for a curved bend.
The details of the function are described
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Bend.dp_curvedOverall\">here</a>.
</p>

<p>
The bend characteristic is valid for constant density and constant dynamic viscosity.
It can be approximately also used for compressible media. This is performed by providing
the upstream density and upstream dynamic viscosity. In order to be able to regularize density
and dynamic viscosity around zero mass flow rate, the two quantities have to be given if
fluid flows from port_a to port_b (d_a, eta_a) and if fluid flows from port_b to port_a
(d_b, eta_b).
</p>

</html>"));
        end massFlowRate;

        function pressureLoss
            "Return pressure loss dp as function of mass flow rate m_flow for a curved bend"
          extends Modelica_Icons.Function;

            input SI.MassFlowRate m_flow "Mass flow rate (= port_a.m_flow)";
          input Geometry geometry "Geometry of bend";
            input SI.Density d_a
              "Density at port_a when fluid is flowing from port_a to port_b";
            input SI.Density d_b
              "Density at port_b when fluid is flowing from port_b to port_a";
            input SI.DynamicViscosity eta_a
              "Dynamic viscosity at port_a when fluid is flowing from port_a to port_b";
            input SI.DynamicViscosity eta_b
              "Dynamic viscosity at port_b when fluid is flowing from port_b to port_a";
            input SI.AbsolutePressure dp_small
              "Small pressure drop used for regularization if m_flow=f(...,dp_small,..,dp)";
            input SI.MassFlowRate m_flow_small
              "Small mass flow rate used for regularization if dp=f_inv(...,m_flow_small,m_flow)";
            output SI.Pressure dp "Pressure loss";
        algorithm
            dp := Dissipation.PressureLoss.Bend.dp_curvedOverall_DP(
                      geometry,
                      Dissipation.PressureLoss.Bend.dp_curvedOverall_IN_var(rho
                =Utilities.regStep(
                        m_flow,
                        d_a,
                        d_b,
                        m_flow_small), eta=Utilities.regStep(
                        m_flow,
                        eta_a,
                        eta_b,
                        m_flow_small)),
                      m_flow);

           annotation(Inline=true, Documentation(info="<html>
<p>
This function returns the pressure loss dp as function of mass flow rate m_flow for a curved bend.
The details of the function are described
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Bend.dp_curvedOverall\">here</a>.
</p>

<p>
The bend characteristic is valid for constant density and constant dynamic viscosity.
It can be approximately also used for compressible media. This is performed by providing
the upstream density and upstream dynamic viscosity. In order to be able to regularize density
and dynamic viscosity around zero mass flow rate, the two quantities have to be given if
fluid flows from port_a to port_b (d_a, eta_a) and if fluid flows from port_b to port_a
(d_b, eta_b).
</p>
</html>"));
        end pressureLoss;

          record Geometry "Geometric data for a curved bend"
            extends Modelica_Icons.Record;

            SI.Diameter d_hyd "Hydraulic diameter" annotation (Dialog);
            SI.Radius R_0 "Curvature radius" annotation (Dialog);
            SI.Angle delta=1.5707963267949 "Angle of turning"
              annotation (Dialog);
            Types.Roughness K=2.5e-5
              "Absolute roughness, with a default for a smooth steel pipe"
              annotation (Dialog);
            annotation (Documentation(info="<html>
<p>
This record is used to define the geometric (constant) data of a curved bend.
The details of the record are described
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Bend.dp_curvedOverall\">here</a>.
</p>
</html>"));
          end Geometry;
          annotation (Documentation(info="<html>
<p>
This package contains utility functions and records
for the CurvedBend fitting component.
</p>

</html>"));
        end CurvedBend;

        package EdgedBend "Pressure loss functions for edged bends"
            extends Modelica_Icons.Package;

        function massFlowRate
            "Return mass flow rate m_flow as function of pressure loss dp for a curved bend"
          extends Modelica_Icons.Function;

            input SI.Pressure dp "Pressure loss";
          input Geometry geometry "Geometry of bend";
            input SI.Density d_a
              "Density at port_a when fluid is flowing from port_a to port_b";
            input SI.Density d_b
              "Density at port_b when fluid is flowing from port_b to port_a";
            input SI.DynamicViscosity eta_a
              "Dynamic viscosity at port_a when fluid is flowing from port_a to port_b";
            input SI.DynamicViscosity eta_b
              "Dynamic viscosity at port_b when fluid is flowing from port_b to port_a";
            input SI.AbsolutePressure dp_small
              "Small pressure drop used for regularization if m_flow=f(...,dp_small,..,dp)";
            input SI.MassFlowRate m_flow_small
              "Small mass flow rate used for regularization if dp=f_inv(...,m_flow_small,m_flow)";
            output SI.MassFlowRate m_flow "Mass flow rate (= port_a.m_flow)";
        algorithm
            m_flow := Dissipation.PressureLoss.Bend.dp_edgedOverall_MFLOW(
                      Dissipation.PressureLoss.Bend.dp_edgedOverall_IN_con(
                        d_hyd=geometry.d_hyd,
                        delta=geometry.delta,
                        K=geometry.K),
                      Dissipation.PressureLoss.Bend.dp_edgedOverall_IN_var(rho=
                Utilities.regStep(
                        dp,
                        d_a,
                        d_b,
                        dp_small), eta=Utilities.regStep(
                        dp,
                        eta_a,
                        eta_b,
                        dp_small)),
                      dp);

           annotation(Inline=false, LateInline=true,
                      inverse(dp=Modelica_Fluid.Fittings.BaseClasses.Bends.EdgedBend.pressureLoss(
                                    m_flow, geometry, d_a, d_b, eta_a, eta_b, dp_small, m_flow_small)),
            Documentation(info="<html>
<p>
This function returns the mass flow rate m_flow as function of pressure loss dp for an edged bend.
The details of the function are described
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Bend.dp_edgedOverall\">here</a>.
</p>

<p>
The bend characteristic is valid for constant density and constant dynamic viscosity.
It can be approximately also used for compressible media. This is performed by providing
the upstream density and upstream dynamic viscosity. In order to be able to regularize density
and dynamic viscosity around zero mass flow rate, the two quantities have to be given if
fluid flows from port_a to port_b (d_a, eta_a) and if fluid flows from port_b to port_a
(d_b, eta_b).
</p>

</html>"));
        end massFlowRate;

        function pressureLoss
            "Return pressure loss dp as function of mass flow rate m_flow for a curved bend"
          extends Modelica_Icons.Function;

            input SI.MassFlowRate m_flow "Mass flow rate (= port_a.m_flow)";
          input Geometry geometry "Geometry of bend";
            input SI.Density d_a
              "Density at port_a when fluid is flowing from port_a to port_b";
            input SI.Density d_b
              "Density at port_b when fluid is flowing from port_b to port_a";
            input SI.DynamicViscosity eta_a
              "Dynamic viscosity at port_a when fluid is flowing from port_a to port_b";
            input SI.DynamicViscosity eta_b
              "Dynamic viscosity at port_b when fluid is flowing from port_b to port_a";
            input SI.AbsolutePressure dp_small
              "Small pressure drop used for regularization if m_flow=f(...,dp_small,..,dp)";
            input SI.MassFlowRate m_flow_small
              "Small mass flow rate used for regularization if dp=f_inv(...,m_flow_small,m_flow)";
            output SI.Pressure dp "Pressure loss";
        algorithm
            dp := Dissipation.PressureLoss.Bend.dp_edgedOverall_DP(
                      Dissipation.PressureLoss.Bend.dp_edgedOverall_IN_con(
                        d_hyd=geometry.d_hyd,
                        delta=geometry.delta,
                        K=geometry.K),
                      Dissipation.PressureLoss.Bend.dp_edgedOverall_IN_var(rho=
                Utilities.regStep(
                        m_flow,
                        d_a,
                        d_b,
                        m_flow_small), eta=Utilities.regStep(
                        m_flow,
                        eta_a,
                        eta_b,
                        m_flow_small)),
                      m_flow);

           annotation(Inline=true, Documentation(info="<html>
<p>
This function returns the pressure loss dp as function of mass flow rate m_flow for an edged bend.
The details of the function are described
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Bend.dp_edgedOverall\">here</a>.
</p>

<p>
The bend characteristic is valid for constant density and constant dynamic viscosity.
It can be approximately also used for compressible media. This is performed by providing
the upstream density and upstream dynamic viscosity. In order to be able to regularize density
and dynamic viscosity around zero mass flow rate, the two quantities have to be given if
fluid flows from port_a to port_b (d_a, eta_a) and if fluid flows from port_b to port_a
(d_b, eta_b).
</p>
</html>"));
        end pressureLoss;

          record Geometry "Geometric data for a curved bend"
            extends Modelica_Icons.Record;

            SI.Diameter d_hyd "Hydraulic diameter" annotation (Dialog);
            SI.Angle delta "Angle of turning" annotation (Dialog);
            Types.Roughness K=2.5e-5
              "Absolute roughness, with a default for a smooth steel pipe"
              annotation (Dialog);
            annotation (Documentation(info="<html>
<p>
This record is used to define the geometric (constant) data of an edged bend.
The details of the record are described
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Bend.dp_edgedOverall\">here</a>.
</p>
</html>"));
          end Geometry;
          annotation (Documentation(info="<html>
<p>
This package contains utility functions and records
for the EdgedBend fitting component.
</p>

</html>"));
        end EdgedBend;
      end Bends;

      package Orifices "Pressure loss functions for orifices"
          extends Modelica_Icons.VariantsPackage;
        package ThickEdgedOrifice
          "Pressure loss functions for thick edged orifices"
            extends Modelica_Icons.Package;

        function massFlowRate
            "Return mass flow rate m_flow as function of pressure loss dp for a thick edged orifice"
          extends Modelica_Icons.Function;

            input SI.Pressure dp "Pressure loss";
          input Geometry geometry "Geometry of bend";
            input SI.Density d_a
              "Density at port_a when fluid is flowing from port_a to port_b";
            input SI.Density d_b
              "Density at port_b when fluid is flowing from port_b to port_a";
            input SI.DynamicViscosity eta_a
              "Dynamic viscosity at port_a when fluid is flowing from port_a to port_b";
            input SI.DynamicViscosity eta_b
              "Dynamic viscosity at port_b when fluid is flowing from port_b to port_a";
            input SI.AbsolutePressure dp_small
              "Small pressure drop used for regularization if m_flow=f(...,dp_small,..,dp)";
            input SI.MassFlowRate m_flow_small
              "Small mass flow rate used for regularization if dp=f_inv(...,m_flow_small,m_flow)";
            output SI.MassFlowRate m_flow "Mass flow rate (= port_a.m_flow)";
        algorithm
            m_flow :=
              Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_MFLOW(

                Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_IN_con(
                        A_0=geometry.venaCrossArea,
                        A_1=geometry.crossArea,
                        C_0=geometry.venaPerimeter,
                        C_1=geometry.perimeter,
                        L=geometry.venaLength,
                        dp_smooth=dp_small),

                Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_IN_var(
                rho=Utilities.regStep(
                        dp,
                        d_a,
                        d_b,
                        dp_small), eta=Utilities.regStep(
                        dp,
                        eta_a,
                        eta_b,
                        dp_small)),
                      dp);

           annotation(Inline=false, LateInline=true,
                      inverse(dp=Modelica_Fluid.Fittings.BaseClasses.Orifices.ThickEdgedOrifice.pressureLoss(
                                    m_flow, geometry, d_a, d_b, eta_a, eta_b, dp_small, m_flow_small)),
              Documentation(info="<html>
<p>
This function returns the mass flow rate m_flow as function of pressure loss dp for a thick edged orifice.
The details of the function are described
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Orifice.dp_thickEdgedOverall\">here</a>.
</p>

<p>
The orifice characteristic is valid for constant density and constant dynamic viscosity.
It can be approximately also used for compressible media. This is performed by providing
the upstream density and upstream dynamic viscosity. In order to be able to regularize density
and dynamic viscosity around zero mass flow rate, the two quantities have to be given if
fluid flows from port_a to port_b (d_a, eta_a) and if fluid flows from port_b to port_a
(d_b, eta_b).
</p>

</html>"));
        end massFlowRate;

        function pressureLoss
            "Return pressure loss dp as function of mass flow rate m_flow for a thick edged orifice"
          extends Modelica_Icons.Function;

            input SI.MassFlowRate m_flow "Mass flow rate (= port_a.m_flow)";
          input Geometry geometry "Geometry of bend";
            input SI.Density d_a
              "Density at port_a when fluid is flowing from port_a to port_b";
            input SI.Density d_b
              "Density at port_b when fluid is flowing from port_b to port_a";
            input SI.DynamicViscosity eta_a
              "Dynamic viscosity at port_a when fluid is flowing from port_a to port_b";
            input SI.DynamicViscosity eta_b
              "Dynamic viscosity at port_b when fluid is flowing from port_b to port_a";
            input SI.AbsolutePressure dp_small
              "Small pressure drop used for regularization if m_flow=f(...,dp_small,..,dp)";
            input SI.MassFlowRate m_flow_small
              "Small mass flow rate used for regularization if dp=f_inv(...,m_flow_small,m_flow)";
            output SI.Pressure dp "Pressure loss";
        algorithm
            dp := Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_DP(

                Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_IN_con(
                        A_0=geometry.venaCrossArea,
                        A_1=geometry.crossArea,
                        C_0=geometry.venaPerimeter,
                        C_1=geometry.perimeter,
                        L=geometry.venaLength,
                        dp_smooth=dp_small),

                Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_IN_var(
                rho=Utilities.regStep(
                        m_flow,
                        d_a,
                        d_b,
                        m_flow_small), eta=Utilities.regStep(
                        m_flow,
                        eta_a,
                        eta_b,
                        m_flow_small)),
                      m_flow);

           annotation(Inline=true, Documentation(info="<html>
<p>
This function returns the pressure loss dp as function of mass flow rate m_flow for a thick edged orifice.
The details of the function are described
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Orifice.dp_thickEdgedOverall\">here</a>.
</p>

<p>
The orifice characteristic is valid for constant density and constant dynamic viscosity.
It can be approximately also used for compressible media. This is performed by providing
the upstream density and upstream dynamic viscosity. In order to be able to regularize density
and dynamic viscosity around zero mass flow rate, the two quantities have to be given if
fluid flows from port_a to port_b (d_a, eta_a) and if fluid flows from port_b to port_a
(d_b, eta_b).
</p>
</html>"));
        end pressureLoss;

          record Geometry "Geometric data for a thick edged orifice"
            extends Modelica_Icons.Record;

            SI.Area crossArea "Inner cross sectional area" annotation (Dialog);
            SI.Length perimeter "Inner perimeter" annotation (Dialog);

            SI.Area venaCrossArea "Cross sectional area of vena contraction"
              annotation (Dialog);
            SI.Length venaPerimeter "Perimeter of vena contraction"
              annotation (Dialog);
            SI.Length venaLength "Length of vena contraction"
              annotation (Dialog);

            annotation (Documentation(info="<html>
<p>
This record is used to define the geometric (constant) data of a thick edged orifice.
The details of the record are described
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Orifice.dp_thickEdgedOverall\">here</a>.
</p>
</html>"));
          end Geometry;

        package Choices "Choices for Geometry"
          extends Modelica_Icons.Package;

          function circular "Circular cross section"
              import Modelica_Constants.pi;

              input SI.Diameter diameter "Inner diameter of circular orifice"
                annotation (Dialog);
              input SI.Diameter venaDiameter "Diameter of vena contraction"
                annotation (Dialog);
              input SI.Length venaLength "Length of vena contraction"
                annotation (Dialog);

             output ThickEdgedOrifice.Geometry geometry
                "Geometry of circular thick edged orifice";
          algorithm
             geometry.crossArea := diameter^2*pi/4;
             geometry.perimeter := pi*diameter;
             geometry.venaCrossArea := venaDiameter^2*pi/4;
             geometry.venaPerimeter := pi*venaDiameter;
             geometry.venaLength := venaLength;
            annotation (                               Icon(coordinateSystem(preserveAspectRatio=false,
                             extent={{-100,-100},{100,100}}), graphics={Ellipse(
                    extent={{-80,80},{80,-80}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid)}),
              Documentation(revisions="",
                  info="<html>
<p>
Function that returns the ThickEdgedOrifice.Geometry for a circular
cross section of the orifice.
</p>
</html>"));
          end circular;

          function rectangular "Rectangular cross section"
              import Modelica_Constants.pi;

              input SI.Length width "Inner width of rectangular orifice"
                annotation (Dialog);
              input SI.Length height "Inner height of rectangular orifice"
                annotation (Dialog);
              input SI.Length venaWidth "Width of vena contraction"
                annotation (Dialog);
              input SI.Length venaHeight "Height of vena contraction"
                annotation (Dialog);
              input SI.Length venaLength "Length of vena contraction"
                annotation (Dialog);

             output ThickEdgedOrifice.Geometry geometry
                "Geometry of circular thick edged orifice";
          algorithm
             geometry.crossArea := width*height;
             geometry.perimeter := 2*width + 2*height;
             geometry.venaCrossArea := venaWidth*venaHeight;
             geometry.venaPerimeter := 2*venaWidth + 2*venaHeight;
             geometry.venaLength := venaLength;
            annotation (                               Icon(coordinateSystem(preserveAspectRatio=true,
                             extent={{-100,-100},{100,100}}), graphics={Rectangle(
                    extent={{-80,60},{80,-60}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid)}),
              Documentation(revisions="",
                  info="<html>
<p>
Function that returns the ThickEdgedOrifice.Geometry for a rectangular
cross section of the orifice.
</p>
</html>"));
          end rectangular;

          function general "General cross section"
              import Modelica_Constants.pi;

              input SI.Area crossArea "Inner cross sectional area"
                annotation (Dialog);
              input SI.Length perimeter "Inner perimeter" annotation (Dialog);

              input SI.Area venaCrossArea
                "Cross sectional area of vena contraction" annotation (Dialog);
              input SI.Length venaPerimeter "Perimeter of vena contraction"
                annotation (Dialog);
              input SI.Length venaLength "Length of vena contraction"
                annotation (Dialog);

             output ThickEdgedOrifice.Geometry geometry
                "Geometry of circular thick edged orifice";
          algorithm
             geometry.crossArea := crossArea;
             geometry.perimeter := perimeter;
             geometry.venaCrossArea := venaCrossArea;
             geometry.venaPerimeter := venaPerimeter;
             geometry.venaLength := venaLength;
            annotation (                               Icon(coordinateSystem(preserveAspectRatio=false,
                             extent={{-100,-100},{100,100}}), graphics={
                                                   Polygon(
                    points={{-80,8},{0,80},{80,40},{20,-20},{40,-80},{-60,-80},{-80,8}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid)}),
              Documentation(revisions="",
                  info="<html>
<p>
Function that returns the ThickEdgedOrifice.Geometry for a general
cross section of the orifice.
</p>
</html>"));
          end general;
            annotation (Documentation(info="<html>
<p>
Choices to compute the \"Geometry\" record for a ThickEdgedOrifice.
</p>
</html>"));
        end Choices;
          annotation (Documentation(info="<html>
<p>
This package contains utility functions and records
for the ThickEdgedOrifice fitting component.
</p>
</html>"));
        end ThickEdgedOrifice;
      end Orifices;

      package GenericResistances
        "Pressure loss functions for generic, geometry independent flow resistances"
          extends Modelica_Icons.VariantsPackage;
        package VolumeFlowRate
          "Pressure loss functions for generic resistances parameterized with the volume flow rate"
            extends Modelica_Icons.Package;

        function massFlowRate
            "Return mass flow rate m_flow as function of pressure loss dp for a curved bend"
          extends Modelica_Icons.Function;

            input SI.Pressure dp "Pressure loss";
          input Real a(unit="(Pa.s2)/m6")
              "Coefficient for quadratic term (dp = a*V_flow^2 + b*V_flow)";
          input Real b(unit="(Pa.s)/m3")
              "Coefficient for linear term (dp = a*V_flow^2 + b*V_flow)";
            input SI.Density d_a
              "Density at port_a when fluid is flowing from port_a to port_b";
            input SI.Density d_b
              "Density at port_b when fluid is flowing from port_b to port_a";
            input SI.AbsolutePressure dp_small
              "Small pressure drop used for regularization if m_flow=f(...,dp_small,..,dp)";
            input SI.MassFlowRate m_flow_small
              "Small mass flow rate used for regularization if dp=f_inv(...,m_flow_small,m_flow)";
            output SI.MassFlowRate m_flow "Mass flow rate (= port_a.m_flow)";
        algorithm
            m_flow := Dissipation.PressureLoss.General.dp_volumeFlowRate_MFLOW(
                      Dissipation.PressureLoss.General.dp_volumeFlowRate_IN_con(
                        a=a,
                        b=b,
                        dp_min=dp_small),
                      Dissipation.PressureLoss.General.dp_volumeFlowRate_IN_var(
                rho=Utilities.regStep(
                        dp,
                        d_a,
                        d_b,
                        dp_small)),
                      dp);

           annotation(LateInline=true,
                      inverse(dp=Modelica_Fluid.Fittings.BaseClasses.GenericResistances.VolumeFlowRate.pressureLoss(
                                    m_flow, a, b, d_a, d_b, dp_small, m_flow_small)),
            Documentation(info="<html>
<p>
This function returns the mass flow rate m_flow as function of pressure loss dp for an edged bend.
The details of the function are described
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_volumeFlowRate\">here</a>.
</p>

<p>
The bend characteristic is valid for constant density and constant dynamic viscosity.
It can be approximately also used for compressible media. This is performed by providing
the upstream density and upstream dynamic viscosity. In order to be able to regularize density
and dynamic viscosity around zero mass flow rate, the two quantities have to be given if
fluid flows from port_a to port_b (d_a, eta_a) and if fluid flows from port_b to port_a
(d_b, eta_b).
</p>

</html>"));
        end massFlowRate;

        function pressureLoss
            "Return pressure loss dp as function of mass flow rate m_flow for a curved bend"
          extends Modelica_Icons.Function;

            input SI.MassFlowRate m_flow "Mass flow rate (= port_a.m_flow)";
          input Real a(unit="(Pa.s2)/m6")
              "Coefficient for quadratic term (dp = a*V_flow^2 + b*V_flow)";
          input Real b(unit="(Pa.s)/m3")
              "Coefficient for linear term (dp = a*V_flow^2 + b*V_flow)";
            input SI.Density d_a
              "Density at port_a when fluid is flowing from port_a to port_b";
            input SI.Density d_b
              "Density at port_b when fluid is flowing from port_b to port_a";
            input SI.AbsolutePressure dp_small
              "Small pressure drop used for regularization if m_flow=f(...,dp_small,..,dp)";
            input SI.MassFlowRate m_flow_small
              "Small mass flow rate used for regularization if dp=f_inv(...,m_flow_small,m_flow)";
            output SI.Pressure dp "Pressure loss";
        algorithm
            dp := Dissipation.PressureLoss.General.dp_volumeFlowRate_DP(
                      Dissipation.PressureLoss.General.dp_volumeFlowRate_IN_con(
                        a=a,
                        b=b,
                        dp_min=dp_small),
                      Dissipation.PressureLoss.General.dp_volumeFlowRate_IN_var(
                rho=Utilities.regStep(
                        m_flow,
                        d_a,
                        d_b,
                        m_flow_small)),
                      m_flow);

           annotation(Inline=true, Documentation(info="<html>
<p>
This function returns the pressure loss dp as function of mass flow rate m_flow for an edged bend.
The details of the function are described
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_volumeFlowRate\">here</a>.
</p>

<p>
The bend characteristic is valid for constant density and constant dynamic viscosity.
It can be approximately also used for compressible media. This is performed by providing
the upstream density and upstream dynamic viscosity. In order to be able to regularize density
and dynamic viscosity around zero mass flow rate, the two quantities have to be given if
fluid flows from port_a to port_b (d_a, eta_a) and if fluid flows from port_b to port_a
(d_b, eta_b).
</p>
</html>"));
        end pressureLoss;

          annotation (Documentation(info="<html>
<p>
This package contains utility functions
for the VolumeFlowRate fitting component.
</p>
</html>"));
        end VolumeFlowRate;
      end GenericResistances;
    end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This sublibrary contains models and functions providing pressure
loss correlations. All models in this library have the property
that no mass and no energy is stored in the component. Therefore,
none of the models have a state.
</p>

<p>
All functions are continuous and have a finite, non-zero, smooth, first derivative.
The functions are all guaranteed to be strict monotonically increasing.
The mentioned properties guarantee that a unique inverse of every
function exists. Note, the usual quadratic pressure loss correlation
</p>

<ul>
<li> in the form m_flow = f(dp) has an infinite derivative at zero
     mass flow rate and is therefore problematic to use.</li>
<li> in the form dp = f(m_flow) has a zero derivative at zero mass flow rate
     and is therefore problematic to invert, since the inverse function has
     then an infinite derivative at zero mass flow rate.</li>
</ul>
<p>
The two mentioned problems are solved in this package by approximating
the characteristics around zero mass flow rates with appropriate
polynomials. The monotonicity is guaranteed using results from:
</p>

<dl>
<dt> Fritsch F.N. and Carlson R.E. (1980):</dt>
<dd> <b>Monotone piecewise cubic interpolation</b>.
     SIAM J. Numerc. Anal., Vol. 17, No. 2, April 1980, pp. 238-246</dd>
</dl>

</html>",   revisions="<html>
<ul>
<li><i>Jan. 3, 2006</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    New design and implementation based on previous iterations.</li>
</ul>
</html>"));
  end Fittings;

  package Sources "Define fixed or prescribed boundary conditions"
    extends Modelica_Icons.SourcesPackage;
    model FixedBoundary "Boundary source component"
      import Modelica_Media_Interfaces.Choices.IndependentVariables;
      extends Sources.BaseClasses.PartialSource;
      parameter Boolean use_p=true "select p or d"
        annotation (Evaluate = true,
                    Dialog(group = "Boundary pressure or Boundary density"));
      parameter Medium.AbsolutePressure p=Medium.p_default "Boundary pressure"
        annotation (Dialog(group = "Boundary pressure or Boundary density",
                           enable = use_p));
      parameter Medium.Density d=Medium.density_pTX(Medium.p_default, Medium.T_default, Medium.X_default)
        "Boundary density"
        annotation (Dialog(group = "Boundary pressure or Boundary density",
                           enable=not use_p));
      parameter Boolean use_T=true "select T or h"
        annotation (Evaluate = true,
                    Dialog(group = "Boundary temperature or Boundary specific enthalpy"));
      parameter Medium.Temperature T=Medium.T_default "Boundary temperature"
        annotation (Dialog(group = "Boundary temperature or Boundary specific enthalpy",
                           enable = use_T));
      parameter Medium.SpecificEnthalpy h=Medium.h_default
        "Boundary specific enthalpy"
        annotation (Dialog(group="Boundary temperature or Boundary specific enthalpy",
                    enable = not use_T));
      parameter Medium.MassFraction X[Medium.nX](
           quantity=Medium.substanceNames)=Medium.X_default
        "Boundary mass fractions m_i/m"
        annotation (Dialog(group = "Only for multi-substance flow", enable=Medium.nXi > 0));

      parameter Medium.ExtraProperty C[Medium.nC](
           quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
        "Boundary trace substances"
        annotation (Dialog(group = "Only for trace-substance flow", enable=Medium.nC > 0));
    protected
      Medium.ThermodynamicState state;
    equation
      Utilities.checkBoundary(
            Medium.mediumName,
            Medium.substanceNames,
            Medium.singleState,
            use_p,
            X,
            "FixedBoundary");
      if use_p or Medium.singleState then
         // p given
         if use_T then
            // p,T,X given
            state = Medium.setState_pTX(p, T, X);
         else
            // p,h,X given
            state = Medium.setState_phX(p, h, X);
         end if;

         if Medium.ThermoStates == IndependentVariables.dTX then
            medium.d = Medium.density(state);
         else
            medium.p = Medium.pressure(state);
         end if;

         if Medium.ThermoStates == IndependentVariables.ph or
            Medium.ThermoStates == IndependentVariables.phX then
            medium.h = Medium.specificEnthalpy(state);
         else
            medium.T = Medium.temperature(state);
         end if;

      else
         // d given
         if use_T then
            // d,T,X given
            state = Medium.setState_dTX(d, T, X);

            if Medium.ThermoStates == IndependentVariables.dTX then
               medium.d = Medium.density(state);
            else
               medium.p = Medium.pressure(state);
            end if;

            if Medium.ThermoStates == IndependentVariables.ph or
               Medium.ThermoStates == IndependentVariables.phX then
               medium.h = Medium.specificEnthalpy(state);
            else
               medium.T = Medium.temperature(state);
            end if;

         else
            // d,h,X given
            medium.d = d;
            medium.h = h;
            state = Medium.setState_dTX(d,T,X);
         end if;
      end if;

      medium.Xi = X[1:Medium.nXi];

      ports.C_outflow = fill(C, nPorts);
      annotation (defaultComponentName="boundary",
        Icon(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}}), graphics={Ellipse(
              extent={{-100,100},{100,-100}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={0,127,255}), Text(
              extent={{-150,110},{150,150}},
              textString="%name",
              lineColor={0,0,255})}),
        Documentation(info="<html>
<p>
Model <b>FixedBoundary</b> defines constant values for boundary conditions:
</p>
<ul>
<li> Boundary pressure or boundary density.</li>
<li> Boundary temperature or boundary specific enthalpy.</li>
<li> Boundary composition (only for multi-substance or trace-substance flow).</li>
</ul>
<p>
Note, that boundary temperature, density, specific enthalpy,
mass fractions and trace substances have only an effect if the mass flow
is from the Boundary into the port. If mass is flowing from
the port into the boundary, the boundary definitions,
with exception of boundary pressure, do not have an effect.
</p>
</html>"));
    end FixedBoundary;

    model Boundary_pT
      "Boundary with prescribed pressure, temperature, composition and trace substances"
      import Modelica_Media_Interfaces.Choices.IndependentVariables;

      extends Sources.BaseClasses.PartialSource;
      parameter Boolean use_p_in = false
        "Get the pressure from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Boolean use_T_in= false
        "Get the temperature from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Boolean use_X_in = false
        "Get the composition from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Boolean use_C_in = false
        "Get the trace substances from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Medium.AbsolutePressure p = Medium.p_default
        "Fixed value of pressure"
        annotation (Evaluate = true,
                    Dialog(enable = not use_p_in));
      parameter Medium.Temperature T = Medium.T_default
        "Fixed value of temperature"
        annotation (Evaluate = true,
                    Dialog(enable = not use_T_in));
      parameter Medium.MassFraction X[Medium.nX] = Medium.X_default
        "Fixed value of composition"
        annotation (Evaluate = true,
                    Dialog(enable = (not use_X_in) and Medium.nXi > 0));
      parameter Medium.ExtraProperty C[Medium.nC](
           quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
        "Fixed values of trace substances"
        annotation (Evaluate=true,
                    Dialog(enable = (not use_C_in) and Medium.nC > 0));
      Modelica_Blocks_Interfaces.RealInput p_in if use_p_in
        "Prescribed boundary pressure"
        annotation (Placement(transformation(extent={{-140,60},{-100,100}},
              rotation=0)));
      Modelica_Blocks_Interfaces.RealInput T_in if use_T_in
        "Prescribed boundary temperature"
        annotation (Placement(transformation(extent={{-140,20},{-100,60}},
              rotation=0)));
      Modelica_Blocks_Interfaces.RealInput X_in[Medium.nX] if use_X_in
        "Prescribed boundary composition"
        annotation (Placement(transformation(extent={{-140,-60},{-100,-20}},
              rotation=0)));
      Modelica_Blocks_Interfaces.RealInput C_in[Medium.nC] if use_C_in
        "Prescribed boundary trace substances"
        annotation (Placement(transformation(extent={{-140,-100},{-100,-60}},
              rotation=0)));
    protected
      Modelica_Blocks_Interfaces.RealInput p_in_internal
        "Needed to connect to conditional connector";
      Modelica_Blocks_Interfaces.RealInput T_in_internal
        "Needed to connect to conditional connector";
      Modelica_Blocks_Interfaces.RealInput X_in_internal[Medium.nX]
        "Needed to connect to conditional connector";
      Modelica_Blocks_Interfaces.RealInput C_in_internal[Medium.nC]
        "Needed to connect to conditional connector";
    equation
      Utilities.checkBoundary(
            Medium.mediumName,
            Medium.substanceNames,
            Medium.singleState,
            true,
            X_in_internal,
            "Boundary_pT");
      connect(p_in, p_in_internal);
      connect(T_in, T_in_internal);
      connect(X_in, X_in_internal);
      connect(C_in, C_in_internal);
      if not use_p_in then
        p_in_internal = p;
      end if;
      if not use_T_in then
        T_in_internal = T;
      end if;
      if not use_X_in then
        X_in_internal = X;
      end if;
      if not use_C_in then
        C_in_internal = C;
      end if;
      medium.p = p_in_internal;
      if Medium.ThermoStates == IndependentVariables.ph or
         Medium.ThermoStates == IndependentVariables.phX then
         medium.h = Medium.specificEnthalpy(Medium.setState_pTX(p_in_internal, T_in_internal, X_in_internal));
      else
         medium.T = T_in_internal;
      end if;
      medium.Xi = X_in_internal[1:Medium.nXi];
      ports.C_outflow = fill(C_in_internal, nPorts);
      annotation (defaultComponentName="boundary",
        Icon(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}}), graphics={
            Ellipse(
              extent={{-100,100},{100,-100}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={0,127,255}),
            Text(
              extent={{-150,120},{150,160}},
              textString="%name",
              lineColor={0,0,255}),
            Line(
              visible=use_p_in,
              points={{-100,80},{-58,80}},
              color={0,0,255}),
            Line(
              visible=use_T_in,
              points={{-100,40},{-92,40}},
              color={0,0,255}),
            Line(
              visible=use_X_in,
              points={{-100,-40},{-92,-40}},
              color={0,0,255}),
            Line(
              visible=use_C_in,
              points={{-100,-80},{-60,-80}},
              color={0,0,255}),
            Text(
              visible=use_p_in,
              extent={{-152,134},{-68,94}},
              lineColor={0,0,0},
              textString="p"),
            Text(
              visible=use_X_in,
              extent={{-164,4},{-62,-36}},
              lineColor={0,0,0},
              textString="X"),
            Text(
              visible=use_C_in,
              extent={{-164,-90},{-62,-130}},
              lineColor={0,0,0},
              textString="C"),
            Text(
              visible=use_T_in,
              extent={{-162,34},{-60,-6}},
              lineColor={0,0,0},
              textString="T")}),
        Documentation(info="<html>
<p>
Defines prescribed values for boundary conditions:
</p>
<ul>
<li> Prescribed boundary pressure.</li>
<li> Prescribed boundary temperature.</li>
<li> Boundary composition (only for multi-substance or trace-substance flow).</li>
</ul>
<p>If <code>use_p_in</code> is false (default option), the <code>p</code> parameter
is used as boundary pressure, and the <code>p_in</code> input connector is disabled; if <code>use_p_in</code> is true, then the <code>p</code> parameter is ignored, and the value provided by the input connector is used instead.</p>
<p>The same thing goes for the temperature, composition and trace substances.</p>
<p>
Note, that boundary temperature,
mass fractions and trace substances have only an effect if the mass flow
is from the boundary into the port. If mass is flowing from
the port into the boundary, the boundary definitions,
with exception of boundary pressure, do not have an effect.
</p>
</html>"));
    end Boundary_pT;

    model Boundary_ph
      "Boundary with prescribed pressure, specific enthalpy, composition and trace substances"
      import Modelica_Media_Interfaces.Choices.IndependentVariables;
      extends Sources.BaseClasses.PartialSource;
      parameter Boolean use_p_in = false
        "Get the pressure from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Boolean use_h_in= false
        "Get the specific enthalpy from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Boolean use_X_in = false
        "Get the composition from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Boolean use_C_in = false
        "Get the trace substances from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Medium.AbsolutePressure p = Medium.p_default
        "Fixed value of pressure"
        annotation (Evaluate = true,
                    Dialog(enable = not use_p_in));
      parameter Medium.SpecificEnthalpy h = Medium.h_default
        "Fixed value of specific enthalpy"
        annotation (Evaluate = true,
                    Dialog(enable = not use_h_in));
      parameter Medium.MassFraction X[Medium.nX] = Medium.X_default
        "Fixed value of composition"
        annotation (Evaluate = true,
                    Dialog(enable = (not use_X_in) and Medium.nXi > 0));
      parameter Medium.ExtraProperty C[Medium.nC](
           quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
        "Fixed values of trace substances"
        annotation (Evaluate=true,
                    Dialog(enable = (not use_C_in) and Medium.nC > 0));
      Modelica_Blocks_Interfaces.RealInput p_in if use_p_in
        "Prescribed boundary pressure"
        annotation (Placement(transformation(extent={{-140,60},{-100,100}},
              rotation=0)));
      Modelica_Blocks_Interfaces.RealInput h_in if use_h_in
        "Prescribed boundary specific enthalpy"
        annotation (Placement(transformation(extent={{-140,20},{-100,60}},
              rotation=0)));
      Modelica_Blocks_Interfaces.RealInput X_in[Medium.nX] if use_X_in
        "Prescribed boundary composition"
        annotation (Placement(transformation(extent={{-140,-60},{-100,-20}},
              rotation=0)));
      Modelica_Blocks_Interfaces.RealInput C_in[Medium.nC] if use_C_in
        "Prescribed boundary trace substances"
        annotation (Placement(transformation(extent={{-140,-100},{-100,-60}},
              rotation=0)));
    protected
      Modelica_Blocks_Interfaces.RealInput p_in_internal
        "Needed to connect to conditional connector";
      Modelica_Blocks_Interfaces.RealInput h_in_internal
        "Needed to connect to conditional connector";
      Modelica_Blocks_Interfaces.RealInput X_in_internal[Medium.nX]
        "Needed to connect to conditional connector";
      Modelica_Blocks_Interfaces.RealInput C_in_internal[Medium.nC]
        "Needed to connect to conditional connector";
    equation
      Utilities.checkBoundary(
            Medium.mediumName,
            Medium.substanceNames,
            Medium.singleState,
            true,
            X_in_internal,
            "Boundary_ph");
      connect(p_in, p_in_internal);
      connect(h_in, h_in_internal);
      connect(X_in, X_in_internal);
      connect(C_in, C_in_internal);
      if not use_p_in then
        p_in_internal = p;
      end if;
      if not use_h_in then
        h_in_internal = h;
      end if;
      if not use_X_in then
        X_in_internal = X;
      end if;
      if not use_C_in then
        C_in_internal = C;
      end if;
      medium.p = p_in_internal;
      if Medium.ThermoStates == IndependentVariables.ph or
         Medium.ThermoStates == IndependentVariables.phX then
         medium.h = h_in_internal;
      else
         medium.T = Medium.temperature(Medium.setState_phX(p_in_internal, h_in_internal, X_in_internal));
      end if;
      medium.Xi = X_in_internal[1:Medium.nXi];
      ports.C_outflow = fill(C_in_internal, nPorts);
      annotation (defaultComponentName="boundary",
        Icon(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}}), graphics={
            Ellipse(
              extent={{-100,100},{100,-100}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={0,127,255}),
            Text(
              extent={{-150,110},{150,150}},
              textString="%name",
              lineColor={0,0,255}),
            Line(
              visible=use_p_in,
              points={{-100,80},{-60,80}},
              color={0,0,255}),
            Line(
              visible=use_h_in,
              points={{-100,40},{-92,40}},
              color={0,0,255}),
            Line(
              visible=use_X_in,
              points={{-100,-40},{-92,-40}},
              color={0,0,255}),
            Line(
              visible=use_C_in,
              points={{-100,-80},{-60,-80}},
              color={0,0,255}),
            Text(
              visible=use_p_in,
              extent={{-150,134},{-72,94}},
              lineColor={0,0,0},
              textString="p"),
            Text(
              visible=use_h_in,
              extent={{-166,34},{-64,-6}},
              lineColor={0,0,0},
              textString="h"),
            Text(
              visible=use_X_in,
              extent={{-164,4},{-62,-36}},
              lineColor={0,0,0},
              textString="X"),
            Text(
              visible=use_C_in,
              extent={{-164,-90},{-62,-130}},
              lineColor={0,0,0},
              textString="C")}),
        Documentation(info="<html>
<p>
Defines prescribed values for boundary conditions:
</p>
<ul>
<li> Prescribed boundary pressure.</li>
<li> Prescribed boundary temperature.</li>
<li> Boundary composition (only for multi-substance or trace-substance flow).</li>
</ul>
<p>If <code>use_p_in</code> is false (default option), the <code>p</code> parameter
is used as boundary pressure, and the <code>p_in</code> input connector is disabled; if <code>use_p_in</code> is true, then the <code>p</code> parameter is ignored, and the value provided by the input connector is used instead.</p>
<p>The same thing goes for the specific enthalpy and composition</p>
<p>
Note, that boundary temperature,
mass fractions and trace substances have only an effect if the mass flow
is from the boundary into the port. If mass is flowing from
the port into the boundary, the boundary definitions,
with exception of boundary pressure, do not have an effect.
</p>
</html>"));
    end Boundary_ph;

    model MassFlowSource_T
      "Ideal flow source that produces a prescribed mass flow with prescribed temperature, mass fraction and trace substances"
      import Modelica_Media_Interfaces.Choices.IndependentVariables;
      extends Sources.BaseClasses.PartialFlowSource;
      parameter Boolean use_m_flow_in = false
        "Get the mass flow rate from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Boolean use_T_in= false
        "Get the temperature from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Boolean use_X_in = false
        "Get the composition from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Boolean use_C_in = false
        "Get the trace substances from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Medium.MassFlowRate m_flow = 0
        "Fixed mass flow rate going out of the fluid port"
        annotation (Evaluate = true,
                    Dialog(enable = not use_m_flow_in));
      parameter Medium.Temperature T = Medium.T_default
        "Fixed value of temperature"
        annotation (Evaluate = true,
                    Dialog(enable = not use_T_in));
      parameter Medium.MassFraction X[Medium.nX] = Medium.X_default
        "Fixed value of composition"
        annotation (Evaluate = true,
                    Dialog(enable = (not use_X_in) and Medium.nXi > 0));
      parameter Medium.ExtraProperty C[Medium.nC](
           quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
        "Fixed values of trace substances"
        annotation (Evaluate=true,
                    Dialog(enable = (not use_C_in) and Medium.nC > 0));
      Modelica_Blocks_Interfaces.RealInput m_flow_in if     use_m_flow_in
        "Prescribed mass flow rate"
        annotation (Placement(transformation(extent={{-120,60},{-80,100}},
              rotation=0), iconTransformation(extent={{-120,60},{-80,100}})));
      Modelica_Blocks_Interfaces.RealInput T_in if         use_T_in
        "Prescribed fluid temperature"
        annotation (Placement(transformation(extent={{-140,20},{-100,60}},
              rotation=0), iconTransformation(extent={{-140,20},{-100,60}})));
      Modelica_Blocks_Interfaces.RealInput X_in[Medium.nX] if
                                                            use_X_in
        "Prescribed fluid composition"
        annotation (Placement(transformation(extent={{-140,-60},{-100,-20}},
              rotation=0)));
      Modelica_Blocks_Interfaces.RealInput C_in[Medium.nC] if
                                                            use_C_in
        "Prescribed boundary trace substances"
        annotation (Placement(transformation(extent={{-120,-100},{-80,-60}},
              rotation=0)));
    protected
      Modelica_Blocks_Interfaces.RealInput m_flow_in_internal
        "Needed to connect to conditional connector";
      Modelica_Blocks_Interfaces.RealInput T_in_internal
        "Needed to connect to conditional connector";
      Modelica_Blocks_Interfaces.RealInput X_in_internal[Medium.nX]
        "Needed to connect to conditional connector";
      Modelica_Blocks_Interfaces.RealInput C_in_internal[Medium.nC]
        "Needed to connect to conditional connector";
    equation
      Utilities.checkBoundary(Medium.mediumName, Medium.substanceNames,
        Medium.singleState, true, X_in_internal, "MassFlowSource_T");
      connect(m_flow_in, m_flow_in_internal);
      connect(T_in, T_in_internal);
      connect(X_in, X_in_internal);
      connect(C_in, C_in_internal);
      if not use_m_flow_in then
        m_flow_in_internal = m_flow;
      end if;
      if not use_T_in then
        T_in_internal = T;
      end if;
      if not use_X_in then
        X_in_internal = X;
      end if;
      if not use_C_in then
        C_in_internal = C;
      end if;
      if Medium.ThermoStates == IndependentVariables.ph or
         Medium.ThermoStates == IndependentVariables.phX then
         medium.h = Medium.specificEnthalpy(Medium.setState_pTX(medium.p, T_in_internal, X_in_internal));
      else
         medium.T = T_in_internal;
      end if;
      sum(ports.m_flow) = -m_flow_in_internal;
      medium.Xi = X_in_internal[1:Medium.nXi];
      ports.C_outflow = fill(C_in_internal, nPorts);
      annotation (defaultComponentName="boundary",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{35,45},{100,-45}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={0,127,255}),
            Ellipse(
              extent={{-100,80},{60,-80}},
              lineColor={0,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-60,70},{60,0},{-60,-68},{-60,70}},
              lineColor={0,0,255},
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-54,32},{16,-30}},
              lineColor={255,0,0},
              textString="m"),
            Text(
              extent={{-150,130},{150,170}},
              textString="%name",
              lineColor={0,0,255}),
            Ellipse(
              extent={{-26,30},{-18,22}},
              lineColor={255,0,0},
              fillColor={255,0,0},
              fillPattern=FillPattern.Solid),
            Text(
              visible=use_m_flow_in,
              extent={{-185,132},{-45,100}},
              lineColor={0,0,0},
              textString="m_flow"),
            Text(
              visible=use_T_in,
              extent={{-111,71},{-71,37}},
              lineColor={0,0,0},
              textString="T"),
            Text(
              visible=use_X_in,
              extent={{-153,-44},{-33,-72}},
              lineColor={0,0,0},
              textString="X"),
            Text(
              visible=use_C_in,
              extent={{-155,-98},{-35,-126}},
              lineColor={0,0,0},
              textString="C")}),
        Documentation(info="<html>
<p>
Models an ideal flow source, with prescribed values of flow rate, temperature, composition and trace substances:
</p>
<ul>
<li> Prescribed mass flow rate.</li>
<li> Prescribed temperature.</li>
<li> Boundary composition (only for multi-substance or trace-substance flow).</li>
</ul>
<p>If <code>use_m_flow_in</code> is false (default option), the <code>m_flow</code> parameter
is used as boundary pressure, and the <code>m_flow_in</code> input connector is disabled; if <code>use_m_flow_in</code> is true, then the <code>m_flow</code> parameter is ignored, and the value provided by the input connector is used instead.</p>
<p>The same thing goes for the temperature and composition</p>
<p>
Note, that boundary temperature,
mass fractions and trace substances have only an effect if the mass flow
is from the boundary into the port. If mass is flowing from
the port into the boundary, the boundary definitions,
with exception of boundary flow rate, do not have an effect.
</p>
</html>"));
    end MassFlowSource_T;

    model MassFlowSource_h
      "Ideal flow source that produces a prescribed mass flow with prescribed specific enthalpy, mass fraction and trace substances"
      import Modelica_Media_Interfaces.Choices.IndependentVariables;
      extends Sources.BaseClasses.PartialFlowSource;
      parameter Boolean use_m_flow_in = false
        "Get the mass flow rate from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Boolean use_h_in= false
        "Get the specific enthalpy from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Boolean use_X_in = false
        "Get the composition from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Boolean use_C_in = false
        "Get the trace substances from the input connector"
        annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
      parameter Medium.MassFlowRate m_flow = 0
        "Fixed mass flow rate going out of the fluid port"
        annotation (Evaluate = true,
                    Dialog(enable = not use_m_flow_in));
      parameter Medium.SpecificEnthalpy h = Medium.h_default
        "Fixed value of specific enthalpy"
        annotation (Evaluate = true,
                    Dialog(enable = not use_h_in));
      parameter Medium.MassFraction X[Medium.nX] = Medium.X_default
        "Fixed value of composition"
        annotation (Evaluate = true,
                    Dialog(enable = (not use_X_in) and Medium.nXi > 0));
      parameter Medium.ExtraProperty C[Medium.nC](
           quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
        "Fixed values of trace substances"
        annotation (Evaluate=true,
                    Dialog(enable = (not use_C_in) and Medium.nC > 0));
      Modelica_Blocks_Interfaces.RealInput m_flow_in if     use_m_flow_in
        "Prescribed mass flow rate"
        annotation (Placement(transformation(extent={{-120,60},{-80,100}},
              rotation=0)));
      Modelica_Blocks_Interfaces.RealInput h_in if              use_h_in
        "Prescribed fluid specific enthalpy"
        annotation (Placement(transformation(extent={{-140,20},{-100,60}},
              rotation=0), iconTransformation(extent={{-140,20},{-100,60}})));
      Modelica_Blocks_Interfaces.RealInput X_in[Medium.nX] if
                                                            use_X_in
        "Prescribed fluid composition"
        annotation (Placement(transformation(extent={{-140,-60},{-100,-20}},
              rotation=0)));
      Modelica_Blocks_Interfaces.RealInput C_in[Medium.nC] if
                                                            use_C_in
        "Prescribed boundary trace substances"
        annotation (Placement(transformation(extent={{-120,-100},{-80,-60}},
              rotation=0), iconTransformation(extent={{-120,-100},{-80,-60}})));
    protected
      Modelica_Blocks_Interfaces.RealInput m_flow_in_internal
        "Needed to connect to conditional connector";
      Modelica_Blocks_Interfaces.RealInput h_in_internal
        "Needed to connect to conditional connector";
      Modelica_Blocks_Interfaces.RealInput X_in_internal[Medium.nX]
        "Needed to connect to conditional connector";
      Modelica_Blocks_Interfaces.RealInput C_in_internal[Medium.nC]
        "Needed to connect to conditional connector";
    equation
      Utilities.checkBoundary(Medium.mediumName, Medium.substanceNames,
        Medium.singleState, true, X_in_internal, "MassFlowSource_h");
      connect(m_flow_in, m_flow_in_internal);
      connect(h_in, h_in_internal);
      connect(X_in, X_in_internal);
      connect(C_in, C_in_internal);
      if not use_m_flow_in then
        m_flow_in_internal = m_flow;
      end if;
      if not use_h_in then
        h_in_internal = h;
      end if;
      if not use_X_in then
        X_in_internal = X;
      end if;
      if not use_C_in then
        C_in_internal = C;
      end if;
      if Medium.ThermoStates == IndependentVariables.ph or
         Medium.ThermoStates == IndependentVariables.phX then
         medium.h = h_in_internal;
      else
         medium.T = Medium.temperature(Medium.setState_phX(medium.p, h_in_internal, X_in_internal));
      end if;
      sum(ports.m_flow) = -m_flow_in_internal;
      medium.Xi = X_in_internal[1:Medium.nXi];
      ports.C_outflow = fill(C_in_internal, nPorts);
      annotation (defaultComponentName="boundary",
        Icon(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{36,45},{100,-45}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={0,127,255}),
            Ellipse(
              extent={{-100,80},{60,-80}},
              lineColor={0,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-60,70},{60,0},{-60,-68},{-60,70}},
              lineColor={0,0,255},
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-54,32},{16,-30}},
              lineColor={255,0,0},
              textString="m"),
            Ellipse(
              extent={{-26,30},{-18,22}},
              lineColor={255,0,0},
              fillColor={255,0,0},
              fillPattern=FillPattern.Solid),
            Text(
              visible=use_m_flow_in,
              extent={{-185,132},{-45,100}},
              lineColor={0,0,0},
              textString="m_flow"),
            Text(
              visible=use_h_in,
              extent={{-113,72},{-73,38}},
              lineColor={0,0,0},
              textString="h"),
            Text(
              visible=use_X_in,
              extent={{-153,-44},{-33,-72}},
              lineColor={0,0,0},
              textString="X"),
            Text(
              visible=use_X_in,
              extent={{-155,-98},{-35,-126}},
              lineColor={0,0,0},
              textString="C"),
            Text(
              extent={{-150,110},{150,150}},
              textString="%name",
              lineColor={0,0,255})}),
        Documentation(info="<html>
<p>
Models an ideal flow source, with prescribed values of flow rate, temperature and composition:
</p>
<ul>
<li> Prescribed mass flow rate.</li>
<li> Prescribed specific enthalpy.</li>
<li> Boundary composition (only for multi-substance or trace-substance flow).</li>
</ul>
<p>If <code>use_m_flow_in</code> is false (default option), the <code>m_flow</code> parameter
is used as boundary pressure, and the <code>m_flow_in</code> input connector is disabled; if <code>use_m_flow_in</code> is true, then the <code>m_flow</code> parameter is ignored, and the value provided by the input connector is used instead.</p>
<p>The same thing goes for the temperature and composition</p>
<p>
Note, that boundary temperature,
mass fractions and trace substances have only an effect if the mass flow
is from the boundary into the port. If mass is flowing from
the port into the boundary, the boundary definitions,
with exception of boundary flow rate, do not have an effect.
</p>
</html>"));
    end MassFlowSource_h;

    package BaseClasses
      "Base classes used in the Sources package (only of interest to build new component models)"
      extends Modelica_Icons.BasesPackage;
    partial model PartialSource
        "Partial component source with one fluid connector"
        import Constants = Modelica_Constants;

      parameter Integer nPorts=0 "Number of ports" annotation(Dialog(connectorSizing=true));

      replaceable package Medium =
          Modelica_Media_Interfaces.PartialMedium
          "Medium model within the source"
         annotation (choicesAllMatching=true);

      Medium.BaseProperties medium "Medium in the source";

        Modelica_Fluid_Interfaces.FluidPorts_b ports[nPorts](redeclare each
            package Medium = Medium, m_flow(each max=if flowDirection == Types.PortFlowDirection.Leaving
                 then 0 else +Constants.inf, each min=if flowDirection == Types.PortFlowDirection.Entering
                 then 0 else -Constants.inf))
          annotation (Placement(transformation(extent={{90,40},{110,-40}})));
      protected
      parameter Types.PortFlowDirection flowDirection=
                       Types.PortFlowDirection.Bidirectional
          "Allowed flow direction"             annotation(Evaluate=true, Dialog(tab="Advanced"));
    equation
      // Only one connection allowed to a port to avoid unwanted ideal mixing
      for i in 1:nPorts loop
        assert(cardinality(ports[i]) <= 1,"
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");

         ports[i].p          = medium.p;
         ports[i].h_outflow  = medium.h;
         ports[i].Xi_outflow = medium.Xi;
      end for;

      annotation (defaultComponentName="boundary", Documentation(info="<html>
<p>
Partial component to model the <b>volume interface</b> of a <b>source</b>
component, such as a mass flow source. The essential
features are:
</p>
<ul>
<li> The pressure in the connection port (= ports.p) is identical to the
     pressure in the volume.</li>
<li> The outflow enthalpy rate (= port.h_outflow) and the composition of the
     substances (= port.Xi_outflow) are identical to the respective values in the volume.</li>
</ul>
</html>"));
    end PartialSource;

    partial model PartialFlowSource
        "Partial component source with one fluid connector"
      import Constants = Modelica_Constants;

      parameter Integer nPorts=0 "Number of ports" annotation(Dialog(connectorSizing=true));

      replaceable package Medium =
          Modelica_Media_Interfaces.PartialMedium
          "Medium model within the source"
         annotation (choicesAllMatching=true);

      Medium.BaseProperties medium "Medium in the source";

        Modelica_Fluid_Interfaces.FluidPort_b ports[nPorts](redeclare each
            package Medium = Medium, m_flow(each max=if flowDirection == Types.PortFlowDirection.Leaving
                 then 0 else +Constants.inf, each min=if flowDirection == Types.PortFlowDirection.Entering
                 then 0 else -Constants.inf))
          annotation (Placement(transformation(extent={{90,10},{110,-10}})));
      protected
      parameter Types.PortFlowDirection flowDirection=
                       Types.PortFlowDirection.Bidirectional
          "Allowed flow direction"             annotation(Evaluate=true, Dialog(tab="Advanced"));
    equation
      assert(abs(sum(abs(ports.m_flow)) - max(abs(ports.m_flow))) <=
          Modelica_Constants.small,                                                            "FlowSource only supports one connection with flow");
      // Only one connection allowed to a port to avoid unwanted ideal mixing
      for i in 1:nPorts loop
        assert(cardinality(ports[i]) <= 1,"
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");      ports[i].p          = medium.p;
         ports[i].h_outflow  = medium.h;
         ports[i].Xi_outflow = medium.Xi;
      end for;

      annotation (defaultComponentName="boundary", Documentation(info="<html>
<p>
Partial component to model the <b>volume interface</b> of a <b>source</b>
component, such as a mass flow source. The essential
features are:
</p>
<ul>
<li> The pressure in the connection port (= ports.p) is identical to the
     pressure in the volume.</li>
<li> The outflow enthalpy rate (= port.h_outflow) and the composition of the
     substances (= port.Xi_outflow) are identical to the respective values in the volume.</li>
</ul>
</html>"));
    end PartialFlowSource;
    end BaseClasses;
    annotation (Documentation(info="<html>
<p>
Package <b>Sources</b> contains generic sources for fluid connectors
to define fixed or prescribed ambient conditions.
</p>
</html>"));
  end Sources;

  package Sensors
    "Ideal sensor components to extract signals from a fluid connector"
    extends Modelica_Icons.SensorsPackage;

    model Pressure "Ideal pressure sensor"
      extends Sensors.BaseClasses.PartialAbsoluteSensor;
      extends Modelica_Icons.RotationalSensor;
      Modelica_Blocks_Interfaces.RealOutput p(final quantity="Pressure",
                                              final unit="Pa",
                                              displayUnit="bar",
                                              min=0) "Pressure at port"
        annotation (Placement(transformation(extent={{100,-10},{120,10}},
              rotation=0)));
    equation
      p = port.p;
      annotation (
      Icon(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{70,0},{100,0}}, color={0,0,127}),
            Line(points={{0,-70},{0,-100}}, color={0,127,255}),
            Text(
              extent={{-150,80},{150,120}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{151,-20},{57,-50}},
              lineColor={0,0,0},
              textString="p")}),
        Documentation(info="<HTML>
<p>
This component monitors the absolute pressure at its fluid port. The sensor is
ideal, i.e., it does not influence the fluid.
</p>
</html>"));
    end Pressure;

    model Density "Ideal one port density sensor"
      extends Sensors.BaseClasses.PartialAbsoluteSensor;
      extends Modelica_Icons.RotationalSensor;
      Modelica_Blocks_Interfaces.RealOutput d(final quantity="Density",
                                              final unit="kg/m3",
                                              displayUnit="g/cm3",
                                              min=0) "Density in port medium"
        annotation (Placement(transformation(extent={{100,-10},{120,10}},
              rotation=0)));

    equation
      d = Medium.density(Medium.setState_phX(port.p, inStream(port.h_outflow), inStream(port.Xi_outflow)));
    annotation (defaultComponentName="density",
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={
            Line(points={{0,-70},{0,-100}}, color={0,0,127}),
            Text(
              extent={{-150,80},{150,120}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{154,-31},{56,-61}},
              lineColor={0,0,0},
              textString="d"),
            Line(points={{70,0},{100,0}}, color={0,0,127})}),
      Documentation(info="<HTML>
<p>
This component monitors the density of the fluid passing its port.
The sensor is ideal, i.e., it does not influence the fluid.
</p>

</HTML>"));
    end Density;

    model DensityTwoPort "Ideal two port density sensor"
      extends Sensors.BaseClasses.PartialFlowSensor;
      extends Modelica_Icons.RotationalSensor;
      Modelica_Blocks_Interfaces.RealOutput d(final quantity="Density",
                                              final unit="kg/m3",
                                              displayUnit="g/cm3",
                                              min=0)
        "Density of the passing fluid"
        annotation (Placement(transformation(
            origin={0,110},
            extent={{10,-10},{-10,10}},
            rotation=270)));

    protected
      Medium.Density rho_a_inflow "Density of inflowing fluid at port_a";
      Medium.Density rho_b_inflow
        "Density of inflowing fluid at port_b or rho_a_inflow, if uni-directional flow";
    equation
      if allowFlowReversal then
         rho_a_inflow = Medium.density(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow));
         rho_b_inflow = Medium.density(Medium.setState_phX(port_a.p, port_a.h_outflow, port_a.Xi_outflow));
        d = Utilities.regStep(
              port_a.m_flow,
              rho_a_inflow,
              rho_b_inflow,
              m_flow_small);
      else
         d = Medium.density(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow));
         rho_a_inflow = d;
         rho_b_inflow = d;
      end if;
    annotation (defaultComponentName="density",
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={
            Text(
              extent={{102,124},{6,95}},
              lineColor={0,0,0},
              textString="d"),
            Line(points={{0,100},{0,70}}, color={0,0,127}),
            Line(points={{-100,0},{-70,0}}, color={0,128,255}),
            Line(points={{70,0},{100,0}}, color={0,128,255})}),
      Documentation(info="<HTML>
<p>
This component monitors the density of the fluid flowing from port_a to port_b.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>"));
    end DensityTwoPort;

    model Temperature "Ideal one port temperature sensor"
        extends Sensors.BaseClasses.PartialAbsoluteSensor;

      Modelica_Blocks_Interfaces.RealOutput T(final quantity="ThermodynamicTemperature",
                                              final unit = "K", displayUnit = "degC", min=0)
        "Temperature in port medium"
        annotation (Placement(transformation(extent={{60,-10},{80,10}}, rotation=
                0)));

    equation
      T = Medium.temperature(Medium.setState_phX(port.p, inStream(port.h_outflow), inStream(port.Xi_outflow)));
    annotation (defaultComponentName="temperature",
        Documentation(info="<HTML>
<p>
This component monitors the temperature of the fluid passing its port.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>"),   Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                100,100}}), graphics={
            Line(points={{0,-70},{0,-100}}, color={0,0,127}),
            Ellipse(
              extent={{-20,-98},{20,-60}},
              lineColor={0,0,0},
              lineThickness=0.5,
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-12,40},{12,-68}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-12,40},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},{
                  12,80},{12,40},{-12,40}},
              lineColor={0,0,0},
              lineThickness=0.5),
            Line(
              points={{-12,40},{-12,-64}},
              color={0,0,0},
              thickness=0.5),
            Line(
              points={{12,40},{12,-64}},
              color={0,0,0},
              thickness=0.5),
            Line(points={{-40,-20},{-12,-20}}, color={0,0,0}),
            Line(points={{-40,20},{-12,20}}, color={0,0,0}),
            Line(points={{-40,60},{-12,60}}, color={0,0,0}),
            Line(points={{12,0},{60,0}}, color={0,0,127})}),
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={
            Ellipse(
              extent={{-20,-88},{20,-50}},
              lineColor={0,0,0},
              lineThickness=0.5,
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-12,50},{12,-58}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-12,50},{-12,90},{-10,96},{-6,98},{0,100},{6,98},{10,96},{
                  12,90},{12,50},{-12,50}},
              lineColor={0,0,0},
              lineThickness=0.5),
            Line(
              points={{-12,50},{-12,-54}},
              color={0,0,0},
              thickness=0.5),
            Line(
              points={{12,50},{12,-54}},
              color={0,0,0},
              thickness=0.5),
            Line(points={{-40,-10},{-12,-10}}, color={0,0,0}),
            Line(points={{-40,30},{-12,30}}, color={0,0,0}),
            Line(points={{-40,70},{-12,70}}, color={0,0,0}),
            Text(
              extent={{126,-30},{6,-60}},
              lineColor={0,0,0},
              textString="T"),
            Text(
              extent={{-150,110},{150,150}},
              textString="%name",
              lineColor={0,0,255}),
            Line(points={{12,0},{60,0}}, color={0,0,127})}));
    end Temperature;

    model TemperatureTwoPort "Ideal two port temperature sensor"
      extends Sensors.BaseClasses.PartialFlowSensor;

      Modelica_Blocks_Interfaces.RealOutput T( final quantity="ThermodynamicTemperature",
                                               final unit="K",
                                               min = 0,
                                               displayUnit="degC")
        "Temperature of the passing fluid"
        annotation (Placement(transformation(
            origin={0,110},
            extent={{10,-10},{-10,10}},
            rotation=270)));

    protected
      Medium.Temperature T_a_inflow "Temperature of inflowing fluid at port_a";
      Medium.Temperature T_b_inflow
        "Temperature of inflowing fluid at port_b or T_a_inflow, if uni-directional flow";
    equation
      if allowFlowReversal then
         T_a_inflow = Medium.temperature(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow));
         T_b_inflow = Medium.temperature(Medium.setState_phX(port_a.p, port_a.h_outflow, port_a.Xi_outflow));
        T = Utilities.regStep(
              port_a.m_flow,
              T_a_inflow,
              T_b_inflow,
              m_flow_small);
      else
         T = Medium.temperature(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow));
         T_a_inflow = T;
         T_b_inflow = T;
      end if;
    annotation (defaultComponentName="temperature",
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={
            Line(points={{0,100},{0,50}}, color={0,0,127}),
            Line(points={{-92,0},{100,0}}, color={0,128,255}),
            Ellipse(
              extent={{-20,-68},{20,-30}},
              lineColor={0,0,0},
              lineThickness=0.5,
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-12,50},{12,-34}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-12,50},{-12,70},{-10,76},{-6,78},{0,80},{6,78},{10,76},{
                  12,70},{12,50},{-12,50}},
              lineColor={0,0,0},
              lineThickness=0.5),
            Line(
              points={{-12,50},{-12,-35}},
              color={0,0,0},
              thickness=0.5),
            Line(
              points={{12,50},{12,-34}},
              color={0,0,0},
              thickness=0.5),
            Line(points={{-40,-10},{-12,-10}}, color={0,0,0}),
            Line(points={{-40,20},{-12,20}}, color={0,0,0}),
            Line(points={{-40,50},{-12,50}}, color={0,0,0}),
            Text(
              extent={{94,122},{0,92}},
              lineColor={0,0,0},
              textString="T")}),
      Documentation(info="<HTML>
<p>
This component monitors the temperature of the passing fluid.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>"));
    end TemperatureTwoPort;

    model SpecificEnthalpy "Ideal one port specific enthalpy sensor"
      extends Sensors.BaseClasses.PartialAbsoluteSensor;
      extends Modelica_Icons.RotationalSensor;
      Modelica_Blocks_Interfaces.RealOutput h_out(final quantity="SpecificEnergy",
                                                  final unit="J/kg")
        "Specific enthalpy in port medium"
        annotation (Placement(transformation(extent={{100,-10},{120,10}},
              rotation=0)));

    equation
      h_out = inStream(port.h_outflow);
    annotation (defaultComponentName="specificEnthalpy",
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={
            Line(points={{0,-70},{0,-100}}, color={0,0,127}),
            Text(
              extent={{-150,80},{150,120}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{168,-30},{52,-60}},
              lineColor={0,0,0},
              textString="h"),
            Line(points={{70,0},{100,0}}, color={0,0,127})}),
      Documentation(info="<HTML>
<p>
This component monitors the specific enthalpy of the fluid passing its port.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>"));
    end SpecificEnthalpy;

    model SpecificEnthalpyTwoPort
      "Ideal two port sensor for the specific enthalpy"
      extends Sensors.BaseClasses.PartialFlowSensor;
      extends Modelica_Icons.RotationalSensor;
      Modelica_Blocks_Interfaces.RealOutput h_out(final quantity="SpecificEnergy",
                                                  final unit="J/kg")
        "Specific enthalpy of the passing fluid"
        annotation (Placement(transformation(
            origin={0,110},
            extent={{10,-10},{-10,10}},
            rotation=270)));

    equation
      if allowFlowReversal then
        h_out = Utilities.regStep(
              port_a.m_flow,
              port_b.h_outflow,
              port_a.h_outflow,
              m_flow_small);
      else
         h_out = port_b.h_outflow;
      end if;
    annotation (defaultComponentName="specificEnthalpy",
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={
            Text(
              extent={{102,120},{0,90}},
              lineColor={0,0,0},
              textString="h"),
            Line(points={{0,100},{0,70}}, color={0,0,127}),
            Line(points={{-100,0},{-70,0}}, color={0,128,255}),
            Line(points={{70,0},{100,0}}, color={0,128,255})}),
      Documentation(info="<HTML>
<p>
This component monitors the specific enthalpy of a passing fluid.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>"));
    end SpecificEnthalpyTwoPort;

    model SpecificEntropy "Ideal one port specific entropy sensor"
      extends Sensors.BaseClasses.PartialAbsoluteSensor;
      extends Modelica_Icons.RotationalSensor;
      Modelica_Blocks_Interfaces.RealOutput s(final quantity="SpecificEntropy",
                                              final unit="J/(kg.K)")
        "Specific entropy in port medium"
        annotation (Placement(transformation(extent={{100,-10},{120,10}},
              rotation=0)));

    equation
      s = Medium.specificEntropy(Medium.setState_phX(port.p, inStream(port.h_outflow), inStream(port.Xi_outflow)));
    annotation (defaultComponentName="specificEntropy",
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={
            Line(points={{0,-70},{0,-100}}, color={0,0,127}),
            Text(
              extent={{-150,80},{150,120}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{156,-24},{54,-54}},
              lineColor={0,0,0},
              textString="s"),
            Line(points={{70,0},{100,0}}, color={0,0,127})}),
      Documentation(info="<HTML>
<p>
This component monitors the specific entropy of the fluid passing its port.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>"));
    end SpecificEntropy;

    model SpecificEntropyTwoPort
      "Ideal two port sensor for the specific entropy"
      extends Sensors.BaseClasses.PartialFlowSensor;
      extends Modelica_Icons.RotationalSensor;
      Modelica_Blocks_Interfaces.RealOutput s(final quantity="SpecificEntropy",
                                              final unit="J/(kg.K)")
        "Specific entropy of the passing fluid"
        annotation (Placement(transformation(
            origin={0,110},
            extent={{10,-10},{-10,10}},
            rotation=270)));

    protected
      Medium.SpecificEntropy s_a_inflow
        "Specific entropy of inflowing fluid at port_a";
      Medium.SpecificEntropy s_b_inflow
        "Specific entropy of inflowing fluid at port_b or s_a_inflow, if uni-directional flow";
    equation
      if allowFlowReversal then
         s_a_inflow = Medium.specificEntropy(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow));
         s_b_inflow = Medium.specificEntropy(Medium.setState_phX(port_a.p, port_a.h_outflow, port_a.Xi_outflow));
        s = Utilities.regStep(
              port_a.m_flow,
              s_a_inflow,
              s_b_inflow,
              m_flow_small);
      else
         s = Medium.specificEntropy(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow));
         s_a_inflow = s;
         s_b_inflow = s;
      end if;
    annotation (defaultComponentName="specificEntropy",
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={
            Text(
              extent={{120,120},{0,90}},
              lineColor={0,0,0},
              textString="s"),
            Line(points={{0,100},{0,70}}, color={0,0,127}),
            Line(points={{-100,0},{-70,0}}, color={0,128,255}),
            Line(points={{70,0},{100,0}}, color={0,128,255})}),
      Documentation(info="<HTML>
<p>
This component monitors the specific entropy of the passing fluid.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>"));
    end SpecificEntropyTwoPort;

    model MassFractions "Ideal one port mass fraction sensor"
      extends BaseClasses.PartialAbsoluteSensor;
      extends Modelica_Icons.RotationalSensor;
      parameter String substanceName = "water" "Name of mass fraction";

      Modelica_Blocks_Interfaces.RealOutput Xi "Mass fraction in port medium"
        annotation (Placement(transformation(extent={{100,-10},{120,10}},
              rotation=0)));

    protected
      parameter Integer ind(fixed=false)
        "Index of species in vector of independent mass fractions";
      Medium.MassFraction XiVec[Medium.nXi]
        "Mass fraction vector, needed because indexed argument for the operator inStream is not supported";
    initial algorithm
      ind:= -1;
      for i in 1:Medium.nXi loop
        if (Modelica_Utilities.Strings.isEqual(Medium.substanceNames[i],
            substanceName)) then
          ind := i;
        end if;
      end for;
      assert(ind > 0, "Mass fraction '" + substanceName + "' is not present in medium '"
             + Medium.mediumName + "'.\n"
             + "Check sensor parameter and medium model.");
    equation
      XiVec = inStream(port.Xi_outflow);
      Xi = XiVec[ind];
    annotation (defaultComponentName="massFraction",
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={
            Line(points={{0,-70},{0,-100}}, color={0,0,127}),
            Text(
              extent={{-150,80},{150,120}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{160,-30},{60,-60}},
              lineColor={0,0,0},
              textString="Xi"),
            Line(points={{70,0},{100,0}}, color={0,0,127})}),
      Documentation(info="<HTML>
<p>
This component monitors the mass fraction contained in the fluid passing its port.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>",     revisions="<html>
<ul>
<li>2011-12-14: Stefan Wischhusen: Initial Release.</li>
</ul>
</html>"));
    end MassFractions;

    model MassFractionsTwoPort "Ideal two port sensor for mass fraction"
      extends BaseClasses.PartialFlowSensor;
      extends Modelica_Icons.RotationalSensor;
      Modelica_Blocks_Interfaces.RealOutput Xi "Mass fraction in port medium"
        annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
            origin={0,110}), iconTransformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={0,110})));
      parameter String substanceName = "water" "Name of mass fraction";

    protected
      parameter Integer ind(fixed=false)
        "Index of species in vector of independent mass fractions";
    initial algorithm
      ind:= -1;
      for i in 1:Medium.nC loop
        if ( Modelica_Utilities.Strings.isEqual(Medium.substanceNames[i], substanceName)) then
          ind := i;
        end if;
      end for;
      assert(ind > 0, "Mass fraction '" + substanceName + "' is not present in medium '"
             + Medium.mediumName + "'.\n"
             + "Check sensor parameter and medium model.");
    equation
      if allowFlowReversal then
        Xi = Utilities.regStep(
              port_a.m_flow,
              port_b.Xi_outflow[ind],
              port_a.Xi_outflow[ind],
              m_flow_small);
      else
         Xi = port_b.Xi_outflow[ind];
      end if;
    annotation (defaultComponentName="massFraction",
      Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                100}}), graphics={
            Text(
              extent={{82,122},{0,92}},
              lineColor={0,0,0},
              textString="Xi"),
            Line(points={{0,100},{0,70}}, color={0,0,127}),
            Line(points={{-100,0},{-70,0}}, color={0,128,255}),
            Line(points={{70,0},{100,0}}, color={0,128,255})}),
      Documentation(info="<HTML>
<p>
This component monitors the mass fraction of the passing fluid.
The sensor is ideal, i.e., it does not influence the fluid.
</p> </HTML>",   revisions="<html>
<ul>
<li>2011-12-14: Stefan Wischhusen: Initial Release.</li>
</ul>
</html>"));
    end MassFractionsTwoPort;

    model TraceSubstances "Ideal one port trace substances sensor"
      extends Sensors.BaseClasses.PartialAbsoluteSensor;
      extends Modelica_Icons.RotationalSensor;
      parameter String substanceName = "CO2" "Name of trace substance";

      Modelica_Blocks_Interfaces.RealOutput C "Trace substance in port medium"
        annotation (Placement(transformation(extent={{100,-10},{120,10}},
              rotation=0)));

    protected
      parameter Integer ind(fixed=false)
        "Index of species in vector of auxiliary substances";
      Medium.ExtraProperty CVec[Medium.nC](
          quantity=Medium.extraPropertiesNames)
        "Trace substances vector, needed because indexed argument for the operator inStream is not supported";
    initial algorithm
      ind:= -1;
      for i in 1:Medium.nC loop
        if ( Modelica_Utilities.Strings.isEqual(Medium.extraPropertiesNames[i], substanceName)) then
          ind := i;
        end if;
      end for;
      assert(ind > 0, "Trace substance '" + substanceName + "' is not present in medium '"
             + Medium.mediumName + "'.\n"
             + "Check sensor parameter and medium model.");
    equation
      CVec = inStream(port.C_outflow);
      C = CVec[ind];
    annotation (defaultComponentName="traceSubstance",
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={
            Line(points={{0,-70},{0,-100}}, color={0,0,127}),
            Text(
              extent={{-150,80},{150,120}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{160,-30},{60,-60}},
              lineColor={0,0,0},
              textString="C"),
            Line(points={{70,0},{100,0}}, color={0,0,127})}),
      Documentation(info="<HTML>
<p>
This component monitors the trace substances contained in the fluid passing its port.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>"));
    end TraceSubstances;

    model TraceSubstancesTwoPort "Ideal two port sensor for trace substance"
      extends Sensors.BaseClasses.PartialFlowSensor;
      extends Modelica_Icons.RotationalSensor;
      Modelica_Blocks_Interfaces.RealOutput C
        "Trace substance of the passing fluid"
        annotation (Placement(transformation(
            origin={0,110},
            extent={{10,-10},{-10,10}},
            rotation=270)));
      parameter String substanceName = "CO2" "Name of trace substance";

    protected
      parameter Integer ind(fixed=false)
        "Index of species in vector of auxiliary substances";
    initial algorithm
      ind:= -1;
      for i in 1:Medium.nC loop
        if ( Modelica_Utilities.Strings.isEqual(Medium.extraPropertiesNames[i], substanceName)) then
          ind := i;
        end if;
      end for;
      assert(ind > 0, "Trace substance '" + substanceName + "' is not present in medium '"
             + Medium.mediumName + "'.\n"
             + "Check sensor parameter and medium model.");
    equation
      if allowFlowReversal then
        C = Utilities.regStep(
              port_a.m_flow,
              port_b.C_outflow[ind],
              port_a.C_outflow[ind],
              m_flow_small);
      else
         C = port_b.C_outflow[ind];
      end if;
    annotation (defaultComponentName="traceSubstance",
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={
            Text(
              extent={{82,122},{0,92}},
              lineColor={0,0,0},
              textString="C"),
            Line(points={{0,100},{0,70}}, color={0,0,127}),
            Line(points={{-100,0},{-70,0}}, color={0,128,255}),
            Line(points={{70,0},{100,0}}, color={0,128,255})}),
      Documentation(info="<HTML>
<p>
This component monitors the trace substance of the passing fluid.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>"));
    end TraceSubstancesTwoPort;

    model MassFlowRate "Ideal sensor for mass flow rate"
      extends Sensors.BaseClasses.PartialFlowSensor;
      extends Modelica_Icons.RotationalSensor;
      Modelica_Blocks_Interfaces.RealOutput m_flow(quantity="MassFlowRate",
                                                   final unit="kg/s")
        "Mass flow rate from port_a to port_b" annotation (Placement(
            transformation(
            origin={0,110},
            extent={{10,-10},{-10,10}},
            rotation=270)));

    equation
      m_flow = port_a.m_flow;
    annotation (
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={
            Line(points={{70,0},{100,0}}, color={0,128,255}),
            Text(
              extent={{162,120},{2,90}},
              lineColor={0,0,0},
              textString="m_flow"),
            Line(points={{0,100},{0,70}}, color={0,0,127}),
            Line(points={{-100,0},{-70,0}}, color={0,128,255})}),
      Documentation(info="<HTML>
<p>
This component monitors the mass flow rate flowing from port_a to port_b.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>"));
    end MassFlowRate;

    model VolumeFlowRate "Ideal sensor for volume flow rate"
      extends Sensors.BaseClasses.PartialFlowSensor;
      extends Modelica_Icons.RotationalSensor;
      Modelica_Blocks_Interfaces.RealOutput V_flow(final quantity="VolumeFlowRate",
                                                   final unit="m3/s")
        "Volume flow rate from port_a to port_b"
        annotation (Placement(transformation(
            origin={0,110},
            extent={{10,-10},{-10,10}},
            rotation=270)));

    protected
      Medium.Density rho_a_inflow "Density of inflowing fluid at port_a";
      Medium.Density rho_b_inflow
        "Density of inflowing fluid at port_b or rho_a_inflow, if uni-directional flow";
      Medium.Density d "Density of the passing fluid";
    equation
      if allowFlowReversal then
         rho_a_inflow = Medium.density(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow));
         rho_b_inflow = Medium.density(Medium.setState_phX(port_a.p, port_a.h_outflow, port_a.Xi_outflow));
        d = Utilities.regStep(
              port_a.m_flow,
              rho_a_inflow,
              rho_b_inflow,
              m_flow_small);
      else
         d = Medium.density(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow));
         rho_a_inflow = d;
         rho_b_inflow = d;
      end if;
      V_flow = port_a.m_flow/d;
    annotation (
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={
            Text(
              extent={{160,120},{0,90}},
              lineColor={0,0,0},
              textString="V_flow"),
            Line(points={{0,100},{0,70}}, color={0,0,127}),
            Line(points={{-100,0},{-70,0}}, color={0,128,255}),
            Line(points={{70,0},{100,0}}, color={0,128,255})}),
      Documentation(info="<HTML>
<p>
This component monitors the volume flow rate flowing from port_a to port_b.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>"));
    end VolumeFlowRate;

    model RelativePressure "Ideal relative pressure sensor"
      extends Sensors.BaseClasses.PartialRelativeSensor;

      Modelica_Blocks_Interfaces.RealOutput p_rel(final quantity="Pressure",
                                                  final unit="Pa",
                                                  displayUnit="bar")
        "Relative pressure signal" annotation (Placement(transformation(
            origin={0,-90},
            extent={{10,-10},{-10,10}},
            rotation=90)));
    equation

      // Relative pressure
      p_rel = port_a.p - port_b.p;
      annotation (
        Icon(graphics={
            Line(points={{0,-30},{0,-80}}, color={0,0,127}),
            Text(
              extent={{130,-70},{4,-100}},
              lineColor={0,0,0},
              textString="p_rel")}),
        Documentation(info="<HTML>
<p>
The relative pressure \"port_a.p - port_b.p\" is determined between
the two ports of this component and is provided as output signal. The
sensor should be connected in parallel with other equipment, no flow
through the sensor is allowed.
</p>
</html>"));
    end RelativePressure;

    model RelativeTemperature "Ideal relative temperature sensor"
      extends Sensors.BaseClasses.PartialRelativeSensor;

      Modelica_Blocks_Interfaces.RealOutput T_rel(final quantity="ThermodynamicTemperature",
                                                  final unit = "K", displayUnit = "degC", min=0)
        "Relative temperature signal"                                                                               annotation (Placement(
            transformation(
            origin={0,-90},
            extent={{10,-10},{-10,10}},
            rotation=90)));
    equation
      // Relative temperature
      T_rel = Medium.temperature(Medium.setState_phX(port_a.p, inStream(port_a.h_outflow), inStream(port_a.Xi_outflow))) -
              Medium.temperature(Medium.setState_phX(port_b.p, inStream(port_b.h_outflow), inStream(port_b.Xi_outflow)));
      annotation (
        Icon(graphics={
            Line(points={{0,-30},{0,-80}}, color={0,0,127}),
            Text(
              extent={{128,-70},{10,-100}},
              lineColor={0,0,0},
              textString="T_rel")}),
        Documentation(info="<HTML>
<p>
The relative temperature \"T(port_a) - T(port_b)\" is determined between
the two ports of this component and is provided as output signal. The
sensor should be connected in parallel with other equipment, no flow
through the sensor is allowed.
</p>
</html>"));
    end RelativeTemperature;

    package BaseClasses
      "Base classes used in the Sensors package (only of interest to build new component models)"
      extends Modelica_Icons.BasesPackage;

      partial model PartialAbsoluteSensor
        "Partial component to model a sensor that measures a potential variable"

        replaceable package Medium=Modelica_Media_Interfaces.PartialMedium
          "Medium in the sensor"
          annotation(choicesAllMatching=true);

        Modelica_Fluid_Interfaces.FluidPort_a port(redeclare package Medium =
              Medium, m_flow(min=0)) annotation (Placement(transformation(
              origin={0,-100},
              extent={{-10,-10},{10,10}},
              rotation=90)));

      equation
        port.m_flow = 0;
        port.h_outflow = Medium.h_default;
        port.Xi_outflow = Medium.X_default[1:Medium.nXi];
        port.C_outflow = zeros(Medium.nC);
        annotation (Documentation(info="<html>
<p>
Partial component to model an <b>absolute sensor</b>. Can be used for pressure sensor models.
Use for other properties such as temperature or density is discouraged, because the enthalpy at the connector can have different meanings, depending on the connection topology. Use <code>PartialFlowSensor</code> instead.
as signal.
</p>
</html>"));
      end PartialAbsoluteSensor;

      model PartialRelativeSensor
        "Partial component to model a sensor that measures the difference between two potential variables"
        extends Modelica_Icons.TranslationalSensor;
        replaceable package Medium =
          Modelica_Media_Interfaces.PartialMedium "Medium in the sensor"  annotation (
            choicesAllMatching = true);

        Modelica_Fluid_Interfaces.FluidPort_a port_a(m_flow(min=0), redeclare
            package Medium = Medium) annotation (Placement(transformation(
                extent={{-110,-10},{-90,10}}, rotation=0)));
        Modelica_Fluid_Interfaces.FluidPort_b port_b(m_flow(min=0), redeclare
            package Medium = Medium) annotation (Placement(transformation(
                extent={{110,-12},{90,8}}, rotation=0), iconTransformation(
                extent={{110,-10},{90,10}})));

      equation
        // Zero flow equations for connectors
        port_a.m_flow = 0;
        port_b.m_flow = 0;

        // No contribution of specific quantities
        port_a.h_outflow = Medium.h_default;
        port_b.h_outflow = Medium.h_default;
        port_a.Xi_outflow = Medium.X_default[1:Medium.nXi];
        port_b.Xi_outflow = Medium.X_default[1:Medium.nXi];
        port_a.C_outflow  = zeros(Medium.nC);
        port_b.C_outflow  = zeros(Medium.nC);

        annotation (
          Icon(graphics={
              Line(points={{-100,0},{-70,0}}, color={0,127,255}),
              Line(points={{70,0},{100,0}}, color={0,127,255}),
              Text(
                extent={{-150,40},{150,80}},
                textString="%name",
                lineColor={0,0,255}),
              Line(
                points={{32,3},{-58,3}},
                color={0,128,255},
                smooth=Smooth.None),
              Polygon(
                points={{22,18},{62,3},{22,-12},{22,18}},
                lineColor={0,128,255},
                smooth=Smooth.None,
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<HTML>
<p>
The relative pressure \"port_a.p - port_b.p\" is determined between
the two ports of this component and is provided as output signal. The
sensor should be connected in parallel with other equipment, no flow
through the sensor is allowed.
</p>
</html>"));
      end PartialRelativeSensor;

      partial model PartialFlowSensor
        "Partial component to model sensors that measure flow properties"
        extends Modelica_Fluid_Interfaces.PartialTwoPort;

        parameter Medium.MassFlowRate m_flow_nominal = system.m_flow_nominal
          "Nominal value of m_flow = port_a.m_flow"
          annotation(Dialog(tab = "Advanced"));
        parameter Medium.MassFlowRate m_flow_small(min=0) = if system.use_eps_Re then system.eps_m_flow*m_flow_nominal else system.m_flow_small
          "Regularization for bi-directional flow in the region |m_flow| < m_flow_small (m_flow_small > 0 required)"
          annotation(Dialog(tab="Advanced"));

      equation
        // mass balance
        0 = port_a.m_flow + port_b.m_flow;

        // momentum equation (no pressure loss)
        port_a.p = port_b.p;

        // isenthalpic state transformation (no storage and no loss of energy)
        port_a.h_outflow = inStream(port_b.h_outflow);
        port_b.h_outflow = inStream(port_a.h_outflow);

        port_a.Xi_outflow = inStream(port_b.Xi_outflow);
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);

        port_a.C_outflow = inStream(port_b.C_outflow);
        port_b.C_outflow = inStream(port_a.C_outflow);
        annotation (Documentation(info="<html>
<p>
Partial component to model a <b>sensor</b> that measures any intensive properties
of a flow, e.g., to get temperature or density in the flow
between fluid connectors.<br>
The model includes zero-volume balance equations. Sensor models inheriting from
this partial class should add a medium instance to calculate the measured property.
</p>
</html>"));
      end PartialFlowSensor;

    end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
<p align = justify>
Package <b>Sensors</b> consists of idealized sensor components that
provide variables of a medium model and/or fluid ports as
output signals. These signals can be, e.g., further processed
with components of the Modelica_Blocks library.
Also more realistic sensor models can be built, by further
processing (e.g., by attaching block Modelica_Blocks.FirstOrder to
model the time constant of the sensor).
</p>

<p align = justify>For the thermodynamic state variables temperature, specific enthalpy, specific entropy and density
the fluid library provides two different types of sensors: <b>regular one port</b> and <b>two port</b> sensors.</p>

<ul>
<li>The <b>regular one port</b> sensors have the advantage of easy introduction and removal from a model, as no connections have to be broken.
A potential drawback is that the obtained value jumps as flow reverts.
</li>

<li>The <b>two port</b> sensors offer the advantages of an adjustable regularized step function around zero flow.
Moreover the obtained result is restricted to the value flowing into port_a if allowFlowReversal is false.</li>
</ul>

<p>
<a href=\"modelica://Modelica_Fluid.Examples.Explanatory.MeasuringTemperature\">Modelica_Fluid.Examples.Explanatory.MeasuringTemperature</a>
demonstrates the differences between one- and two-port sensor at hand of a
simple example.
</p>
</html>",   revisions="<html>
<ul>
<li><i>22 Dec 2008</i>
    by R;uumldiger Franke<br>
    <ul>
    <li>flow sensors based on Interfaces.PartialTwoPort</li>
    <li>adapted docu to stream connectors, i.e., less need for two port sensors</li>
    </ul>
<li><i>4 Dec 2008</i>
    by Michael Wetter<br>
       included sensors for trace substance</li>
<li><i>31 Oct 2007</i>
    by Carsten Heinrich<br>
       updated sensor models, included one and two port sensors for thermodynamic state variables</li>
</ul>
</html>"));
  end Sensors;

  package Types "Common types for fluid models"
    extends Modelica_Icons.TypesPackage;

    type HydraulicConductance = Modelica_Icons.TypeReal (
        final quantity="HydraulicConductance",
        final unit="kg/(s.Pa)") "Real type for hydraulic conductance";
    type HydraulicResistance = Modelica_Icons.TypeReal (
        final quantity="HydraulicResistance",
        final unit="Pa.s/kg") "Real type for hydraulic resistance";

    type Roughness = Modelica_Icons.TypeReal (final quantity="Length", final unit="m", displayUnit="mm")
      "Real type for roughness of a pipe"
      annotation (Documentation(info="<html>
<p>
This Real type defines the absolute roughness of the inner surface of a
pipe or fitting, i.e., the absolute average height of surface asperities.
It has usually to
be estimated. In <i>[Idelchik 1994, pp. 105-109,
Table 2-5; Miller 1990, p. 190, Table 8-1]</i> many examples are given.
As a short summary:
</p>

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td colspan=\"2\" align=\"center\"><b>Type of pipe</b></td>
      <td align=\"center\">Roughness</td></tr>

  <tr><td><b>Smooth pipes</b></td>
      <td>Drawn brass, copper, aluminium, glass, etc.</td>
      <td> 0.0025 mm</td>
  </tr>
  <tr><td rowspan=\"3\"><b>Steel pipes</b></td>
      <td>New smooth pipes</td>
      <td>0.025 mm</td>
  </tr>
  <tr><td>Mortar lined, average finish</td>
      <td>0.1 mm</td>
  </tr>
  <tr><td>Heavy rust</td>
      <td>1 mm</td>
  </tr>
  <tr><td rowspan=\"3\"><b>Concrete pipes</b></td>
      <td>Steel forms, first class workmanship</td>
      <td>0.025 mm</td>
  </tr>
  <tr><td>Steel forms, average workmanship</td>
      <td>0.1 mm</td>
  </tr>
  <tr><td>Block linings</td>
      <td>1 mm</td>
  </tr>
</table>

<h4>References</h4>

<dl>
    <dt>Idelchik I.E. (1994):</dt>
    <dd><a href=\"http://www.bookfinder.com/dir/i/Handbook_of_Hydraulic_Resistance/0849399084/\"><b>Handbook
        of Hydraulic Resistance</b></a>. 3rd edition, Begell House, ISBN
        0-8493-9908-4</dd>
    <dt>Miller D. S. (1990):</dt>
    <dd><b>Internal flow systems</b>.
    2nd edition. Cranfield:BHRA(Information Services).</dd>
</dl>
</html>"));
    type Dynamics = enumeration(
        DynamicFreeInitial
          "DynamicFreeInitial -- Dynamic balance, Initial guess value",
        FixedInitial "FixedInitial -- Dynamic balance, Initial value fixed",
        SteadyStateInitial
          "SteadyStateInitial -- Dynamic balance, Steady state initial with guess value",

        SteadyState "SteadyState -- Steady state balance, Initial guess value")
      "Enumeration to define definition of balance equations"
    annotation (Documentation(info="<html>
<p>
Enumeration to define the formulation of balance equations
(to be selected via choices menu):
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Dynamics.</b></th><th><b>Meaning</b></th></tr>
<tr><td>DynamicFreeInitial</td><td>Dynamic balance, Initial guess value</td></tr>

<tr><td>FixedInitial</td><td>Dynamic balance, Initial value fixed</td></tr>

<tr><td>SteadyStateInitial</td><td>Dynamic balance, Steady state initial with guess value</td></tr>

<tr><td>SteadyState</td><td>Steady state balance, Initial guess value</td></tr>
</table>

<p>
The enumeration \"Dynamics\" is used for the mass, energy and momentum balance equations
respectively. The exact meaning for the three balance equations is stated in the following
tables:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td colspan=\"3\"><b>Mass balance</b> </td>
<tr><td><b>Dynamics.</b></td>
    <td><b>Balance equation</b></td>
    <td><b>Initial condition</b></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> <b>if</b> Medium.singleState <b>then</b> <br>
         &nbsp;&nbsp;no initial condition<br>
         <b>else</b> p=p_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <b>if</b> Medium.singleState <b>then</b> <br>
         &nbsp;&nbsp;no initial condition<br>
         <b>else</b> <b>der</b>(p)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <b>der</b>(m)=0  </td>
    <td> no initial conditions </td></tr>
</table>

&nbsp;<br>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td colspan=\"3\"><b>Energy balance</b> </td>
<tr><td><b>Dynamics.</b></td>
    <td><b>Balance equation</b></td>
    <td><b>Initial condition</b></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> T=T_start or h=h_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <b>der</b>(T)=0 or <b>der</b>(h)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <b>der</b>(U)=0  </td>
    <td> no initial conditions </td></tr>
</table>

&nbsp;<br>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td colspan=\"3\"><b>Momentum balance</b> </td>
<tr><td><b>Dynamics.</b></td>
    <td><b>Balance equation</b></td>
    <td><b>Initial condition</b></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> m_flow = m_flow_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <b>der</b>(m_flow)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <b>der</b>(m_flow)=0 </td>
    <td> no initial conditions </td></tr>
</table>

<p>
In the tables above, the equations are given for one-substance fluids. For multiple-substance
fluids and for trace substances, equivalent equations hold.
</p>

<p>
Medium.singleState is a medium property and defines whether the medium is only
described by one state (+ the mass fractions in case of a multi-substance fluid). In such
a case one initial condition less must be provided. For example, incompressible
media have Medium.singleState = <b>true</b>.
</p>

</html>"));

    type CvTypes = enumeration(
        Av "Av (metric) flow coefficient",
        Kv "Kv (metric) flow coefficient",
        Cv "Cv (US) flow coefficient",
        OpPoint "Av defined by operating point")
      "Enumeration to define the choice of valve flow coefficient" annotation (
        Documentation(info="<html>

<p>
Enumeration to define the choice of valve flow coefficient
(to be selected via choices menu):
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>CvTypes.</b></th>
    <th><b>Meaning</b></th></tr>

<tr><td>Av</td>
    <td>Av (metric) flow coefficient</td></tr>

<tr><td>Kv</td>
    <td>Kv (metric) flow coefficient</td></tr>

<tr><td>Cv</td>
    <td>Cv (US) flow coefficient</td></tr>

<tr><td>OpPoint</td>
    <td>Av defined by operating point</td></tr>

</table>

<p>
The details of the coefficients are explained in the
<a href=\"modelica://Modelica_Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">
   User's Guide </a>.
</p>

</html>"));

    type PortFlowDirection = enumeration(
        Entering "Fluid flow is only entering",
        Leaving "Fluid flow is only leaving",
        Bidirectional "No restrictions on fluid flow (flow reversal possible)")
      "Enumeration to define whether flow reversal is allowed" annotation (
        Documentation(info="<html>

<p>
Enumeration to define the assumptions on the model for the
direction of fluid flow at a port (to be selected via choices menu):
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>PortFlowDirection.</b></th>
    <th><b>Meaning</b></th></tr>

<tr><td>Entering</td>
    <td>Fluid flow is only entering the port from the outside</td></tr>

<tr><td>Leaving</td>
    <td>Fluid flow is only leaving the port to the outside</td></tr>

<tr><td>Bidirectional</td>
    <td>No restrictions on fluid flow (flow reversal possible)</td></tr>
</table>

<p>
The default is \"PortFlowDirection.Bidirectional\". If you are completely sure that
the flow is only in one direction, then the other settings may
make the simulation of your model faster.
</p>

</html>"));

    type ModelStructure = enumeration(
        av_vb "av_vb: port_a - volume - flow model - volume - port_b",
        a_v_b "a_v_b: port_a - flow model - volume - flow model - port_b",
        av_b "av_b: port_a - volume - flow model - port_b",
        a_vb "a_vb: port_a - flow model - volume - port_b")
      "Enumeration with choices for model structure in distributed pipe model"
      annotation (Documentation(info="<html>

<p>
Enumeration to define the discretization structure of
distributed pipe models according to the staggered grid scheme:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>ModelStructure.</b></th>
    <th><b>Meaning</b></th></tr>

<tr><td>av_vb</td>
    <td>port_a - volume - flow model - volume - port_b</td></tr>

<tr><td>a_v_b</td>
    <td>port_a - flow model - volume - flow model - port_b</td></tr>

<tr><td>av_b</td>
    <td>port_a - volume - flow model - port_b</td></tr>

<tr><td>a_vb</td>
    <td>port_a - flow model - volume - port_b</td></tr>
</table>

<p>
The default is \"ModelStructure.av_vb\", i.e., the distributed pipe
has \"volumes\" at its both ends. The advantage is that connections
of the pipe to flow models (like fittings) lead to the desirable structure
of alternating volume and flow models, which means that no non-linear
algebraic equations occur.
</p>

<p>
Direct connections of distributed pipes with
this option means that two volumes are directly connected together. Due to the
stream concept this means that the pressures of the two connected volumes
are identical, but the temperatures are not set equal
(this corresponds to volumes that are connected together with a very
short distance and it needs some time until different volume temperatures
are equilibrated). Since the pressures of the volumes are identical, the number
of states is reduced and index reduction takes place (which means that medium
equations depending on pressure are differentiated and the number of required
initial conditions is reduced by one).
</p>

<p>
The default option \"av_vb\" cannot be used, if the dynamic pipe is connected to a model with non-differentiable pressure, like a Sources.Boundary_pT with prescribed jumping pressure. The modelStructure can be configured as appropriate in such situations, in order to place a momentum balance between a pressure state of the pipe and a non-differentiable boundary condition
(e.g., if the jumping pressure component is connected to port_a, use model structure
ModelStructure.a_vb).
</p>

</html>"));

    annotation (preferredView="info",
                Documentation(info="<html>

</html>"));
  end Types;

  package Dissipation
    "Functions for convective heat transfer and pressure loss characteristics"
      extends Modelica_Icons.BasesPackage;
    import PI = Modelica_Constants.pi;
    import REC = Modelica_Fluid.Dissipation.Utilities.Records;
    import TYP = Modelica_Fluid.Dissipation.Utilities.Types;

    package UsersGuide "User's guide"
      extends Modelica_Icons.Information;
      class GettingStarted "Getting Started"
        extends Modelica_Icons.Information;

        annotation (Documentation(info="<html>
<p>
The <b> Fluid.Dissipation </b> library provides convective heat transfer and pressure loss
(HTPL) correlations for a broad range of energy devices to build up thermohydraulic
energy systems.
</p>
<p>
This section introduces an implementation method for the integration of the provided HTPL
functions by Fluid.Dissipation into own application models. Additionally you can find
ready-to-use application models integrated into Modelica_Fluid as thermohydraulic
framework <a href=\"modelica://Modelica_Fluid.Fittings\"> (see
package Fittings)</a>.<br />
In the following the implementation method is described in 5 steps for a straight pipe as
example. Generally the implementation method can be used for all HTPL correlations
throughout the library in the same manner.
</p>

<h4>Step 1: Use/Create model with missing pressure loss correlation</h4>

<p>
All thermohydraulic systems using pressure loss calculations can be modelled for an <b>
incompressible case </b>, where the pressure loss (DP) is calculated in dependence of a
known mass flow rate (m_flow)
</p>
<pre>
   DP = f(m_flow,...)
</pre>
<p>
or a <b> compressible case </b> , where the mass flow rate (M_FLOW) is calculated in
dependence of a known pressure loss (dp)
</p>
<pre>
   M_FLOW = f(dp,...).
</pre>
<p>
In both cases one target variable (DP for the compressible or M_FLOW for the
incompressible case) is calculated as a function of the corresponding input variable
(m_flow or dp respectively). Both functions for these cases can be found in the library
for the pressure loss device of interest enlarged with a corresponding underscore
describing its intended use (functionname_MFLOW for compressible or functionname_DP for
incompressible calculation).
</p>
<p>
To create a simplified thermohydraulic model, the pressure loss (dp) and the mass flow
rate (M_FLOW) have to be defined as unknown variables and only a functional correlation
between them is still missing. Here the implementation for the compressible case of a
flow model will be explained as example.
</p>
<pre>
   model straightPipe
    //compressible case M_FLOW = f(dp)
     Modelica_SIunits.Pressure dp \"Input pressure loss\";
     Modelica_SIunits.MassFlowRate M_FLOW \"Output mass flow rate\";
   end straightPipe

   equation
  end straightPipe
</pre>

<h4>Step 2: Choose pressure loss <b> function </b> of interest</h4>

<p>
The HTPL correlations are modelled with functions for several devices. The pressure loss
of a straight pipe to be modelled can be found by browsing through the <b>
Fluid.Dissipation </b> library and looking up the function of interest, here:
</p>
<pre>
   Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_MFLOW
</pre>

<p>
This HTPL correlation for the compressible case of a straight pipe have to be dragged and
dropped in the equation section of the <b> equation layer </b> of the model in Step 1.
</p>
<pre>
   model straightPipe
    //compressible case M_FLOW = f(dp)
     Modelica_SIunits.Pressure dp \"Input pressure loss\";
     Modelica_SIunits.MassFlowRate M_FLOW \"Output mass flow rate\";

    equation
    Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_<b>MFLOW</b>
   end straightPipe
</pre>

<h4>Step 3: Choose corresponding pressure loss <b> records </b>
</h4>
<p>
The chosen function in Step 2 still needs its corresponding input values provided by
records. These input records are spitted into one for input parameters (e.g., for
geometry) and one for input variables (e.g., for fluid properties). The name of these
input records are identical with the corresponding function but with the extension <b>
_IN_con </b> for parameters and <b> _IN_var </b> for variables as input. These
corresponding input record for the chosen function have to be dragged and dropped on the
<b> diagram layer </b> of the model in Step 1.
</p>
<pre>
  Input parameter record:
Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall<b>_IN_con</b> IN_con
  Input variable record:
Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall<b>_IN_var</b> IN_var
</pre>
<p>
Now the equation layer of the model in Step 1 should look similar to the following
(without comments and annotation):
</p>
<pre>
  model straightPipe
   ...
   //records
   Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_IN_con <b>IN_con</b>;
   Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_IN_var <b>IN_var</b>;

   equation
   Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_MFLOW
  end straightPipe
</pre>

<h4>Step 4: Build function-record construction </h4>
<p>
Now the input record have to be assigned to the chosen function in the equation layer.
The resulting function-record implementation for the compressible case looks like the
following:
</p>
<pre>
model straightPipe
   ...
  equation
  //compressible case
  M_FLOW = Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_MFLOW(IN_con,IN_var,dp);
end straightPipe
</pre>

<p>
Here the compressible case for the unknown mass flow rate (M_FLOW) is calculated by the
known pressure difference (dp) out of the interfaces of the thermohydraulic framework and
the input records (IN_con,IN_var) provide data like geometry and fluid properties for
example.
</p>
<h4>Step 5: Assign record variables </h4>
<p>
In the last step the variables of the input records for the function have to be assigned.
The assignment of the record variables can either be done directly in the record on the
diagram layer or in the equation layer.
The assignment of the input record in the equation layer results into the following
model:
</p>
<pre>
model straightPipe
 ...
//compressible fluid flow
  //input record

Fluid.Dissipation.Examples.Applications.PressureLoss.BaseClasses.StraightPipe.Overall.Pres
sureLossInput_con
    IN_con(
    d_hyd=d_hyd,
    L=L,
    roughness=roughness,
    K=K);

Fluid.Dissipation.Examples.Applications.PressureLoss.BaseClasses.StraightPipe.Overall.Pres
sureLossInput_var
    IN_var(
    eta=eta,
    rho=rho);
 ...
end straight Pipe;
</pre>

<p>
If the implementation of a HTPL correlation is done in an existing application model, the
unknown variables out of Step 1 (M_FLOW and dp for compressible or DP and m_flow for
incompressible case) have to be adjusted to the model variables (typically the interface
variables). The implementation of HTPL correlation into <b> Modelica_Fluid </b> can be
found for <a href=\"modelica://Modelica_Fluid.Fittings\"> flow
models of several devices</a>.
</p>
 </html>"));
      end GettingStarted;

      class ReleaseNotes "Release notes"
        extends Modelica_Icons.ReleaseNotes;

        annotation (Documentation(info="<html>
<h4>Version 1.0 Beta 4-6, 2010-01-12</h4>

<p>
Fluid.Dissipation was improved for the release as follows:
</p>

<ul>
  <li> Changed structure for input records of all heat transfer and pressure loss
functions:
    <ul>
      <li> Reduced amount of input records for compressible and incompressible functions as well as for their combinational one to improve usability of library.</li>
      <li> Splitting input records of one function into one with parameters (e.g., for geometry) and one with variables (e.g., fluid properties) to ease work of IDE-solver.</li>
    </ul>
  </li>
  <li> Improved Modelica_Fluid application models for available heat transfer and pressure
loss functions:
  <ul>
    <li> Flattened inheritance with one base flow model for all energy devices.</li>
    <li> Implemented smooth state of fluid density and dynamic viscosity for reverse flow.</li>
  </ul>
  </li>
<li> Adaption of complete library due to structure change.</li>
</ul>

<h4>Version 1.0 Beta 3, 2009-07-03</h4>

<p>
Fluid.Dissipation was improved for the release as follows:
</p>

<ul>
<li> Changed flow models structure: <br>
Now that a future feature for the automatic choice of using either a mass flow rate (compressible case) or a pressure loss (incompressible case) function for calculation is supported if implemented by IDE. Due to that no manual selection of a compressible or incompressible calculation in the Modelica_Fluid flow models is possible anymore. Therefore nonlinear equations will be created from the Modelica_Fluid flow models, if the future feature is not supported and the mass flow rate is known at a fluid port instead of the pressure loss.
</li>
<li> Changed structure and amount of records used as input for function calls due to
changed structure of flow model.
</li>
<li> Changed structure of function calls due to changed structure of flow model.
</li>
<li> Finished validation of all available heat transfer and pressure loss functions.
</li>
<li> Included scripts for verification of all available heat transfer and pressure loss functions.
</li>
</ul>

<h4>Version 1.0 Beta 2, 2009-04-22</h4>

<p>
Fluid.Dissipation was improved for the release as follows:
</p>

<ul>
<li> Support of analytical Jacobians at inverse calculation of heat transfer and pressure loss functions.
</li>
<li> Included Modelica_Fluid application models for available heat transfer and pressure loss functions.
</li>
<li> Adaption of complete library to Modelica Standard nomenclature.</li>
</ul>

<h4>Version 1.0 Beta 1, 2008-10-08</h4>

Initial release of Fluid.Dissipation.

</html>"));
      end ReleaseNotes;

    class Contact "Contact"
      extends Modelica_Icons.Contact;
        annotation (Documentation(info="<html>
<dl>
<dt>Maintainer and co-author:</dt>
<dd>Stefan Wischhusen<br />
    XRG Simulation GmbH<br />
    Hamburg, Germany<br />
    email: <A HREF=\"mailto:wischhusen@xrg-simulation.de\">wischhusen@xrg-simulation.de</A></dd>
</dl>
<h4>  Acknowledgements </h4>
<p>
The following people contributed to the Modelica_Fluid.Dissipation library (alphabetical list):
J&ouml;rg Eiden, Ole Engel, Nina Peci, Sven Rutkowski, Thorben Vahlenkamp, Stefan
Wischhusen.
</p>
<p>
The development of the Modelica_Fluid.Dissipation library was founded within the ITEA research
project EuroSysLib-D by German Federal Ministry of Education and Research (promotional
reference 01IS07022B). The project is started in October 2007 and ended in June 2010.
</p>
</html>"));
    end Contact;
      annotation (DocumentationClass=true, Documentation(info="<html>
</html>"));
    end UsersGuide;

    package HeatTransfer "Package for calculation of heat transfer"
    extends Modelica_Icons.VariantsPackage;
      package Channel
      extends Modelica_Icons.VariantsPackage;

        function kc_evenGapLaminar
          "Mean heat transfer coefficient of even gap | laminar flow regime | considering boundary layer development | heat transfer at ONE or BOTH sides | identical and constant wall temperatures"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, Section Gb 6-10

          //input records
          input kc_evenGapLaminar_IN_con IN_con
            "Input record for function kc_evenGapLaminar"
            annotation (Dialog(group="Constant inputs"));
          input kc_evenGapLaminar_IN_var IN_var
            "Input record for function kc_evenGapLaminar"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Convective heat transfer coefficient"
            annotation (Dialog(group="Output"));
          output SI.PrandtlNumber Pr "Prandtl number"
            annotation (Dialog(group="Output"));
          output SI.ReynoldsNumber Re "Reynolds number"
            annotation (Dialog(group="Output"));
          output SI.NusseltNumber Nu "Nusselt number"
            annotation (Dialog(group="Output"));
          output Real failureStatus
            "0== boundary conditions fulfilled | 1== failure >> check if still meaningful results"
            annotation (Dialog(group="Output"));

        protected
          type TYP = Utilities.Types.kc_evenGap;

          Real MIN=Modelica_Constants.eps;

          Real laminar=2200 "Maximum Reynolds number of laminar flow regime";

          SI.Area A_cross=IN_con.s*IN_con.h "Cross sectional area of gap";
          SI.Diameter d_hyd=2*IN_con.s "Hydraulic diameter";

          Real prandtlMax=if IN_con.target == TYP.UndevOne then 10 else if IN_con.target
               == TYP.UndevBoth then 1000 else 0 "Maximum Prandtl number";
          Real prandtlMin=if IN_con.target == TYP.UndevOne or IN_con.target == TYP.UndevBoth then
                    0.1 else 0 "Minimum Prandtl number";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity in gap";

          //failure status
          Real fstatus[2] "Check of expected boundary conditions";

          //Documentation
        algorithm
          Pr := abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));
          Re := max(1, abs(IN_var.rho*velocity*d_hyd/max(MIN, IN_var.eta)));
          kc := kc_evenGapLaminar_KC(IN_con, IN_var);
          Nu := kc*d_hyd/max(MIN, IN_var.lambda);

          //failure status
          fstatus[1] := if Re > laminar then 1 else 0;
          fstatus[2] := if IN_con.target == TYP.UndevOne or IN_con.target == TYP.UndevBoth then
                  if Pr > prandtlMax or Pr < prandtlMin then 1 else 0 else 0;

          failureStatus := 0;
          for i in 1:size(fstatus, 1) loop
            if fstatus[i] == 1 then
              failureStatus := 1;
            end if;
          end for;
        annotation(Inline=false, Documentation(info="<html>
<p>Calculation of the mean convective heat transfer coefficient <b>kc </b>for a laminar fluid flow through an even gap at different fluid flow and heat transfer situations. Note that additionally a failure status is observed in this function to check if the intended boundary conditions are fulfilled.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Channel.kc_evenGapLaminar\">See more information.</a> </p>
</html>"),   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_evenGapLaminar;

        function kc_evenGapLaminar_KC
          "Mean heat transfer coefficient of even gap | laminar flow regime | considering boundary layer development | heat transfer at ONE or BOTH sides | identical and constant wall temperatures"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, Section Gb 6-10

          //input records
          input kc_evenGapLaminar_IN_con IN_con
            "Input record for function kc_evenGapLaminar_KC"
            annotation (Dialog(group="Constant inputs"));
          input kc_evenGapLaminar_IN_var IN_var
            "Input record for function kc_evenGapLaminar_KC"
            annotation (Dialog(group="Variable inputs"));
          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Output for function kc_evenGapLaminar_KC";

        protected
          type TYP = Utilities.Types.kc_evenGap;

          Real MIN=Modelica_Constants.eps;

          SI.Area A_cross=max(MIN, IN_con.s*IN_con.h)
            "Cross sectional area of gap";
          SI.Diameter d_hyd=2*IN_con.s "Hydraulic diameter";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity in gap";
          SI.ReynoldsNumber Re=max(1, IN_var.rho*velocity*d_hyd/max(MIN, IN_var.eta));
          SI.PrandtlNumber Pr=abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));

          //variables for mean Nusselt number
          //SOURCE: p.Gb 7, eq. 36/37
          SI.NusseltNumber Nu_1=if IN_con.target == TYP.DevOne or IN_con.target
               == TYP.UndevOne then 4.861 else if IN_con.target == TYP.DevBoth
               or IN_con.target == TYP.UndevBoth then 7.541 else 0
            "First Nusselt number";
          //SOURCE: p.Gb 7, eq. 38
          SI.NusseltNumber Nu_2=1.841*(Re*Pr*d_hyd/(max(IN_con.L, MIN)))^(1/3)
            "Second Nusselt number";
          //SOURCE: p.Gb 7, eq. 42
          SI.NusseltNumber Nu_3=if IN_con.target == TYP.UndevOne or IN_con.target
               == TYP.UndevBoth then (2/(1 + 22*Pr))^(1/6)*(Re*Pr*d_hyd/(max(
              IN_con.L, MIN)))^(0.5) else 0 "Third mean Nusselt number";
          SI.NusseltNumber Nu=((Nu_1)^3 + (Nu_2)^3 + (Nu_3)^3)^(1/3);

          //Documentation
        algorithm
          kc := Nu*((IN_var.lambda/max(MIN, d_hyd)));
          annotation(Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a laminar fluid flow through an even gap at different fluid flow and heat transfer situations.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Channel.kc_evenGapLaminar\">See more information.</a>
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_evenGapLaminar_KC;

        record kc_evenGapLaminar_IN_con
          "Input record for function kc_evenGapLaminar and kc_evenGapLaminar_KC"

          extends kc_evenGapOverall_IN_con;

          annotation (Documentation(info="<html>
<p>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Channel.kc_evenGapLaminar\"> kc_evenGapLaminar</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Channel.kc_evenGapLaminar_KC\"> kc_evenGapLaminar_KC</a>.</p>
</html>"));
        end kc_evenGapLaminar_IN_con;

        record kc_evenGapLaminar_IN_var
          "Input record for function kc_evenGapLaminar and kc_evenGapLaminar_KC"

          extends kc_evenGapOverall_IN_var;

          annotation (Documentation(info="<html>
<p>
This record is used as <b> input record </b> for the heat transfer function <a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.Channel.kc_evenGapLaminar\"> kc_evenGapLaminar</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Channel.kc_evenGapLaminar_KC\"> kc_evenGapLaminar_KC</a>.</p>
</html>"));
        end kc_evenGapLaminar_IN_var;

        function kc_evenGapOverall
          "Mean heat transfer coefficient of even gap | overall flow regime | considering boundary layer development | heat transfer at ONE or BOTH sides | identical and constant wall temperatures | surface roughness"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, Section Gb 6-10

          import MIN = Modelica_Constants.eps;
          // import SMOOTH = Modelica_Fluid.Dissipation.Utilities.Functions.Stepsmoother;

          //input records
          input kc_evenGapOverall_IN_con IN_con
            "Input record for function kc_evenGapOverall"
            annotation (Dialog(group="Constant inputs"));
          input kc_evenGapOverall_IN_var IN_var
            "Input record for function kc_evenGapOverall"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Convective heat transfer coefficient"
            annotation (Dialog(group="Output"));
          output SI.PrandtlNumber Pr "Prandtl number"
            annotation (Dialog(group="Output"));
          output SI.ReynoldsNumber Re "Reynolds number"
            annotation (Dialog(group="Output"));
          output SI.NusseltNumber Nu "Nusselt number"
            annotation (Dialog(group="Output"));
          output Real failureStatus
            "0== boundary conditions fulfilled | 1== failure >> check if still meaningful results"
            annotation (Dialog(group="Output"));

        protected
          type TYP = Utilities.Types.kc_evenGap;

          Real MIN=Modelica_Constants.eps;

          Real laminar=2200 "Maximum Reynolds number for laminar regime";
          Real turbulent=1e4 "Minimum Reynolds number for turbulent regime";

          SI.Area A_cross=IN_con.s*IN_con.h "Cross sectional area of gap";
          SI.Diameter d_hyd=2*IN_con.s "Hydraulic diameter";

          Real prandtlMax=if IN_con.target == TYP.UndevOne then 10 else if IN_con.target
               == TYP.UndevBoth then 1000 else 0 "Maximum Prandtl number";
          Real prandtlMin=if IN_con.target == TYP.UndevOne or IN_con.target == TYP.UndevBoth then
                    0.1 else 0 "Minimum Prandtl number";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity in gap";

          //failure status
          Real fstatus[2] "Check of expected boundary conditions";

          //Documentation
        algorithm
          Pr := abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));
          Re := max(1e-3, abs(IN_var.rho*velocity*d_hyd/max(MIN, IN_var.eta)));
          kc := kc_evenGapOverall_KC(IN_con, IN_var);
          Nu := kc*d_hyd/max(MIN, IN_var.lambda);

          //failure status
          fstatus[1] := if IN_con.target == TYP.UndevOne or IN_con.target == TYP.UndevBoth then
                  if Pr > prandtlMax or Pr < prandtlMin then 1 else 0 else 0;
          fstatus[2] := if d_hyd/IN_con.L > 1.0 then 1 else 0;

          failureStatus := 0;
          for i in 1:size(fstatus, 1) loop
            if fstatus[i] == 1 then
              failureStatus := 1;
            end if;
          end for;

        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
              Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for an overall fluid flow through an even gap at different fluid flow and heat transfer situations. Note that additionally a failure status is observed in this function to check if the intended boundary conditions are fulfilled. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Channel.kc_evenGapOverall\">See more information.</a>
</p>
</html>"));
        end kc_evenGapOverall;

        function kc_evenGapOverall_KC
          "Mean heat transfer coefficient of even gap | overall flow regime | considering boundary layer development | heat transfer at ONE or BOTH sides | identical and constant wall temperatures | surface roughness"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, Section Gb 6-10

          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

          //input records
          input kc_evenGapOverall_IN_con IN_con
            "Input record for function kc_evenGapOverall_KC"
            annotation (Dialog(group="Constant inputs"));
          input kc_evenGapOverall_IN_var IN_var
            "Input record for function kc_evenGapOverall_KC"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Output for function kc_evenGapOverall_KC";

        protected
          Real MIN=Modelica_Constants.eps;

          Real laminar=2200 "Maximum Reynolds number for laminar regime";
          Real turbulent=1e4 "Minimum Reynolds number for turbulent regime";

          SI.Area A_cross=max(MIN, IN_con.s*IN_con.h)
            "Cross sectional area of gap";
          SI.Diameter d_hyd=2*IN_con.s "Hydraulic diameter";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity in gap";
          SI.ReynoldsNumber Re=max(1, IN_var.rho*velocity*d_hyd/max(MIN, IN_var.eta));
          SI.PrandtlNumber Pr=abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));

          kc_evenGapTurbulent_IN_con IN_con_turb(h=IN_con.h,s=IN_con.s,L=IN_con.L);
        algorithm
          kc := SMOOTH(
                    laminar,
                    turbulent,
                    Re)*Dissipation.HeatTransfer.Channel.kc_evenGapLaminar_KC(
            IN_con, IN_var) + SMOOTH(
                    turbulent,
                    laminar,
                    Re)*Dissipation.HeatTransfer.Channel.kc_evenGapTurbulent_KC(
            IN_con_turb, IN_var);
        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for an overall fluid flow through an even gap at different fluid flow and heat transfer situations. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Channel.kc_evenGapOverall\">See more information.</a>
</p>
</html>"),         smoothOrder(normallyConstant=IN_con) = 2);
        end kc_evenGapOverall_KC;

        record kc_evenGapOverall_IN_con
          "Input record for function kc_evenGapOverall and kc_evenGapOverall_KC"

                //even gap variables
                extends Utilities.Records.HeatTransfer.EvenGap;

                annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Channel.kc_evenGapOverall\"> kc_evenGapOverall</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Channel.kc_evenGapOverall_KC\"> kc_evenGapOverall_KC</a>.
</html>"));
        end kc_evenGapOverall_IN_con;

        record kc_evenGapOverall_IN_var
          "Input record for function kc_evenGapOverall and kc_evenGapOverall_KC"

          //fluid property variables
          extends Utilities.Records.General.FluidProperties;

          //input variable (mass flow rate)
          SI.MassFlowRate m_flow annotation (Dialog(group="Input"));

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.Channel.kc_evenGapOverall\"> kc_evenGapOverall</a> and
<a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.Channel.kc_evenGapOverall_KC\"> kc_evenGapOverall_KC</a>.
</html>"));
        end kc_evenGapOverall_IN_var;

        function kc_evenGapTurbulent
          "Mean heat transfer coefficient of even gap | turbulent flow regime | developed fluid flow | heat transfer at BOTH sides | identical and constant wall temperatures"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, Section Gb 7

          import MIN = Modelica_Constants.eps;

          //input records
          input kc_evenGapTurbulent_IN_con IN_con
            "Input record for function kc_evenGapTurbulent"
            annotation (Dialog(group="Constant inputs"));
          input kc_evenGapTurbulent_IN_var IN_var
            "Input record for function kc_evenGapTurbulent"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Convective heat transfer coefficient"
            annotation (Dialog(group="Output"));
          output SI.PrandtlNumber Pr "Prandtl number"
            annotation (Dialog(group="Output"));
          output SI.ReynoldsNumber Re "Reynolds number"
            annotation (Dialog(group="Output"));
          output SI.NusseltNumber Nu "Nusselt number"
            annotation (Dialog(group="Output"));
          output Real failureStatus
            "0== boundary conditions fulfilled | 1== failure >> check if still meaningful results"
            annotation (Dialog(group="Output"));

        protected
          Real MIN=Modelica_Constants.eps;

          Real prandtlMax=100 "Maximum Prandtl number";
          Real prandtlMin=0.6 "Minimum Prandtl number";
          Real turbulentMax=1e6
            "Maximum Reynolds number for turbulent flow regime";
          Real turbulentMin=3e4
            "Minimum Reynolds number for turbulent flow regime";

          SI.Area A_cross=max(MIN, IN_con.s*IN_con.h)
            "Cross sectional area of gap";
          SI.Diameter d_hyd=2*IN_con.s "Hydraulic diameter";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity in gap";

          //failure status
          Real fstatus[3] "check of expected boundary conditions";

          //Documentation
        algorithm
          Pr := abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));
          Re := max(1, abs(IN_var.rho*velocity*d_hyd/max(MIN, IN_var.eta)));
          kc := kc_evenGapTurbulent_KC(IN_con, IN_var);
          Nu := kc*d_hyd/max(MIN, IN_var.lambda);

          //failure status
          fstatus[1] := if Re > turbulentMax or Re < turbulentMin then 1 else 0;
          fstatus[2] := if Pr > prandtlMax or Pr < prandtlMin then 1 else 0;
          fstatus[3] := if d_hyd/max(MIN, IN_con.L) > 1.0 then 1 else 0;

          failureStatus := 0;
          for i in 1:size(fstatus, 1) loop
            if fstatus[i] == 1 then
              failureStatus := 1;
            end if;
          end for;
        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a developed turbulent fluid flow through an even gap at heat transfer from both sides. Note that additionally a failure status is observed in this function to check if the intended boundary conditions are fulfilled. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Channel.kc_evenGapTurbulent\">See more information.</a>
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_evenGapTurbulent;

        function kc_evenGapTurbulent_KC
          "Mean heat transfer coefficient of even gap | turbulent flow regime | developed fluid flow | heat transfer at BOTH sides | identical and constant wall temperatures"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, Section Gb 7

          //input records
          input kc_evenGapTurbulent_IN_con IN_con
            "Input record for function kc_evenGapTurbulent_KC"
            annotation (Dialog(group="Constant inputs"));
          input kc_evenGapTurbulent_IN_var IN_var
            "Input record for function kc_evenGapTurbulent_KC"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Output for function kc_evenGapTurbulent_KC";

        protected
          Real MIN=Modelica_Constants.eps;

          SI.Area A_cross=max(MIN, IN_con.s*IN_con.h)
            "Cross sectional area of gap";
          SI.Diameter d_hyd=2*IN_con.s "Hydraulic diameter";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity in gap";
          SI.ReynoldsNumber Re=max(2.6, IN_var.rho*velocity*d_hyd/max(MIN,
              IN_var.eta));
          SI.PrandtlNumber Pr=abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));

          //SOURCE: p.Ga 5, eq. 27
          Real zeta=1/max(MIN, 1.8*Modelica_Math.log10(abs(Re)) - 1.5)^2
            "Pressure loss coefficient";

          //SOURCE: p.Gb 5, eq. 26
          //assumption according to Gb 7, sec. 2.4
          SI.NusseltNumber Nu=abs((zeta/8)*Re*Pr/(1 + 12.7*(zeta/8)^0.5*(Pr^(2/
              3) - 1))*(1 + (d_hyd/max(MIN, IN_con.L))^(2/3)));

          //Documentation
        algorithm
          kc := Nu*(IN_var.lambda/max(MIN, d_hyd));

        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a developed turbulent fluid flow through an even gap at heat transfer from both sides. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Channel.kc_evenGapTurbulent\">See more information.</a>
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_evenGapTurbulent_KC;

        record kc_evenGapTurbulent_IN_con
          "Input record for function kc_evenGapTurbulent and kc_evenGapTurbulent_KC"

          extends kc_evenGapOverall_IN_con(final target=Utilities.Types.kc_evenGap.DevBoth);

          annotation (Documentation(info="<html>
<p>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Channel.kc_evenGapTurbulent\"> kc_evenGapTurbulent</a> and
<a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.Channel.kc_evenGapTurbulent_KC\"> kc_evenGapTurbulent_KC</a>.
</p>
</html>"));
        end kc_evenGapTurbulent_IN_con;

        record kc_evenGapTurbulent_IN_var
          "Input record for function kc_evenGapTurbulent and kc_evenGapTurbulent_KC"

          extends kc_evenGapOverall_IN_var;

          annotation (Documentation(info="<html>
<p>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Channel.kc_evenGapTurbulent\"> kc_evenGapTurbulent</a> and
<a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.Channel.kc_evenGapTurbulent_KC\"> kc_evenGapTurbulent_KC</a>.
</p>
</html>"));
        end kc_evenGapTurbulent_IN_var;
      annotation (preferredView="info", Documentation(info="<html>
<h4>Even gap</h4>
<h5>Laminar flow</h5>
<p>Calculation of the mean convective heat transfer coefficient <b>kc </b>for a laminar fluid flow through an even gap at different fluid flow and heat transfer situations. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Channel.kc_evenGapLaminar\">See more information.</a> </p>

<h5>Turbulent flow</h5>
<p>Calculation of the mean convective heat transfer coefficient <b>kc </b>for a laminar fluid flow through an even gap at different fluid flow and heat transfer situations. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Channel.kc_evenGapTurbulent\">See more information.</a></p>

<h5>Overall flow</h5>
<p>Calculation of the mean convective heat transfer coefficient <b>kc </b>for a laminar fluid flow through an even gap at different fluid flow and heat transfer situations. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Channel.kc_evenGapOverall\">See more information.</a></p>
</html>"));
      end Channel;

      package General
      extends Modelica_Icons.VariantsPackage;
        function kc_approxForcedConvection
          "Mean convective heat transfer coefficient for forced convection | approximation | turbulent regime | hydrodynamically developed fluid flow"
          extends Modelica_Icons.Function;
          //SOURCE: A Bejan and A.D. Kraus. Heat Transfer handbook.John Wiley & Sons, 2nd edition, 2003. (p.424 ff)
          //Notation of equations according to SOURCE

          //input records
          input kc_approxForcedConvection_IN_con IN_con
            "Input record for function kc_approxForcedConvection"
            annotation (Dialog(group="Constant inputs"));
          input kc_approxForcedConvection_IN_var IN_var
            "Input record for function kc_approxForcedConvection"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Convective heat transfer coefficient"
            annotation (Dialog(group="Output"));
          output SI.PrandtlNumber Pr "Prandtl number"
            annotation (Dialog(group="Output"));
          output SI.ReynoldsNumber Re "Reynolds number"
            annotation (Dialog(group="Output"));
          output SI.NusseltNumber Nu "Nusselt number"
            annotation (Dialog(group="Output"));
          output Real failureStatus
            "0== boundary conditions fulfilled | 1== failure >> check if still meaningful results"
            annotation (Dialog(group="Output"));

        protected
          type TYP = Utilities.Types.kc_general;

          Real MIN=Modelica_Constants.eps;

          Real prandtlMax[3]={120,16700,500} "Maximum Prandtl number";
          Real prandtlMin[3]={0.7,0.7,1.5} "Minimum Prandtl number";
          Real reynoldsMax[3]={1.24e5,1e6,1e6} "Maximum Reynolds number";
          Real reynoldsMin[3]={2500,1e4,3e3} "Minimum Reynolds number";

          SI.Diameter d_hyd=max(MIN, 4*IN_con.A_cross/max(MIN, IN_con.perimeter))
            "Hydraulic diameter";

          //failure status
          Real fstatus[2] "Check of expected boundary conditions";

        algorithm
          Pr := Utilities.Functions.General.PrandtlNumber(
                    IN_var.cp,
                    IN_var.eta,
                    IN_var.lambda);
          Re := max(1, Utilities.Functions.General.ReynoldsNumber(
                    IN_con.A_cross,
                    IN_con.perimeter,
                    IN_var.rho,
                    IN_var.eta,
                    abs(IN_var.m_flow))) "Reynolds number";
          kc := kc_approxForcedConvection_KC(IN_con, IN_var);
          Nu := kc*d_hyd/max(MIN, IN_var.lambda);

          //failure status
          fstatus[1] := if IN_con.target == TYP.Rough then if Pr > prandtlMax[1] or Pr
             < prandtlMin[1] then 1 else 0 else if IN_con.target == TYP.Middle then if
            Pr > prandtlMax[2] or Pr < prandtlMin[2] then 1 else 0 else if IN_con.target
             == TYP.Finest then if Pr > prandtlMax[3] or Pr < prandtlMin[3] then 1 else
                  0 else 0;
          fstatus[2] := if IN_con.target == TYP.Rough then if Re > reynoldsMax[1] or Re
             < reynoldsMin[1] then 1 else 0 else if IN_con.target == TYP.Middle then
            if Re > reynoldsMax[2] or Re < reynoldsMin[2] then 1 else 0 else if IN_con.target
             == TYP.Finest then if Re > reynoldsMax[3] or Re < reynoldsMin[3] then 1 else
                  0 else 0;

          failureStatus := 0;
          for i in 1:size(fstatus, 1) loop
            if fstatus[i] == 1 then
              failureStatus := 1;
            end if;
          end for;

        annotation (Inline=false, Documentation(info="<html>
<p>
Approximate calculation of the mean convective heat transfer coefficient <b> kc </b> for forced convection with a fully developed fluid flow in a turbulent regime.
</p>

<p>
A detailed documentation for this convective heat transfer calculation can be found in its underlying function
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.General.kc_approxForcedConvection_KC\">kc_approxForcedConvection_KC</a> .
Note that additionally a failure status is observed in this function to check if the intended boundary conditions are fulfilled.  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.General.kc_approxForcedConvection\">See more information</a> .
</p>
</html>"),            smoothOrder(normallyConstant=IN_con) = 2);
        end kc_approxForcedConvection;

        function kc_approxForcedConvection_KC
          "Mean convective heat transfer coefficient for forced convection | approximation | turbulent regime | hydrodynamically developed fluid flow"
          extends Modelica_Icons.Function;
          //SOURCE: A Bejan and A.D. Kraus. Heat Transfer handbook.John Wiley & Sons, 2nd edition, 2003. (p.424 ff)
          //Notation of equations according to SOURCE

          //type =
          //input records
          input kc_approxForcedConvection_IN_con IN_con
            "Input record for function kc_approxForcedConvection_KC"
            annotation (Dialog(group="Constant inputs"));
          input kc_approxForcedConvection_IN_var IN_var
            "Input record for function kc_approxForcedConvection_KC"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Output for function kc_approxForcedConvection_KC";

        protected
          type TYP = Utilities.Types.kc_general;

          Real MIN=Modelica_Constants.eps;

          SI.Diameter d_hyd=max(MIN, 4*IN_con.A_cross/max(MIN, IN_con.perimeter))
            "Hydraulic diameter";

          SI.PrandtlNumber Pr=max(MIN, abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda)))
            "Prandtl number";
          SI.ReynoldsNumber Re=max(1, 4*abs(IN_var.m_flow)/max(MIN, IN_con.perimeter
              *IN_var.eta)) "Reynolds number";

        algorithm
          kc := IN_var.lambda/d_hyd*(if IN_con.target == TYP.Rough then 0.023*Re^(4/5)*
            Pr^IN_con.exp_Pr else if IN_con.target == TYP.Middle then 0.023*Re^(4/5)*Pr
            ^(1/3)*(IN_var.eta/IN_var.eta_wall)^0.14 else if IN_con.target == TYP.Finest and Pr
             <= 1.5 then 0.0214*max(1, abs(Re^0.8 - 100))*Pr^0.4 else if IN_con.target
             == TYP.Finest then 0.012*max(1, abs(Re^0.87 - 280))*Pr^0.4 else 0);

          //Documentation

        annotation (Inline=false, Documentation(info="<html>
<p>
Approximate calculation of the mean convective heat transfer coefficient <b> kc </b> for forced convection with a fully developed fluid flow in a turbulent regime.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.General.kc_approxForcedConvection\">See more information</a> .
</p>
</html>"),         smoothOrder(normallyConstant=IN_con) = 2);
        end kc_approxForcedConvection_KC;

        record kc_approxForcedConvection_IN_con
          "Input record for function kc_approxForcedConvection and kc_approxForcedConvection_KC"
          //generic variables
          extends Utilities.Records.HeatTransfer.General;
          parameter Real exp_Pr=0.4
            "Exponent for Prandtl number w.r.t. Dittus/Boelter | 0.4 for heating | 0.3 for cooling"
            annotation (Dialog(group="Generic variables",enable=if target == 1 then
                  true else false));

        annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.General.kc_approxForcedConvection\"> kc_approxForcedConvection</a> and
<a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.General.kc_approxForcedConvection_KC\"> kc_approxForcedConvection_KC</a>.
</html>"));
        end kc_approxForcedConvection_IN_con;

        record kc_approxForcedConvection_IN_var
          "Input record for function kc_approxForcedConvection and kc_approxForcedConvection_KC"
          //fluid property variables
          extends Utilities.Records.General.FluidProperties;
          SI.DynamicViscosity eta_wall
            "Dynamic viscosity of fluid at wall temperature" annotation (Dialog(
                group="Fluid properties", enable=if target == 2 then true else
                  false));

          //input variable (mass flow rate)
          SI.MassFlowRate m_flow annotation (Dialog(group="Input"));

        annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.General.kc_approxForcedConvection\"> kc_approxForcedConvection</a> and
<a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.General.kc_approxForcedConvection_KC\"> kc_approxForcedConvection_KC</a>.
</html>"));
        end kc_approxForcedConvection_IN_var;
      annotation (preferredView="info", Documentation(info="<html>
<h4>General heat transfer</h4>
<h5>Approximated forced convection</h5>
<p>Approximate calculation of the mean convective heat transfer coefficient <b> kc </b> for forced convection with a fully developed fluid flow in a turbulent regime. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.General.kc_approxForcedConvection\">See more information.</a> </p>
</html>"));
      end General;

      package HeatExchanger
      extends Modelica_Icons.VariantsPackage;
        function kc_flatTube
          extends Modelica_Icons.Function;
          //SOURCE: A.M. Jacobi, Y. Park, D. Tafti, X. Zhang. AN ASSESSMENT OF THE STATE OF THE ART, AND POTENTIAL DESIGN IMPROVEMENTS, FOR FLAT-TUBE HEAT EXCHANGERS IN AIR CONDITIONING AND REFRIGERATION APPLICATIONS - PHASE I

          //icon

          //input records
          input kc_flatTube_IN_con IN_con
            "Input record for function kc_flatTube"
            annotation (Dialog(group="Constant inputs"));
          input kc_flatTube_IN_var IN_var
            "Input record for function kc_flatTube"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Convective heat transfer coefficient"
            annotation (Dialog(group="Output"));
          output SI.PrandtlNumber Pr "Prandtl number"
            annotation (Dialog(group="Output"));
          output SI.ReynoldsNumber Re "Reynolds number"
            annotation (Dialog(group="Output"));
          output SI.NusseltNumber Nu "Nusselt number"
            annotation (Dialog(group="Output"));
          output Real failureStatus
            "0== boundary conditions fulfilled | 1== failure >> check if still meaningful results"
            annotation (Dialog(group="Output"));

        protected
          type TYP =
              Utilities.Types.HTXGeometry_flatTubes;

          SI.Area A_c=if IN_con.geometry == TYP.LouverFin then IN_con.A_fr*((
              IN_con.F_l - IN_con.delta_f)*(IN_con.F_p - IN_con.delta_f)/((
              IN_con.F_l + IN_con.D_m)*IN_con.F_p)) else if IN_con.geometry ==
              TYP.RectangularFin then IN_con.A_fr*(h*s/((h + t + IN_con.D_m)*(s
               + t))) else 0 "Minimum flow cross-sectional area";
          SI.Length h=if IN_con.geometry == TYP.RectangularFin then IN_con.D_h*
              (1 + IN_con.alpha)/(2*IN_con.alpha) else 0 "Free flow height";
          SI.Length l=if IN_con.geometry == TYP.RectangularFin then t/IN_con.delta
               else 0 "Fin length";
          SI.Length s=if IN_con.geometry == TYP.RectangularFin then h*IN_con.alpha
               else 0 "Lateral fin spacing (free flow width)";
          SI.Length t=if IN_con.geometry == TYP.RectangularFin then s*IN_con.gamma
               else 0 "Fin thickness";
        algorithm
          kc := kc_flatTube_KC(IN_con, IN_var);
          Pr := abs(IN_var.eta*IN_var.cp/IN_var.lambda);

          if IN_con.geometry == TYP.LouverFin then
            Re := max(1e-3, abs(IN_var.m_flow)*IN_con.L_p/(IN_var.eta*A_c));
            Nu := max(1e-3, kc*IN_con.L_p/IN_var.lambda);
          elseif IN_con.geometry == TYP.RectangularFin then
            Re := max(1e-3, abs(IN_var.m_flow)*IN_con.D_h/(IN_var.eta*A_c));
            Nu := max(1e-3, kc*IN_con.D_h/IN_var.lambda);
          end if;

          failureStatus := if IN_con.geometry == TYP.LouverFin then if Re < 100 or Re
             > 3000 then 1 else 0 else if IN_con.geometry == TYP.RectangularFin then
            if Re < 300 or Re > 5000 then 1 else 0 else 0;

        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for the air-side heat transfer of heat exchangers with flat tubes and several fin geometries. Note that additionally a failure status is observed in this function to check if the intended boundary conditions are fulfilled.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.HeatExchanger.kc_flatTube\">See more information</a> .
</p>

</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_flatTube;

        function kc_flatTube_KC
          extends Modelica_Icons.Function;
          //SOURCE: A.M. Jacobi, Y. Park, D. Tafti, X. Zhang. AN ASSESSMENT OF THE STATE OF THE ART, AND POTENTIAL DESIGN IMPROVEMENTS, FOR FLAT-TUBE HEAT EXCHANGERS IN AIR CONDITIONING AND REFRIGERATION APPLICATIONS - PHASE I

          //input records
          input kc_flatTube_IN_con IN_con
            "Input record for function kc_flatTube_KC"
            annotation (Dialog(group="Constant inputs"));
          input kc_flatTube_IN_var IN_var
            "Input record for function kc_flatTube_KC"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Output for function kc_flatTubePlateFin_KC";

        protected
          type TYP =
              Utilities.Types.HTXGeometry_flatTubes;

          Real MIN=Modelica_Constants.eps;
          Real Phi=IN_con.Phi*180/PI "Louver angle";

          SI.ReynoldsNumber Re_Dh=max(1e-3, abs(IN_var.m_flow)*IN_con.D_h/(
              IN_var.eta*A_c)) "Reynolds number based on hydraulic diameter";
          SI.ReynoldsNumber Re_Lp=max(1e-3, abs(IN_var.m_flow)*IN_con.L_p/(
              IN_var.eta*A_c)) "Reynolds number based on louver pitch";
          SI.PrandtlNumber Pr=IN_var.eta*IN_var.cp/IN_var.lambda
            "Prandtl number";
          Real j "Colburn j faktor";

          SI.Area A_c=if IN_con.geometry == TYP.LouverFin then IN_con.A_fr*((
              IN_con.F_l - IN_con.delta_f)*(IN_con.F_p - IN_con.delta_f)/((
              IN_con.F_l + IN_con.D_m)*IN_con.F_p)) else if IN_con.geometry ==
              TYP.RectangularFin then IN_con.A_fr*(h*s/((h + t + IN_con.D_m)*(s
               + t))) else 0 "Minimum flow cross-sectional area";
          SI.Length h=if IN_con.geometry == TYP.RectangularFin then IN_con.D_h*
              (1 + IN_con.alpha)/(2*IN_con.alpha) else 0 "Free flow height";
          SI.Length l=if IN_con.geometry == TYP.RectangularFin then t/IN_con.delta
               else 0 "Fin length";
          SI.Length s=if IN_con.geometry == TYP.RectangularFin then h*IN_con.alpha
               else 0 "Lateral fin spacing (free flow width)";
          SI.Length t=if IN_con.geometry == TYP.RectangularFin then s*IN_con.gamma
               else 0 "Fin thickness";

        algorithm
          if IN_con.geometry == TYP.LouverFin then
            j := Re_Lp^(-0.49)*(Phi/90)^0.27*(IN_con.F_p/IN_con.L_p)^(-0.14)*(IN_con.F_l
              /IN_con.L_p)^(-0.29)*(IN_con.T_d/IN_con.L_p)^(-0.23)*(IN_con.L_l/IN_con.L_p)
              ^0.68*(IN_con.T_p/IN_con.L_p)^(-0.28)*(IN_con.delta_f/IN_con.L_p)^(-0.05);
            kc := j*(Re_Lp*Pr^(1/3)*IN_var.lambda/IN_con.L_p);

          elseif IN_con.geometry == TYP.RectangularFin then
            j := 0.6522*Re_Dh^(-0.5403)*(s/h)^(-0.1541)*(t/l)^0.1499*(t/s)^(-0.0678)*(1
               + 5.269e-5*Re_Dh^1.340*(s/h)^0.504*(t/l)^0.456*(t/s)^(-1.055))^0.1;
            kc := j*(Re_Dh*Pr^(1/3)*IN_var.lambda/IN_con.D_h);

          else

          end if;

        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for the air-side heat transfer of heat exchangers with flat tubes and several fin geometries.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.HeatExchanger.kc_flatTube\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_flatTube_KC;

        record kc_flatTube_IN_con
          "Input record for function kc_flatTube and kc_flatTube_KC"
          extends Modelica_Icons.Record;

        protected
          type TYP =
              Utilities.Types.HTXGeometry_flatTubes;

        public
          Utilities.Types.HTXGeometry_flatTubes geometry=Dissipation.Utilities.Types.HTXGeometry_flatTubes.LouverFin
            "Choice of fin geometry" annotation (Dialog(group="HeatExchanger"));

          SI.Area A_fr=0 "Frontal area"
            annotation (Dialog(group="HeatExchanger"));
          SI.Length D_h=0 "Hydraulic diameter" annotation (Dialog(group=
                  "HeatExchanger", enable=if geometry == 2 then true else false));
          SI.Length D_m=0 "Major tube diameter for flat tube"
            annotation (Dialog(group="HeatExchanger"));
          SI.Length F_l=0 "Fin length" annotation (Dialog(group="HeatExchanger",
                enable=if geometry == 1 then true else false));
          SI.Length F_p=0 "Fin pitch, fin spacing + fin thickness" annotation (
              Dialog(group="HeatExchanger", enable=if geometry == 1 then true
                   else false));
          SI.Length L_l=0 "Louver length" annotation (Dialog(group=
                  "HeatExchanger", enable=if geometry == 1 then true else false));
          SI.Length L_p=0 "Louver pitch" annotation (Dialog(group=
                  "HeatExchanger", enable=if geometry == 1 then true else false));
          SI.Length T_d=0 "Tube depth" annotation (Dialog(group="HeatExchanger",
                enable=if geometry == 1 then true else false));
          SI.Length T_p=0 "Tube pitch" annotation (Dialog(group="HeatExchanger",
                enable=if geometry == 1 then true else false));

          Real alpha=0 "Lateral fin spacing (s) / free flow height (h)" annotation (
              Dialog(group="HeatExchanger", enable=if geometry == 2 then true else
                  false));
          Real gamma=0 "Fin thickness (t) / lateral fin spacing (s)" annotation (Dialog(
                group="HeatExchanger", enable=if geometry == 2 then true else false));
          Real delta=0 "Fin thickness (t) / Fin length (l)" annotation (Dialog(group=
                  "HeatExchanger", enable=if geometry == 2 then true else false));
          SI.Length delta_f=0 "Fin thickness" annotation (Dialog(group=
                  "HeatExchanger", enable=if geometry == 1 then true else false));
          SI.Angle Phi=0 "Louver angle" annotation (Dialog(group=
                  "HeatExchanger", enable=if geometry == 1 then true else false));

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HeatExchanger.kc_flatTube\"> kc_flatTube</a> and
<a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HeatExchanger.kc_flatTube_KC\"> kc_flatTube_KC</a>.
</html>"));

        end kc_flatTube_IN_con;

        record kc_flatTube_IN_var
          "Input record for function kc_flatTube and kc_flatTube_KC"
          extends Modelica_Icons.Record;

          //fluid property variables
          extends Utilities.Records.General.FluidProperties;

          //input variable (mass flow rate)
          SI.MassFlowRate m_flow annotation (Dialog(group="Input"));

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.HeatExchanger.kc_flatTube\"> kc_flatTube</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.HeatExchanger.kc_flatTube_KC\"> kc_flatTube_KC</a>.
</html>"));

        end kc_flatTube_IN_var;

        function kc_roundTube
          extends Modelica_Icons.Function;
          //SOURCE: A.M. Jacobi, Y. Park, D. Tafti, X. Zhang. AN ASSESSMENT OF THE STATE OF THE ART, AND POTENTIAL DESIGN IMPROVEMENTS, FOR FLAT-TUBE HEAT EXCHANGERS IN AIR CONDITIONING AND REFRIGERATION APPLICATIONS - PHASE I

          //input records
          input kc_roundTube_IN_con IN_con
            "Input record for function kc_roundTube"
            annotation (Dialog(group="Constant inputs"));
          input kc_roundTube_IN_var IN_var
            "Input record for function kc_roundTube"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Convective heat transfer coefficient"
            annotation (Dialog(group="Output"));
          output SI.PrandtlNumber Pr "Prandtl number"
            annotation (Dialog(group="Output"));
          output SI.ReynoldsNumber Re "Reynolds number"
            annotation (Dialog(group="Output"));
          output SI.NusseltNumber Nu "Nusselt number"
            annotation (Dialog(group="Output"));
          output Real failureStatus
            "0== boundary conditions fulfilled | 1== failure >> check if still meaningful results"
            annotation (Dialog(group="Output"));

        protected
          type TYP =
              Utilities.Types.HTXGeometry_roundTubes;

          SI.Area A_c=IN_con.A_fr*((IN_con.F_p*IN_con.P_t - IN_con.F_p*IN_con.D_c
               - (IN_con.P_t - IN_con.D_c)*IN_con.delta_f)/(IN_con.F_p*IN_con.P_t))
            "Minimum flow cross-sectional area";
          SI.Area A_tot=if IN_con.geometry == TYP.LouverFin then IN_con.A_fr*((
              IN_con.N*PI*IN_con.D_c*(IN_con.F_p - IN_con.delta_f) + 2*(IN_con.P_t
              *IN_con.L - IN_con.N*PI*IN_con.D_c^2/4))/(IN_con.P_t*IN_con.F_p))
               else 0 "Total heat transfer area";
          SI.Length D_h=if IN_con.geometry == TYP.LouverFin then 4*A_c*IN_con.L
              /A_tot else 0 "Hydraulic diameter";

          /*SI.Length D_h=
    if IN_con.geometry==2 then
      4*A_c/(IN_con.A_fr*(2*(IN_con.P_t-IN_con.D_c+IN_con.F_p)/(IN_con.F_p*(IN_con.P_t-IN_con.D_c)))) else
      0 "Hydraulic diameter";*/

        algorithm
          kc := kc_roundTube_KC(IN_con, IN_var);
          Pr := abs(IN_var.eta*IN_var.cp/IN_var.lambda);

          if IN_con.geometry == TYP.PlainFin or IN_con.geometry == TYP.LouverFin or
              IN_con.geometry == TYP.SlitFin or IN_con.geometry == TYP.WavyFin then
            Re := max(1e-3, abs(IN_var.m_flow)*IN_con.D_c/(IN_var.eta*A_c));
            Nu := max(1e-3, kc*IN_con.D_c/IN_var.lambda);
          end if;

          failureStatus := if IN_con.geometry == TYP.PlainFin then if Re < 300 or Re >
            8000 then 1 else 0 else if IN_con.geometry == TYP.LouverFin then if Re <
            300 or Re > 7000 then 1 else 0 else if IN_con.geometry == TYP.SlitFin then
            if Re < 400 or Re > 7000 then 1 else 0 else if IN_con.geometry == TYP.WavyFin then
                  if Re < 350 or Re > 7000 then 1 else 0 else 0;

        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for the air-side heat transfer of heat exchangers with round tubes and several fin geometries. Note that additionally a failure status is observed in this function to check if the intended boundary conditions are fulfilled.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.HeatExchanger.kc_roundTube\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_roundTube;

        function kc_roundTube_KC
          extends Modelica_Icons.Function;
          //SOURCE: A.M. Jacobi, Y. Park, D. Tafti, X. Zhang. AN ASSESSMENT OF THE STATE OF THE ART, AND POTENTIAL DESIGN IMPROVEMENTS, FOR FLAT-TUBE HEAT EXCHANGERS IN AIR CONDITIONING AND REFRIGERATION APPLICATIONS - PHASE I

          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

          //input records
          input kc_roundTube_IN_con IN_con
            "Input record for function kc_roundTube_KC"
            annotation (Dialog(group="Constant inputs"));
          input kc_roundTube_IN_var IN_var
            "Input record for function kc_roundTube_KC"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Output for function kc_roundTube_KC";

        protected
          type TYP =
              Utilities.Types.HTXGeometry_roundTubes;

          Real MIN=Modelica_Constants.eps;

          SI.ReynoldsNumber Re_Dc=max(1e-3, abs(IN_var.m_flow)*IN_con.D_c/(
              IN_var.eta*A_c)) "Reynolds number based on fin collar diameter";
          SI.PrandtlNumber Pr=IN_var.eta*IN_var.cp/IN_var.lambda
            "Prandtl number";
          Real j "Colburn j faktor";

          SI.Area A_c=IN_con.A_fr*((IN_con.F_p*IN_con.P_t - IN_con.F_p*IN_con.D_c
               - (IN_con.P_t - IN_con.D_c)*IN_con.delta_f)/(IN_con.F_p*IN_con.P_t))
            "Minimum flow cross-sectional area";
          SI.Area A_tot=if IN_con.geometry == TYP.LouverFin then IN_con.A_fr*((
              IN_con.N*PI*IN_con.D_c*(IN_con.F_p - IN_con.delta_f) + 2*(IN_con.P_t
              *IN_con.L - IN_con.N*PI*IN_con.D_c^2/4))/(IN_con.P_t*IN_con.F_p))
               else 0 "Total heat transfer area";
          SI.Length D_h=if IN_con.geometry == TYP.LouverFin then 4*A_c*IN_con.L
              /A_tot else 0 "Hydraulic diameter";

          /*SI.Length D_h=
    if IN_con.geometry==2 then
      4*A_c/(IN_con.A_fr*(2*(IN_con.P_t-IN_con.D_c+IN_con.F_p-IN_con.delta_f)/(IN_con.F_p*IN_con.P_t))) else
      0 "Hydraulic diameter";*/

          Real J1=0 "Exponent for computation of Colburn j faktor";
          Real J2=0 "Exponent for computation of Colburn j faktor";
          Real J3=0 "Exponent for computation of Colburn j faktor";
          Real J4=0 "Exponent for computation of Colburn j faktor";
          Real J5=0 "Exponent for computation of Colburn j faktor";
          Real J6=0 "Exponent for computation of Colburn j faktor";
          Real J7=0 "Exponent for computation of Colburn j faktor";
          Real J8=0 "Exponent for computation of Colburn j faktor";

        algorithm
          if IN_con.geometry == TYP.PlainFin then
            j := 0.991*(2.24*Re_Dc^(-0.092)*(IN_con.N/4)^(-0.031))^(0.607*(4 - IN_con.N))
              *(0.14*Re_Dc^(-0.328)*(IN_con.P_t/IN_con.P_l)^(-0.502)*(IN_con.F_p/IN_con.D_c)
              ^(0.0312))*(2.55*(IN_con.P_l/IN_con.D_c)^(-1.28));
            kc := j*(Re_Dc*Pr^(1/3)*IN_var.lambda/IN_con.D_c);

          elseif IN_con.geometry == TYP.LouverFin then
            if Re_Dc < 900 then
              J1 := -0.991 - 0.1055*(IN_con.P_l/IN_con.P_t)^3.1*log(IN_con.L_h/IN_con.L_p);
              J2 := -0.7344 + 2.1059*IN_con.N^0.55/(log(Re_Dc) - 3.2);
              J3 := 0.08485*(IN_con.P_l/IN_con.P_t)^(-4.4)*IN_con.N^(-0.68);
              J4 := -0.1741*log(IN_con.N);
              j := 14.3117*Re_Dc^J1*(IN_con.F_p/IN_con.D_c)^J2*(IN_con.L_h/IN_con.L_p)^
                J3*(IN_con.F_p/IN_con.P_l)^J4*(IN_con.P_l/IN_con.P_t)^(-1.724);
            elseif Re_Dc > 1100 then
              J5 := -0.6027 + 0.02593*(IN_con.P_l/D_h)^0.52*IN_con.N^(-0.5)*log(IN_con.L_h
                /IN_con.L_p);
              J6 := -0.4776 + 0.40774*IN_con.N^0.7/(log(Re_Dc) - 4.4);
              J7 := -0.58655*(IN_con.F_p/D_h)^2.3*(IN_con.P_l/IN_con.P_t)^(-1.6)*IN_con.N
                ^(-0.65);
              J8 := 0.0814*(log(Re_Dc) - 3);
              j := 1.1373*Re_Dc^J5*(IN_con.F_p/IN_con.P_l)^J6*(IN_con.L_h/IN_con.L_p)^
                J7*(IN_con.P_l/IN_con.P_t)^J8*IN_con.N^0.3545;
            else
              J1 := -0.991 - 0.1055*(IN_con.P_l/IN_con.P_t)^3.1*log(IN_con.L_h/IN_con.L_p);
              J2 := -0.7344 + 2.1059*IN_con.N^0.55/(log(Re_Dc) - 3.2);
              J3 := 0.08485*(IN_con.P_l/IN_con.P_t)^(-4.4)*IN_con.N^(-0.68);
              J4 := -0.1741*log(IN_con.N);
              J5 := -0.6027 + 0.02593*(IN_con.P_l/D_h)^0.52*IN_con.N^(-0.5)*log(IN_con.L_h
                /IN_con.L_p);
              J6 := -0.4776 + 0.40774*IN_con.N^0.7/(log(Re_Dc) - 4.4);
              J7 := -0.58655*(IN_con.F_p/D_h)^2.3*(IN_con.P_l/IN_con.P_t)^(-1.6)*IN_con.N
                ^(-0.65);
              J8 := 0.0814*(log(Re_Dc) - 3);
              j := SMOOTH(
                        900,
                        1100,
                        Re_Dc)*(14.3117*Re_Dc^J1*(IN_con.F_p/IN_con.D_c)^J2*(
                IN_con.L_h/IN_con.L_p)^J3*(IN_con.F_p/IN_con.P_l)^J4*(IN_con.P_l
                /IN_con.P_t)^(-1.724)) + SMOOTH(
                        1100,
                        900,
                        Re_Dc)*(1.1373*Re_Dc^J5*(IN_con.F_p/IN_con.P_l)^J6*(
                IN_con.L_h/IN_con.L_p)^J7*(IN_con.P_l/IN_con.P_t)^J8*IN_con.N^
                0.3545);
            end if;
            kc := SMOOTH(
                      100,
                      0,
                      Re_Dc)*j*(Re_Dc*Pr^(1/3)*IN_var.lambda/IN_con.D_c);

          elseif IN_con.geometry == TYP.SlitFin then
            J1 := -0.674 + 0.1316*IN_con.N/log(Re_Dc) - 0.3769*IN_con.F_p/IN_con.D_c -
              1.8857*IN_con.N/Re_Dc;
            J2 := -0.0178 + 0.996*IN_con.N/log(Re_Dc) + 26.7*IN_con.N/Re_Dc;
            J3 := 1.865 + 1244.03*IN_con.F_p/(Re_Dc*IN_con.D_c) - 14.37/log(Re_Dc);
            j := 1.6409*Re_Dc^J1*(IN_con.S_p/IN_con.S_h)^1.16*(IN_con.P_t/IN_con.P_l)^
              1.37*(IN_con.F_p/IN_con.D_c)^J2*IN_con.N^J3;
            kc := j*(Re_Dc*Pr^(1/3)*IN_var.lambda/IN_con.D_c);

          elseif IN_con.geometry == TYP.WavyFin then
            if Re_Dc < exp(2.921) then
              j := 1.201/(log(exp(2.921)^(A_c/IN_con.A_fr)))^2.921;
              kc := j*(exp(2.921)*Pr^(1/3)*IN_var.lambda/IN_con.D_c);
            else
              j := 1.201/((log(Re_Dc^(A_c/IN_con.A_fr)))^2.921);
              kc := j*(Re_Dc*Pr^(1/3)*IN_var.lambda/IN_con.D_c);
            end if;

          else

          end if;

        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for the air-side heat transfer of heat exchangers with round tubes and several fin geometries.<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.HeatExchanger.kc_roundTube\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_roundTube_KC;

        record kc_roundTube_IN_con
          "Input record for function kc_roundTube and kc_roundTube_KC"
          extends Modelica_Icons.Record;

          Utilities.Types.HTXGeometry_roundTubes geometry=Dissipation.Utilities.Types.HTXGeometry_roundTubes.PlainFin
            "Choice of fin geometry" annotation (Dialog(group="HeatExchanger"));

          SI.Area A_fr=0 "Frontal area"
            annotation (Dialog(group="HeatExchanger"));
          SI.Length D_c=0 "Fin collar diameter"
            annotation (Dialog(group="HeatExchanger"));
          SI.Length F_p=0 "Fin pitch, fin spacing + fin thickness"
            annotation (Dialog(group="HeatExchanger"));
          SI.Length L=0 "Heat exchanger length" annotation (Dialog(group=
                  "HeatExchanger", enable=if geometry == 2 then true else false));
          SI.Length L_h=0 "Louver height" annotation (Dialog(group=
                  "HeatExchanger", enable=if geometry == 2 then true else false));
          SI.Length L_p=0 "Louver pitch" annotation (Dialog(group=
                  "HeatExchanger", enable=if geometry == 2 then true else false));
          Integer N=0 "Number of tube rows" annotation (Dialog(group="HeatExchanger",
                enable=if geometry == 1 or geometry == 2 or geometry == 3 then true else
                        false));
          SI.Length P_d=0 "Pattern depth of wavy fin, wave height" annotation (
              Dialog(group="HeatExchanger", enable=if geometry == 4 then true
                   else false));
          SI.Length P_l=0 "Longitudinal tube pitch" annotation (Dialog(group=
                  "HeatExchanger", enable=if geometry == 1 or geometry == 2 or
                  geometry == 3 then true else false));
          SI.Length P_t=0 "Transverse tube pitch"
            annotation (Dialog(group="HeatExchanger"));
          SI.Length S_h=0 "Slit height" annotation (Dialog(group=
                  "HeatExchanger", enable=if geometry == 3 then true else false));
          SI.Length S_p=0 "Slit pitch" annotation (Dialog(group="HeatExchanger",
                enable=if geometry == 3 then true else false));
          SI.Length X_f=0 "Half wave length of wavy fin" annotation (Dialog(
                group="HeatExchanger", enable=if geometry == 4 then true else
                  false));

          SI.Length delta_f=0 "Fin thickness"
            annotation (Dialog(group="HeatExchanger"));

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HeatExchanger.kc_roundTube\"> kc_roundTube</a> and
<a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HeatExchanger.kc_roundTube_KC\"> kc_roundTube_KC</a>.
</html>"));

        end kc_roundTube_IN_con;

        record kc_roundTube_IN_var
          "Input record for function kc_roundTube and kc_roundTube_KC"
          extends Modelica_Icons.Record;

          //fluid property variables
          extends Utilities.Records.General.FluidProperties;

          //input variable (mass flow rate)
          SI.MassFlowRate m_flow annotation (Dialog(group="Input"));

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HeatExchanger.kc_roundTube\"> kc_roundTube</a> and
<a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HeatExchanger.kc_roundTube_KC\"> kc_roundTube_KC</a>.
</html>"));

        end kc_roundTube_IN_var;
      annotation (preferredView="info", Documentation(info="<html>
<h4>Heat exchanger</h4>
<h5>Flat tube heat exchanger</h5>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for the air-side heat transfer of heat exchangers with flat tubes and several fin geometries.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.HeatExchanger.kc_flatTube\">See more information</a> .
</p>

<h5>Round tube heat exchanger</h5>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for the air-side heat transfer of heat exchangers with round tubes and several fin geometries.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.HeatExchanger.kc_roundTube\">See more information</a> .
</p>
</html>"));
      end HeatExchanger;

      package HelicalPipe
      extends Modelica_Icons.VariantsPackage;
        function kc_laminar
          "Mean heat transfer coefficient of helical pipe | laminar flow regime"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, section Gc1 - Gc2
          //Notation of equations according to SOURCE

          //input records
          input kc_laminar_IN_con IN_con "Input record for function kc_laminar"
            annotation (Dialog(group="Constant inputs"));
          input kc_laminar_IN_var IN_var "Input record for function kc_laminar"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Convective heat transfer coefficient"
            annotation (Dialog(group="Output"));
          output SI.PrandtlNumber Pr "Prandtl number"
            annotation (Dialog(group="Output"));
          output SI.ReynoldsNumber Re "Reynolds number"
            annotation (Dialog(group="Output"));
          output SI.NusseltNumber Nu "Nusselt number"
            annotation (Dialog(group="Output"));
          output Real failureStatus
            "0== boundary conditions fulfilled | 1== failure >> check if still meaningful results"
            annotation (Dialog(group="Output"));

        protected
          Real MIN=Modelica_Constants.eps;

          SI.Diameter d_hyd=IN_con.d_hyd "Hydraulic diameter";
          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Circular cross sectional area";
          SI.Diameter d_s=IN_con.L/(IN_con.n_nt*PI) "Mean coil diameter";
          SI.Diameter d_w=sqrt(max(MIN, (d_s^2 - (IN_con.h/PI)^2)))
            "Mean helical pipe diameter";
          SI.Diameter d_coil=max(d_w, d_w*(1 + (IN_con.h/(PI*d_w))^2))
            "Mean curvature diameter of helical pipe";
          SI.ReynoldsNumber Re_crit=2300*(1 + 8.6*(IN_con.d_hyd/d_coil)^0.45)
            "Critical Reynolds number";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity";

          //failure status
          Real fstatus[1] "Check of expected boundary conditions";

          //Documentation
        algorithm
          Pr := abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));
          Re := max(1, abs(IN_var.rho*velocity*IN_con.d_hyd/max(MIN, IN_var.eta)));
          kc := kc_laminar_KC(IN_con, IN_var);
          Nu := kc*IN_con.d_hyd/max(MIN, IN_var.lambda);

          //failure status
          fstatus[1] := if Re > Re_crit then 1 else 0;

          failureStatus := 0;
          for i in 1:size(fstatus, 1) loop
            if fstatus[i] == 1 then
              failureStatus := 1;
            end if;
          end for;
          annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a helical pipe in the laminar flow regime. Note that additionally a failure status is observed in this function to check if the intended boundary conditions are fulfilled.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.HelicalPipe.kc_laminar\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_laminar;

        function kc_laminar_KC
          "Mean heat transfer coefficient of helical pipe | hydrodynamically developed laminar flow regime"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, section Gc1 - Gc2
          //Notation of equations according to SOURCE

          //input records
          input kc_laminar_IN_con IN_con
            "Input record for function kc_laminar_KC"
            annotation (Dialog(group="Constant inputs"));
          input kc_laminar_IN_var IN_var
            "Input record for function kc_laminar_KC"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Output for function kc_laminar_KC";

        protected
          Real MIN=Modelica_Constants.eps;

          SI.Diameter d_hyd=IN_con.d_hyd "Hydraulic diameter";
          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Circular cross sectional area";
          SI.Diameter d_s=IN_con.L/(IN_con.n_nt*PI) "Mean coil diameter";
          SI.Diameter d_w=sqrt(max(MIN, (d_s^2 - (IN_con.h/PI)^2)))
            "Mean helical pipe diameter";
          SI.Diameter d_coil=max(d_w, d_w*(1 + (IN_con.h/(PI*d_w))^2))
            "Mean curvature diameter of helical pipe";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity";
          SI.ReynoldsNumber Re=max(1, IN_var.rho*velocity*IN_con.d_hyd/max(MIN,
              IN_var.eta));
          SI.PrandtlNumber Pr=abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));

          Real m=0.5 + 0.2903*(IN_con.d_hyd/d_coil)^0.194
            "Exponent for actual Reynolds number";

          //Documentation
        algorithm
          kc := (IN_var.lambda/IN_con.d_hyd)*(3.66 + 0.08*(1 + 0.8*(IN_con.d_hyd/d_coil)
            ^0.9)*Re^(m)*Pr^(1/3));
        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a helical pipe in the laminar flow regime.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.HelicalPipe.kc_laminar\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_laminar_KC;

        record kc_laminar_IN_con
          "Input record for function kc_laminar and kc_laminar_KC"

          extends kc_overall_IN_con;

        annotation (  Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_laminar\"> kc_laminar</a> and
<a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_laminar_KC\"> kc_laminar_KC</a>.
</html>"));
        end kc_laminar_IN_con;

        record kc_laminar_IN_var
          "Input record for function kc_laminar and kc_laminar_KC"

          extends kc_overall_IN_var;

        annotation (  Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_laminar\"> kc_laminar</a> and
<a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_laminar_KC\"> kc_laminar_KC</a>.
</html>"));
        end kc_laminar_IN_var;

        function kc_overall
          "Mean heat transfer coefficient of helical pipe | overall flow regime"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, section Gc1 - Gc2
          //Notation of equations according to SOURCE

          //input records
          input kc_overall_IN_con IN_con "Input record for function kc_overall"
            annotation (Dialog(group="Constant inputs"));
          input kc_overall_IN_var IN_var "Input record for function kc_overall"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Convective heat transfer coefficient"
            annotation (Dialog(group="Output"));
          output SI.PrandtlNumber Pr "Prandtl number"
            annotation (Dialog(group="Output"));
          output SI.ReynoldsNumber Re "Reynolds number"
            annotation (Dialog(group="Output"));
          output SI.NusseltNumber Nu "Nusselt number"
            annotation (Dialog(group="Output"));
          output Real failureStatus
            "0== boundary conditions fulfilled | 1== failure >> check if still meaningful results"
            annotation (Dialog(group="Output"));

        protected
          Real MIN=Modelica_Constants.eps;

          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Cross sectional area";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity";

          //Documentation
        algorithm
          Pr := abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));
          Re := max(MIN, IN_var.rho*velocity*IN_con.d_hyd/max(MIN, IN_var.eta));
          kc := kc_overall_KC(IN_con, IN_var);
          Nu := kc*IN_con.d_hyd/max(MIN, IN_var.lambda);

          failureStatus := 0;
        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> of a helical pipe in a hydrodynamically developed laminar and turbulent flow regime. Note that additionally a failure status is observed in this function to check if the intended boundary conditions are fulfilled.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.HelicalPipe.kc_overall\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_overall;

        function kc_overall_KC
          "Mean heat transfer coefficient of helical pipe | overall flow regime"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, section Gc1 - Gc2
          //Notation of equations according to SOURCE

          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

          //input records
          input kc_overall_IN_con IN_con
            "Input record for function kc_overall_KC"
            annotation (Dialog(group="Constant inputs"));
          input kc_overall_IN_var IN_var
            "Input record for function kc_overall_KC"
            annotation (Dialog(group="Variable inputs"));
          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Output for function kc_overall_KC";

        protected
          Real MIN=Modelica_Constants.eps;
          Real laminar=2e3 "Maximum Reynolds number for laminar regime";
          Real turbulent=2.2e4 "Minimum Reynolds number for turbulent regime";

          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Cross sectional area";
          SI.Diameter d_s=max(1e-6, IN_con.L/(IN_con.n_nt*PI))
            "Mean coil diameter";
          SI.Diameter d_w=sqrt(max(MIN, abs(d_s^2 - (IN_con.h/PI)^2)))
            "Mean helical pipe diameter";
          SI.Diameter d_coil=d_w*(1 + (IN_con.h/(PI*d_w))^2)
            "Mean curvature diameter of helical pipe";
          SI.ReynoldsNumber Re_crit=min(4e3, 2300*(1 + 8.6*(IN_con.d_hyd/d_coil)
              ^0.45)) "Critical Reynolds number";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity";
          SI.ReynoldsNumber Re=max(1e-3, IN_var.rho*velocity*IN_con.d_hyd/max(
              MIN, IN_var.eta));
          SI.PrandtlNumber Pr=abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));

          //Documentation
        algorithm
          kc := SMOOTH(
                    Re_crit,
                    turbulent,
                    Re)*Dissipation.HeatTransfer.HelicalPipe.kc_laminar_KC(
            IN_con, IN_var) + SMOOTH(
                    turbulent,
                    Re_crit,
                    Re)*Dissipation.HeatTransfer.HelicalPipe.kc_turbulent_KC(
            IN_con, IN_var);
        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> of a helical pipe in a hydrodynamically developed laminar and turbulent flow regime.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.HelicalPipe.kc_overall\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_overall_KC;

        record kc_overall_IN_con
          "Input record for function kc_overall and kc_overall_KC"

          //helical pipe variables
          extends Utilities.Records.HeatTransfer.HelicalPipe;

        annotation (  Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_overall\"> kc_overall</a> and
<a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_overall_KC\"> kc_overall_KC</a>.
</html>"));
        end kc_overall_IN_con;

        record kc_overall_IN_var
          "Input record for function kc_overall and kc_overall_KC"

          //fluid property variables
          extends Utilities.Records.General.FluidProperties;

          //input variable (mass flow rate)
          SI.MassFlowRate m_flow annotation (Dialog(group="Input"));

        annotation (  Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_overall\"> kc_overall</a> and
<a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_overall_KC\"> kc_overall_KC</a>.
</html>"));
        end kc_overall_IN_var;

        function kc_turbulent
          "Mean heat transfer coefficient of helical pipe | hydrodynamically developed turbulent flow regime"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, section Gc1 - Gc2
          //Notation of equations according to SOURCE

          //input records
          input kc_turbulent_IN_con IN_con
            "Input record for function kc_turbulent"
            annotation (Dialog(group="Constant inputs"));
          input kc_turbulent_IN_var IN_var
            "Input record for function kc_turbulent"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Convective heat transfer coefficient"
            annotation (Dialog(group="Output"));
          output SI.PrandtlNumber Pr "Prandtl number"
            annotation (Dialog(group="Output"));
          output SI.ReynoldsNumber Re "Reynolds number"
            annotation (Dialog(group="Output"));
          output SI.NusseltNumber Nu "Nusselt number"
            annotation (Dialog(group="Output"));
          output Real failureStatus
            "0== boundary conditions fulfilled | 1== failure >> check if still meaningful results"
            annotation (Dialog(group="Output"));

        protected
          Real MIN=Modelica_Constants.eps;

          Real turbulent=2.2e4 "Minimum Reynolds number for turbulent regime";

          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Cross sectional area";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity";

          //failure status
          Real fstatus[1] "Check of expected boundary conditions";

          //Documentation
        algorithm
          Pr := abs(IN_var.eta*IN_var.cp/IN_var.lambda);
          Re := max(1e-3, abs(IN_var.rho*velocity*IN_con.d_hyd/IN_var.eta));
          kc := kc_turbulent_KC(IN_con, IN_var);
          Nu := kc*IN_con.d_hyd/max(MIN, IN_var.lambda);

          //failure status
          fstatus[1] := if Re < turbulent then 1 else 0;

          failureStatus := 0;
          for i in 1:size(fstatus, 1) loop
            if fstatus[i] == 1 then
              failureStatus := 1;
            end if;
          end for;
        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> of a helical pipe for turbulent flow regime. Note that additionally a failure status is observed in this function to check if the intended boundary conditions are fulfilled.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.HelicalPipe.kc_turbulent\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_turbulent;

        function kc_turbulent_KC
          "Mean heat transfer coefficient of helical pipe | hydrodynamically developed turbulent flow regime"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, section Gc1 - Gc2
          //Notation of equations according to SOURCE

          //input records
          input kc_turbulent_IN_con IN_con
            "Input record for function kc_turbulent_KC"
            annotation (Dialog(group="Constant inputs"));
          input kc_turbulent_IN_var IN_var
            "Input record for function kc_turbulent_KC"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Output for function kc_turbulent_KC";

        protected
          Real MIN=Modelica_Constants.eps;
          Real turbulent=2.2e4 "Minimum Reynolds number for turbulent regime";

          SI.Diameter d_hyd=IN_con.d_hyd "Hydraulic diameter";
          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Circular cross sectional area";
          SI.Diameter d_s=IN_con.L/(IN_con.n_nt*PI) "Mean coil diameter";
          SI.Diameter d_w=sqrt(max(MIN, (d_s^2 - (IN_con.h/PI)^2)))
            "Mean helical pipe diameter";
          SI.Diameter d_coil=max(d_w, d_w*(1 + (IN_con.h/(PI*d_w))^2))
            "Mean curvature diameter of helical pipe";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity";
          SI.ReynoldsNumber Re=max(1e-3, IN_var.rho*velocity*IN_con.d_hyd/max(
              MIN, IN_var.eta));
          SI.PrandtlNumber Pr=abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));

          Real zeta_TOT=0.3164*max(turbulent, Re)^(-0.25) + 0.03*sqrt(IN_con.d_hyd/
              d_coil) "Pressure loss coefficient";

          //Documentation
        algorithm
          kc := (IN_var.lambda/IN_con.d_hyd)*(zeta_TOT/8)*Re*Pr/(1 + 12.7*sqrt(zeta_TOT
            /8)*(Pr^(2/3) - 1));
        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> of a helical pipe for turbulent flow regime.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.HelicalPipe.kc_turbulent\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_turbulent_KC;

        record kc_turbulent_IN_con
          "Input record for function kc_turbulent and kc_turbulent_KC"

          extends kc_overall_IN_con;

        annotation (  Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_turbulent\">  kc_turbulent</a> and
<a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_turbulent_KC\">  kc_turbulent_KC</a>.
</html>"));
        end kc_turbulent_IN_con;

        record kc_turbulent_IN_var
          "Input record for function kc_turbulent and kc_turbulent_KC"

          extends kc_overall_IN_var;

        annotation (  Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_turbulent\">  kc_turbulent</a> and
<a href=\"Modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_turbulent_KC\">  kc_turbulent_KC</a>.
</html>"));
        end kc_turbulent_IN_var;
      annotation (preferredView="info", Documentation(info="<html>
<h4>Helical pipe</h4>
<h5>Laminar flow</h5>
<p>Calculation of the mean convective heat transfer coefficient <b> kc </b> for a helical pipe in the laminar flow regime.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.HelicalPipe.kc_laminar\">See more information</a>.</p>

<h5>Turbulent flow</h5>
<p>Calculation of the mean convective heat transfer coefficient <b> kc </b> of a helical pipe for turbulent flow regime.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.HelicalPipe.kc_turbulent\">See more information</a>.</p>

<h5>Overall flow</h5>
<p>Calculation of the mean convective heat transfer coefficient <b> kc </b> of a helical pipe in a hydrodynamically developed laminar and turbulent flow regime.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.HelicalPipe.kc_overall\">See more information</a>.</p>
</html>"));
      end HelicalPipe;

      package Plate
      extends Modelica_Icons.VariantsPackage;

        function kc_laminar
          "Mean heat transfer coefficient of plate | laminar regime"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, Aufl. 9, Springer-Verlag, 2002, Section Gd 1
          //Notation of equations according to SOURCE

          //input records
          input kc_laminar_IN_con IN_con "Input record for function kc_laminar"
            annotation (Dialog(group="Constant inputs"));
          input kc_laminar_IN_var IN_var "Input record for function kc_laminar"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Convective heat transfer coefficient"
            annotation (Dialog(group="Output"));
          output SI.PrandtlNumber Pr "Prandtl number"
            annotation (Dialog(group="Output"));
          output SI.ReynoldsNumber Re "Reynolds number"
            annotation (Dialog(group="Output"));
          output SI.NusseltNumber Nu "Nusselt number"
            annotation (Dialog(group="Output"));
          output Real failureStatus
            "0== boundary conditions fulfilled | 1== failure >> check if still meaningful results"
            annotation (Dialog(group="Output"));

        protected
          Real MIN=Modelica_Constants.eps;

          Real laminar=1e5 "Maximum Reynolds number of laminar flow regime";
          Real prandtlMax=2000 "Maximum Prandtl number";
          Real prandtlMin=0.6 "Minimum Prandtl number";

          //failure status
          Real fstatus[2] "Check of expected boundary conditions";

          //Documentation
        algorithm
          Pr := IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda);
          Re := max(1e-3, abs(IN_var.rho*IN_var.velocity*IN_con.L/max(MIN, IN_var.eta)));
          kc := kc_laminar_KC(IN_con, IN_var);
          Nu := kc*IN_con.L/max(MIN, IN_var.lambda);

          //failure status
          fstatus[1] := if Re > laminar then 1 else 0;
          fstatus[2] := if Pr > prandtlMax or Pr < prandtlMin then 1 else 0;

          failureStatus := 0;
          for i in 1:size(fstatus, 1) loop
            if fstatus[i] == 1 then
              failureStatus := 1;
            end if;
          end for;
        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a laminar fluid flow over an even surface. Note that additionally a failure status is observed in this function to check if the intended boundary conditions are fulfilled. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Plate.kc_laminar\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_laminar;

        function kc_laminar_KC
          "Mean heat transfer coefficient of plate | laminar regime"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, Aufl. 9, Springer-Verlag, 2002, Section Gd 1
          //Notation of equations according to SOURCE

          //input records
          input kc_laminar_IN_con IN_con
            "Input record for function kc_laminar_KC"
            annotation (Dialog(group="Constant inputs"));
          input kc_laminar_IN_var IN_var
            "Input record for function kc_laminar_KC"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Output for function kc_laminar_KC";

        protected
          Real MIN=Modelica_Constants.eps;

          SI.Length L=max(MIN, IN_con.L);

          SI.SpecificHeatCapacityAtConstantPressure cp=IN_var.cp;
          SI.DynamicViscosity eta=max(MIN, IN_var.eta);
          SI.ThermalConductivity lambda=max(MIN, IN_var.lambda);
          SI.Density rho=IN_var.rho;

          SI.Velocity velocity=abs(IN_var.velocity) "Mean velocity";
          SI.ReynoldsNumber Re=max(1e-3, rho*velocity*L/eta);
          SI.PrandtlNumber Pr=eta*cp/lambda;

          //Documentation
        algorithm
          kc := (lambda/L)*(0.664*abs(Re)^0.5*Pr^(1/3));
        annotation (Inline=true, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a laminar fluid flow over an even surface.
Generally this function is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known fluid velocity.
 <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Plate.kc_laminar\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_laminar_KC;

        record kc_laminar_IN_con
          "Input record for function kc_laminar and kc_laminar_KC"
          extends kc_overall_IN_con;

        annotation (  Documentation(info="<html>
<p>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Plate.kc_laminar\">  kc_laminar</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Plate.kc_laminar_KC\">  kc_laminar_KC</a>.
</p>
</html>"));
        end kc_laminar_IN_con;

        record kc_laminar_IN_var
          "Input record for function kc_laminar and kc_laminar_KC"
          extends kc_overall_IN_var;

        annotation (  Documentation(info="<html>
<p>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Plate.kc_laminar\">  kc_laminar</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Plate.kc_laminar_KC\">  kc_laminar_KC</a>.
</p>
</html>"));
        end kc_laminar_IN_var;

        function kc_overall
          "Mean heat transfer coefficient of even plate | overall regime | constant wall temperature"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, Aufl. 9, Springer-Verlag, 2002, Section Gd 1
          //Notation of equations according to SOURCE

          //input records
          input kc_overall_IN_con IN_con "Input record for function kc_overall"
            annotation (Dialog(group="Constant inputs"));
          input kc_overall_IN_var IN_var "Input record for function kc_overall"
            annotation (Dialog(group="Variable inputs"));
          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Convective heat transfer coefficient"
            annotation (Dialog(group="Output"));
          output SI.PrandtlNumber Pr "Prandtl number"
            annotation (Dialog(group="Output"));
          output SI.ReynoldsNumber Re "Reynolds number"
            annotation (Dialog(group="Output"));
          output SI.NusseltNumber Nu "Nusselt number"
            annotation (Dialog(group="Output"));
          output Real failureStatus
            "0== boundary conditions fulfilled | 1== failure >> check if still meaningful results"
            annotation (Dialog(group="Output"));

        protected
          Real MIN=Modelica_Constants.eps;

          Real prandtlMax=2000 "Maximum Prandtl number";
          Real prandtlMin=0.6 "Minimum Prandtl number";
          Real reynoldsMax=1e7 "Maximum Reynolds number";
          Real reynoldsMin=1e1 "Minimum Reynolds number";

          //failure status
          Real fstatus[2] "Check of expected boundary conditions";

          //Documentation
        algorithm
          Pr := IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda);
          Re := max(1e-3, abs(IN_var.rho*IN_var.velocity*IN_con.L/max(MIN, IN_var.eta)));
          kc := kc_overall_KC(IN_con, IN_var);
          Nu := kc*IN_con.L/max(MIN, IN_var.lambda);

          //failure status
          fstatus[1] := if Re > reynoldsMax or Re < reynoldsMin then 1 else 0;
          fstatus[2] := if Pr > prandtlMax or Pr < prandtlMin then 1 else 0;

          failureStatus := 0;
          for i in 1:size(fstatus, 1) loop
            if fstatus[i] == 1 then
              failureStatus := 1;
            end if;
          end for;
        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a laminar or turbulent fluid flow over an even surface. Note that additionally a failure status is observed in this function to check if the intended boundary conditions are fulfilled.  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Plate.kc_overall\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_overall;

        function kc_overall_KC
          "Mean heat transfer coefficient of even plate | overall regime | constant wall temperature"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, Aufl. 9, Springer-Verlag, 2002, Section Gd 1
          //Notation of equations according to SOURCE

          //input records
          input kc_overall_IN_con IN_con
            "Input record for function kc_overall_KC"
            annotation (Dialog(group="Constant inputs"));
          input kc_overall_IN_var IN_var
            "Input record for function kc_overall_KC"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Output for function kc_overall_KC";

        protected
          SI.CoefficientOfHeatTransfer kc_lam=kc_laminar_KC(IN_con, IN_var);
          SI.CoefficientOfHeatTransfer kc_turb=kc_turbulent_KC(IN_con, IN_var);

          //Documentation
        algorithm
          kc := sqrt((kc_lam)^2 + (kc_turb)^2);
        annotation (Inline=true, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a laminar or turbulent fluid flow over an even surface.
Generally this function is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known fluid velocity.
 <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Plate.kc_overall\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_overall_KC;

        record kc_overall_IN_con
          "Input record for function kc_overall and function kc_overall_KC"
          //plate variables
          extends Utilities.Records.HeatTransfer.Plate;

        annotation (  Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Plate.kc_overall\"> kc_overall</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Plate.kc_overall_KC\"> kc_overall_KC</a>.
</html>"));
        end kc_overall_IN_con;

        record kc_overall_IN_var
          "Input record for function kc_overall and function kc_overall_KC"
          //fluid property variables
          extends Utilities.Records.General.FluidProperties;

          //input variable (fluid flow velocity)
          SI.Velocity velocity annotation (Dialog(group="Input"));

        annotation (  Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Plate.kc_overall\"> kc_overall</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Plate.kc_overall_KC\"> kc_overall_KC</a>.
</html>"));
        end kc_overall_IN_var;

        function kc_turbulent
          "Mean heat transfer coefficient of even plate | turbulent regime | constant wall temperature"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, Aufl. 9, Springer-Verlag, 2002, Section Gd 1
          //Notation of equations according to SOURCE

          //input records
          input kc_turbulent_IN_con IN_con
            "Input record for function kc_turbulent"
            annotation (Dialog(group="Constant inputs"));
          input kc_turbulent_IN_var IN_var
            "Input record for function kc_turbulent"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Convective heat transfer coefficient"
            annotation (Dialog(group="Output"));
          output SI.PrandtlNumber Pr "Prandtl number"
            annotation (Dialog(group="Output"));
          output SI.ReynoldsNumber Re "Reynolds number"
            annotation (Dialog(group="Output"));
          output SI.NusseltNumber Nu "Nusselt number"
            annotation (Dialog(group="Output"));
          output Real failureStatus
            "0== boundary conditions fulfilled | 1== failure >> check if still meaningful results"
            annotation (Dialog(group="Output"));

        protected
          Real MIN=Modelica_Constants.eps;

          Real prandtlMax=2000 "Maximum Prandtl number";
          Real prandtlMin=0.6 "Minimum Prandtl number";
          Real reynoldsMax=1e7 "Maximum Reynolds number";
          Real reynoldsMin=5e5 "Minimum Reynolds number";

          //failure status
          Real fstatus[2] "Check of expected boundary conditions";

          //Documentation
        algorithm
          Pr := abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));
          Re := max(1e-3, abs(IN_var.rho*IN_var.velocity*IN_con.L/max(MIN, IN_var.eta)));
          kc := kc_turbulent_KC(IN_con, IN_var);
          Nu := kc*IN_con.L/max(MIN, IN_var.lambda);

          //failure status
          fstatus[1] := if Re > reynoldsMax or Re < reynoldsMin then 1 else 0;
          fstatus[2] := if Pr > prandtlMax or Pr < prandtlMin then 1 else 0;

          failureStatus := 0;
          for i in 1:size(fstatus, 1) loop
            if fstatus[i] == 1 then
              failureStatus := 1;
            end if;
          end for;
        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a hydrodynamically developed turbulent fluid flow over an even surface. Note that additionally a failure status is observed in this function to check if the intended boundary conditions are fulfilled.  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Plate.kc_turbulent\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_turbulent;

        function kc_turbulent_KC
          "Mean heat transfer coefficient of even plate | turbulent regime | constant wall temperature"
          extends Modelica_Icons.Function;
          //SOURCE: VDI-Waermeatlas, Aufl. 9, Springer-Verlag, 2002, Section Gd 1
          //Notation of equations according to SOURCE

          //input records
          input kc_turbulent_IN_con IN_con
            "Input record for function kc_turbulent_KC"
            annotation (Dialog(group="Constant inputs"));
          input kc_turbulent_IN_var IN_var
            "Input record for function kc_turbulent_KC"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Output for function kc_turbulent_KC";

        protected
          Real MIN=Modelica_Constants.eps;

          SI.Length L=max(MIN, IN_con.L);

          SI.SpecificHeatCapacityAtConstantPressure cp=IN_var.cp;
          SI.DynamicViscosity eta=IN_var.eta;
          SI.ThermalConductivity lambda=max(MIN, IN_var.lambda);
          SI.Density rho=IN_var.rho;

          SI.Velocity velocity=abs(IN_var.velocity) "Mean velocity";
          SI.ReynoldsNumber Re=max(1e-3, abs(rho*velocity*L/eta));
          SI.PrandtlNumber Pr=abs(eta*cp/lambda);

          //Documentation
        algorithm
          kc := abs((lambda/L))*(0.037*Re^0.8*Pr)/(1 + 2.443/(max(Re^0.1, 1e-6))*(Pr^(2
            /3) - 1));
        annotation (Inline=true, Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a hydrodynamically developed turbulent fluid flow over an even surface.
Generally this function is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known fluid velocity.
 <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Plate.kc_turbulent\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_turbulent_KC;

        record kc_turbulent_IN_con
          "Input record for function kc_turbulent and kc_turbulent_KC"
          extends kc_overall_IN_con;

        annotation (  Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Plate.kc_turbulent\">  kc_turbulent</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Plate.kc_turbulent_KC\">  kc_turbulent_KC</a>.
</html>"));
        end kc_turbulent_IN_con;

        record kc_turbulent_IN_var
          "Input record for function kc_turbulent and kc_turbulent_KC"
          extends kc_overall_IN_var;

        annotation (  Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Plate.kc_turbulent\">  kc_turbulent</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Plate.kc_turbulent_KC\">  kc_turbulent_KC</a>.
</html>"));
        end kc_turbulent_IN_var;
        annotation (preferredView="info", Documentation(info="<html>
<h4>Even plate</h4>
<h5>Laminar flow</h5>
<p>Calculation of the mean convective heat transfer coefficient <b> kc </b> for a laminar fluid flow over an even surface. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Plate.kc_laminar\">See more information</a> .</p>

<h5>Turbulent flow</h5>
<p>Calculation of the mean convective heat transfer coefficient <b> kc </b> for a hydrodynamically developed turbulent fluid flow over an even surface. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Plate.kc_turbulent\">See more information</a>.</p>

<h5>Overall flow</h5>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for an laminar and turbulent fluid flow over an even surface. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Plate.kc_overall\">See more information</a>.
</p>
</html>"));
      end Plate;

      package StraightPipe
      extends Modelica_Icons.VariantsPackage;

        function kc_laminar
          "Mean heat transfer coefficient of straight pipe | uniform wall temperature or uniform heat flux | hydrodynamically developed or undeveloped laminar flow regime"
          extends Modelica_Icons.Function;
          //input records
          input kc_laminar_IN_con IN_con "Input record for function kc_laminar"
            annotation (Dialog(group="Constant inputs"));
          input kc_laminar_IN_var IN_var "Input record for function kc_laminar"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Convective heat transfer coefficient"
            annotation (Dialog(group="Output"));
          output SI.PrandtlNumber Pr "Prandtl number"
            annotation (Dialog(group="Output"));
          output SI.ReynoldsNumber Re "Reynolds number"
            annotation (Dialog(group="Output"));
          output SI.NusseltNumber Nu "Nusselt number"
            annotation (Dialog(group="Output"));
          output Real failureStatus
            "0== boundary conditions fulfilled | 1== failure >> check if still meaningful results"
            annotation (Dialog(group="Output"));

        protected
          Real MIN=Modelica_Constants.eps;

          Real laminar=2e3 "Maximum Reynolds number of laminar flow regime";
          Real prandtlMax=1000 "Maximum Prandtl number";
          Real prandtlMin=0.6 "Minimum Prandtl number";

          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Cross sectional area";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity";

          //failure status
          Real fstatus[2] "check of expected boundary conditions";

          //Documentation
        algorithm
          Pr := abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));
          Re := max(1e-3, IN_var.rho*velocity*IN_con.d_hyd/max(MIN, IN_var.eta));
          kc := kc_laminar_KC(IN_con, IN_var);
          Nu := kc*IN_con.d_hyd/max(MIN, IN_var.lambda);

          //failure status
          fstatus[1] := if Re > laminar then 1 else 0;
          fstatus[2] := if Pr > prandtlMax or Pr < prandtlMin then 1 else 0;

          failureStatus := 0;
          for i in 1:size(fstatus, 1) loop
            if fstatus[i] == 1 then
              failureStatus := 1;
            end if;
          end for;
        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of mean convective heat transfer coefficient <b> kc </b> of a straight pipe at an uniform wall temperature <b> or </b> uniform heat flux <b>and</b> for a hydrodynamically developed <b>or</b> undeveloped laminar fluid flow. Note that additionally a failure status is observed in this function to check if the intended boundary conditions are fulfilled.  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.StraightPipe.kc_laminar\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_laminar;

        function kc_laminar_KC
          "Mean heat transfer coefficient of straight pipe | uniform wall temperature or uniform heat flux | hydrodynamically developed or undeveloped laminar flow regime"
          extends Modelica_Icons.Function;
          //input records
          input kc_laminar_IN_con IN_con
            "Input record for function kc_laminar_KC"
            annotation (Dialog(group="Constant inputs"));
          input kc_laminar_IN_var IN_var
            "Input record for function kc_laminar_KC"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Output for function kc_laminar_KC";

        protected
          type TYP =
              Utilities.Types.HeatTransferBoundary;

          Real MIN=Modelica_Constants.eps;

          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Circular cross sectional area";

          Real Nu0=if IN_con.target == TYP.UWTuDFF or IN_con.target == TYP.UWTuUFF then
                    0.7 else if IN_con.target == TYP.UHFuDFF or IN_con.target == TYP.UHFuUFF then
                    0.6 else 0 "Help variable for mean Nusselt number";
          Real Nu1=if IN_con.target == TYP.UWTuDFF or IN_con.target == TYP.UWTuUFF then
                    3.66 else if IN_con.target == TYP.UHFuDFF or IN_con.target == TYP.UHFuUFF then
                    4.364 else 0 "Help variable for mean Nusselt number";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity";
          SI.ReynoldsNumber Re=max(1e-3, IN_var.rho*velocity*IN_con.d_hyd/max(
              MIN, IN_var.eta));
          SI.PrandtlNumber Pr=abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));

          SI.NusseltNumber Nu2=if IN_con.target == TYP.UWTuDFF or IN_con.target
               == TYP.UWTuUFF then 1.615*(Re*Pr*IN_con.d_hyd/IN_con.L)^(1/3)
               else if IN_con.target == TYP.UHFuDFF or IN_con.target == TYP.UHFuUFF
               then 1.953*(Re*Pr*IN_con.d_hyd/IN_con.L)^(1/3) else 0
            "Help variable for mean Nusselt number";
          SI.NusseltNumber Nu3=if IN_con.target == TYP.UWTuUFF then (2/(1 + 22*
              Pr))^(1/6)*(Re*Pr*IN_con.d_hyd/IN_con.L)^0.5 else if IN_con.target
               == TYP.UHFuUFF then 0.924*(Pr^(1/3))*(Re*IN_con.d_hyd/IN_con.L)^
              (1/2) else 0 "Help variable for mean Nusselt number";

          SI.NusseltNumber Nu=(Nu1^3 + Nu0^3 + (Nu2 - Nu0)^3 + Nu3^3)^(1/3)
            "Mean Nusselt number";

          //Documentation
        algorithm
          kc := Nu*IN_var.lambda/max(MIN, IN_con.d_hyd);
        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of mean convective heat transfer coefficient <b> kc </b> of a straight pipe at an uniform wall temperature <b> or </b> uniform heat flux <b>and</b> for a hydrodynamically developed <b>or</b> undeveloped laminar fluid flow. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.StraightPipe.kc_laminar\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_laminar_KC;

        record kc_laminar_IN_con
          "Input record for function kc_laminar and kc_laminar_KC"
          extends Utilities.Records.HeatTransfer.StraightPipe;

            //choices
          Utilities.Types.HeatTransferBoundary target=Dissipation.Utilities.Types.HeatTransferBoundary.UWTuDFF
            "Choice of heat transfer boundary condition"
            annotation (Dialog(group="Choices"));

        annotation (  Documentation(info="<html>
<p>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.StraightPipe.kc_laminar\"> kc_laminar</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.StraightPipe.kc_laminar_KC\"> kc_laminar_KC</a>.
</p>
</html>"));
        end kc_laminar_IN_con;

        record kc_laminar_IN_var
          "Input record for function kc_laminar and kc_laminar_KC"
          extends kc_overall_IN_var;

        annotation (  Documentation(info="<html>
<p>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.StraightPipe.kc_laminar\"> kc_laminar</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.StraightPipe.kc_laminar_KC\"> kc_laminar_KC</a>.
</p>
</html>"));
        end kc_laminar_IN_var;

        function kc_overall
          "Mean heat transfer coefficient of straight pipe | uniform wall temperature or uniform heat flux | hydrodynamically developed or undeveloped overall flow regime| pressure loss dependence"
          extends Modelica_Icons.Function;
          //input records
          input kc_overall_IN_con IN_con "Input record for function kc_overall"
            annotation (Dialog(group="Constant inputs"));
          input kc_overall_IN_var IN_var "Input record for function kc_overall"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Convective heat transfer coefficient"
            annotation (Dialog(group="Output"));
          output SI.PrandtlNumber Pr "Prandtl number"
            annotation (Dialog(group="Output"));
          output SI.ReynoldsNumber Re "Reynolds number"
            annotation (Dialog(group="Output"));
          output SI.NusseltNumber Nu "Nusselt number"
            annotation (Dialog(group="Output"));
          output Real failureStatus
            "0== boundary conditions fulfilled | 1== failure >> check if still meaningful results"
            annotation (Dialog(group="Output"));

        protected
          type TYP = Utilities.Types.Roughness;

          Real MIN=Modelica_Constants.eps;

          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Cross sectional area";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity";

          //failure status
          Real fstatus[3] "Check of expected boundary conditions";

        algorithm
          Pr := abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));
          Re := max(1e-3, IN_var.rho*velocity*IN_con.d_hyd/max(MIN, IN_var.eta));
          kc := kc_overall_KC(IN_con, IN_var);
          Nu := kc*IN_con.d_hyd/max(MIN, IN_var.lambda);

          //failure status
          if IN_con.roughness == TYP.Neglected then
            if Re < 2e4 or Re > 1e6 then
              fstatus[1] := 1;
            else
              fstatus[1] := 0;
            end if;
          elseif IN_con.roughness == TYP.Considered then
            if Re < 1e4 or Re > 1e6 then
              fstatus[1] := 1;
            else
              fstatus[1] := 0;
            end if;
          else
            assert(false, "No choice of roughness is selected");
          end if;
          fstatus[2] := if Pr < 0.6 or Pr > 1e3 then 1 else 0;
          fstatus[3] := if IN_con.d_hyd/max(MIN, IN_con.L) > 1 then 1 else 0;

          failureStatus := 0;
          for i in 1:size(fstatus, 1) loop
            if fstatus[i] == 1 then
              failureStatus := 1;
            end if;
          end for;
        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of mean convective heat transfer coefficient <b> kc </b> of a straight pipe at an uniform wall temperature <b> or </b> uniform heat flux <b> and </b> for a hydrodynamically developed <b>or</b> undeveloped overall fluid flow with neglect <b> or </b> consideration of pressure loss influence. Note that additionally a failure status is observed in this function to check if the intended boundary conditions are fulfilled.  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.StraightPipe.kc_overall\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_overall;

        function kc_overall_KC
          "Mean heat transfer coefficient of straight pipe | uniform wall temperature or uniform heat flux | hydrodynamically developed or undeveloped overall flow regime| pressure loss dependence"
          extends Modelica_Icons.Function;
          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

          //input records
          input kc_overall_IN_con IN_con
            "Input record for function kc_overall_KC"
            annotation (Dialog(group="Constant inputs"));
          input kc_overall_IN_var IN_var
            "Input record for function kc_overall_KC"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Output for function kc_overall_KC";

        protected
          Real MIN=Modelica_Constants.eps;
          Real laminar=2200 "Maximum Reynolds number for laminar regime";
          Real turbulent=1e4 "Minimum Reynolds number for turbulent regime";

          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Cross sectional area";

          SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho*A_cross)
            "Mean velocity";
          SI.ReynoldsNumber Re=max(1e-3, IN_var.rho*velocity*IN_con.d_hyd/max(
              MIN, IN_var.eta));
          SI.PrandtlNumber Pr=abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));

          kc_turbulent_IN_con IN_con_turb(d_hyd=IN_con.d_hyd, L= IN_con.L, roughness = IN_con.roughness, K=IN_con.K);
          kc_laminar_IN_con IN_con_lam(d_hyd=IN_con.d_hyd, L= IN_con.L, target=IN_con.target);

        algorithm
          kc := SMOOTH(
                    laminar,
                    turbulent,
                    Re)*Dissipation.HeatTransfer.StraightPipe.kc_laminar_KC(
            IN_con_lam, IN_var) + SMOOTH(
                    turbulent,
                    laminar,
                    Re)*Dissipation.HeatTransfer.StraightPipe.kc_turbulent_KC(
            IN_con_turb, IN_var);

        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of mean convective heat transfer coefficient <b> kc </b> of a straight pipe at an uniform wall temperature <b> or </b> uniform heat flux <b> and </b> for a hydrodynamically developed <b>or</b> undeveloped overall fluid flow with neglect <b> or </b> consideration of pressure loss influence.<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.StraightPipe.kc_overall\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_overall_KC;

        record kc_overall_IN_con
          "Input record for function kc_overall and kc_overall_KC"

            //choices
          Utilities.Types.HeatTransferBoundary target=Dissipation.Utilities.Types.HeatTransferBoundary.UWTuDFF
            "Choice of heat transfer boundary condition"
            annotation (Dialog(group="Choices"));

          extends kc_turbulent_IN_con;

        annotation (  Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall\"> kc_overall</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC\"> kc_overall_KC</a>.
</html>"));
        end kc_overall_IN_con;

        record kc_overall_IN_var
          "Input record for function kc_overall and kc_overall_KC"
          //fluid property variables
          extends Utilities.Records.General.FluidProperties;

          //input variable (mass flow rate)
          SI.MassFlowRate m_flow annotation (Dialog(group="Input"));

        annotation (  Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall\"> kc_overall</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC\"> kc_overall_KC</a>.
</html>"));
        end kc_overall_IN_var;

        function kc_turbulent
          "Mean heat transfer coefficient of straight pipe | hydrodynamically developed turbulent flow regime | pressure loss dependence"
          extends Modelica_Icons.Function;
          //input records
          input kc_turbulent_IN_con IN_con
            "Input record for function kc_turbulent"
            annotation (Dialog(group="Constant inputs"));
          input kc_turbulent_IN_var IN_var
            "Input record for function kc_turbulent"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Convective heat transfer coefficient"
            annotation (Dialog(group="Output"));
          output SI.PrandtlNumber Pr "Prandtl number"
            annotation (Dialog(group="Output"));
          output SI.ReynoldsNumber Re "Reynolds number"
            annotation (Dialog(group="Output"));
          output SI.NusseltNumber Nu "Nusselt number"
            annotation (Dialog(group="Output"));
          output Real failureStatus
            "0== boundary conditions fulfilled | 1== failure >> check if still meaningful results"
            annotation (Dialog(group="Output"));

        protected
          type TYP = Utilities.Types.Roughness;

          Real MIN=Modelica_Constants.eps;

          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Cross sectional area";

          SI.Velocity velocity=abs(IN_var.m_flow)/(IN_var.rho*A_cross)
            "Mean velocity";

          //failure status
          Real fstatus[3] "check of expected boundary conditions";

          //Documentation
        algorithm
          Pr := abs(IN_var.eta*IN_var.cp/max(MIN, IN_var.lambda));
          Re := max(1e-3, IN_var.rho*velocity*IN_con.d_hyd/max(MIN, IN_var.eta));
          kc := kc_turbulent_KC(IN_con, IN_var);
          Nu := kc*IN_con.d_hyd/max(MIN, IN_var.lambda);

          //failure status
          if IN_con.roughness == TYP.Neglected then
            if Re < 2e4 or Re > 1e6 then
              fstatus[1] := 1;
            else
              fstatus[1] := 0;
            end if;
          elseif IN_con.roughness == TYP.Considered then
            if Re < 1e4 or Re > 1e6 then
              fstatus[1] := 1;
            else
              fstatus[1] := 0;
            end if;
          else
            assert(false, "No choice of roughness is selected");
          end if;
          fstatus[2] := if Pr <= 0.6 or Pr >= 1e3 then 1 else 0;
          fstatus[3] := if IN_con.d_hyd/max(MIN, IN_con.L) > 1 then 1 else 0;

          failureStatus := 0;
          for i in 1:size(fstatus, 1) loop
            if fstatus[i] == 1 then
              failureStatus := 1;
            end if;
          end for;
        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of mean convective heat transfer coefficient <b> kc </b> of a straight pipe for a hydrodynamically developed turbulent fluid flow at uniform wall temperature <b> or </b> uniform heat flux with neglecting <b> or </b> considering of pressure loss influence. Note that additionally a failure status is observed in this function to check if the intended boundary conditions are fulfilled.  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.StraightPipe.kc_turbulent\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_turbulent;

        function kc_turbulent_KC
          "Mean heat transfer coefficient of straight pipe | hydrodynamically developed turbulent flow regime | pressure loss dependence"
          extends Modelica_Icons.Function;
          //input records
          input kc_turbulent_IN_con IN_con
            "Input record for function kc_turbulent_KC"
            annotation (Dialog(group="Constant inputs"));
          input kc_turbulent_IN_var IN_var
            "Input record for function kc_turbulent_KC"
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Output for function kc_turbulent_KC";

        protected
          type TYP = Utilities.Types.Roughness;

          Real MIN=Modelica_Constants.eps;

          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Circular cross sectional area";

          SI.Velocity velocity=abs(IN_var.m_flow)/(IN_var.rho*A_cross)
            "Mean velocity";
          SI.ReynoldsNumber Re=max(2.6, IN_var.rho*velocity*IN_con.d_hyd/IN_var.eta);
          SI.PrandtlNumber Pr=abs(IN_var.eta*IN_var.cp/IN_var.lambda);

          Real zeta=abs(1/max(MIN, 1.8*Modelica_Math.log10(abs(Re)) - 1.5)^2)
            "Pressure loss coefficient";

          //Documentation
        algorithm
          kc := if IN_con.roughness == TYP.Neglected then abs(IN_var.lambda/IN_con.d_hyd)
            *0.023*Re^0.8*Pr^(1/3) else if IN_con.roughness == TYP.Considered then abs(
            IN_var.lambda/IN_con.d_hyd)*(abs(zeta)/8)*abs(Re)*abs(Pr)/(1 + 12.7*(abs(
            zeta)/8)^0.5*(abs(Pr)^(2/3) - 1))*(1 + (IN_con.d_hyd/IN_con.L)^(2/3)) else
            0;
        annotation (Inline=false, Documentation(info="<html>
<p>
Calculation of mean convective heat transfer coefficient <b> kc </b> of a straight pipe for a hydrodynamically developed turbulent fluid flow at uniform wall temperature <b> or </b> uniform heat flux with neglecting <b> or </b> considering of pressure loss influence. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.StraightPipe.kc_turbulent\">See more information</a> .
</p>
</html>"),                   smoothOrder(normallyConstant=IN_con) = 2);
        end kc_turbulent_KC;

        record kc_turbulent_IN_con
          "Input record for function kc_turbulent and kc_turbulent_KC"
          extends Utilities.Records.HeatTransfer.StraightPipe;

          Utilities.Types.Roughness roughness=Dissipation.Utilities.Types.Roughness.Considered
            "Choice of considering surface roughness"
            annotation (Dialog(group="Choices"));

          SI.Length K=0 "Roughness (average height of surface asperities)"
            annotation (Dialog(group="Straight pipe", enable=roughness ==
                  Modelica_Fluid.Dissipation.Utilities.Types.Roughness.considered));

        annotation (  Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.StraightPipe.kc_turbulent\">kc_turbulent</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.StraightPipe.kc_turbulent_KC\">kc_turbulent_KC</a>.
</html>"));
        end kc_turbulent_IN_con;

        record kc_turbulent_IN_var
          "Input record for function kc_turbulent and kc_turbulent_KC"
          extends kc_overall_IN_var;

        annotation (  Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.StraightPipe.kc_turbulent\">kc_turbulent</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.StraightPipe.kc_turbulent_KC\">kc_turbulent_KC</a>.
</html>"));
        end kc_turbulent_IN_var;

        function kc_twoPhaseOverall_KC
          "Local two phase heat transfer coefficient of straight pipe | horizontal or vertical boiling | horizontal condensation"
          extends Modelica_Icons.Function;
          //SOURCE_1: Bejan,A.: HEAT TRANSFER HANDBOOK, Wiley, 2003.
          //SOURCE_2: Gungor, K.E. and R.H.S. Winterton: A general correlation for flow boiling in tubes and annuli, Int.J. Heat Mass Transfer, Vol.29, p.351-358, 1986.

          //input records
          input kc_twoPhaseOverall_KC_IN_con IN_con
            annotation (Dialog(group="Constant inputs"));
          input kc_twoPhaseOverall_KC_IN_var IN_var
            annotation (Dialog(group="Variable inputs"));

          //output variables
          output SI.CoefficientOfHeatTransfer kc
            "Local two phase heat transfer coefficient";

        protected
          Real MIN=Modelica_Constants.eps;

          //Documentation
        algorithm
          kc := if IN_con.target == Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.BoilHor
             then
            Utilities.Functions.HeatTransfer.TwoPhase.kc_twoPhase_boilingHorizontal_KC(
            IN_con, IN_var) else if IN_con.target == Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.BoilVer
             then
            Utilities.Functions.HeatTransfer.TwoPhase.kc_twoPhase_boilingVertical_KC(
            IN_con, IN_var) else if IN_con.target == Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.CondHor
             then
            Utilities.Functions.HeatTransfer.TwoPhase.kc_twoPhase_condensationHorizontal_KC(
            IN_con, IN_var) else MIN;
        annotation(Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
              Documentation(info=
                        "<html>
<p>Calculation of local <b>two phase</b> heat transfer coefficient <b>kc_2ph </b>for (horizontal/vertical) <b>boiling</b> or (horizontal) <b>condensation</b> for an overall flow regime. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.StraightPipe.kc_twoPhaseOverall\">See more information</a> .</p>
</html>"));
        end kc_twoPhaseOverall_KC;

        record kc_twoPhaseOverall_KC_IN_con
          "Input record for function kc_twoPhaseOverall_KC"
          extends Utilities.Records.HeatTransfer.TwoPhaseFlowHT_IN_con;

        annotation (  Documentation(info="<html>
This record is used as <b> input record </b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.StraightPipe.kc_twoPhaseOverall_KC\"> kc_twoPhaseOverall_KC</a>.
</html>"));
        end kc_twoPhaseOverall_KC_IN_con;

        record kc_twoPhaseOverall_KC_IN_var
          "Input record for function kc_twoPhaseOverall_KC"
          extends Utilities.Records.HeatTransfer.TwoPhaseFlowHT_IN_var;

        annotation (  Documentation(info="<html>
This record is used as <b>input record</b> for the heat transfer function <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.StraightPipe.kc_twoPhaseOverall_KC\"> kc_twoPhaseOverall_KC</a>.
</html>"));
        end kc_twoPhaseOverall_KC_IN_var;
        annotation (preferredView="info", Documentation(info="<html>
<h4>Straight pipe</h4>
<h5>Laminar flow</h5>
<p>Calculation of mean convective heat transfer coefficient <b>kc</b> of a straight pipe at an uniform wall temperature <b>or</b> uniform heat flux <b>and</b> for a hydrodynamically developed <b>or</b> undeveloped laminar fluid flow. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.StraightPipe.kc_laminar\">See more information</a>.</p>

<h5>Turbulent flow</h5>
<p>Calculation of mean convective heat transfer coefficient <b>kc</b> of a straight pipe for a hydrodynamically developed turbulent fluid flow at uniform wall temperature <b>or</b> <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.StraightPipe.kc_twoPhaseOverall\">See more information</a>.</p>
</html>"));
      end StraightPipe;
    annotation(preferredView="info");
    end HeatTransfer;

    package PressureLoss "Package for calculation of pressure loss"
    extends Modelica_Icons.VariantsPackage;

      package Bend "Package for pressure loss calculation of bends"
      extends Modelica_Icons.VariantsPackage;

        function dp_curvedOverall_DP
          "Pressure loss of curved bend | calculate pressure loss | overall flow regime | surface roughness"
          extends Modelica_Icons.Function;
          //SOURCE_1: Idelchik, I.E.: HANDBOOK OF HYDRAULIC RESISTANCE, 3rd edition, 2006.
          //SOURCE_2: Miller, D.S.: INTERNAL FLOW SYSTEMS, 2nd edition, 1984.
          //SOURCE_3: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, Section Lac 6 (Verification)
          //Notation of equations according to SOURCES

          import FD = Modelica_Fluid.Dissipation.PressureLoss.Bend;
          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

          //input records
          input FD.dp_curvedOverall_IN_con IN_con
            "Input record for function dp_curvedOverall_DP"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_curvedOverall_IN_var IN_var
            "Input record for function dp_curvedOverall_DP"
            annotation (Dialog(group="Variable inputs"));
          input SI.MassFlowRate m_flow "Mass flow rate"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.Pressure DP "Output for function dp_curvedOverall_DP";

        protected
          Real MIN=Modelica_Constants.eps;

          SI.Diameter d_hyd=max(MIN, IN_con.d_hyd) "Hydraulic diameter";
          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Circular cross sectional area";
          Real frac_RD=max(MIN, IN_con.R_0/d_hyd) "Relative curvature radius";
          Real k=max(MIN, abs(IN_con.K)/d_hyd) "Relative roughness";
          Real delta=IN_con.delta*180/PI "Angle of turning";
          SI.Length L=IN_con.delta*IN_con.R_0 "Length of flow path";

          //SOURCE_1: p.336, sec.15: definition of flow regime boundaries
          SI.ReynoldsNumber Re_min=1 "Minimum Reynolds number";
          SI.ReynoldsNumber Re_lam_max=6.5e3
            "Maximum Reynolds number for laminar regime (6.5e3)";
          SI.ReynoldsNumber Re_turb_min=4e4
            "Minimum Reynolds number for turbulent regime (4e4)";
          SI.ReynoldsNumber Re_turb_max=3e5
            "Maximum Reynolds number for turbulent regime (3e5)";
          SI.ReynoldsNumber Re_turb_const=1e6
            "Reynolds number for independence on pressure loss coefficient (1e6)";

          SI.ReynoldsNumber Re_lam_leave=min(Re_lam_max, max(1e2, 754*
              Modelica_Math.exp(if k <= 0.007 then 0.0065/0.007 else 0.0065/k)))
            "Start of transition regime for increasing Reynolds number (leaving laminar regime)";

          //SOURCE_1: p.357, diag. 6-1: coefficients for local resistance coefficient [zeta_LOC]:
          //IN_con.R_0/IN_con.d_hyd <= 3
          Real A1=if delta <= 70 then 0.9*sin(delta*PI/180) else if delta >= 100 then
              0.7 + 0.35*delta/90 else 1.0
            "Coefficient considering effect for angle of turning on zeta_LOC";
          Real A2=if frac_RD > 2.0 then 6e2 else if frac_RD <= 2.0 and frac_RD >= 0.7 then
                    (if frac_RD > 1.0 then 1e3 else if frac_RD <= 1.0 and frac_RD > 0.7 then
                    3e3 else 6e3) else 4e3
            "Coefficient considering laminar regime on zeta_LOC";
          Real B1=if frac_RD >= 1.0 then 0.21*(frac_RD)^(-0.5) else 0.21*(frac_RD)^(-2.5)
            "Coefficient considering relative curvature radius (R_0/d_hyd) on zeta_LOC";
          Real C1=1.0
            "Considering relative elongation of cross sectional area on zeta_LOC (here: circular cross sectional area)";
          Utilities.Types.LocalResistanceCoefficient zeta_LOC_sharp_turb=max(MIN,
              A1*B1*C1)
            "Local resistance coefficient for turbulent regime (Re > Re_turb_max)";

          SI.ReynoldsNumber Re=max(Re_min, 4*abs(m_flow)/(PI*IN_con.d_hyd*
              IN_var.eta)) "Reynolds number";

          //mass flow rate boundaries for w.r.t flow regimes
          SI.MassFlowRate m_flow_smooth=Re_min*PI*IN_con.d_hyd*IN_var.eta/4;

          //SOURCE_1: p.357, diag. 6-1, sec. 2 / p.336, sec. 15 (turbulent regime + hydraulically rough):
          //IN_con.R_0/IN_con.d_hyd < 3
          Real C_Re=if frac_RD > 0.7 then 11.5/Re^0.19 else if frac_RD <= 0.7 and
              frac_RD >= 0.55 then 5.45/Re^0.131 else 1 + 4400/Re
            "Correction factor for hydraulically rough turbulent regime (Re_turb_min < Re < Re_turb_max)";

          //SOURCE_1: p.357, diag. 6-1
          //IN_con.R_0/IN_con.d_hyd < 3
          Utilities.Types.LocalResistanceCoefficient zeta_LOC_sharp=if Re <
              Re_lam_leave then A2/Re + zeta_LOC_sharp_turb else if Re <
              Re_turb_min then SMOOTH(
                      Re_lam_leave,
                      Re_turb_min,
                      Re)*(A2/max(Re_lam_leave, Re) + zeta_LOC_sharp_turb) +
              SMOOTH( Re_turb_min,
                      Re_lam_leave,
                      Re)*(C_Re*zeta_LOC_sharp_turb) else if Re < Re_turb_max
               then SMOOTH(
                      Re_turb_min,
                      Re_turb_max,
                      Re)*(C_Re*zeta_LOC_sharp_turb) + SMOOTH(
                      Re_turb_max,
                      Re_turb_min,
                      Re)*zeta_LOC_sharp_turb else zeta_LOC_sharp_turb
            "Local resistance coefficient for R_0/d_hyd < 3";

          Utilities.Types.LocalResistanceCoefficient zeta_LOC=zeta_LOC_sharp
            "Local resistance coefficient";

          //SOURCE_2: p.191, eq. 8.4: considering surface roughness
          //restriction of lambda_FRI at maximum Reynolds number Re=1e6 (SOURCE_2: p.207, sec. 9.2.4)
          Utilities.Types.DarcyFrictionFactor lambda_FRI_rough=0.25/(
              Modelica_Math.log10(k/(3.7*IN_con.d_hyd) + 5.74/min(1e6, max(
              Re_lam_leave, Re))^0.9))^2
            "Darcy friction factor considering surface roughness";

          //SOURCE_2: p.207, sec. 9.2.4: correction factors CF w.r.t.surface roughness
          Real CF_fri=1+SMOOTH(
              Re_lam_max,
              Re_lam_leave,
              Re)*min(1.4, (lambda_FRI_rough*L/d_hyd/zeta_LOC)) + SMOOTH(
              Re_lam_leave,
              Re_lam_max,
              Re) "Correction factor for surface roughness";

          Utilities.Types.PressureLossCoefficient zeta_TOT=max(1, CF_fri)*
              zeta_LOC "Pressure loss coefficient";

          //Documentation

        algorithm
          DP := zeta_TOT*(IN_var.rho/2)*Utilities.Functions.General.SmoothPower(
                    m_flow,
                    m_flow_smooth,
                    2)/max(MIN, (IN_var.rho*A_cross)^2);
        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
            inverse(m_flow=Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_curvedOverall_MFLOW(
                  IN_con,
                  IN_var,
                  DP)),
            Documentation(info="<html>
<p>Calculation of pressure loss in curved bends at overall flow regime for incompressible and single-phase fluid flow through circular cross sectional area considering surface roughness. </p>

<p>Generally this function is numerically best used for the <b>incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. On the other hand the function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_curvedOverall_MFLOW\">dp_curvedOverall_MFLOW</a> is numerically best used for the <b>compressible case </b>if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Bend.dp_curvedOverall\">See more information</a>.</p>
</html>"));
        end dp_curvedOverall_DP;

        function dp_curvedOverall_MFLOW
          "Pressure loss of curved bend | calculate mass flow rate | overall flow regime | surface roughness"
          extends Modelica_Icons.Function;
          //SOURCE_1: Idelchik, I.E.: HANDBOOK OF HYDRAULIC RESISTANCE, 3rd edition, 2006.
          //SOURCE_2: Miller, D.S.: INTERNAL FLOW SYSTEMS, 2nd edition, 1984.
          //SOURCE_3: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, Section Lac 6 (Verification)
          //Notation of equations according to SOURCES

          import FD = Modelica_Fluid.Dissipation.PressureLoss.Bend;
          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

          //input records
          input FD.dp_curvedOverall_IN_con IN_con
            "Input record for function dp_curvedOverall_MFLOW"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_curvedOverall_IN_var IN_var
            "Input record for function dp_curvedOverall_MFLOW"
            annotation (Dialog(group="Variable inputs"));
          input SI.Pressure dp "Pressure loss"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.MassFlowRate M_FLOW
            "Output for function dp_curvedOverall_MFLOW";

        protected
          Real MIN=Modelica_Constants.eps;

          SI.Diameter d_hyd=max(MIN, IN_con.d_hyd) "Hydraulic diameter";
          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Circular cross sectional area";
          Real frac_RD=max(MIN, IN_con.R_0/d_hyd) "Relative curvature radius";
          Real k=max(MIN, abs(IN_con.K)/d_hyd) "Relative roughness";
          Real delta=IN_con.delta*180/PI "Angle of turning";
          SI.Length L=IN_con.delta*IN_con.R_0 "Length of flow path";

          //SOURCE_1: p.336, sec.15: definition of flow regime boundaries
          SI.ReynoldsNumber Re_min=1 "Minimum Reynolds number";
          SI.ReynoldsNumber Re_lam_max=6.5e3
            "Maximum Reynolds number for laminar regime (6.5e3)";
          SI.ReynoldsNumber Re_turb_min=4e4
            "Minimum Reynolds number for turbulent regime (4e4)";
          SI.ReynoldsNumber Re_turb_max=3e5
            "Maximum Reynolds number for turbulent regime (3e5)";
          SI.ReynoldsNumber Re_turb_const=1e6
            "Reynolds number for independence on pressure loss coefficient (1e6)";

          SI.ReynoldsNumber Re_lam_leave=min(Re_lam_max, max(1e2, 754*
              Modelica_Math.exp(if k <= 0.007 then 0.0065/0.007 else 0.0065/k)))
            "Start of transition regime for increasing Reynolds number (leaving laminar regime)";

          //SOURCE_1: p.357, diag. 6-1: coefficients for local resistance coefficient [zeta_LOC]:
          //IN_con.R_0/IN_con.d_hyd <= 3
          Real A1=if delta <= 70 then 0.9*sin(delta/180*PI) else if delta >= 100 then
              0.7 + 0.35*delta/90 else 1.0
            "Coefficient considering effect for angle of turning on zeta_LOC";
          Real A2=if frac_RD > 2.0 then 6e2 else if frac_RD <= 2.0 and frac_RD >= 0.7 then
                    (if frac_RD > 1.0 then 1e3 else if frac_RD <= 1.0 and frac_RD > 0.7 then
                    3e3 else 6e3) else 4e3
            "Coefficient considering laminar regime on zeta_LOC";
          Real B1=if frac_RD >= 1.0 then 0.21*(frac_RD)^(-0.5) else 0.21*(frac_RD)^(-2.5)
            "Coefficient considering relative curvature radius (R_0/d_hyd) on zeta_LOC";
          Real C1=1.0
            "Considering relative elongation of cross sectional area on zeta_LOC (here: circular cross sectional area)";
          Utilities.Types.LocalResistanceCoefficient zeta_LOC_sharp_turb=max(MIN,
              A1*B1*C1)
            "Local resistance coefficient for turbulent regime (Re > Re_turb_max)";

          //SOURCE_1: p.357, diag. 6-1: pressure loss boundaries for w.r.t flow regimes
          //IN_con.R_0/d_hyd <=3
          SI.AbsolutePressure dp_lam_max=(zeta_LOC_sharp_turb + A2/Re_lam_leave)
              *IN_var.rho/2*(Re_lam_leave*IN_var.eta/(IN_var.rho*d_hyd))^2
            "Maximum pressure loss for laminar regime";
          SI.AbsolutePressure dp_turb_min=zeta_LOC_sharp_turb*(if frac_RD > 0.7
               then 11.5/Re_turb_min^0.19 else if frac_RD <= 0.7 and frac_RD
               >= 0.55 then 5.45/Re_turb_min^0.131 else 1 + 4400/Re_turb_min)*
              IN_var.rho/2*(Re_turb_min*IN_var.eta/(IN_var.rho*d_hyd))^2
            "Minimum pressure loss for turbulent regime";
          SI.AbsolutePressure dp_turb_max=zeta_LOC_sharp_turb*(if frac_RD > 0.7
               then 11.5/Re_turb_max^0.19 else if frac_RD <= 0.7 and frac_RD
               >= 0.55 then 5.45/Re_turb_max^0.131 else 1 + 4400/Re_turb_max)*
              IN_var.rho/2*(Re_turb_max*IN_var.eta/(IN_var.rho*d_hyd))^2
            "Maximum pressure loss for turbulent regime";
          SI.AbsolutePressure dp_turb_const=zeta_LOC_sharp_turb*IN_var.rho/2*(
              Re_turb_const*IN_var.eta/(IN_var.rho*d_hyd))^2
            "Pressure loss for independence of Reynolds number on pressure loss coefficient";

          //SOURCE_1: p.357, diag. 6-1: mean velocities for assumed flow regime
          //IN_con.R_0/d_hyd <=3
          SI.Velocity v_lam=(-A2/2*IN_var.eta + 0.5*sqrt(max(MIN, (A2*IN_var.eta)
              ^2 + 8*zeta_LOC_sharp_turb*abs(dp)*IN_var.rho*d_hyd^2)))/
              zeta_LOC_sharp_turb/IN_var.rho/d_hyd
            "Mean velocity in laminar regime (Re < Re_lam_leave)";
          SI.Velocity v_tra=(-A2/2*IN_var.eta + 0.5*sqrt(max(MIN, (A2*IN_var.eta)
              ^2 + 8*zeta_LOC_sharp_turb*abs(dp_lam_max)*IN_var.rho*d_hyd^2)))/
              zeta_LOC_sharp_turb/IN_var.rho/d_hyd
            "Mean velocity in transition regime (Re_lam_leave < Re_turb_min)";
          SI.Velocity v_turb=if frac_RD > 0.7 then (max(MIN, abs(dp))/(IN_var.rho
              /2*11.5*zeta_LOC_sharp_turb)*(IN_var.rho*IN_con.d_hyd/max(MIN,
              IN_var.eta))^0.19)^(1/(2 - 0.19)) else if frac_RD > 0.55 and
              frac_RD < 0.7 then (max(MIN, abs(dp))/(IN_var.rho/2*5.45*
              zeta_LOC_sharp_turb)*(IN_var.rho*IN_con.d_hyd/max(MIN, IN_var.eta))
              ^0.131)^(1/(2 - 0.131)) else -2200/(IN_var.rho*IN_con.d_hyd/
              IN_var.eta) + ((-2200/(IN_var.rho*IN_con.d_hyd/max(MIN, IN_var.eta)))
              ^2 + 2*abs(max(MIN, dp))/max(MIN, IN_var.rho))^0.5
            "Mean velocity in turbulent regime with dependence on pressure loss coefficient (Re_turb_min < Re < Re_turb_max)";
          SI.Velocity v_turb_const=sqrt(max(MIN, 2*abs(dp)/(IN_var.rho*
              zeta_LOC_sharp_turb)))
            "Mean velocity in turbulent regime with independence on pressure loss coefficient (Re > Re_turb_max)";

          //mean velocity under smooth conditions w.r.t flow regime
          SI.Velocity v_smooth=if dp < dp_lam_max then v_lam else if dp <
              dp_turb_min then SMOOTH(
                      dp_lam_max,
                      dp_turb_min,
                      dp)*v_lam + SMOOTH(
                      dp_turb_min,
                      dp_lam_max,
                      dp)*v_turb else if dp < dp_turb_max then v_turb else
              SMOOTH( dp_turb_max,
                      dp_turb_const,
                      dp)*v_turb + SMOOTH(
                      dp_turb_const,
                      dp_turb_max,
                      dp)*v_turb_const
            "Mean velocity under smooth conditions for R_0/d_hyd < 3";

          SI.ReynoldsNumber Re_smooth=max(Re_min, IN_var.rho*v_smooth*d_hyd/
              IN_var.eta) "Reynolds number under smooth conditions";

          //SOURCE_2: p.191, eq. 8.4: considering surface roughness
          //restriction of lambda_FRI at maximum Reynolds number Re=1e6 (SOURCE_2: p.207, sec. 9.2.4)
          Utilities.Types.DarcyFrictionFactor lambda_FRI_rough=0.25/(
              Modelica_Math.log10(k/(3.7*IN_con.d_hyd) + 5.74/min(1e6, max(
              Re_lam_leave, Re_smooth))^0.9))^2
            "Darcy friction factor considering surface roughness";
          Utilities.Types.DarcyFrictionFactor lambda_FRI_smooth=0.25/(
              Modelica_Math.log10(5.74/max(Re_lam_leave, Re_smooth)^0.9))^2
            "Darcy friction factor neglecting surface roughness";

          //SOURCE_2: p.207, sec. 9.2.4: correction factors CF w.r.t.surface roughness
          Real CF_3=1+SMOOTH(
              6e3,
              1e3,
              Re_smooth)*min(1.4, (lambda_FRI_rough*L/d_hyd/zeta_LOC_sharp_turb)) + SMOOTH(
              1e3,
              6e3,
              Re_smooth) "Correction factor for surface roughness";

          SI.Velocity velocity=v_smooth/max(1, CF_3)^(0.5)
            "Corrected velocity considering surface roughness";

          //Documentation

        algorithm
          M_FLOW := sign(dp)*IN_var.rho*A_cross*abs(velocity);

        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
            inverse(dp=Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_curvedOverall_DP(
                  IN_con,
                  IN_var,
                  M_FLOW)),
            Documentation(info="<html>
<p>
Calculation of pressure loss in curved bends at overall flow regime for incompressible and single-phase fluid flow through circular cross sectional area considering surface roughness.
</p>

<p>
Generally this function is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated. On the other hand the function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_curvedOverall_DP\">dp_curvedOverall_DP</a> is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Bend.dp_curvedOverall\">See more information</a> .</p>
</html>"));
        end dp_curvedOverall_MFLOW;

        record dp_curvedOverall_IN_con
          "Input record for function dp_curvedOverall_DP and dp_curvedOverall_MFLOW"

          //bend variables
          extends Utilities.Records.PressureLoss.Bend;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_curvedOverall_DP\"> dp_curvedOverall_DP </a>
and <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_curvedOverall_MFLOW\"> dp_curvedOverall_MFLOW </a>.
</html>"));
        end dp_curvedOverall_IN_con;

        record dp_curvedOverall_IN_var
          "Input record for function dp_curvedOverall_DP and dp_curvedOverall_MFLOW"

          //fluid property variables
          extends Utilities.Records.General.PressureLoss;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_curvedOverall_DP\"> dp_curvedOverall_DP </a>
and <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_curvedOverall_MFLOW\"> dp_curvedOverall_MFLOW </a>.
</html>"));
        end dp_curvedOverall_IN_var;

        function dp_edgedOverall_DP
          "Pressure loss of edged bend | calculate pressure loss | overall flow regime | surface roughness"
          extends Modelica_Icons.Function;
          //SOURCE_1: Idelchik, I.E.: HANDBOOK OF HYDRAULIC RESISTANCE, 3rd edition, 2006.
          //SOURCE_2: Miller, D.S.: INTERNAL FLOW SYSTEMS, 2nd edition, 1984.
          //SOURCE_3: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, Section Lac 6 (Verification)
          //Notation of equations according to SOURCES

          import FD = Modelica_Fluid.Dissipation.PressureLoss.Bend;
          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

          //input records
          input FD.dp_edgedOverall_IN_con IN_con
            "Input record for function dp_edgedOverall_DP"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_edgedOverall_IN_var IN_var
            "Input record for function dp_edgedOverall_DP"
            annotation (Dialog(group="Variable inputs"));
          input SI.MassFlowRate m_flow "Mass flow rate"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.Pressure DP "Output for function dp_edgedOverall_DP";

        protected
          Real MIN=Modelica_Constants.eps;

          SI.Diameter d_hyd=max(MIN, IN_con.d_hyd) "Hydraulic diameter";
          SI.Area A_cross=PI*d_hyd^2/4 "Circular cross sectional area";
          Real k=max(MIN, abs(IN_con.K)/IN_con.d_hyd) "Relative roughness";
          Real delta=IN_con.delta*180/PI "Angle of turning";

          //definition of flow regime boundaries
          //SOURCE_2: p.207, sec. 9.2.4
          //SOURCE_3: p.Lac 6, fig. 16
          SI.ReynoldsNumber Re_min=1 "Minimum Reynolds number";
          SI.ReynoldsNumber Re_lam_min=5e2
            "Start of transition regime for roughness contribution";
          SI.ReynoldsNumber Re_lam_max=1e4
            "End of transition regime for roughness contribution";
          SI.ReynoldsNumber Re_turb_min=1e5
            "Minimum Reynolds number for Reynolds-dependent transition regime";
          SI.ReynoldsNumber Re_turb_max=2e5
            "Maximum Reynolds number for Reynolds-dependent transition regime (k_Re=1)";
          SI.ReynoldsNumber Re_turb_const=1e6
            "Reynolds number for independence on pressure loss coefficient (1e6)";

          //SOURCE_1: p. 81, sec. 2-2-21: start of transition regime
          SI.ReynoldsNumber Re_lam_leave=min(Re_lam_max, max(Re_lam_min, 754*
              Modelica_Math.exp(if k <= 0.007 then 0.0065/0.007 else 0.0065/k)))
            "Start of transition regime for increasing Reynolds number (leaving laminar regime)";

          //SOURCE_1: p.366, diag. 6-7
          Real A=0.95 + 33.5/max(MIN, delta)
            "Coefficient considering effect of angle of turning on zeta_LOC";
          Real C1=1
            "Considering relative elongation of cross sectional area on zeta_LOC (here: circular cross sectional area)";

          //SOURCE_1: p.366, diag. 6-7
          Utilities.Types.LocalResistanceCoefficient zeta_LOC=max(MIN, 0.95*sin(
              PI/180*delta/2)^2 + 2.05*sin(PI/180*delta/2)^4)
            "Local resistance coefficient";

          //SOURCE_1: p.365: Correction w.r.t effect of Reynolds number in laminar regime
          Real B=24.8
            "Coefficient considering effect of Reynolds number on zeta_TOT";
          Real exp=0.263
            "Exponent for Reynolds number correction in laminar regime";

          Real v_min=Re_min*IN_var.eta/(IN_var.rho*d_hyd)
            "Minimum mean velocity for linear interpolation";

          SI.Velocity velocity=m_flow/(IN_var.rho*A_cross) "Mean velocity";
          SI.ReynoldsNumber Re=max(Re_min, IN_var.rho*abs(velocity)*d_hyd/
              IN_var.eta) "Reynolds number";

          //SOURCE_2: p.191, eq. 8.4: considering surface roughness
          Utilities.Types.DarcyFrictionFactor lambda_FRI_rough=0.25/(
              Modelica_Math.log10(k/(3.7*IN_con.d_hyd) + 5.74/max(Re_lam_min,
              Re)^0.9))^2 "Darcy friction factor considering surface roughness";
          Utilities.Types.DarcyFrictionFactor lambda_FRI_smooth=0.25/(
              Modelica_Math.log10(5.74/max(Re_lam_min, Re)^0.9))^2
            "Darcy friction factor neglecting surface roughness";

          //SOURCE_3: Lac 6, Figure 18
          Real CF_fri= SMOOTH(Re_lam_leave, Re_lam_min, Re)*max(1, min(1.4, (lambda_FRI_rough/
              lambda_FRI_smooth))) + SMOOTH(Re_lam_min, Re_lam_leave, Re)
            "Correction factor for surface roughness";

          //SOURCE_2: p.208, diag. 9.3: Correction w.r.t effect of Reynolds number
          Real CF_Re=SMOOTH(
              Re_turb_min,
              Re_turb_max,
              Re)*B/Re^exp + SMOOTH(
              Re_turb_max,
              Re_turb_min,
              Re) "Correction factor for Reynolds number";

          Utilities.Types.PressureLossCoefficient zeta_TOT=A*C1*zeta_LOC*CF_Re*
              CF_fri "Pressure loss coefficient";

        algorithm
          DP := zeta_TOT*(IN_var.rho/2)*Utilities.Functions.General.SmoothPower(
                    velocity,
                    v_min,
                    2);
         annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(m_flow=Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_edgedOverall_MFLOW(
                  IN_con,
                  IN_var,
                  DP)), Documentation(info="<html>
<p>
Calculation of pressure loss in edged bends with sharp corners at overall flow regime for incompressible and single-phase fluid flow through circular cross sectional area considering surface roughness.
</p>

<p>
There are larger pressure losses in an edged bend compared to a curved bend under the same conditions. The effect of a sharp corner in an edged bend on the pressure loss is much larger than the influence of surface roughness.
</p>

<p>
Generally this function is numerically best used for the <b>incompressible case</b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. On the other hand the function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_edgedOverall_MFLOW\">dp_edgedOverall_MFLOW</a> is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Bend.dp_edgedOverall\">See more information</a> .</p>
</html>"));
        end dp_edgedOverall_DP;

        function dp_edgedOverall_MFLOW
          "Pressure loss of edged bend | calculate mass flow rate | overall flow regime | surface roughness"
          extends Modelica_Icons.Function;
          //SOURCE_1: Idelchik, I.E.: HANDBOOK OF HYDRAULIC RESISTANCE, 3rd edition, 2006.
          //SOURCE_2: Miller, D.S.: INTERNAL FLOW SYSTEMS, 2nd edition, 1984.
          //SOURCE_3: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002, Section Lac 6 (Verification)
          //Notation of equations according to SOURCES

          import FD = Modelica_Fluid.Dissipation.PressureLoss.Bend;
          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

          //input records
          input FD.dp_edgedOverall_IN_con IN_con
            "Input record for function dp_edgedOverall_MFLOW"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_edgedOverall_IN_var IN_var
            "Input record for function dp_edgedOverall_MFLOW"
            annotation (Dialog(group="Variable inputs"));
          input SI.Pressure dp "Pressure loss"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.MassFlowRate M_FLOW
            "Output for function dp_edgedOverall_MFLOW";

        protected
          Real MIN=Modelica_Constants.eps;

          SI.Diameter d_hyd=IN_con.d_hyd "Hydraulic diameter";
          SI.Area A_cross=PI*d_hyd^2/4 "Circular cross sectional area";
          Real k=max(MIN, abs(IN_con.K)/IN_con.d_hyd) "Relative roughness";
          Real delta=IN_con.delta*180/PI "Angle of turning";

          //definition of flow regime boundaries
          //SOURCE_2: p.207, sec. 9.2.4
          //SOURCE_3: p.Lac 6, fig. 16
          SI.ReynoldsNumber Re_min=1 "Minimum Reynolds number";
          SI.ReynoldsNumber Re_lam_min=500
            "Start of transition regime for roughness contribution";
          SI.ReynoldsNumber Re_lam_max=1e4
            "End of transition regime for roughness contribution";
          SI.ReynoldsNumber Re_turb_min=1e5
            "Minimum Reynolds number for Reynolds-dependent transition regime";
          SI.ReynoldsNumber Re_turb_max=2e5
            "Maximum Reynolds number for Reynolds-dependent transition regime (k_Re=1)";
          SI.ReynoldsNumber Re_turb_const=1e6
            "Reynolds number for independence on pressure loss coefficient (1e6)";

          //SOURCE_1: p. 81, sec. 2-2-21: start of transition regime
          SI.ReynoldsNumber Re_lam_leave=min(Re_lam_max, max(Re_lam_min, 754*
              Modelica_Math.exp(if k <= 0.007 then 0.0065/0.007 else 0.0065/k)))
            "Start of transition regime for increasing Reynolds number (leaving laminar regime)";

          //SOURCE_1: p.366, diag. 6-7
          Real A=0.95 + 33.5/max(MIN, delta)
            "Coefficient considering effect of angle of turning on zeta_LOC";
          Real C1=1
            "Considering relative elongation of cross sectional area on zeta_LOC (here: circular cross sectional area)";

          //SOURCE_1: p.366, diag. 6-7
          Utilities.Types.LocalResistanceCoefficient zeta_LOC=max(MIN, 0.95*sin(
              PI/180*delta/2)^2 + 2.05*sin(PI/180*delta/2)^4)
            "Local resistance coefficient";

          //SOURCE_1: p.365: Correction w.r.t effect of Reynolds number
          Real B=24.8
            "Coefficient considering effect of Reynolds number on zeta_TOT";
          Real exp=0.263 "Exponent for Reynolds number correction";
          Real pow=(2 - exp) "pressure loss = f(mass flow rate^pow)";
        //   Real k_Re = B/(max(MIN, velocity)*IN_con.d_hyd*IN_var.rho)^exp*IN_var.eta^exp;

          SI.Velocity v_min=Re_min*IN_var.eta/(IN_var.rho*d_hyd)
            "Minimum mean velocity for regularization";

          SI.Pressure dp_min=A*C1*zeta_LOC*(B/2)*(d_hyd/IN_var.eta)^(-exp)*
              IN_var.rho^(1 - exp)*v_min^(pow)
            "Linear smoothing of mass flow rate for decreasing pressure loss";

          SI.Velocity v_lam_min=Re_lam_min*IN_var.eta/(IN_var.rho*d_hyd)
            "Mean velocity for starting of transition to roughness regime";
          SI.Velocity v_lam_leave=Re_lam_leave*IN_var.eta/(IN_var.rho*d_hyd)
            "Mean velocity for end of transition to roughness regime";

          SI.Pressure dp_lam_min=A*C1*zeta_LOC*(B/2)*(d_hyd/IN_var.eta)^(-exp)*
              IN_var.rho^(1 - exp)*v_lam_min^(pow)
            "Pressure loss for starting of transition to roughness regime";

          Utilities.Types.DarcyFrictionFactor lambda_lam_leave_rough=0.25/(
              Modelica_Math.log10(k/(3.7*IN_con.d_hyd) + 5.74/Re_lam_leave^0.9))
              ^2
            "Darcy friction factor considering surface roughness at Re_lem_leave";
          Utilities.Types.DarcyFrictionFactor lambda_lam_leave_smooth=0.25/(
              Modelica_Math.log10(5.74/Re_lam_leave^0.9))^2
            "Darcy friction factor neglecting surface roughness at Re_lam_leave";

          SI.Pressure dp_lam_leave=A*C1*zeta_LOC*(B/2)*max(1, min(1.4, (
              lambda_lam_leave_rough/lambda_lam_leave_smooth)))*(d_hyd/IN_var.eta)
              ^(-exp)*IN_var.rho^(1 - exp)*v_lam_leave^(pow)
            "Pressure loss at end of transition to surface roughness regime";

          Utilities.Types.DarcyFrictionFactor lambda_turb_min_rough=0.25/(
              Modelica_Math.log10(k/(3.7*IN_con.d_hyd) + 5.74/Re_turb_min^0.9))
              ^2
            "Darcy friction factor considering surface roughness at starting transition to constant turbulent regime";
          Utilities.Types.DarcyFrictionFactor lambda_turb_min_smooth=0.25/(
              Modelica_Math.log10(5.74/Re_turb_min^0.9))^2
            "Darcy friction factor neglecting surface roughness at starting transition to constant turbulent regimee";

          Utilities.Types.DarcyFrictionFactor lambda_turb_max_rough=0.25/(
              Modelica_Math.log10(k/(3.7*IN_con.d_hyd) + 5.74/Re_turb_max^0.9))
              ^2
            "Darcy friction factor considering surface roughness at starting transition to constant turbulent regime";
          Utilities.Types.DarcyFrictionFactor lambda_turb_max_smooth=0.25/(
              Modelica_Math.log10(5.74/Re_turb_max^0.9))^2
            "Darcy friction factor neglecting surface roughness at starting transition to constant turbulent regimee";

          SI.Velocity v_turb_min=Re_turb_min*IN_var.eta/(IN_var.rho*d_hyd)
            "Mean velocity for starting of transition to constant turbulent regime";

          SI.Velocity v_turb_max=Re_turb_max*IN_var.eta/(IN_var.rho*d_hyd)
            "Mean velocity for end of transition to constant turbulent regime";

          SI.Pressure dp_turb_min=A*C1*zeta_LOC*(B/2)*max(1, min(1.4, (
              lambda_turb_min_rough/lambda_turb_min_smooth)))*(d_hyd/IN_var.eta)
              ^(-exp)*IN_var.rho^(1 - exp)*v_turb_min^(pow)
            "Pressure loss at starting of transition to constant turbulent regime";

          SI.Pressure dp_turb_max=A*C1*zeta_LOC*max(1, min(1.4, (
              lambda_turb_max_rough/lambda_turb_max_smooth)))*IN_var.rho/2*
              v_turb_max^2
            "Pressure loss at end of transition to constant turbulent regime";

          SI.Velocity v_turb=(A*C1*zeta_LOC*IN_var.rho/2)^(-0.5)*
              Utilities.Functions.General.SmoothPower(
                      abs(dp),
                      dp_min,
                      0.5) "Mean velocity under turbulent conditions";

          SI.Velocity v_lam=(2*(d_hyd/IN_var.eta)^exp/(A*C1*zeta_LOC*B*(IN_var.rho)
              ^(1 - exp)))^(1/pow)*Utilities.Functions.General.SmoothPower(
                      abs(dp),
                      dp_min,
                      1/pow) "Mean velocity under laminar conditions";

          //mean velocity under smooth conditions w.r.t flow regime
          SI.Velocity v_smooth=if abs(dp) > dp_turb_max then v_turb else if abs(
              dp) < dp_turb_min then v_lam else SMOOTH(
                      dp_turb_max,
                      dp_turb_min,
                      abs(dp))*v_turb + SMOOTH(
                      dp_turb_min,
                      dp_turb_max,
                      abs(dp))*v_lam "Mean velocity under smooth conditions";

          SI.ReynoldsNumber Re_smooth=max(Re_min, IN_var.rho*v_smooth*d_hyd/
              IN_var.eta) "Reynolds number under smooth conditions";

          //SOURCE_2: p.191, eq. 8.4: considering surface roughness
          Utilities.Types.DarcyFrictionFactor lambda_FRI_rough=0.25/(
              Modelica_Math.log10(k/(3.7*IN_con.d_hyd) + 5.74/max(Re_lam_min,
              Re_smooth)^0.9))^2
            "Darcy friction factor considering surface roughness";
          Utilities.Types.DarcyFrictionFactor lambda_FRI_smooth=0.25/(
              Modelica_Math.log10(5.74/max(Re_lam_min, Re_smooth)^0.9))^2
            "Darcy friction factor neglecting surface roughness";

          //SOURCE_3: Lac 6, Figure 18
          Real CF_fri= SMOOTH(dp_lam_leave, dp_lam_min, abs(dp))*max(1, min(1.4, (lambda_FRI_rough/
              lambda_FRI_smooth))) + SMOOTH(dp_lam_min, dp_lam_leave, abs(dp))
            "Correction factor for surface roughness";

          SI.Velocity velocity=v_smooth/max(1, CF_fri)^(0.5)
            "Corrected velocity considering surface roughness";

        algorithm
            M_FLOW := sign(dp)*IN_var.rho*A_cross*velocity;

        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(dp=Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_edgedOverall_DP(
                  IN_con,
                  IN_var,
                  M_FLOW)), Documentation(info="<html>
<p>
Calculation of pressure loss in edged bends with sharp corners at overall flow regime for incompressible and single-phase fluid flow through circular cross sectional area considering surface roughness.
</p>

<p>
There are larger pressure losses in an edged bend compared to a curved bend under the same conditions. The effect of a sharp corner in an edged bend on the pressure loss is much larger than the influence of surface roughness.
</p>

<p>
Generally this function is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated. On the other hand the function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_edgedOverall_DP\">dp_edgedOverall_DP</a> is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Bend.dp_edgedOverall\">See more information</a> .</p>
</html>"));
        end dp_edgedOverall_MFLOW;

        record dp_edgedOverall_IN_con
          "Input record for function dp_edgedOverall_DP and dp_edgedOverall_MFLOW"

          //edged bend variables
          extends Utilities.Records.PressureLoss.EdgedBend;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the  pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_edgedOverall_DP\"> dp_edgedOverall_DP </a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_edgedOverall_MFLOW\"> dp_edgedOverall_MFLOW </a>.
</html>"));
        end dp_edgedOverall_IN_con;

        record dp_edgedOverall_IN_var
          "Input record for function dp_edgedOverall_DP and  dp_edgedOverall_MFLOW"

          //fluid property variables
          extends Utilities.Records.General.PressureLoss;
          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the  pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_edgedOverall_DP\"> dp_edgedOverall_DP </a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Bend.dp_edgedOverall_MFLOW\"> dp_edgedOverall_MFLOW </a>.
</html>"));
        end dp_edgedOverall_IN_var;
        annotation (preferredView="info", Documentation(info="<html>
<h4>Bend</h4>
<h5>Curved bend overall flow</h5>
<p>Calculation of pressure loss in curved bends at overall flow regime for incompressible and single-phase fluid flow through circular cross sectional area considering surface roughness.  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Bend.dp_curvedOverall\">See more information</a>. </p>

<h5>Edged bend overall flow</h5>
<p>
Calculation of pressure loss in edged bends with sharp corners at overall flow regime for incompressible and single-phase fluid flow through circular cross sectional area considering surface roughness.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Bend.dp_edgedOverall\">See more information</a> .</p>

</html>"));
      end Bend;

      package Channel "Package for pressure loss calculation of channels"
      extends Modelica_Icons.VariantsPackage;

        function dp_internalFlowOverall_DP
          "Pressure loss of internal flow | calculate pressure loss | overall flow regime | surface roughness | several geometries"
          extends Modelica_Icons.Function;
          //SOURCE_1: Idelchik, I.E.: HANDBOOK OF HYDRAULIC RESISTANCE, 3rd edition, 2006.
          //SOURCE_2: Miller, D.S.: INTERNAL FLOW SYSTEMS, 1978.
          //SOURCE_3: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002
          //Notation of equations according to SOURCES

          import FD = Modelica_Fluid.Dissipation.PressureLoss.Channel;
          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

          //input records
          input FD.dp_internalFlowOverall_IN_con IN_con
            "Input record for function dp_internalFlowOverall_DP"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_internalFlowOverall_IN_var IN_var
            "Input record for function dp_internalFlowOverall_DP"
            annotation (Dialog(group="Variable inputs"));
          input SI.MassFlowRate m_flow "Mass flow rate"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.Pressure DP "Output for function dp_internalFlowOverall_DP";

        protected
          type TYP =
              Utilities.Types.GeometryOfInternalFlow;

          Real MIN=Modelica_Constants.eps;

          SI.Area A_cross=max(MIN, if IN_con.geometry == TYP.Annular then (PI/4)
              *((IN_con.D_ann)^2 - (IN_con.d_ann)^2) else if IN_con.geometry
               == TYP.Circular then PI/4*(IN_con.d_cir)^2 else if IN_con.geometry
               == TYP.Elliptical then PI*IN_con.a_ell*IN_con.b_ell else if
              IN_con.geometry == TYP.Rectangular then IN_con.a_rec*IN_con.b_rec
               else if IN_con.geometry == TYP.Isosceles then 0.5*(IN_con.a_tri*
              IN_con.h_tri) else 0) "Cross sectional area";
          SI.Length perimeter=max(MIN, if IN_con.geometry == TYP.Annular then
              PI*(IN_con.D_ann + IN_con.d_ann) else if IN_con.geometry == TYP.Circular
               then PI*IN_con.d_cir else if IN_con.geometry == TYP.Elliptical
               then PI*(IN_con.a_ell + IN_con.b_ell) else if IN_con.geometry
               == TYP.Rectangular then 2*(IN_con.a_rec + IN_con.b_rec) else if
              IN_con.geometry == TYP.Isosceles then IN_con.a_tri + 2*((IN_con.h_tri)
              ^2 + (IN_con.a_tri/2)^2)^0.5 else 0) "Perimeter";
          SI.Diameter d_hyd=4*A_cross/perimeter "Hydraulic diameter";
          Real beta=IN_con.beta*180/PI "Top angle";

          //SOURCE_2: p.138, sec 8.5
          Real Dd_ann=min(max(MIN, IN_con.d_ann), IN_con.D_ann)/max(MIN, max(IN_con.d_ann,
              IN_con.D_ann))
            "Ratio of small to large diameter of annular geometry";
          Real CF_ann=98.7378*Dd_ann^0.0589
            "Correction factor for annular geometry";
          Real ab_rec=min(IN_con.a_rec, IN_con.b_rec)/max(MIN, max(IN_con.a_rec, IN_con.b_rec))
            "Aspect ratio of rectangular geometry";
          Real CF_rec=-59.85*(ab_rec)^3 + 148.67*(ab_rec)^2 - 128.1*(ab_rec) + 96.1
            "Correction factor for rectangular geometry";
          Real ab_ell=min(IN_con.a_ell, IN_con.b_ell)/max(MIN, max(IN_con.a_ell, IN_con.b_ell))
            "Ratio of small to large length of annular geometry";
          Real CF_ell=-169.2211*(ab_ell)^4 + 260.9028*(ab_ell)^3 - 113.7890*(ab_ell)^2
               + 9.2588*(ab_ell)^1 + 78.7124
            "Correction factor for elliptical geometry";
          Real CF_tri=-0.0013*(min(90, beta))^2 + 0.1577*(min(90, beta)) + 48.5575
            "Correction factor for triangular geometry";
          Real CF_lam=if IN_con.geometry == TYP.Annular then CF_ann else if IN_con.geometry
               == TYP.Circular then 64 else if IN_con.geometry == TYP.Elliptical then
              CF_ell else if IN_con.geometry == TYP.Rectangular then CF_rec else if
              IN_con.geometry == TYP.Isosceles then CF_tri else 0
            "Correction factor for laminar flow";

          //SOURCE_1: p.81, fig. 2-3, sec 21-22: definition of flow regime boundaries
          Real k=max(MIN, abs(IN_con.K)/d_hyd) "Relative roughness";
          SI.ReynoldsNumber Re_lam_min=1e3
            "Minimum Reynolds number for laminar regime";
          SI.ReynoldsNumber Re_lam_max=2090*(1/max(0.007, k))^0.0635
            "Maximum Reynolds number for laminar regime";
          SI.ReynoldsNumber Re_lam_leave=min(Re_lam_max, max(Re_lam_min, 754*
              Modelica_Math.exp(if k <= 0.007 then 0.0065/0.007 else 0.0065/k)))
            "Start of transition regime for increasing Reynolds number (leaving laminar regime)";

          //Adapted mass flow rate for function dp_turbulent of a straight pipe
          SI.MassFlowRate m_flow_turb=m_flow*(PI/4*d_hyd^2)/A_cross
            "Mass flow rate for turbulent calculation";
          SI.Velocity velocity=m_flow/(IN_var.rho*A_cross)
            "Velocity of internal flow";
          SI.ReynoldsNumber Re=IN_var.rho*abs(velocity)*d_hyd/IN_var.eta;

        protected
          StraightPipe.dp_overall_IN_con IN_2_con(
            final roughness=IN_con.roughness,
            final d_hyd=d_hyd,
            final K=IN_con.K,
            final L=IN_con.L) "Input record for turbulent regime"
            annotation (Placement(transformation(extent={{-100,20},{-80,40}})));
          StraightPipe.dp_overall_IN_var IN_2_var(final eta=IN_var.eta, final
              rho=IN_var.rho) "Input record for turbulent regime"
            annotation (Placement(transformation(extent={{-80,20},{-60,40}})));

          //Documentation

        algorithm
          DP := SMOOTH(
                    Re_lam_min,
                    Re_lam_max,
                    Re)*(CF_lam/2)*IN_con.L/d_hyd^2*velocity*IN_var.eta +
            SMOOTH( Re_lam_max,
                    Re_lam_min,
                    Re)*Dissipation.PressureLoss.StraightPipe.dp_turbulent_DP(
                    IN_2_con,
                    IN_2_var,
                    m_flow_turb);
        annotation(Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(m_flow=Modelica_Fluid.Dissipation.PressureLoss.Channel.dp_internalFlowOverall_MFLOW(
                  IN_con,
                  IN_var,
                  DP)), Documentation(info="<html>
<p>
Calculation of pressure loss for an internal flow through different geometries at overall flow regime for incompressible and single-phase fluid flow considering surface roughness.
</p>

<p>
Generally this function is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. On the other hand the function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Channel.dp_internalFlowOverall_MFLOW\">dp_internalFlowOverall_MFLOW</a> is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated.  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Channel.dp_internalFlowOverall\">See more information</a>.
</p>
</html>"));
        end dp_internalFlowOverall_DP;

        function dp_internalFlowOverall_MFLOW
          "Pressure loss of internal flow | calculate mass flow rate | overall flow regime | surface roughness | several geometries"
          extends Modelica_Icons.Function;
          import FD = Modelica_Fluid.Dissipation.PressureLoss.Channel;
          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

          //input records
          input FD.dp_internalFlowOverall_IN_con IN_con
            "Input record for function dp_internalFlowOverall_MFLOW"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_internalFlowOverall_IN_var IN_var
            "Input record for function dp_internalFlowOverall_MFLOW"
            annotation (Dialog(group="Variable inputs"));
          input SI.Pressure dp "Pressure loss"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.MassFlowRate M_FLOW "Output of function dp_overall_MFLOW";

        protected
          type TYP1 =
              Utilities.Types.GeometryOfInternalFlow;
          type TYP2 = Utilities.Types.Roughness;

          Real MIN=Modelica_Constants.eps;

          SI.Area A_cross=max(MIN, if IN_con.geometry == TYP1.Annular then (PI/
              4)*((IN_con.D_ann)^2 - (IN_con.d_ann)^2) else if IN_con.geometry
               == TYP1.Circular then PI/4*(IN_con.d_cir)^2 else if IN_con.geometry
               == TYP1.Elliptical then PI*IN_con.a_ell*IN_con.b_ell else if
              IN_con.geometry == TYP1.Rectangular then IN_con.a_rec*IN_con.b_rec
               else if IN_con.geometry == TYP1.Isosceles then 0.5*(IN_con.a_tri
              *IN_con.h_tri) else 0) "Cross sectional area";
          SI.Length perimeter=max(MIN, if IN_con.geometry == TYP1.Annular then
              PI*(IN_con.D_ann + IN_con.d_ann) else if IN_con.geometry == TYP1.Circular
               then PI*IN_con.d_cir else if IN_con.geometry == TYP1.Elliptical
               then PI*(IN_con.a_ell + IN_con.b_ell) else if IN_con.geometry
               == TYP1.Rectangular then 2*(IN_con.a_rec + IN_con.b_rec) else
              if IN_con.geometry == TYP1.Isosceles then IN_con.a_tri + 2*((
              IN_con.h_tri)^2 + (IN_con.a_tri/2)^2)^0.5 else 0) "Perimeter";
          SI.Diameter d_hyd=4*A_cross/perimeter "Hydraulic diameter";
          Real beta=IN_con.beta*180/PI "Top angle";

          //SOURCE_2: p.138, sec 8.5
          Real Dd_ann=min(max(MIN, IN_con.d_ann), IN_con.D_ann)/max(MIN, max(IN_con.d_ann,
              IN_con.D_ann))
            "Ratio of small to large diameter of annular geometry";
          Real CF_ann=98.7378*Dd_ann^0.0589
            "Correction factor for annular geometry";
          Real ab_rec=min(IN_con.a_rec, IN_con.b_rec)/max(MIN, max(IN_con.a_rec, IN_con.b_rec))
            "Aspect ratio of rectangular geometry";
          Real CF_rec=-59.85*(ab_rec)^3 + 148.67*(ab_rec)^2 - 128.1*(ab_rec) + 96.1
            "Correction factor for rectangular geometry";
          Real ab_ell=min(IN_con.a_ell, IN_con.b_ell)/max(MIN, max(IN_con.a_ell, IN_con.b_ell))
            "Ratio of small to large length of annular geometry";
          Real CF_ell=-169.2211*(ab_ell)^4 + 260.9028*(ab_ell)^3 - 113.7890*(ab_ell)^2
               + 9.2588*(ab_ell)^1 + 78.7124
            "Correction factor for elliptical geometry";
          Real CF_tri=-0.0013*(min(90, beta))^2 + 0.1577*(min(90, beta)) + 48.5575
            "Correction factor for triangular geometry";
          Real CF_lam=if IN_con.geometry == TYP1.Annular then CF_ann else if IN_con.geometry
               == TYP1.Circular then 64 else if IN_con.geometry == TYP1.Elliptical then
                    CF_ell else if IN_con.geometry == TYP1.Rectangular then CF_rec else
                    if IN_con.geometry == TYP1.Isosceles then CF_tri else 0
            "Correction factor for laminar flow";

          //SOURCE_1: p.81, fig. 2-3, sec 21-22: definition of flow regime boundaries
          Real k=max(MIN, abs(IN_con.K)/d_hyd) "Relative roughness";
          SI.ReynoldsNumber Re_lam_min=1e3
            "Minimum Reynolds number for laminar regime";
          SI.ReynoldsNumber Re_lam_max=2090*(1/max(0.007, k))^0.0635
            "Maximum Reynolds number for laminar regime";
          SI.ReynoldsNumber Re_turb_min=4e3
            "Minimum Reynolds number for turbulent regime";

          SI.ReynoldsNumber Re_lam_leave=min(Re_lam_max, max(Re_lam_min, 754*
              Modelica_Math.exp(if k <= 0.007 then 0.0065/0.007 else 0.0065/k)))
            "Start of transition regime for increasing Reynolds number (leaving laminar regime)";

          //determining Darcy friction factor out of pressure loss calculation for straight pipe:
          //dp = lambda_FRI*L/d_hyd*(rho/2)*velocity^2 and assuming lambda_FRI == lambda_FRI_calc/Re^2
          Utilities.Types.DarcyFrictionFactor lambda_FRI_calc=2*abs(dp)*d_hyd^3
              *IN_var.rho/(IN_con.L*IN_var.eta^2)
            "Adapted Darcy friction factor";

          //SOURCE_3: p.Lab 1, eq. 5: determine Re assuming laminar regime
          SI.ReynoldsNumber Re_lam=lambda_FRI_calc/CF_lam
            "Reynolds number assuming laminar regime";

          //SOURCE_3: p.Lab 2, eq. 10: determine Re assuming turbulent regime (Colebrook-White)
          SI.ReynoldsNumber Re_turb=if IN_con.roughness == TYP2.Neglected then
              (max(MIN, lambda_FRI_calc)/0.3164)^(1/1.75) else -2*sqrt(max(
              lambda_FRI_calc, MIN))*Modelica_Math.log10(2.51/sqrt(max(
              lambda_FRI_calc, MIN)) + k/3.7)
            "Reynolds number assuming turbulent regime";

          //determine actual flow regime
          SI.ReynoldsNumber Re_check=if Re_lam < Re_lam_leave then Re_lam else
              Re_turb;
          //determine Re for transition regime
          SI.ReynoldsNumber Re_trans=if Re_lam >= Re_lam_leave then
              Utilities.Functions.General.CubicInterpolation_DP(
                      Re_check,
                      Re_lam_leave,
                      Re_turb_min,
                      k,
                      lambda_FRI_calc) else 0;
          //determine actual Re
          SI.ReynoldsNumber Re=if Re_lam < Re_lam_leave then Re_lam else if
              Re_turb > Re_turb_min then Re_turb else Re_trans;

          StraightPipe.dp_overall_IN_con IN_2_con(
            final roughness=IN_con.roughness,
            final d_hyd=d_hyd,
            final K=IN_con.K,
            final L=IN_con.L) "Input record for turbulent regime"
            annotation (Placement(transformation(extent={{-100,20},{-80,40}})));
          StraightPipe.dp_overall_IN_var IN_2_var(final eta=IN_var.eta, final
              rho=IN_var.rho) "Input record for turbulent regime"
            annotation (Placement(transformation(extent={{-80,20},{-60,40}})));

          //Documentation

        algorithm
          M_FLOW := SMOOTH(
                    Re_lam_min,
                    Re_turb,
                    Re)*IN_var.rho*A_cross*(dp*(2/CF_lam)*(d_hyd^2/IN_con.L)*(1
            /IN_var.eta)) + SMOOTH(
                    Re_turb,
                    Re_lam_min,
                    Re)*(A_cross/((PI/4)*d_hyd^2))*
            StraightPipe.dp_turbulent_MFLOW(
                    IN_2_con,
                    IN_2_var,
                    dp);
        annotation(Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(dp=Modelica_Fluid.Dissipation.PressureLoss.Channel.dp_internalFlowOverall_DP(
                  IN_con,
                  IN_var,
                  M_FLOW)), Documentation(info="<html>
<p>
Calculation of pressure loss for an internal flow through different geometries at overall flow regime for incompressible and single-phase fluid flow considering surface roughness.
</p>

<p>
Generally this function is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated. On the other hand the function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Channel.dp_internalFlowOverall_DP\">dp_internalFlowOverall_DP</a> is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. </p>

<p>
The pressure loss calculation for internal fluid flow in different geometries is further documented  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Channel.dp_internalFlowOverall\">here</a>.
</p>
</html>"));
        end dp_internalFlowOverall_MFLOW;

        record dp_internalFlowOverall_IN_con
          "Input record for function dp_internalFlowOverall_DP and dp_internalFlowOverall_MFLOW"

          //channel variables
          Utilities.Types.Roughness roughness=Dissipation.Utilities.Types.Roughness.Considered
            "Choice of considering surface roughness"
            annotation (Dialog(group="Channel"));
          extends Utilities.Records.PressureLoss.Geometry;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Channel.dp_internalFlowOverall_DP\"> dp_internalFlowOverall_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Channel.dp_internalFlowOverall_MFLOW\"> dp_internalFlowOverall_MFLOW</a>.
</html>"));
        end dp_internalFlowOverall_IN_con;

        record dp_internalFlowOverall_IN_var
          "Input record for function dp_internalFlowOverall_DP and dp_internalFlowOverall_MFLOW"

          //fluid property variables
          extends Utilities.Records.General.PressureLoss;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Channel.dp_internalFlowOverall_DP\"> dp_internalFlowOverall_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Channel.dp_internalFlowOverall_MFLOW\"> dp_internalFlowOverall_MFLOW</a>.
</html>"));
        end dp_internalFlowOverall_IN_var;
        annotation (preferredView="info", Documentation(info="<html>
<h4>Channel</h4>
<h5>Internal overall flow</h5>
<p>
Calculation of pressure loss for an internal flow through different geometries at laminar and turbulent flow regime considering surface roughness.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Channel.dp_internalFlowOverall\">See more information</a>.
</p>
</html>"));
      end Channel;

      package General "Package for generic pressure loss calculations"
      extends Modelica_Icons.VariantsPackage;

        function dp_idealGas_DP
          "Generic pressure loss | calculate pressure loss | ideal gas | mean density"
          extends Modelica_Icons.Function;
          import FD = Modelica_Fluid.Dissipation.PressureLoss.General;
          //input records
          input FD.dp_idealGas_IN_con IN_con
            "Input record for function dp_idealGas_DP"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_idealGas_IN_var IN_var
            "Input record for function dp_idealGas_DP"
            annotation (Dialog(group="Variable inputs"));
          input SI.MassFlowRate m_flow "Mass flow rate"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.Pressure DP "Output for function dp_idealGas_DP";

        protected
          Real Km_internal=IN_con.Km "Coefficient for pressure loss";

          SI.Density rho_internal=IN_var.p_m/(IN_con.R_s*IN_var.T_m)
            "Mean density";
          SI.VolumeFlowRate V_flow=m_flow/rho_internal
            "Volume flow rate [m3/s]";
          SI.VolumeFlowRate V_flow_min=(IN_con.R_s/Km_internal)^(1/IN_con.exp)*
              rho_internal^(1/IN_con.exp - 1)*IN_con.dp_smooth^(1/IN_con.exp)
            "Start of approximation for decreasing volume flow rate";

          //Documentation

        algorithm
          DP := (Km_internal/IN_con.R_s)*(rho_internal)^(IN_con.exp - 1)*
            Utilities.Functions.General.SmoothPower(
                    V_flow,
                    V_flow_min,
                    IN_con.exp);
        annotation (Inline=true, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(m_flow=Modelica_Fluid.Dissipation.PressureLoss.General.dp_idealGas_MFLOW(
                  IN_con,
                  IN_var,
                  DP)), Documentation(info="<html>
<p>
Calculation of a generic pressure loss for an <b> ideal gas </b> using mean density.
</p>

<p>
Generally this  function is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_idealGas_MFLOW\">dp_idealGas_MFLOW</a> is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated.  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_idealGas\">See more information</a>.
</p>
</html>"));
        end dp_idealGas_DP;

        function dp_idealGas_MFLOW
          "Generic pressure loss | calculate mass flow rate | ideal gas | mean density"
          extends Modelica_Icons.Function;
          import FD = Modelica_Fluid.Dissipation.PressureLoss.General;
          //input records
          input FD.dp_idealGas_IN_con IN_con
            "Input record for function dp_idealGas_MFLOW"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_idealGas_IN_var IN_var
            "Input record for function dp_idealGas_MFLOW"
            annotation (Dialog(group="Variable inputs"));
          input SI.Pressure dp "Pressure loss"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.MassFlowRate M_FLOW "Output for function dp_idealGas_MFLOW";

        protected
          Real Km_internal=IN_con.Km "Coefficient for pressure loss";

          SI.Density rho_internal=IN_var.p_m/(IN_con.R_s*IN_var.T_m)
            "Mean density";

          //Documentation

        algorithm
          M_FLOW := (IN_con.R_s/Km_internal)^(1/IN_con.exp)*(rho_internal)^(1/
            IN_con.exp)*Dissipation.Utilities.Functions.General.SmoothPower(
                  dp,
                  IN_con.dp_smooth,
                  1/IN_con.exp);
        annotation (Inline=true, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(dp=Modelica_Fluid.Dissipation.PressureLoss.General.dp_idealGas_DP(
                  IN_con,
                  IN_var,
                  M_FLOW)), Documentation(info="<html>
<p>
Calculation of a generic pressure loss for an <b> ideal gas </b> using mean density.
</p>

<p>
Generally this  function is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_idealGas_DP\">dp_idealGas_DP</a> is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated.  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_idealGas\">See more information</a>.
</p>
</html>"));
        end dp_idealGas_MFLOW;

        record dp_idealGas_IN_con
          "Input record for function dp_idealGas_DP and dp_idealGas_MFLOW"

          //generic variables
          extends Utilities.Records.General.IdealGas_con;

          //linearisation
          SI.Pressure dp_smooth(min=Modelica_Constants.eps)=1
            "Start linearisation for smaller pressure loss"
            annotation (Dialog(group="Linearisation"));

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_idealGas_DP\"> dp_idealGas_DP </a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_idealGas_MFLOW\"> dp_idealGas_MFLOW </a>.
</html>"));

        end dp_idealGas_IN_con;

        record dp_idealGas_IN_var
          "Input record for function dp_idealGas_DP and dp_idealGas_MFLOW"

          //generic variables
          extends Utilities.Records.General.IdealGas_var;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_idealGas_DP\"> dp_idealGas_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_idealGas_MFLOW\"> dp_idealGas_MFLOW</a>.
</html>"));

        end dp_idealGas_IN_var;

        function dp_nominalDensityViscosity_DP
          "Generic pressure loss | calculate mass flow rate | nominal operation point | pressure loss law (exponent) | density and dynamic viscosity dependence"
          extends Modelica_Icons.Function;
          import FD = Modelica_Fluid.Dissipation.PressureLoss.General;

          //input records
          input FD.dp_nominalDensityViscosity_IN_con IN_con
            "Input record for function dp_nominalDensityViscosity_DP"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_nominalDensityViscosity_IN_var IN_var
            "Input record for function dp_nominalDensityViscosity_DP"
            annotation (Dialog(group="Variable inputs"));
          input SI.MassFlowRate m_flow "Mass flow rate"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.Pressure DP
            "Output for function dp_nominalDensityViscosity_DP";

        protected
          SI.MassFlowRate m_flow_smooth=(max(1, 0.01*IN_con.dp_nom)*IN_var.rho/
              IN_con.rho_nom*(1/IN_var.eta*IN_con.eta_nom)^(IN_con.exp_eta)*(1/
              IN_con.m_flow_nom))^(1/IN_con.exp)
            "Start of approximation for decreasing mass flow rate";

          //Documentation

        algorithm
          DP := if IN_con.exp > 1.0 or IN_con.exp < 1.0 then
            Utilities.Functions.General.SmoothPower(
                    m_flow,
                    m_flow_smooth,
                    IN_con.exp)*(IN_var.eta/IN_con.eta_nom)^IN_con.exp_eta*
            IN_con.rho_nom/IN_var.rho*IN_con.dp_nom*(1/IN_con.m_flow_nom)^(
            IN_con.exp) else m_flow/IN_con.m_flow_nom*(IN_var.eta/IN_con.eta_nom)
            ^IN_con.exp_eta*IN_con.rho_nom/IN_var.rho*IN_con.dp_nom;
        annotation (Inline=true, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(m_flow=Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalDensityViscosity_MFLOW(
                  IN_con,
                  IN_var,
                  DP)), Documentation(info="<html>
<p>
Calculation of a generic pressure loss in dependence of nominal fluid variables (e.g., nominal density, nominal dynamic viscosity) at an operation point via interpolation.
This generic function considers the pressure loss law via a pressure loss exponent and the influence of density and dynamic viscosity on pressure loss.
</p>

<p>
Generally this function is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. On the other hand the function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalDensityViscosity_MFLOW\">dp_nominalDensityViscosity_MFLOW</a> is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated.  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_nominalDensityViscosity\">See more information</a>.
</p>
</html>"));
        end dp_nominalDensityViscosity_DP;

        function dp_nominalDensityViscosity_MFLOW
          "Generic pressure loss | calculate M_FLOW (compressible) | nominal operation point | pressure loss law (exponent) | density and dynamic viscosity dependence"
          extends Modelica_Icons.Function;
          import FD = Modelica_Fluid.Dissipation.PressureLoss.General;

          //input records
          input FD.dp_nominalDensityViscosity_IN_con IN_con
            "Input record for function dp_nominalDensityViscosity_MFLOW"
            annotation (Dialog(group="Constant inputs"));

          input FD.dp_nominalDensityViscosity_IN_var IN_var
            "Input record for function dp_nominalDensityViscosity_MFLOW"
            annotation (Dialog(group="Variable inputs"));

          input SI.Pressure dp "Pressure loss"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.MassFlowRate M_FLOW
            "Output for function dp_nominalDensityViscosity_MFLOW";

          //Documentation

        algorithm
          M_FLOW := if IN_con.exp > 1.0 or IN_con.exp < 1.0 then
            Utilities.Functions.General.SmoothPower(
                    dp,
                    0.01*IN_con.dp_nom,
                    1/IN_con.exp)*(IN_con.eta_nom/IN_var.eta)^(IN_con.exp_eta/
            IN_con.exp)*(1/IN_con.dp_nom*IN_var.rho/IN_con.rho_nom)^(1/IN_con.exp)
            *IN_con.m_flow_nom else dp/IN_con.dp_nom*(IN_con.eta_nom/IN_var.eta)
            ^(IN_con.exp_eta)*IN_var.rho/IN_con.rho_nom*IN_con.m_flow_nom;
        annotation (Inline=true, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(dp=Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalDensityViscosity_DP(
                  IN_con,
                  IN_var,
                  M_FLOW)), Documentation(info="<html>
<p>
Calculation of a generic pressure loss in dependence of nominal fluid variables (e.g., nominal density, nominal dynamic viscosity) at an operation point via interpolation.
This generic function considers the pressure loss law via a pressure loss exponent and the influence of density and dynamic viscosity on pressure loss.
</p>

<p>
Generally this function is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated. On the other hand the function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalDensityViscosity_DP\">dp_genericDensityViscosity_DP</a> is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_nominalDensityViscosity\">See more information</a>.
</p>
</html>"));
        end dp_nominalDensityViscosity_MFLOW;

        record dp_nominalDensityViscosity_IN_con
          "Output record for function dp_nominalDensityViscosity_DP and dp_nominalDensityViscosity_MFLOW"

          //generic variables
          extends Utilities.Records.General.NominalDensityViscosity;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalDensityViscosity_DP\"> dp_nominalDensityViscosity_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalDensityViscosity_MFLOW\"> dp_nominalDensityViscosity_MFLOW</a>.
</html>"));
        end dp_nominalDensityViscosity_IN_con;

        record dp_nominalDensityViscosity_IN_var
          "Output record for function dp_nominalDensityViscosity_DP and dp_nominalDensityViscosity_MFLOW"

          //fluid property variables
          extends Utilities.Records.General.PressureLoss;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalDensityViscosity_DP\"> dp_nominalDensityViscosity_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalDensityViscosity_MFLOW\"> dp_nominalDensityViscosity_MFLOW</a>.
</html>"));
        end dp_nominalDensityViscosity_IN_var;

        function dp_nominalPressureLossLawDensity_DP
          "Generic pressure loss | calculate pressure loss | nominal operation point | pressure loss law (coefficient and exponent) | density dependence"
          extends Modelica_Icons.Function;
          import FD = Modelica_Fluid.Dissipation.PressureLoss.General;

          //input records
          input FD.dp_nominalPressureLossLawDensity_IN_con IN_con
            "Input record for function dp_nominalPressureLossLawDensity_DP"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_nominalPressureLossLawDensity_IN_var IN_var
            "Input record for function dp_nominalPressureLossLawDensity_DP"
            annotation (Dialog(group="Variable inputs"));
          input SI.MassFlowRate m_flow "Mass flow rate"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.Pressure DP
            "Output for function dp_nominalPressureLossLawDensity_yesAJac_DP";

        protected
          Real exp_density=if IN_con.target ==Dissipation.Utilities.Types.MassOrVolumeFlowRate.MassFlowRate then
                    1 - IN_con.exp else 1
            "Exponent of density fraction (rho/rho_nom)";
          SI.MassFlowRate m_flow_nom=if IN_con.target == Dissipation.Utilities.Types.MassOrVolumeFlowRate.MassFlowRate
               then IN_con.m_flow_nom else IN_var.rho*IN_con.V_flow_nom
            "Nominal mean flow velocity at operation point";

          SI.MassFlowRate m_flow_linear=(0.01*(IN_con.zeta_TOT_nom/IN_var.zeta_TOT)
              *(IN_con.rho_nom/IN_var.rho)^(exp_density)*(IN_con.A_cross/IN_con.A_cross_nom)
              ^(IN_con.exp)*IN_con.m_flow_nom)^(1/IN_con.exp)
            "Start of approximation for decreasing mass flow rate";

          //Documentation

        algorithm
          DP := if IN_con.exp > 1.0 or IN_con.exp < 1.0 then
            Utilities.Functions.General.SmoothPower(
                    m_flow,
                    m_flow_linear,
                    IN_con.exp)*IN_con.dp_nom*(IN_var.zeta_TOT/IN_con.zeta_TOT_nom)
            *(IN_var.rho/IN_con.rho_nom)^(exp_density)*(IN_con.A_cross_nom/
            IN_con.A_cross)^(IN_con.exp)*(1/IN_con.m_flow_nom)^(IN_con.exp)
             else IN_con.dp_nom*(IN_var.zeta_TOT/IN_con.zeta_TOT_nom)*(IN_var.rho
            /IN_con.rho_nom)^(exp_density)*(IN_con.A_cross_nom/IN_con.A_cross)^
            (1)*(m_flow/IN_con.m_flow_nom)^(1);

        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(m_flow=Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalPressureLossLawDensity_MFLOW(
                  IN_con,
                  IN_var,
                  DP)), Documentation(info="<html>
<p>
Calculation of a generic pressure loss in dependence of nominal fluid variables (e.g., nominal density) via interpolation from an operation point.
This generic function considers the pressure loss law via a nominal pressure loss (dp_nom), a pressure loss coefficient (zeta_TOT) and a pressure loss law exponent (exp) as well as the influence of density on pressure loss.
</p>

<p>
Generally this function is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. On the other hand the function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalPressureLossLawDensity_MFLOW\">dp_nominalPressureLossLawDensity_MFLOW</a> is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_nominalPressureLossLawDensity\">See more information</a>.
</p>
</html>"));
        end dp_nominalPressureLossLawDensity_DP;

        function dp_nominalPressureLossLawDensity_MFLOW
          "Generic pressure loss | calculate mass flow rate | nominal operation point | pressure loss law (coefficient and exponent) | density dependence"
          extends Modelica_Icons.Function;
          import FD = Modelica_Fluid.Dissipation.PressureLoss.General;

          //input records
          input FD.dp_nominalPressureLossLawDensity_IN_con IN_con
            "Input record for function dp_nominalPressureLossLawDensity_MFLOW"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_nominalPressureLossLawDensity_IN_var IN_var
            "Input record for function dp_nominalPressureLossLawDensity_MFLOW"
            annotation (Dialog(group="Variable inputs"));
          input SI.Pressure dp "Pressure loss"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.MassFlowRate M_FLOW
            "Output for function dp_nominalPressurelosslawDensity_MFLOW";

        protected
          Real exp_density=if IN_con.target ==Dissipation.Utilities.Types.MassOrVolumeFlowRate.MassFlowRate then
                    1 - IN_con.exp else 1
            "Exponent of density fraction (rho/rho_nom)";
          SI.MassFlowRate m_flow_nom=if IN_con.target == Dissipation.Utilities.Types.MassOrVolumeFlowRate.MassFlowRate
               then IN_con.m_flow_nom else IN_var.rho*IN_con.V_flow_nom
            "Nominal mean flow velocity at operation point";

          //Documentation

        algorithm
          M_FLOW := if IN_con.exp > 1.0 or IN_con.exp < 1.0 then
            Utilities.Functions.General.SmoothPower(
                    dp,
                    0.01*IN_con.dp_nom,
                    1/IN_con.exp)*IN_con.m_flow_nom*(IN_con.A_cross/IN_con.A_cross_nom)
            *(IN_con.rho_nom/IN_var.rho)^(exp_density/IN_con.exp)*((1/IN_con.dp_nom)
            *(IN_con.zeta_TOT_nom/IN_var.zeta_TOT))^(1/IN_con.exp) else IN_con.m_flow_nom
            *(IN_con.A_cross/IN_con.A_cross_nom)*(IN_con.rho_nom/IN_var.rho)^(
            exp_density/1)*((dp/IN_con.dp_nom)*(IN_con.zeta_TOT_nom/IN_var.zeta_TOT))
            ^(1/1);
        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(dp=Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalPressureLossLawDensity_DP(
                  IN_con,
                  IN_var,
                  M_FLOW)), Documentation(info="<html>
<p>
Calculation of a generic pressure loss in dependence of nominal fluid variables (e.g., nominal density) via interpolation from an operation point.
This generic function considers the pressure loss law via a nominal pressure loss (dp_nom), a pressure loss coefficient (zeta_TOT) and a pressure loss law exponent (exp) as well as the influence of density on pressure loss.
</p>

<p>
Generally this function is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated. On the other hand the function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalPressureLossLawDensity_DP\">dp_nominalPressurelosslawDensity_DP</a> is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_nominalPressureLossLawDensity\">See more information</a>.
</p>
</html>"));
        end dp_nominalPressureLossLawDensity_MFLOW;

        record dp_nominalPressureLossLawDensity_IN_con
          "Input record for function dp_nominalPressureLossLawDensity_DP and dp_nominalPressureLossLawDensity_MFLOW"

          //generic variables
          extends Utilities.Records.General.NominalPressureLossLawDensity_con;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalPressureLossLawDensity_DP\"> dp_nominalPressureLosslawDensity_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalPressureLossLawDensity_MFLOW\"> dp_nominalPressureLosslawDensity_MFLOW</a>.
</html>"));
        end dp_nominalPressureLossLawDensity_IN_con;

        record dp_nominalPressureLossLawDensity_IN_var
          "Input record for function dp_nominalPressureLossLawDensity_DP and dp_nominalPressureLossLawDensity_MFLOW"

          //generic variables
          extends Utilities.Records.General.NominalPressureLossLawDensity_var;

          //fluid property variables
          SI.Density rho "Density of fluid"
            annotation (Dialog(group="Fluid properties"));

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalPressureLossLawDensity_DP\"> dp_nominalPressureLosslawDensity_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_nominalPressureLossLawDensity_MFLOW\"> dp_nominalPressureLosslawDensity_MFLOW</a>.
</html>"));
        end dp_nominalPressureLossLawDensity_IN_var;

        function dp_pressureLossCoefficient_DP
          "Generic pressure loss | calculate pressure loss | pressure loss coefficient (zeta_TOT)"
          extends Modelica_Icons.Function;
          import FD = Modelica_Fluid.Dissipation.PressureLoss.General;

          //input records
          input FD.dp_pressureLossCoefficient_IN_con IN_con
            "Input record for dp_pressureLossCoefficient_DP"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_pressureLossCoefficient_IN_var IN_var
            "Input record for dp_pressureLossCoefficient_DP"
            annotation (Dialog(group="Variable inputs"));
          input SI.MassFlowRate m_flow "Mass flow rate"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.Pressure DP
            "Output for function dp_pressureLossCoefficient_DP";

          //Documentation

        algorithm
          DP := 0.5*IN_var.zeta_TOT*Utilities.Functions.General.SmoothPower(
                    m_flow,
                    (IN_con.dp_smooth/(0.5*IN_var.zeta_TOT*IN_var.rho))^0.5*
              IN_var.rho*IN_con.A_cross,
                    2)/(IN_var.rho*(IN_con.A_cross)^2);
        annotation (Inline=true, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(m_flow=Modelica_Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_MFLOW(
                  IN_con,
                  IN_var,
                  DP)), Documentation(info="<html>
<p>
Calculation of a generic pressure loss in dependence of a pressure loss coefficient.
</p>

<p>
Generally this function is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_MFLOW\">dp_pressureLossCoefficient_MFLOW</a> is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_pressureLossCoefficient\">See more information</a>.
</p>
</html>"));
        end dp_pressureLossCoefficient_DP;

        function dp_pressureLossCoefficient_MFLOW
          "Generic pressure loss | calculate mass flow rate | pressure loss coefficient (zeta_TOT)"
          extends Modelica_Icons.Function;
          import FD = Modelica_Fluid.Dissipation.PressureLoss.General;

          //input records
          input FD.dp_pressureLossCoefficient_IN_con IN_con
            "Input record for function dp_pressureLossCoefficient_MFLOW"
            annotation (Dialog(group="Constant inputs"));

          input FD.dp_pressureLossCoefficient_IN_var IN_var
            "Input record for function dp_pressureLossCoefficient_MFLOW"
            annotation (Dialog(group="Variable inputs"));
          input SI.Pressure dp "Pressure loss"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.MassFlowRate M_FLOW
            "Output for function dp_pressureLossCoefficientt_MFLOW";

          //Documentation

        algorithm
          M_FLOW := IN_var.rho*IN_con.A_cross*
            Utilities.Functions.General.SmoothPower(
                    dp,
                    IN_con.dp_smooth,
                    0.5)/(0.5*IN_var.zeta_TOT*IN_var.rho)^0.5;
        annotation (Inline=true, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(dp=Modelica_Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_DP(
                  IN_con,
                  IN_var,
                  M_FLOW)), Documentation(info="<html>
<p>
Calculation of a generic pressure loss in dependence of  a pressure loss coefficient.
</p>

<p>
Generally this  function is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_DP\">dp_pressureLossCoefficient_DP</a> is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_pressureLossCoefficient\">See more information</a>.
</p>
</html>"));
        end dp_pressureLossCoefficient_MFLOW;

        record dp_pressureLossCoefficient_IN_con
          "Input record for function dp_pressureLossCoefficient_DP and dp_pressureLossCoefficient_MFLOW"
          extends Modelica_Icons.Record;

          //generic variables
          SI.Area A_cross=Modelica_Constants.pi*0.1^2/4 "Cross sectional area"
            annotation (Dialog(group="Generic variables"));

          //linearisation
          SI.Pressure dp_smooth=1
            "Start linearisation for decreasing pressure loss"
            annotation (Dialog(group="Linearisation"));

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_DP\"> dp_pressureLossCoefficient_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_MFLOW\"> dp_pressureLossCoefficient_MFLOW</a>.
</html>"));
        end dp_pressureLossCoefficient_IN_con;

        record dp_pressureLossCoefficient_IN_var
          "Input record for function dp_pressureLossCoefficient_DP and dp_pressureLossCoefficient_MFLOW"
          extends Modelica_Icons.Record;

          //generic variables
          Utilities.Types.PressureLossCoefficient zeta_TOT=0.02*1/0.1
            "Pressure loss coefficient"
            annotation (Dialog(group="Generic variables"));

          //fluid property variables
          SI.Density rho "Density of fluid"
            annotation (Dialog(group="FluidProperties"));

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_DP\"> dp_pressureLossCoefficient_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_MFLOW\"> dp_pressureLossCoefficient_MFLOW</a>.
</html>"));
        end dp_pressureLossCoefficient_IN_var;

        function dp_volumeFlowRate_DP
          "Generic pressure loss | calculate pressure loss | quadratic function (dp=a*V_flow^2 + b*V_flow)"
          extends Modelica_Icons.Function;
          import FD = Modelica_Fluid.Dissipation.PressureLoss.General;

          //input records
          input FD.dp_volumeFlowRate_IN_con IN_con
            "Input record for function dp_volumeFlowRate_DP"
            annotation (Dialog(group="Constant inputs"));

          input FD.dp_volumeFlowRate_IN_var IN_var
            "Input record for function dp_volumeFlowRate_DP"
            annotation (Dialog(group="Variable inputs"));
          input SI.MassFlowRate m_flow "Mass flow rate"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.Pressure DP "Output for function dp_volumeFlowRate_DP";

        protected
          Real a=max(Modelica_Constants.eps, abs(IN_con.a));
          Real b=max(Modelica_Constants.eps, abs(IN_con.b));

          SI.VolumeFlowRate V_flow=m_flow/max(Modelica_Constants.eps, IN_var.rho)
            "Volume flow rate";
          SI.Pressure dp_min=IN_con.dp_min
            "Start of approximation for decreasing pressure loss";
          SI.VolumeFlowRate V_flow_smooth=if IN_con.a > 0 then -(b/(2*a) + ((-b
              /(2*a))^2 + dp_min/a)^0.5) else dp_min/b
            "Start of approximation for decreasing volume flow rate";

          //Documentation

        algorithm
          DP := a*Dissipation.Utilities.Functions.General.SmoothPower(
                  V_flow,
                  V_flow_smooth,
                  2) + b*V_flow;
        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(m_flow=Modelica_Fluid.Dissipation.PressureLoss.General.dp_volumeFlowRate_MFLOW(
                  IN_con,
                  IN_var,
                  DP)), Documentation(info="<html>
<p>
Calculation of a generic pressure loss with linear or quadratic dependence on volume flow rate.
The function can be used to calculate pressure loss at known mass flow rate <b> or </b> mass flow rate at known pressure loss.
</p>

<p>
Generally this  function is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_volumeFlowRate_MFLOW\">dp_volumeFlowRate_MFLOW</a> is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_volumeFlowRate\">See more information</a>.
</p>
</html>"));
        end dp_volumeFlowRate_DP;

        function dp_volumeFlowRate_MFLOW
          "Generic pressure loss | calculate mass flow rate | quadratic function (dp=a*V_flow^2 + b*V_flow)"
          extends Modelica_Icons.Function;
          import FD = Modelica_Fluid.Dissipation.PressureLoss.General;

          //input records
          input FD.dp_volumeFlowRate_IN_con IN_con
            "Input record for function dp_volumeFlowRate_MFLOW"
            annotation (Dialog(group="Constant inputs"));

          input FD.dp_volumeFlowRate_IN_var IN_var
            "Input record for function dp_volumeFlowRate_MFLOW"
            annotation (Dialog(group="Variable inputs"));
          input SI.Pressure dp "Pressure loss"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.MassFlowRate M_FLOW
            "Output for function dp_volumeFlowRate_MFLOW";

        protected
          Real a=max(Modelica_Constants.eps, abs(IN_con.a));
          Real b=max(Modelica_Constants.eps, abs(IN_con.b));

          SI.Pressure dp_min=IN_con.dp_min
            "Start of approximation for decreasing pressure loss";

          //Documentation

        algorithm
          M_FLOW := IN_var.rho*(-b/(2*a) +
            Utilities.Functions.General.SmoothPower(
                    (b/(2*a))^2 + (1/a)*dp,
                    (b/(2*a))^2 + (1/a)*dp_min,
                    0.5));
        annotation (Inline=true, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(dp=Modelica_Fluid.Dissipation.PressureLoss.General.dp_volumeFlowRate_DP(
                  IN_con,
                  IN_var,
                  M_FLOW)), Documentation(info="<html>
<p>
Calculation of a generic pressure loss with linear or quadratic dependence on volume flow rate.
The function can be used to calculate pressure loss at known mass flow rate <b> or </b> mass flow rate at known pressure loss.
</p>

<p>
Generally this  function is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_volumeFlowRate_DP\">dp_volumeFlowRate_DP</a> is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_volumeFlowRate\">See more information</a>.
</p>
</html>"));
        end dp_volumeFlowRate_MFLOW;

        record dp_volumeFlowRate_IN_con
          "Input record for function dp_volumeFlowRate_DP and dp_volumeFlowRate_MFLOW"

          //generic variables
          extends Utilities.Records.General.QuadraticVFLOW;

          SI.Pressure dp_min=0.1
            "Start of approximation for decreasing pressure loss";

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
 <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_volumeFlowRate_DP\"> dp_volumeFlowRate_DP</a> and
 <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_volumeFlowRate_MFLOW\"> dp_volumeFlowRate_MFLOW</a>.
</html>"));

        end dp_volumeFlowRate_IN_con;

        record dp_volumeFlowRate_IN_var
          "Input record for function dp_volumeFlowRate_DP and dp_volumeFlowRate_MFLOW"
          extends Modelica_Icons.Record;

          SI.Density rho "Density of fluid"
            annotation (Dialog(group="Fluid properties"));
          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
 <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_volumeFlowRate_DP\"> dp_volumeFlowRate_DP</a> and
 <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.General.dp_volumeFlowRate_MFLOW\"> dp_volumeFlowRate_MFLOW</a>.
</html>"));

        end dp_volumeFlowRate_IN_var;
        annotation (preferredView="info", Documentation(info="<html>
<h4>General</h4>
<h5>General pressure loss for ideal gas</h5>
<p>
Calculation of a generic pressure loss for an <b> ideal gas </b> using mean density.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_idealGas\">See more information</a>.
</p>

<h5>Generic pressure loss depending on density and viscosity </h5>
<p>
Calculation of a generic pressure loss in dependence of nominal fluid variables (e.g., nominal density, nominal dynamic viscosity) at an operation point via interpolation.
This generic function considers the pressure loss law via a pressure loss exponent and the influence of density and dynamic viscosity on pressure loss.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_nominalDensityViscosity\">See more information</a>.
</p>

<h5>Generic pressure loss depending on density</h5>
<p>
Calculation of a generic pressure loss in dependence of nominal fluid variables (e.g., nominal density) via interpolation from an operation point.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_nominalPressureLossLawDensity\">See more information</a>.
</p>

<h5>Generic pressure loss depending on pressure loss coefficient</h5>
<p>
Calculation of a generic pressure loss in dependence of a pressure loss coefficient.
 <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_pressureLossCoefficient\">See more information</a>.
</p>

<h5>Generic pressure loss depending on volume flow rate</h5>
<p>
Calculation of a generic pressure loss with linear or quadratic dependence on volume flow rate.
 <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_volumeFlowRate\">See more information</a>.
</p>
</html>"));
      end General;

      package Orifice "Package for pressure loss calculation of orifices"
      extends Modelica_Icons.VariantsPackage;

        function dp_suddenChange_DP
          "Pressure loss of orifice with sudden change in cross sectional area | calculate pressure loss | turbulent flow regime | smooth surface | arbitrary cross sectional area | without buffles | sharp edge"
          extends Modelica_Icons.Function;
          //SOURCE_1: Idelchik, I.E.: HANDBOOK OF HYDRAULIC RESISTANCE, 3rd edition, 2006.
          //Notation of equations according to SOURCES

          import FD = Modelica_Fluid.Dissipation.PressureLoss.Orifice;

          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

          //input records
          input FD.dp_suddenChange_IN_con IN_con
            "Input record for function dp_suddenChange_DP"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_suddenChange_IN_var IN_var
            "Input record for function dp_suddenChange_DP"
            annotation (Dialog(group="Variable inputs"));
          input SI.MassFlowRate m_flow "Mass flow rate"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.Pressure DP "Output for function dp_suddenChange_DP";

        protected
          Real MIN=Modelica_Constants.eps;
          SI.ReynoldsNumber Re_min=1
            "Minimum Reynolds number for linear smoothing";
          //restriction of local resistance coefficient zeta_LOC >> numerical improvement
          Utilities.Types.LocalResistanceCoefficient zeta_LOC_min=1e-3
            "Minimal local resistance coefficient";

          SI.Area A_1=max(MIN, min(IN_con.A_1, IN_con.A_2))
            "Small cross sectional area of orifice";
          SI.Area A_2=max(MIN, max(IN_con.A_1, IN_con.A_2))
            "Large cross sectional area of orifice";
          SI.Length C_1=max(MIN, min(IN_con.C_1, IN_con.C_2))
            "Perimeter of small cross sectional area of orifice";
          SI.Length C_2=max(MIN, max(IN_con.C_1, IN_con.C_2))
            "perimeter of large cross sectional area of orifice";
          SI.Diameter d_hyd=4*A_1/C_1
            "Hydraulic diameter of small cross sectional area of orifice";

          //sudden expansion  :  SOURCE_1, section 4, diagram 4-1, page 208
          //assumption of Re >= 3.3e3 for sudden expansion
          Utilities.Types.LocalResistanceCoefficient zeta_LOC_exp=max(
              zeta_LOC_min, (1 - A_1/A_2)^2);

          //sudden contraction:  SOURCE_1, section 4, diagram 4-9, page 216 / 217
          //assumption of Re >= 1.0e4 for sudden contraction
          Utilities.Types.LocalResistanceCoefficient zeta_LOC_con=max(
              zeta_LOC_min, 0.5*(1 - A_1/A_2)^0.75);

          SI.Velocity velocity_1=m_flow/(IN_var.rho*A_1)
            "Mean velocity in smaller cross sectional area";

          //determine Reynolds number for small cross sectional area of orifice
          SI.ReynoldsNumber Re=IN_var.rho*d_hyd*velocity_1/IN_var.eta;

          //actual local resistance coefficient
          Utilities.Types.LocalResistanceCoefficient zeta_LOC=zeta_LOC_exp*
              SMOOTH( Re_min,
                      0,
                      Re) + zeta_LOC_con*SMOOTH(
                      -Re_min,
                      0,
                      Re) + zeta_LOC_min*SMOOTH(
                      0,
                      Re_min,
                      abs(Re));

          //Documentation

        algorithm
          DP := zeta_LOC*IN_var.rho/2*(IN_var.eta/IN_var.rho/d_hyd)^2*
            Utilities.Functions.General.SmoothPower(
                    Re,
                    Re_min,
                    2);

        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(m_flow=Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_suddenChange_MFLOW(
                  IN_con,
                  IN_var,
                  DP)), Documentation(info="<html>
<p>
Calculation of the local pressure loss at a sudden change of the cross sectional areas (sudden expansion or sudden contraction) with sharp corners at turbulent flow regime for incompressible and single-phase fluid flow through arbitrary shaped cross sectional area (square, circular, etc.) considering a smooth surface. The flow direction determines the type of the transition. In case of the design flow a sudden expansion will be considered. At flow reversal a sudden contraction will be considered.
</p>

<p>
Generally this  function is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_suddenChange_MFLOW\">dp_suddenChange_MFLOW</a> is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated.  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Orifice.dp_suddenChange\">See more information</a>.
</p>
</html>"));
        end dp_suddenChange_DP;

        function dp_suddenChange_MFLOW
          "Pressure loss of orifice with sudden change in cross sectional area | calculate mass flow rate | turbulent flow regime | smooth surface | arbitrary cross sectional area | without buffles | sharp edge"
          extends Modelica_Icons.Function;
          //SOURCE_1: Idelchik, I.E.: HANDBOOK OF HYDRAULIC RESISTANCE, 3rd edition, 2006.
          //Notation of equations according to SOURCES

          import FD = Modelica_Fluid.Dissipation.PressureLoss.Orifice;
          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

          //input records
          input FD.dp_suddenChange_IN_con IN_con
            "Input record for function dp_suddenChange_MFLOW"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_suddenChange_IN_var IN_var
            "Input record for function dp_suddenChange_MFLOW"
            annotation (Dialog(group="Variable inputs"));
          input SI.Pressure dp "Pressure loss"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.MassFlowRate M_FLOW
            "Output for function dp_suddenChange_MFLOW";

        protected
          Real MIN=Modelica_Constants.eps;
          SI.Pressure dp_min=1 "Pressure loss for linear smoothing";
          //restriction of local resistance coefficient zeta_LOC >> numerical improvement
          Utilities.Types.LocalResistanceCoefficient zeta_LOC_min=1e-3
            "Minimal local resistance coefficient";

          SI.Area A_1=max(MIN, min(IN_con.A_1, IN_con.A_2))
            "Small cross sectional area of orifice";
          SI.Area A_2=max(MIN, max(IN_con.A_1, IN_con.A_2))
            "Large cross sectional area of orifice";

          //sudden expansion  :  SOURCE_1, section 4, diagram 4-1, page 208
          //assumption of Re >= 3.3e3 for sudden expansion
          Utilities.Types.LocalResistanceCoefficient zeta_LOC_exp=max(
              zeta_LOC_min, (1 - A_1/A_2)^2);

          //sudden contraction:  SOURCE_1, section 4, diagram 4-9, page 216 / 217
          //assumption of Re >= 1.0e4 for sudden contraction
          Utilities.Types.LocalResistanceCoefficient zeta_LOC_con=max(
              zeta_LOC_min, 0.5*(1 - A_1/A_2)^0.75);

          //actual local resistance coefficient
          Utilities.Types.LocalResistanceCoefficient zeta_LOC=max(zeta_LOC_min,
              zeta_LOC_exp*SMOOTH(
                      dp_min,
                      0,
                      dp) + zeta_LOC_con*SMOOTH(
                      -dp_min,
                      0,
                      dp)) + zeta_LOC_min*SMOOTH(
                      0,
                      dp_min,
                      abs(dp));

          //Documentation

        algorithm
          M_FLOW := IN_var.rho*A_1*Utilities.Functions.General.SmoothPower(
                    dp,
                    dp_min,
                    0.5)*(max(MIN, 2/(IN_var.rho*zeta_LOC)))^0.5;
        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(dp=Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_suddenChange_DP(
                  IN_con,
                  IN_var,
                  M_FLOW)), Documentation(info="<html>
<p>
Calculation of the local pressure loss at a sudden change of the cross sectional areas (sudden expansion or sudden contraction) with sharp corners at turbulent flow regime for incompressible and single-phase fluid flow through arbitrary shaped cross sectional area (square, circular, etc.) considering a smooth surface. The flow direction determines the type of the transition. In case of the design flow a sudden expansion will be considered. At flow reversal a sudden contraction will be considered.
</p>

<p>
Generally this  function is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_suddenChange_DP\">dp_suddenChange_DP</a> is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated.  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Orifice.dp_suddenChange\">See more information</a>.
</p>
</html>"));
        end dp_suddenChange_MFLOW;

        record dp_suddenChange_IN_con
          "Input record for function dp_suddenChange_DP and dp_suddenChange_MFLOW"

          //orifice variables
          extends Utilities.Records.PressureLoss.SuddenChange;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss functions
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_suddenChange_DP\"> dp_suddenChange_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_suddenChange_MFLOW\"> dp_suddenChange_MFLOW</a>.
</html>"));
        end dp_suddenChange_IN_con;

        record dp_suddenChange_IN_var
          "Input record for function dp_suddenChange_DP and dp_suddenChange_MFLOW"

          //fluid property variables
          extends Utilities.Records.General.PressureLoss;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss functions
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_suddenChange_DP\"> dp_suddenChange_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_suddenChange_MFLOW\"> dp_suddenChange_MFLOW</a>.
</html>"));
        end dp_suddenChange_IN_var;

        function dp_thickEdgedOverall_DP
          "Pressure loss of thick and sharp edged orifice | calculate pressure loss | overall flow regime | constant influence of friction  | arbitrary cross sectional area"
          extends Modelica_Icons.Function;
          //SOURCE_1: Idelchik, I.E.: HANDBOOK OF HYDRAULIC RESISTANCE, 3rd edition, 2006.
          //Notation of equations according to SOURCES

          import FD = Modelica_Fluid.Dissipation.PressureLoss.Orifice;
          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

          //input records
          input FD.dp_thickEdgedOverall_IN_con IN_con
            "Input record for function dp_thickEdgedOverall_DP"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_thickEdgedOverall_IN_var IN_var
            "Input record for function dp_thickEdgedOverall_DP"
            annotation (Dialog(group="Variable inputs"));

          input SI.MassFlowRate m_flow "Mass flow rate"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.Pressure DP "Output for function dp_thickEdgedOverall_DP";

        protected
          Real MIN=Modelica_Constants.eps;

          Utilities.Types.DarcyFrictionFactor lambda_FRI=0.02
            "Assumption for Darcy friction factor in vena contraction according to SOURCE_1";
          SI.ReynoldsNumber Re_min=1;
          SI.ReynoldsNumber Re_lim=1e3
            "Limitation for laminar regime if dp is target";

          SI.Area A_0=IN_con.A_0 "Cross sectional area of vena contraction";
          SI.Area A_1=IN_con.A_1
            "Cross sectional area of large cross sectional area";
          SI.Diameter d_hyd_0=max(MIN, 4*A_0/IN_con.C_0)
            "Hydraulic diameter of vena contraction";
          SI.Diameter d_hyd_1=max(MIN, 4*A_1/IN_con.C_1)
            "Hydraulic diameter of large cross sectional area";
          SI.Length l=IN_con.L "Length of vena contraction";
          Real l_bar=IN_con.L/d_hyd_0;

          //SOURCE_1, section 4, diagram 4-15, page 222:
          Real phi=0.25 + 0.535*min(l_bar, 2.4)^8/(0.05 + min(l_bar, 2.4)^8);
          Real tau=(max(2.4 - l_bar, 0))*10^(-phi);

          Utilities.Types.PressureLossCoefficient zeta_TOT_1=max(MIN, (0.5*(1
               - A_0/A_1)^0.75 + tau*(1 - A_0/A_1)^1.375 + (1 - A_0/A_1)^2 +
              lambda_FRI*l/d_hyd_0)*(A_1/A_0)^2)
            "Pressure loss coefficient w.r.t. to flow velocity in large cross sectional area";
          SI.Velocity v_0=m_flow/(IN_var.rho*A_0)
            "Mean velocity in vena contraction";
          SI.ReynoldsNumber Re=IN_var.rho*v_0*d_hyd_0/max(MIN, IN_var.eta)
            "Reynolds number in vena contraction";

          //Documentation

        algorithm
          DP := zeta_TOT_1*IN_var.rho/2*(IN_var.eta/IN_var.rho/d_hyd_1)^2*
            Utilities.Functions.General.SmoothPower(
                    Re,
                    Re_min,
                    2)*(d_hyd_1/d_hyd_0*A_0/A_1)^2;
        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(m_flow=Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_MFLOW(
                  IN_con,
                  IN_var,
                  DP)), Documentation(info="<html>
<p>
Calculation of pressure loss in thick edged orifices with sharp corners at overall flow regime for incompressible and single-phase fluid flow through an arbitrary shaped cross sectional area (square, circular, etc.) considering constant influence of surface roughness.
</p>

<p>
Generally this  function is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_MFLOW\">dp_thickEdgedOverall_MFLOW</a> is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated.  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Orifice.dp_thickEdgedOverall\">See more information</a>.
</p>
</html>"));
        end dp_thickEdgedOverall_DP;

        function dp_thickEdgedOverall_MFLOW
          "Pressure loss of thick and sharp edged orifice | calculate mass flow rate | overall flow regime | constant influence of friction  | arbitrary cross sectional area"
          extends Modelica_Icons.Function;
          //SOURCE_1: Idelchik, I.E.: HANDBOOK OF HYDRAULIC RESISTANCE, 3rd edition, 2006.
          //Notation of equations according to SOURCES

          import FD = Modelica_Fluid.Dissipation.PressureLoss.Orifice;
          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

          //input records
          input FD.dp_thickEdgedOverall_IN_con IN_con
            "Input record for function dp_thickEdgedOverall_MFLOW"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_thickEdgedOverall_IN_var IN_var
            "Input record for function dp_thickEdgedOverall_MFLOW"
            annotation (Dialog(group="Variable inputs"));

          input SI.Pressure dp "Pressure loss"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.MassFlowRate M_FLOW
            "Output for function dp_thickEdgedOverall_MFLOW";

        protected
          Real MIN=Modelica_Constants.eps;
          Utilities.Types.DarcyFrictionFactor lambda_FRI=0.02
            "Assumption for Darcy friction factor in vena contraction according to SOURCE_1";
          SI.ReynoldsNumber Re_lim=1e3
            "Limitation for laminar regime if dp is target";

          SI.Area A_0=IN_con.A_0 "Cross sectional area of vena contraction";
          SI.Area A_1=IN_con.A_1 "Large cross sectional area";
          SI.Diameter d_hyd_0=max(MIN, 4*A_0/IN_con.C_0)
            "Hydraulic diameter of vena contraction";
          SI.Diameter d_hyd_1=max(MIN, 4*A_1/IN_con.C_1)
            "Hydraulic diameter of large cross sectional area";
          SI.Length l=IN_con.L "Length of vena contraction";
          Real l_bar=IN_con.L/d_hyd_0;

          //SOURCE_1, section 4, diagram 4-15, page 222:
          Real phi=0.25 + 0.535*min(l_bar, 2.4)^8/(0.05 + min(l_bar, 2.4)^8);
          Real tau=(max(2.4 - l_bar, 0))*10^(-phi);

          Utilities.Types.PressureLossCoefficient zeta_TOT_1=max(MIN, (0.5*(1
               - A_0/A_1)^0.75 + tau*(1 - A_0/A_1)^1.375 + (1 - A_0/A_1)^2 +
              lambda_FRI*l/d_hyd_0)*(A_1/A_0)^2)
            "Pressure loss coefficient w.r.t. to flow velocity in large cross sectional area";

          //Documentation

        algorithm
          M_FLOW := IN_var.rho*A_1*Utilities.Functions.General.SmoothPower(
                    dp,
                    IN_con.dp_smooth,
                    0.5)/(0.5*IN_var.rho*zeta_TOT_1)^0.5;
        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(dp=Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_DP(
                  IN_con,
                  IN_var,
                  M_FLOW)), Documentation(info="<html>
<p>
Calculation of pressure loss in thick edged orifices with sharp corners at overall flow regime for incompressible and single-phase fluid flow through an arbitrary shaped cross sectional area (square, circular, etc.) considering constant influence of surface roughness.
</p>

<p>
Generally this  function is numerically best used for the <b> compressible case </b>, where the pressure loss (dp) is known (out of pressures as state variable) in the used model and the corresponding mass flow rate (M_FLOW) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_DP\">dp_thickEdgedOverall_DP</a> is numerically best used for the <b> incompressible case </b> if the mass flow rate (m_flow) is known (as state variable) and the pressure loss (DP) has to be calculated.  <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Orifice.dp_thickEdgedOverall\">See more information</a>.
</p>
</html>"));
        end dp_thickEdgedOverall_MFLOW;

        record dp_thickEdgedOverall_IN_con
          "Input record for function dp_thickEdgedOverall_DP and dp_thickEdgedOverall_MFLOW"

          //orifice variables
          extends Utilities.Records.PressureLoss.Orifice;

          //linearisation
          SI.Pressure dp_smooth(min=Modelica_Constants.eps)=1
            "Start linearisation for decreasing pressure loss"
            annotation (Dialog(group="Linearisation"));

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss functions
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_DP\"> dp_thickEdgedOverall_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_MFLOW\"> dp_thickEdgedOverall_MFLOW</a>.
</html>"));
        end dp_thickEdgedOverall_IN_con;

        record dp_thickEdgedOverall_IN_var
          "Input record for function dp_thickEdgedOverall_DP and dp_thickEdgedOverall_MFLOW"

          //fluid property variables
          extends Utilities.Records.General.PressureLoss;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss functions
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_DP\"> dp_thickEdgedOverall_DP </a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Orifice.dp_thickEdgedOverall_MFLOW\"> dp_thickEdgedOverall_MFLOW </a>.
</html>"));
        end dp_thickEdgedOverall_IN_var;
        annotation (preferredView="info", Documentation(info="<html>
<h4>Orifice</h4>
<h5>Sudden change</h5>
<p>
Calculation of the local pressure loss at a sudden change of the cross sectional areas (sudden expansion or sudden contraction) with sharp corners at turbulent flow regime for incompressible and single-phase fluid flow through arbitrary shaped cross sectional area (square, circular, etc.) considering a smooth surface.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Orifice.dp_suddenChange\">See more information</a>.
</p>

<h5>Thick edged orifice</h5>
<p>
Calculation of pressure loss in thick edged orifices with sharp corners at overall flow regime for incompressible and single-phase fluid flow through an arbitrary shaped cross sectional area (square, circular, etc.) considering constant influence of surface roughness.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Orifice.dp_thickEdgedOverall\">See more information</a>.
</p>
</html>"));
      end Orifice;

      package StraightPipe
        "Package for pressure loss calculation of straight pipes"
      extends Modelica_Icons.VariantsPackage;

        function dp_laminar_DP
          "Pressure loss of straight pipe | calculate pressure loss| laminar flow regime (Hagen-Poiseuille)"
          extends Modelica_Icons.Function;
          //SOURCE_1: Idelchik, I.E.: HANDBOOK OF HYDRAULIC RESISTANCE, 3rd edition, 2006.

          import FD = Modelica_Fluid.Dissipation.PressureLoss.StraightPipe;

          //input records
          input FD.dp_laminar_IN_con IN_con
            "Input record for function dp_laminar_DP"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_laminar_IN_var IN_var
            "Input record for function dp_laminar_DP"
            annotation (Dialog(group="Variable inputs"));
          input SI.MassFlowRate m_flow "Mass flow rate"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.Pressure DP "Output for function dp_laminar_DP";

        protected
          Real MIN=Modelica_Constants.eps;

          SI.Diameter d_hyd=IN_con.d_hyd "Hydraulic diameter";
          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Circular cross sectional area";

          SI.Velocity velocity=m_flow/max(MIN, IN_var.rho*A_cross)
            "Mean velocity";

          //Documentation

        algorithm
          DP := 32*IN_var.eta*velocity*IN_con.L/d_hyd^2;
        annotation(Inline=true, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(m_flow=Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_MFLOW(
                  IN_con,
                  IN_var,
                  DP)), Documentation(info="<html>
<p>
Calculation of pressure loss in a straight pipe for <b> laminar </b> flow regime of an incompressible and single-phase fluid flow only.
</p>

<p>
Generally this  function is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_MFLOW\">dp_laminar_MFLOW</a> is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated.   <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.StraightPipe.dp_laminar\">See more information</a>.
</p>
</html>"));
        end dp_laminar_DP;

        function dp_laminar_MFLOW
          "Pressure loss of straight pipe | calculate mass flow rate | laminar flow regime (Hagen-Poiseuille)"
          extends Modelica_Icons.Function;
          //SOURCE_1: Idelchik, I.E.: HANDBOOK OF HYDRAULIC RESISTANCE, 3rd edition, 2006.

          import FD = Modelica_Fluid.Dissipation.PressureLoss.StraightPipe;

          //input records
          input FD.dp_laminar_IN_con IN_con
            "Input record for function dp_laminar_MFLOW"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_laminar_IN_var IN_var
            "Input record for function dp_laminar_MFLOW"
            annotation (Dialog(group="Variable inputs"));
          input SI.Pressure dp "Pressure loss"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.MassFlowRate M_FLOW "Output for function dp_laminar_MFLOW";

        protected
          Real MIN=Modelica_Constants.eps;

          SI.Diameter d_hyd=max(MIN, IN_con.d_hyd) "Hydraulic diameter";
          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Circular cross sectional area";

          //Documentation

        algorithm
          M_FLOW := IN_var.rho*A_cross*(dp*d_hyd^2/(32*IN_var.eta*IN_con.L));
        annotation (Inline=true, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(dp=Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_DP(
                  IN_con,
                  IN_var,
                  M_FLOW)), Documentation(info="<html>
<p>
Calculation of pressure loss in a straight pipe for <b> laminar </b> flow regime of an incompressible and single-phase fluid flow only.
</p>

<p>
Generally this  function is numerically best used for the <b> compressible case </b>, where the pressure loss (dp) is known (out of pressures as state variable) in the used model and the corresponding mass flow rate (M_FLOW) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_DP\">dp_laminar_DP</a> is numerically best used for the <b> incompressible case </b> if the mass flow rate (m_flow) is known (as state variable) and the pressure loss (DP) has to be calculated.   <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.StraightPipe.dp_laminar\">See more information</a>.
</p>
</html>"));
        end dp_laminar_MFLOW;

        record dp_laminar_IN_con
          "Input record for function dp_laminar_DP and dp_laminar_MFLOW"
          extends Utilities.Records.PressureLoss.StraightPipe;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_DP\"> dp_laminar_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_MFLOW\"> dp_laminar_MFLOW</a>.
</html>"));

        end dp_laminar_IN_con;

        record dp_laminar_IN_var
          "Input record for function dp_laminar_DP and dp_laminar_MFLOW"

          extends dp_overall_IN_var;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_DP\"> dp_laminar_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_MFLOW\"> dp_laminar_MFLOW</a>.
</html>"));

        end dp_laminar_IN_var;

        function dp_overall_DP
          "Pressure loss of straight pipe | calculate pressure loss | overall flow regime | surface roughness"
          extends Modelica_Icons.Function;
          import FD = Modelica_Fluid.Dissipation.PressureLoss.StraightPipe;
          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

          //input records
          input FD.dp_overall_IN_con IN_con
            "Input record for function dp_overall_DP"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_overall_IN_var IN_var
            "Input record for function dp_overall_DP"
            annotation (Dialog(group="Variable inputs"));
          input SI.MassFlowRate m_flow "Mass flow rate"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.Pressure DP "Output for function dp_overall_DP";

        protected
          Real MIN=Modelica_Constants.eps;

          SI.Diameter d_hyd=max(MIN, IN_con.d_hyd) "Hydraulic diameter";
          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Circular cross sectional area";
          Real k=max(MIN, abs(IN_con.K)/IN_con.d_hyd) "Relative roughness";
          SI.Length perimeter=PI*IN_con.d_hyd "Perimeter";

          //SOURCE_1: p.81, fig. 2-3, sec 21-22: definition of flow regime boundaries
          SI.ReynoldsNumber Re_lam_min=1e3
            "Minimum Reynolds number for laminar regime";
          SI.ReynoldsNumber Re_lam_max=2090*(1/max(0.007, k))^0.0635
            "Maximum Reynolds number for laminar regime";
          SI.ReynoldsNumber Re_lam_leave=min(Re_lam_max, max(Re_lam_min, 754*
              Modelica_Math.exp(if k <= 0.007 then 0.0065/0.007 else 0.0065/k)))
            "Start of transition regime for increasing Reynolds number (leaving laminar regime)";

          SI.ReynoldsNumber Re=Utilities.Functions.General.ReynoldsNumber(
                      A_cross,
                      perimeter,
                      IN_var.rho,
                      IN_var.eta,
                      m_flow);

          dp_laminar_IN_con IN_con_lam(d_hyd=IN_con.d_hyd, L= IN_con.L);
        algorithm
          DP := SMOOTH(
                    Re_lam_min,
                    Re_lam_max,
                    Re)*Dissipation.PressureLoss.StraightPipe.dp_laminar_DP(
                    IN_con_lam,
                    IN_var,
                    m_flow) + SMOOTH(
                    Re_lam_max,
                    Re_lam_min,
                    Re)*Dissipation.PressureLoss.StraightPipe.dp_turbulent_DP(
                    IN_con,
                    IN_var,
                    m_flow);
        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(m_flow=Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_MFLOW(
                  IN_con,
                  IN_var,
                  DP)), Documentation(info="<html>
<p>
Calculation of pressure loss in a straight pipe for <b> overall </b> flow regime of an incompressible and single-phase fluid flow only considering surface roughness.
</p>

<p>
Generally this  function is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_MFLOW\">dp_overall_MFLOW</a> is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated.   <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.StraightPipe.dp_overall\">See more information</a>.
</p>
</html>"));
        end dp_overall_DP;

        function dp_overall_MFLOW
          "Pressure loss of straight pipe | calculate mass flow rate | overall flow regime | surface roughness"
          extends Modelica_Icons.Function;
          import FD = Modelica_Fluid.Dissipation.PressureLoss.StraightPipe;
          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;
          import Modelica_Fluid.Dissipation.Utilities.Types.Roughness;

          //input records
          input FD.dp_overall_IN_con IN_con
            "Input record for function dp_overall_MFLOW"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_overall_IN_var IN_var
            "Input record for function dp_overall_MFLOW"
            annotation (Dialog(group="Variable inputs"));
          input SI.Pressure dp "Pressure loss"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.MassFlowRate M_FLOW "Output of function dp_overall_MFLOW";

        protected
          Real MIN=Modelica_Constants.eps;

          SI.Diameter d_hyd=max(MIN, IN_con.d_hyd) "Hydraulic diameter";
          SI.Area A_cross=max(MIN, PI*IN_con.d_hyd^2/4)
            "Circular cross sectional area";
          Real k=max(MIN, abs(IN_con.K)/IN_con.d_hyd) "Relative roughness";

          //SOURCE_1: p.81, fig. 2-3, sec 21-22: definition of flow regime boundaries
          SI.ReynoldsNumber Re_lam_min=1e3
            "Minimum Reynolds number for laminar regime";
          SI.ReynoldsNumber Re_lam_max=2090*(1/max(0.007, k))^0.0635
            "Maximum Reynolds number for laminar regime";
          SI.ReynoldsNumber Re_turb_min=4e3
            "Minimum Reynolds number for turbulent regime";

          SI.ReynoldsNumber Re_lam_leave=min(Re_lam_max, max(Re_lam_min, 754*
              Modelica_Math.exp(if k <= 0.007 then 0.0065/0.007 else 0.0065/k)))
            "Start of transition regime for increasing Reynolds number (leaving laminar regime)";

          //determining Darcy friction factor out of pressure loss calculation for straight pipe:
          //dp = lambda_FRI*L/d_hyd*(rho/2)*velocity^2 and assuming lambda_FRI == lambda_FRI_calc/Re^2
          Utilities.Types.DarcyFrictionFactor lambda_FRI_calc=2*abs(dp)*d_hyd^3
              *IN_var.rho/(IN_con.L*IN_var.eta^2)
            "Adapted Darcy friction factor";

          //SOURCE_3: p.Lab 1, eq. 5: determine Re assuming laminar regime (Blasius)
          SI.ReynoldsNumber Re_lam=lambda_FRI_calc/64
            "Reynolds number assuming laminar regime";

          //SOURCE_3: p.Lab 2, eq. 10: determine Re assuming turbulent regime (Colebrook-White)
          SI.ReynoldsNumber Re_turb=if IN_con.roughness == Roughness.Neglected
               then (max(MIN, lambda_FRI_calc)/0.3164)^(1/1.75) else -2*sqrt(
              max(lambda_FRI_calc, MIN))*Modelica_Math.log10(2.51/sqrt(max(
              lambda_FRI_calc, MIN)) + k/3.7)
            "Reynolds number assuming turbulent regime";

          //determine actual flow regime
          SI.ReynoldsNumber Re_check=if Re_lam < Re_lam_leave then Re_lam else
              Re_turb;
          //determine Re for transition regime
          SI.ReynoldsNumber Re_trans=if Re_lam >= Re_lam_leave then
              Utilities.Functions.General.CubicInterpolation_DP(
                      Re_check,
                      Re_lam_leave,
                      Re_turb_min,
                      k,
                      lambda_FRI_calc) else 0;
          //determine actual Re
          SI.ReynoldsNumber Re=if Re_lam < Re_lam_leave then Re_lam else if
              Re_turb > Re_turb_min then Re_turb else Re_trans;

          dp_laminar_IN_con IN_con_lam(d_hyd=IN_con.d_hyd, L= IN_con.L);

        algorithm
          M_FLOW := SMOOTH(
                    Re_lam_min,
                    Re_turb,
                    Re)*Dissipation.PressureLoss.StraightPipe.dp_laminar_MFLOW(
                    IN_con_lam,
                    IN_var,
                    dp) + SMOOTH(
                    Re_turb,
                    Re_lam_min,
                    Re)*
            Dissipation.PressureLoss.StraightPipe.dp_turbulent_MFLOW(
                    IN_con,
                    IN_var,
                    dp);
        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(dp=Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_DP(
                  IN_con,
                  IN_var,
                  M_FLOW)), Documentation(info="<html>
<p>
Calculation of pressure loss in a straight pipe for <b> overall </b> flow regime of an incompressible and single-phase fluid flow only considering surface roughness.
</p>

<p>
Generally this  function is numerically best used for the <b> compressible case </b>, where the pressure loss (dp) is known (out of pressures as state variable) in the used model and the corresponding mass flow rate (M_FLOW) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_DP\">dp_overall_DP</a> is numerically best used for the <b> incompressible case </b> if the mass flow rate (m_flow) is known (as state variable) and the pressure loss (DP) has to be calculated.   <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.StraightPipe.dp_overall\">See more information</a>.
</p>
</html>"));
        end dp_overall_MFLOW;

        record dp_overall_IN_con
          "Input record for function dp_overall_DP and dp_overall_MFLOW"

          //straight pipe variables
          extends dp_turbulent_IN_con;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_DP\"> dp_overall_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_MFLOW\"> dp_overall_MFLOW</a>.
</html>"));

        end dp_overall_IN_con;

        record dp_overall_IN_var
          "Input record for function dp_overall_DP and dp_overall_MFLOW"

          //fluid property variables
          extends Utilities.Records.General.PressureLoss;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_DP\"> dp_overall_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_MFLOW\"> dp_overall_MFLOW</a>.
</html>"));

        end dp_overall_IN_var;

        function dp_turbulent_DP
          "Pressure loss of straight pipe | calculate pressure loss | turbulent flow regime | surface roughness"
          extends Modelica_Icons.Function;
          //SOURCE_1: Idelchik, I.E.: HANDBOOK OF HYDRAULIC RESISTANCE, 3rd edition, 2006.
          //SOURCE_2: Miller, D.S.: INTERNAL FLOW SYSTEMS, 2nd edition, 1984.
          //SOURCE_3: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002.
          import FD = Modelica_Fluid.Dissipation.PressureLoss.StraightPipe;

          //input records
          input FD.dp_turbulent_IN_con IN_con
            "Input record for function dp_turbulent_DP"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_turbulent_IN_var IN_var
            "Input record for function dp_turbulent_DP"
            annotation (Dialog(group="Variable inputs"));
          input SI.MassFlowRate m_flow "Mass flow rate"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.Pressure DP "Output for function dp_turbulent_DP";

        protected
          type TYP1 = Utilities.Types.Roughness;

          Real MIN=Modelica_Constants.eps;

          SI.ReynoldsNumber Re_min=1;
          SI.Velocity v_min=Re_min*IN_var.eta/(IN_var.rho*IN_con.d_hyd);

          SI.Diameter d_hyd=IN_con.d_hyd "Hydraulic diameter";
          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Circular cross sectional area";
          Real k=max(MIN, abs(IN_con.K)/IN_con.d_hyd) "Relative roughness";

          //SOURCE_1: p.81, fig. 2-3, sec 21-22: definition of flow regime boundaries
          SI.ReynoldsNumber Re_lam_min=1e3
            "Minimum Reynolds number for laminar regime";
          SI.ReynoldsNumber Re_lam_max=2090*(1/max(0.007, k))^0.0635
            "Maximum Reynolds number for laminar regime";
          SI.ReynoldsNumber Re_turb_min=4e3
            "Minimum Reynolds number for turbulent regime";

          SI.ReynoldsNumber Re_lam_leave=min(Re_lam_max, max(Re_lam_min, 754*
              Modelica_Math.exp(if k <= 0.007 then 0.0065/0.007 else 0.0065/k)))
            "Start of transition regime for increasing Reynolds number (leaving laminar regime)";

          SI.Velocity velocity=m_flow/(IN_var.rho*A_cross) "Mean velocity";
          SI.ReynoldsNumber Re=max(Re_min, IN_var.rho*abs(velocity)*d_hyd/
              IN_var.eta);

          //SOURCE_2: p.191, eq. 8.4: determining Darcy friction factor
          //assuming lambda_FRI == lambda_FRI_calc/Re^2
          Utilities.Types.DarcyFrictionFactor lambda_FRI_smooth=0.3164*Re^(1.75)
            "Darcy friction factor neglecting surface roughness (Blasius)";
          //here with lambda_FRI_rough == lambda_FRI*Re^2
          Utilities.Types.DarcyFrictionFactor lambda_FRI_rough=0.25*(max(Re,
              Re_lam_leave)/Modelica_Math.log10(k/3.7 + 5.74/max(Re,
              Re_lam_leave)^0.9))^2
            "Darcy friction factor considering surface roughness";
          Utilities.Types.DarcyFrictionFactor lambda_FRI=if IN_con.roughness
               == TYP1.Neglected then lambda_FRI_smooth else lambda_FRI_rough
            "Darcy friction factor";
          Utilities.Types.DarcyFrictionFactor lambda_FRI_calc=if Re <
              Re_lam_leave then 64/Re else if Re > Re_turb_min then lambda_FRI/
              Re^2 else Utilities.Functions.General.CubicInterpolation_MFLOW(
                      Re,
                      Re_lam_leave,
                      Re_turb_min,
                      k)/Re^2 "Darcy friction factor";

          Utilities.Types.PressureLossCoefficient zeta_TOT=lambda_FRI_calc*
              IN_con.L/d_hyd "Pressure loss coefficient";

          //Documentation

        algorithm
          DP := zeta_TOT*(IN_var.rho/2)*Utilities.Functions.General.SmoothPower(
                    velocity,
                    v_min,
                    2);
        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(m_flow=Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_MFLOW(
                  IN_con,
                  IN_var,
                  DP)), Documentation(info="<html>
<p>
Calculation of pressure loss in a straight pipe for <b> turbulent </b> flow regime of an incompressible and single-phase fluid flow only considering surface roughness.
</p>

<p>
Generally this  function is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_MFLOW\">dp_turbulent_MFLOW</a> is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated.   <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.StraightPipe.dp_turbulent\">See more information</a>.
</p>
</html>"));
        end dp_turbulent_DP;

        function dp_turbulent_MFLOW
          "Pressure loss of straight pipe | calculate mass flow rate | turbulent flow regime | surface roughness"
          extends Modelica_Icons.Function;
          //SOURCE_1: Idelchik, I.E.: HANDBOOK OF HYDRAULIC RESISTANCE, 3rd edition, 2006.
          //SOURCE_2: Miller, D.S.: INTERNAL FLOW SYSTEMS, 2nd edition, 1984.
          //SOURCE_3: VDI-Waermeatlas, 9th edition, Springer-Verlag, 2002.

          import FD = Modelica_Fluid.Dissipation.PressureLoss.StraightPipe;

          //input records
          input FD.dp_turbulent_IN_con IN_con
            "Input record for function dp_turbulent_MFLOW"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_turbulent_IN_var IN_var
            "Input record for function dp_turbulent_MFLOW"
            annotation (Dialog(group="Variable inputs"));
          input SI.Pressure dp "Pressure loss"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.MassFlowRate M_FLOW "Mass flow rate";

        protected
          type TYP1 = Utilities.Types.Roughness;

          Real MIN=Modelica_Constants.eps;
          SI.ReynoldsNumber Re_min=1;

          SI.Diameter d_hyd=max(MIN, IN_con.d_hyd) "Hydraulic diameter";
          SI.Area A_cross=PI*IN_con.d_hyd^2/4 "Circular cross sectional area";
          Real k=max(MIN, abs(IN_con.K)/IN_con.d_hyd) "Relative roughness";

          //SOURCE_1: p.81, fig. 2-3, sec 21-22: definition of flow regime boundaries
          SI.ReynoldsNumber Re_lam_min=1e3
            "Minimum Reynolds number for laminar regime";
          SI.ReynoldsNumber Re_lam_max=2090*(1/max(0.007, k))^0.0635
            "Maximum Reynolds number for laminar regime";
          SI.ReynoldsNumber Re_turb_min=4e3
            "Minimum Reynolds number for turbulent regime";

          SI.ReynoldsNumber Re_lam_leave=min(Re_lam_max, max(Re_lam_min, 754*
              Modelica_Math.exp(if k <= 0.007 then 0.0065/0.007 else 0.0065/k)))
            "Start of transition regime for increasing Reynolds number (leaving laminar regime)";

          //determining Darcy friction factor out of pressure loss calculation for straight pipe:
          //dp = lambda_FRI*L/d_hyd*(rho/2)*velocity^2 and assuming lambda_FRI == lambda_FRI_calc/Re^2
          Utilities.Types.DarcyFrictionFactor lambda_FRI_calc=2*abs(dp)*d_hyd^3
              *IN_var.rho/(IN_con.L*IN_var.eta^2)
            "Adapted Darcy friction factor";

          //SOURCE_3: p.Lab 1, eq. 5: determine Re assuming laminar regime (Hagen-Poiseuille)
          SI.ReynoldsNumber Re_lam=lambda_FRI_calc/64
            "Reynolds number assuming laminar regime";

          //SOURCE_3: p.Lab 2, eq. 10: determine Re assuming turbulent regime (Colebrook-White)
          SI.ReynoldsNumber Re_turb=if IN_con.roughness == TYP1.Neglected then
              (max(MIN, lambda_FRI_calc)/0.3164)^(1/1.75) else -2*sqrt(max(
              lambda_FRI_calc, MIN))*Modelica_Math.log10(2.51/sqrt(max(
              lambda_FRI_calc, MIN)) + k/3.7)
            "Reynolds number assuming turbulent regime";

          //determine actual flow regime
          SI.ReynoldsNumber Re_check=if Re_lam < Re_lam_leave then Re_lam else
              Re_turb;
          //determine Re for transition regime
          SI.ReynoldsNumber Re_trans=if Re_lam >= Re_lam_leave then
              Utilities.Functions.General.CubicInterpolation_DP(
                      Re_check,
                      Re_lam_leave,
                      Re_turb_min,
                      k,
                      lambda_FRI_calc) else 0;
          //determine actual Re
          SI.ReynoldsNumber Re=if Re_lam < Re_lam_leave then Re_lam else if
              Re_turb > Re_turb_min then Re_turb else Re_trans;

          //determine velocity
          SI.Velocity velocity=(if dp >= 0 then Re else -Re)*IN_var.eta/(IN_var.rho
              *d_hyd) "Mean velocity";

          //Documentation

        algorithm
          M_FLOW := IN_var.rho*A_cross*velocity;
        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(dp=Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_DP(
                  IN_con,
                  IN_var,
                  M_FLOW)), Documentation(info="<html>
<p>
Calculation of pressure loss in a straight pipe for <b> turbulent </b> flow regime of an incompressible and single-phase fluid flow only considering surface roughness.
</p>

<p>
Generally this function is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_DP\">dp_turbulent_DP</a> is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated.   <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.StraightPipe.dp_turbulent\">See more information</a>.
</p>
</html>"));
        end dp_turbulent_MFLOW;

        record dp_turbulent_IN_con
          "Input record for function dp_turbulent_DP and dp_turbulent_MFLOW"

          Utilities.Types.Roughness roughness=Dissipation.Utilities.Types.Roughness.Neglected
            "Choice of considering surface roughness"
            annotation (Dialog(group="Straight pipe"));

          extends Utilities.Records.PressureLoss.StraightPipe;

          SI.Length K=0 "Roughness (average height of surface asperities)"
            annotation (Dialog(group="Straight pipe"));

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_DP\"> dp_turbulent_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_MFLOW\"> dp_turbulent_MFLOW</a>.
</html>"));
        end dp_turbulent_IN_con;

        record dp_turbulent_IN_var
          "Input record for function dp_turbulent_DP and dp_turbulent_MFLOW"

          extends dp_overall_IN_var;

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_DP\"> dp_turbulent_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_MFLOW\"> dp_turbulent_MFLOW</a>.
</html>"));
        end dp_turbulent_IN_var;

        function dp_twoPhaseOverall_DP
          "Pressure loss of straight pipe for two phase flow | calculate (frictional, momentum, geodetic) pressure loss"
          extends Modelica_Icons.Function;
          //SOURCE_1: Friedel,L.:IMPROVED FRICTION PRESSURE DROP CORRELATIONS FOR HORIZONTAL AND VERTICAL TWO PHASE PIPE FLOW, 3R International, Vol. 18, Issue 7, pp. 485-491, 1979
          //SOURCE_2: Chisholm,D.:PRESSURE GRADIENTS DUE TO FRICTION DURING THE FLOW OF EVAPORATING TWO-PHASE MIXTURES IN SMOOTH TUBES AND CHANNELS, Int. J. Heat Mass Transfer, Vol. 16, pp. 347-358, Pergamon Press 1973
          //SOURCE_3: VDI-Waermeatlas, 10th edition, Springer-Verlag, 2006.
          //SOURCE 4: J.M. Jensen and H. Tummescheit. Moving boundary models for dynamic simulations of two-phase flows. In Proceedings of the 2nd International Modelica Conference, pp. 235-244, Oberpfaffenhofen, Germany, 2002. The Modelica Association.
          //SOURCE_5: Thome, J.R., Engineering Data Book 3, Swiss Federal Institute of Technology Lausanne (EPFL), 2009.

          //input records
          input dp_twoPhaseOverall_IN_con IN_con
            "Input record for function dp_twoPhaseOverall_DP"
            annotation (Dialog(group="Constant inputs"));
          input dp_twoPhaseOverall_IN_var IN_var
            "Input record for function dp_twoPhaseOverall_DP"
            annotation (Dialog(group="Variable inputs"));
          input SI.MassFlowRate m_flow "Mass flow rate"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.Pressure DP "Two phase pressure loss";

        protected
          type TYP =
              Utilities.Types.TwoPhaseFrictionalPressureLoss;

          Real MIN=Modelica_Constants.eps;

          SI.Area A_cross=max(MIN, IN_con.A_cross) "Cross sectional area";
          SI.Diameter d_hyd=max(MIN, 4*A_cross/max(MIN, IN_con.perimeter))
            "Hydraulic diameter";

          Real mdot_A=abs(m_flow)/A_cross "Mass flux";
          Real xflowEnd=min(1, max(0, abs(IN_var.x_flow_end)))
            "Mass flow rate quality at end of length";
          Real xflowSta=min(1, max(0, abs(IN_var.x_flow_sta)))
            "Mass flow rate quality at start of length";
          Real x_flow=(xflowEnd + xflowSta)/2
            "Mean mass flow rate quality over length";

          //SOURCE_5: p.17-1 to 17-5, sec. 17.1 to 17.2: Considering cross sectional void fraction [epsilon=A_g/(A_g+A_l)]
          Real epsilon=
              Utilities.Functions.PressureLoss.TwoPhase.VoidFraction(
              IN_con.voidFractionApproach,
              true,
              IN_var.rho_g,
              IN_var.rho_l,
              x_flow) "Void fraction";

          //SOURCE_1: Considering frictional pressure loss w.r.t. to correlation of Friedel
          //SOURCE_2: Considering frictional pressrue loss w.r.t. to correlation of Chisholm
          SI.Pressure DP_fric=if IN_con.frictionalPressureLoss == TYP.Friedel
               then
              Utilities.Functions.PressureLoss.TwoPhase.dp_twoPhaseFriedel_DP(
                      IN_con,
                      IN_var,
                      m_flow) else if IN_con.frictionalPressureLoss == TYP.Chisholm
               then
              Utilities.Functions.PressureLoss.TwoPhase.dp_twoPhaseChisholm_DP(
                      IN_con,
                      IN_var,
                      m_flow) else 0 "Frictional pressure loss";

          //SOURCE_3: p.Lba 4, eq. 22: Considering momentum pressure loss assuming heterogeneous approach for two phase flow
          //Evaporation >> positive momentum pressure loss (assumed vice versa at condensation)
          SI.Pressure DP_mom=if IN_con.momentumPressureLoss then
              Utilities.Functions.PressureLoss.TwoPhase.dp_twoPhaseMomentum_DP(
                      IN_con.voidFractionApproach,
                      IN_con.massFlowRateCorrection,
                      IN_con.A_cross,
                      IN_con.perimeter,
                      IN_var.rho_g,
                      IN_var.rho_l,
                      IN_var.x_flow_end,
                      IN_var.x_flow_sta,
                      abs(m_flow)) else 0 "Momentum pressure loss";

          //SOURCE_3: p.Lbb 1, eq. 4: Considering geodetic pressure loss assuming constant void fraction for flow length
          SI.Pressure DP_geo=if IN_con.geodeticPressureLoss then
              Utilities.Functions.PressureLoss.TwoPhase.dp_twoPhaseGeodetic_DP(
                      IN_con.voidFractionApproach,
                      true,
                      IN_con.length,
                      IN_con.phi,
                      IN_var.rho_g,
                      IN_var.rho_l,
                      IN_var.x_flow) else 0 "Geodetic pressure loss";

          //Documentation
        algorithm
          DP := DP_fric + DP_mom + DP_geo;

        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      Documentation(info="<html>
<p>
Calculation of pressure loss for <b>two phase flow</b> in a horizontal <b>or</b> vertical straight pipe for an overall flow regime considering frictional, momentum and geodetic pressure loss.
</p>

<p>
Generally the pressure loss for two phase flow in a horizontal or a vertical straight pipe can be calculated for the following fluid flow regimes:
</p>
<p>
<b>Horizontal fluid flow</b> [(a) bubble flow, (b) stratified flow, (c) wavy flow, (d) slug flow, (e) annular flow]:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/pic_twoPhaseFlowRegimes_horizontal.png\" alt=\"pic_twoPhaseFlowRegimes_horizontal\"/>
</p>

<p>
<b>Vertical fluid flow</b> [(a) bubble flow, (b) plug slug flow, (c) foam flow, (d) annular streak flow, (e) annular flow]:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/pic_twoPhaseFlowRegimes_vertical.png\" alt=\"pic_twoPhaseFlowRegimes_vertical\"/>
</p>

<p>
 <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.StraightPipe.dp_twoPhaseOverall\">See more information</a>.
</p>
</html>"));
        end dp_twoPhaseOverall_DP;

        record dp_twoPhaseOverall_IN_con
          "Input record for function dp_twoPhaseOverall_DP"

          //choices
          Utilities.Types.TwoPhaseFrictionalPressureLoss frictionalPressureLoss=
              Dissipation.Utilities.Types.TwoPhaseFrictionalPressureLoss.Friedel
            "Choice of frictional pressure loss approach"
            annotation (Dialog(group="Choices"));
          Utilities.Types.VoidFractionApproach voidFractionApproach=Dissipation.Utilities.Types.VoidFractionApproach.Homogeneous
            "Choice of void fraction approach"
            annotation (Dialog(group="Choices"));

          Boolean momentumPressureLoss=false
            "Considering momentum pressure loss"
            annotation (Dialog(group="Choices"));
          Boolean massFlowRateCorrection=false
            "Consider heterogeneous mass flow rate correction" annotation (Dialog(group=
                 "Choices", enable=if momentumPressureLoss then true else false));
          Boolean geodeticPressureLoss=false
            "Considering geodetic pressure loss"
            annotation (Dialog(group="Choices"));

          extends Utilities.Records.General.TwoPhaseFlow_con;
          SI.Angle phi=0 "Tilt angle to horizontal"
            annotation (Dialog(group="Geometry"));

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_twoPhaseOverall_DP\"> dp_twoPhaseOverall_DP</a>.
</html>"));

        end dp_twoPhaseOverall_IN_con;

        record dp_twoPhaseOverall_IN_var
          "Input record for function dp_twoPhaseOverall_DP"

          Real x_flow_end=0 "Mass flow rate quality at end of length"
            annotation (Dialog(group="Fluid properties"));
          Real x_flow_sta=0 "Mass flow rate quality at start of length"
            annotation (Dialog(group="Fluid properties"));
          extends Utilities.Records.General.TwoPhaseFlow_var(final x_flow=(
                x_flow_end + x_flow_sta)/2);

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_twoPhaseOverall_DP\"> dp_twoPhaseOverall_DP</a>.
</html>"));

        end dp_twoPhaseOverall_IN_var;
        annotation (preferredView="info", Documentation(info="<html>
<h4>Straight Pipe</h4>
<h5>Laminar flow</h5>
<p>
Calculation of pressure loss in a straight pipe for <b> laminar </b> flow regime of single-phase fluid flow only.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.StraightPipe.dp_laminar\">See more information</a>.
</p>

<h5>Turbulent flow</h5>
<p>
Calculation of pressure loss in a straight pipe for <b> turbulent </b> flow regime of single-phase fluid flow only considering surface roughness.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.StraightPipe.dp_turbulent\">See more information</a>.
</p>

<h5>Overall flow</h5>
<p>
Calculation of pressure loss in a straight pipe for <b> laminar or turbulent </b> flow regime of single-phase fluid flow only considering surface roughness.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.StraightPipe.dp_overall\">See more information</a>.
</p>

<h5>Two phase overall flow</h5>
<p>
Calculation of pressure loss for <b>two phase flow</b> in a horizontal <b>or</b> vertical straight pipe for an overall flow regime considering frictional, momentum and geodetic pressure loss.
 <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.StraightPipe.dp_twoPhaseOverall\">See more information</a>.
</p>
</html>"));
      end StraightPipe;

      package Valve "Package for pressure loss calculation of valves"
      extends Modelica_Icons.VariantsPackage;

        function dp_severalGeometryOverall_DP
          "Pressure loss of valve | calculate pressure loss | several geometries | overall flow regime"
          extends Modelica_Icons.Function;
          import FD = Modelica_Fluid.Dissipation.PressureLoss.Valve;
          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;
          import TYP = Modelica_Fluid.Dissipation.Utilities.Types;

          //input records
          input FD.dp_severalGeometryOverall_IN_con IN_con
            "Input record for function dp_severalGeometryOverall_DP"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_severalGeometryOverall_IN_var IN_var
            "Input record for function dp_severalGeometryOverall_DP"
            annotation (Dialog(group="Variable inputs"));
          input SI.MassFlowRate m_flow "Mass flow rate"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.Pressure DP "Pressure loss";

        protected
          type TYP1 =
              TYP.ValveCoefficient;
          type TYP2 = TYP.ValveGeometry;

          Real MIN=Modelica_Constants.eps;

          SI.Area Av=if IN_con.valveCoefficient == TYP1.AV then IN_con.Av else
              if IN_con.valveCoefficient == TYP1.KV then IN_con.Kv*27.7e-6
               else if IN_con.valveCoefficient == TYP1.CV then IN_con.Cv*24e-6
               else if IN_con.valveCoefficient == TYP1.OP then IN_con.m_flow_nominal
              /max(MIN, IN_con.opening_nominal*(IN_con.rho_nominal*IN_con.dp_nominal)
              ^0.5) else MIN "Av (metric) flow coefficient [Av]=m^2";

          TYP.PressureLossCoefficient zeta_bal=SMOOTH(
                      0.05,
                      0,
                      IN_var.opening)*10^(-3.8397*IN_var.opening + 2.9449) +
              SMOOTH( 0,
                      0.05,
                      IN_var.opening)*IN_con.zeta_TOT_max "Ball valves";
          TYP.PressureLossCoefficient zeta_dia=SMOOTH(
                      0.05,
                      0,
                      IN_var.opening)*10^(2.2596*exp(-1.8816*IN_var.opening))
               + SMOOTH(
                      0,
                      0.05,
                      IN_var.opening)*IN_con.zeta_TOT_max "Diaphragm valves";
          TYP.PressureLossCoefficient zeta_but=SMOOTH(
                      0.05,
                      0,
                      IN_var.opening)*619.81*exp(-7.3211*IN_var.opening) +
              SMOOTH( 0,
                      0.05,
                      IN_var.opening)*IN_con.zeta_TOT_max "Butterfly valves";
          TYP.PressureLossCoefficient zeta_gat=SMOOTH(
                      0.05,
                      0,
                      IN_var.opening)*51.45*exp(-6.046*IN_var.opening) + SMOOTH(
                      0,
                      0.05,
                      IN_var.opening)*IN_con.zeta_TOT_max "Gate valves";
          TYP.PressureLossCoefficient zeta_slu=SMOOTH(
                      0.05,
                      0,
                      IN_var.opening)*248.89*exp(-7.8265*IN_var.opening) +
              SMOOTH( 0,
                      0.05,
                      IN_var.opening)*IN_con.zeta_TOT_max "Sluice valves";

          TYP.PressureLossCoefficient zeta_TOT=if IN_con.geometry == TYP2.Ball
               then zeta_bal else if IN_con.geometry == TYP2.Diaphragm then
              zeta_dia else if IN_con.geometry == TYP2.Butterfly then zeta_but
               else if IN_con.geometry == TYP2.Gate then zeta_gat else if
              IN_con.geometry == TYP2.Sluice then zeta_slu else 0
            "Pressure loss coefficient of chosen valve";

          Real valveCharacteristic=(2/min(IN_con.zeta_TOT_max, max(MIN, max(IN_con.zeta_TOT_min,
              abs(zeta_TOT)))))^0.5
            "Valve characteristic considering opening of chosen valve";

          SI.MassFlowRate m_flow_small=valveCharacteristic*Av*(IN_var.rho)^0.5*
              (IN_con.dp_small)^0.5 "Mass flow rate at linearisation";

          //Documentation

        algorithm
          DP := 1/((valveCharacteristic*Av)^2*IN_var.rho)*
            Utilities.Functions.General.SmoothPower(
                    m_flow,
                    m_flow_small,
                    2);

        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(m_flow=Modelica_Fluid.Dissipation.PressureLoss.Valve.dp_severalGeometryOverall_MFLOW(
                  IN_con,
                  IN_var,
                  DP)), Documentation(info="<html>
<p>
Calculation of pressure loss for a valve with different geometries at overall flow regime for incompressible and single-phase fluid flow in dependence of its opening.
</p>

<p>
Generally this function is numerically best used for the <b> incompressible case </b>, where the mass flow rate (m_flow) is known (as state variable) in the used model and the corresponding pressure loss (DP) has to be calculated. On the other hand the function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Valve.dp_severalGeometryOverall_MFLOW\">dp_severalGeometryOverall_MFLOW</a> is numerically best used for the <b> compressible case </b> if the pressure loss (dp) is known (out of pressures as state variable) and the mass flow rate (M_FLOW) has to be calculated. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Valve.dp_severalGeometryOverall\">See more information</a>.
</p>
</html>"));
        end dp_severalGeometryOverall_DP;

        function dp_severalGeometryOverall_MFLOW
          "Pressure loss of valve | calculate mass flow rate | several geometries | overall flow regime"
          extends Modelica_Icons.Function;
          import FD = Modelica_Fluid.Dissipation.PressureLoss.Valve;
          import SMOOTH =
            Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;
          import TYP = Modelica_Fluid.Dissipation.Utilities.Types;

          //input records
          input FD.dp_severalGeometryOverall_IN_con IN_con
            "Input record for function dp_severalGeometryOverall_MFLOW"
            annotation (Dialog(group="Constant inputs"));
          input FD.dp_severalGeometryOverall_IN_var IN_var
            "Input record for function dp_severalGeometryOverall_MFLOW"
            annotation (Dialog(group="Variable inputs"));
          input SI.Pressure dp "Pressure loss"
            annotation (Dialog(group="Input"));

          //output variables
          output SI.MassFlowRate M_FLOW "Mass flow rate";

        protected
          type TYP1 =
              TYP.ValveCoefficient;
          type TYP2 = TYP.ValveGeometry;

          Real MIN=Modelica_Constants.eps;

          SI.Area Av=if IN_con.valveCoefficient == TYP1.AV then IN_con.Av else
              if IN_con.valveCoefficient == TYP1.KV then IN_con.Kv*27.7e-6
               else if IN_con.valveCoefficient == TYP1.CV then IN_con.Cv*24e-6
               else if IN_con.valveCoefficient == TYP1.OP then IN_con.m_flow_nominal
              /max(MIN, IN_con.opening_nominal*(IN_con.rho_nominal*IN_con.dp_nominal)
              ^0.5) else MIN "Av (metric) flow coefficient [Av]=m^2";

          TYP.PressureLossCoefficient zeta_bal=SMOOTH(
                      0.05,
                      0,
                      IN_var.opening)*10^(-3.8397*IN_var.opening + 2.9449) +
              SMOOTH( 0,
                      0.05,
                      IN_var.opening)*IN_con.zeta_TOT_max "Ball valves";
          TYP.PressureLossCoefficient zeta_dia=SMOOTH(
                      0.05,
                      0,
                      IN_var.opening)*10^(2.2596*exp(-1.8816*IN_var.opening))
               + SMOOTH(
                      0,
                      0.05,
                      IN_var.opening)*IN_con.zeta_TOT_max "Diaphragm valves";
          TYP.PressureLossCoefficient zeta_but=SMOOTH(
                      0.05,
                      0,
                      IN_var.opening)*619.81*exp(-7.3211*IN_var.opening) +
              SMOOTH( 0,
                      0.05,
                      IN_var.opening)*IN_con.zeta_TOT_max "Butterfly valves";
          TYP.PressureLossCoefficient zeta_gat=SMOOTH(
                      0.05,
                      0,
                      IN_var.opening)*51.45*exp(-6.046*IN_var.opening) + SMOOTH(
                      0,
                      0.05,
                      IN_var.opening)*IN_con.zeta_TOT_max "Gate valves";
          TYP.PressureLossCoefficient zeta_slu=SMOOTH(
                      0.05,
                      0,
                      IN_var.opening)*248.89*exp(-7.8265*IN_var.opening) +
              SMOOTH( 0,
                      0.05,
                      IN_var.opening)*IN_con.zeta_TOT_max "Sluice valves";

          TYP.PressureLossCoefficient zeta_TOT=if IN_con.geometry == TYP2.Ball
               then zeta_bal else if IN_con.geometry == TYP2.Diaphragm then
              zeta_dia else if IN_con.geometry == TYP2.Butterfly then zeta_but
               else if IN_con.geometry == TYP2.Gate then zeta_gat else if
              IN_con.geometry == TYP2.Sluice then zeta_slu else 0
            "Pressure loss coefficient of chosen valve";

          Real valveCharacteristic=(2/min(IN_con.zeta_TOT_max, max(MIN, max(IN_con.zeta_TOT_min,
              abs(zeta_TOT)))))^0.5
            "Valve characteristic considering opening of chosen valve";

          //Documentation

        algorithm
          M_FLOW := valveCharacteristic*Av*(IN_var.rho)^0.5*
            Utilities.Functions.General.SmoothPower(
                    dp,
                    IN_con.dp_small,
                    0.5);
        annotation (Inline=false, smoothOrder(normallyConstant=IN_con) = 2,
                      inverse(dp=Modelica_Fluid.Dissipation.PressureLoss.Valve.dp_severalGeometryOverall_DP(
                  IN_con,
                  IN_var,
                  M_FLOW)), Documentation(info="<html>
<p>
Calculation of pressure loss for a valve with different geometries at overall flow regime for incompressible and single-phase fluid flow in dependence of its opening.
</p>

<p>
Generally this  function is numerically best used for the <b> compressible case </b>, where the pressure loss (dp) is known (out of pressures as state variable) in the used model and the corresponding mass flow rate (M_FLOW) has to be calculated. On the other hand the  function <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Valve.dp_severalGeometryOverall_DP\">dp_severalGeometryOverall_DP</a> is numerically best used for the <b> incompressible case </b> if the mass flow rate (m_flow) is known (as state variable) and the pressure loss (DP) has to be calculated. <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Valve.dp_severalGeometryOverall\">See more information</a>.
</p>
</html>"));
        end dp_severalGeometryOverall_MFLOW;

        record dp_severalGeometryOverall_IN_con
          "Input record for function dp_severalGeometryOverall_DP and dp_severalGeometryOverall_MFLOW"

          extends Modelica_Icons.Record;

          Utilities.Types.ValveGeometry geometry=Dissipation.Utilities.Types.ValveGeometry.Ball
            "Choice of geometry for valve" annotation (Dialog(group="Valve"));
          Utilities.Types.ValveCoefficient valveCoefficient=Utilities.Types.ValveCoefficient.AV
            "Choice of valve coefficient" annotation (Dialog(group="Valve"));

          //valve variables
          Real Av=PI*0.1^2/4 "Av (metric) flow coefficient [Av]=m^2" annotation (Dialog(
                group="Valve", enable=if valveCoefficient == 1 then true else false));
          Real Kv=Av/27.7e-6 "Kv (metric) flow coefficient [Kv]=m^3/h" annotation (
              Dialog(group="Valve", enable=if valveCoefficient == 2 then true else
                  false));
          Real Cv=Av/24.6e-6 "Cv (US) flow coefficient [Cv]=USG/min" annotation (Dialog(
                group="Valve", enable=if valveCoefficient == 3 then true else false));
          SI.Pressure dp_nominal=1e3 "Nominal pressure loss" annotation (Dialog(
                group="Valve", enable=if valveCoefficient == 4 then true else
                  false));
          SI.MassFlowRate m_flow_nominal=opening_nominal*Av*(rho_nominal*
              dp_nominal)^0.5 "Nominal mass flow rate" annotation (Dialog(group
                ="Valve", enable=if valveCoefficient == 4 then true else false));
          SI.Density rho_nominal=1000 "Nominal inlet density" annotation (
              Dialog(group="Valve", enable=if valveCoefficient == 4 then true
                   else false));
          Real opening_nominal=0.5 "Nominal opening" annotation (Dialog(group="Valve",
                enable=if valveCoefficient == 4 then true else false));
          Real zeta_TOT_min=1e-3
            "Minimal pressure loss coefficient at full opening"
            annotation (Dialog(group="Valve"));
          Real zeta_TOT_max=1e8
            "Maximum pressure loss coefficient at closed opening"
            annotation (Dialog(group="Valve"));

          //numerical aspects
          SI.Pressure dp_small=0.01*dp_nominal
            "Linearisation for a pressure loss smaller then dp_small"
            annotation (Dialog(group="Linearisation"));

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Valve.dp_severalGeometryOverall_DP\"> dp_severalGeometryOverall_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Valve.dp_severalGeometryOverall_MFLOW\"> dp_severalGeometryOverall_MFLOW</a>.
</html>"));
        end dp_severalGeometryOverall_IN_con;

        record dp_severalGeometryOverall_IN_var
          "Input record for function dp_severalGeometryOverall_DP and dp_severalGeometryOverall_MFLOW"

          extends Modelica_Icons.Record;

          //valve variables
          Real opening=1 "Opening of valve | 0==closed and 1== fully opened"
            annotation (Dialog(group="Valve"));

          //fluid property variables
          SI.DynamicViscosity eta "Dynamic viscosity of fluid"
            annotation (Dialog(group="Fluid properties"));
          SI.Density rho "Density of fluid"
            annotation (Dialog(group="Fluid properties"));

          annotation (Documentation(info="<html>
This record is used as <b> input record </b> for the pressure loss function
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Valve.dp_severalGeometryOverall_DP\"> dp_severalGeometryOverall_DP</a> and
<a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.Valve.dp_severalGeometryOverall_MFLOW\"> dp_severalGeometryOverall_MFLOW</a>.
</html>"));
        end dp_severalGeometryOverall_IN_var;
        annotation (preferredView="info", Documentation(info="<html>
<h4>Valve</h4>
<h5>Several geometries</h5>
<p>
Calculation of pressure loss for a valve with different geometries at overall flow regime for incompressible and single-phase fluid flow in dependence of its opening.
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.Valve.dp_severalGeometryOverall\">See more information</a>.
</p>

</html>"));
      end Valve;
    end PressureLoss;

    package Utilities "Package for utilities (should not be used directly)"
    extends Modelica_Icons.UtilitiesPackage;
      package SharedDocumentation "Shared Documentation"
        extends Modelica_Icons.Information;

        package HeatTransfer
          extends Modelica_Icons.Information;

          package Channel
          extends Modelica_Icons.Information;

          class kc_evenGapLaminar
            extends Modelica_Icons.Information;
              annotation (Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a laminar fluid flow through an even gap at different fluid flow and heat transfer situations.
</p>
<h4>Functions <b>kc_evenGapLaminar</b> and <b>kc_evenGapLaminar_KC</b></h4>
<p>
There are basically three differences:
</p>
<ul>
<li>
The function <b>kc_evenGapLaminar</b>  is using <b>kc_evenGapLaminar_KC</b> but offers additional output variables like e.g. Reynolds number or Nusselt number and failure status (an output of <b>1</b> means that the function is not valid for the inputs).</li>
<li>
Generally the  function <b>kc_evenGapLaminar_KC</b> is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known mass flow rate.</li>
<li>
You can perform an inverse calculation from <b>kc_evenGapLaminar_KC</b>, where an unknown mass flow rate is calculated out of a given mean convective heat transfer coefficient <b> kc </b>
</li>
</ul>


<h4>Restriction</h4>
<ul>
<li> laminar regime (Reynolds number &le; 2200)</li>
<li> developed fluid flow
   <ul>
   <li> heat transfer from one side of the gap (target=Modelica_Fluid.Dissipation.Utilities.Types.kc_evenGap.DevOne)</li>
   <li> heat transfer from both sides of the gap (target=Modelica_Fluid.Dissipation.Utilities.Types.kc_evenGap.DevBoth)</li>
   </ul></li>
<li> undeveloped fluid flow
   <ul>
   <li> heat transfer from one side of the gap (target=Modelica_Fluid.Dissipation.Utilities.Types.kc_evenGap.UndevOne)
       <ul>
       <li> Prandtl number 0.1 &le; Pr &le; 10 </li>
       </ul></li>
   <li> heat transfer from both sides of the gap (target=Modelica_Fluid.Dissipation.Utilities.Types.kc_evenGap.UndevBoth)
       <ul>
       <li> Prandtl number 0.1 &le; Pr &le; 1000</li>
       </ul></li>
   </ul></li>
</ul>

<h4>Geometry</h4>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/channel/pic_gap.png\" alt=\"pic_gap\"/>
</p>

<h4>Calculation</h4>
<p>
The mean convective heat transfer coefficient <b> kc</b> for an even gap is calculated through the corresponding Nusselt number <b> Nu_lam</b> according to <i>[VDI 2002, p. Gb 7, eq. 43]</i> :
</p>
<pre>
    Nu_lam = [(Nu_1)^3 + (Nu_2)^3 + (Nu_3)^3]^(1/3)
</pre>

<p>
with the corresponding mean convective heat transfer coefficient <b> kc </b> :
</p>

<pre>
    kc =  Nu_lam * lambda / d_hyd
</pre>

<p>
with
</p>

<table>
<tr><td><b> cp                      </b></td><td> as specific heat capacity at constant pressure [J/(kg.K)],</td></tr>
<tr><td><b> d_hyd = 2*s             </b></td><td> as hydraulic diameter of gap [m],</td></tr>
<tr><td><b> eta                     </b></td><td> as dynamic viscosity of fluid [Pa.s],</td></tr>
<tr><td><b> h                       </b></td><td> as height of cross sectional area in gap [m],</td></tr>
<tr><td><b> kc                      </b></td><td> as mean convective heat transfer coefficient [W/(m2.K)],</td></tr>
<tr><td><b> lambda                  </b></td><td> as heat conductivity of fluid [W/(m.K)],</td></tr>
<tr><td><b> L                       </b></td><td> as overflowed length of gap (normal to cross sectional area) [m] ,</td></tr>
<tr><td><b> Nu_lam                  </b></td><td> as mean Nusselt number [-], </td></tr>
<tr><td><b> Pr = eta*cp/lambda      </b></td><td> as Prandtl number [-],</td></tr>
<tr><td><b> rho                     </b></td><td> as fluid density [kg/m3],</td></tr>
<tr><td><b> s                       </b></td><td> as distance between parallel plates of cross sectional area [m],</td></tr>
<tr><td><b> Re = rho*v*d_hyd/eta    </b></td><td> as Reynolds number [-],</td></tr>
<tr><td><b> v                       </b></td><td> as mean velocity in gap [m/s].</td></tr>
</table>

<p>
The summands for the mean Nusselt number <b> Nu_lam </b> at a chosen fluid flow and heat transfer situation are calculated as follows:
</p>
<ul>
<li> developed fluid flow
   <ul>
   <li> heat transfer from one side of the gap (target=1)
        <ul>
            <li> Nu_1 = 4.861</li>
            <li> Nu_2 = 1.841*(Re*Pr*d_hyd/L)^(1/3)</li>
            <li> Nu_3 = 0</li>
        </ul></li>
   <li> heat transfer from both sides of the gap (target=2)
        <ul>
            <li> Nu_1 = 7.541</li>
            <li> Nu_2 = 1.841*(Re*Pr*d_hyd/L)^(1/3)</li>
            <li> Nu_3 = 0</li>
        </ul></li>
   </ul></li>
<li> undeveloped fluid flow
   <ul>
   <li> heat transfer from one side of the gap (target=3)
        <ul>
            <li> Nu_1 = 4.861</li>
            <li> Nu_2 = 1.841*(Re*Pr*d_hyd/L)^(1/3)</li>
            <li> Nu_3 = [2/(1+22*Pr)]^(1/6)*(Re*Pr*d_hyd/L)^(1/2)</li>
        </ul></li>
   <li> heat transfer from both sides of the gap (target=4)
        <ul>
            <li> Nu_1 = 7.541</li>
            <li> Nu_2 = 1.841*(Re*Pr*d_hyd/L)^(1/3)</li>
            <li> Nu_3 = [2/(1+22*Pr)]^(1/6)*(Re*Pr*d_hyd/L)^(1/2)</li>
        </ul></li>
   </ul></li>
</ul>

<p>
Note that the fluid properties shall be calculated with an arithmetic mean temperature out of the fluid flow temperatures at the entrance and the exit of the gap.
</p>

<h4>Verification</h4>
<p>
The mean Nusselt number <b> Nu_lam </b> representing the mean convective heat transfer coefficient <b> kc </b> in dependence of
the chosen fluid flow and heat transfer situations (targets) is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/channel/fig_channel_kc_evenGapLaminar.png\" alt=\"fig_channel_kc_evenGapLamina\"/>
</p>

<h4>References</h4>
<dl>
<dt>Bejan,A.:</dt>
    <dd><b>Heat transfer handbook</b>.
    Wiley, 2003.</dd>
<dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 9th edition, 2002.</dd>
</dl>
</html>"));
          end kc_evenGapLaminar;

          class kc_evenGapOverall
            extends Modelica_Icons.Information;
              annotation (Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for an laminar or turbulent fluid flow through an even gap at different fluid flow and heat transfer situations.
</p>

<h4>Functions <b>kc_evenGapOverall</b> and <b>kc_evenGapOverall_KC</b></h4>
<p>
There are basically three differences:
</p>
<ul>
<li>
The function <b>kc_evenGapOverall</b> is using <b>kc_evenGapOverall_KC</b> but offers additional output variables like e.g. Reynolds number or Nusselt number and failure status (an output of <b>1</b> means that the function is not valid for the inputs).</li>
<li>
Generally the  function <b>kc_evenGapOverall_KC</b> is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known mass flow rate.</li>
<li>
You can perform an inverse calculation from <b>kc_evenGapOverall_KC</b>, where an unknown mass flow rate is calculated out of a given mean convective heat transfer coefficient <b> kc </b>
</li>
</ul>

<h4>Restriction</h4>

<ul>
<li> developed fluid flow
   <ul>
   <li> heat transfer from one side of the gap (target=Modelica_Fluid.Dissipation.Utilities.Types.kc_evenGap.DevOne) </li>
   <li> heat transfer from both sides of the gap (target=Modelica_Fluid.Dissipation.Utilities.Types.kc_evenGap.DevBoth) </li>
   </ul></li>
<li> undeveloped fluid flow
   <ul>
   <li> heat transfer from one side of the gap (target=Modelica_Fluid.Dissipation.Utilities.Types.kc_evenGap.UndevOne)
       <ul>
       <li> Prandtl number 0.1 &le; Pr &le; 10 </li>
       </ul></li>
   <li> heat transfer from both sides of the gap (target=Modelica_Fluid.Dissipation.Utilities.Types.kc_evenGap.UndevBoth)
   <ul>
       <li> Prandtl number 0.1 &le; Pr &le; 1000 </li>
       </ul></li>
   </ul></li>
<li> turbulent regime always calculated for developed fluid flow and heat transfer from both sides of the gap (target=Modelica_Fluid.Dissipation.Utilities.Types.kc_evenGap.DevBoth)</li>
</ul>

<h4>Geometry and Calculation </h4>

<p>This heat transfer function enables a calculation of heat transfer coefficient for laminar and turbulent flow regime. The geometry, constant and fluid parameters of the function are the same as for
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Channel.kc_evenGapLaminar\">kc_evenGapLaminar</a>  and <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Channel.kc_evenGapTurbulent\">kc_evenGapTurbulent</a>.
</p>
<p>
The calculation conditions for laminar and turbulent flow is equal to the calculation in <b>kc_evenGapLaminar</b>
and <b>kc_evenGapTurbulent</b>. A smooth transition between both functions is carried out between 2200 &le; Re &le; 30000 (see figure below). </p>

<h4>Verification</h4>
<p>
The mean Nusselt number <b> Nu </b> representing the mean convective heat transfer coefficient <b> kc </b> for Prandtl numbers of different fluids in dependence of
the chosen fluid flow and heat transfer situations (targets) is shown in the figures below.
</p>

<ul>
   <li> Target 1: Developed fluid flow and heat transfer from one side of the gap</li>
   <li> Target 2: Developed fluid flow and heat transfer from both sides of the gap</li>
   <li> Target 3: Undeveloped fluid flow and heat transfer from one side of the gap</li>
   <li> Target 4: Undeveloped fluid flow and heat transfer from both sides of the gap</li>
</ul>
<p>
The verification for all targets is shown in the following figure w.r.t. the reference:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/channel/fig_channel_kc_evenGapOverall.png\" alt=\"fig_channel_kc_evenGapOverall\"/>
</p>

<h4>References</h4>
<dl>
<dt>Bejan,A.:</dt>
    <dd><b>Heat transfer handbook</b>.
    Wiley, 2003.</dd>
<dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 9th edition, 2002.</dd>
</dl>

</html>"));
          end kc_evenGapOverall;

          class kc_evenGapTurbulent
            extends Modelica_Icons.Information;
              annotation (Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a developed turbulent fluid flow through an even gap at heat transfer from both sides.
</p>
<h4>Functions <b>kc_evenGapTurbulent</b> and <b>kc_evenGapTurbulent_KC</b></h4>
<p>
There are basically three differences:
</p>
<ul>
<li>
The function <b>kc_evenGapTurbulent</b> is using <b>kc_evenGapTurbulent_KC</b> but offers additional output variables like e.g. Reynolds number or Nusselt number and failure status (an output of <b>1</b> means that the function is not valid for the inputs).</li>
<li>
Generally the  function <b>kc_evenGapTurbulent_KC</b> is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known mass flow rate.</li>
<li>
You can perform an inverse calculation from <b>kc_evenGapTurbulent_KC</b>, where an unknown mass flow rate is calculated out of a given mean convective heat transfer coefficient <b> kc </b>
</li>
</ul>

<h4>Restriction</h4>

<ul>
<li> identical and constant wall temperatures</li>
<li> hydraulic diameter per gap lenght (d_hyd / L) &le; 1</li>
<li> 0.5 &le; Prandtl number Pr &le; 100) </li>
<li> turbulent regime (3e4 &le; Reynolds number &le; 1e6)</li>
<li> developed fluid flow</li>
<li> heat transfer from both sides of the gap (target = Modelica_Fluid.Dissipation.Utilities.Types.kc_evenGap.DevBoth)</li>
</ul>

<h4>Geometry</h4>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/channel/pic_gap.png\" alt=\"pic_gap\"/>
</p>

<h4>Calculation</h4>
<p>
The mean convective heat transfer coefficient <b> kc</b> for an even gap is calculated through the corresponding Nusselt number <b> Nu_turb</b> according to <i> Gnielinski in [VDI 2002, p. Gb 7, sec. 2.4]</i>
</p>
<pre>
    Nu_turb =(zeta/8)*Re*Pr/{1+12.7*[zeta/8]^(0.5)*[Pr^(2/3) -1]}*{1+[d_hyd/L]^(2/3)}
</pre>

<p>
where the pressure loss coefficient <b> zeta </b> according to <i> Konakov in [VDI 2002, p. Ga 5, eq. 27]</i> is determined by
</p>
<pre>
    zeta =  1/[1.8*log10(Re) - 1.5]^2
</pre>

<p>
resulting to the corresponding mean convective heat transfer coefficient <b> kc </b>
</p>
<pre>
    kc =  Nu_turb * lambda / d_hyd
</pre>

<p>
with
</p>

<table>
<tr><td><b> cp                      </b></td><td> as specific heat capacity at constant pressure [J/(kg.K)],</td></tr>
<tr><td><b> d_hyd = 2*s             </b></td><td> as hydraulic diameter of gap [m],</td></tr>
<tr><td><b> eta                     </b></td><td> as dynamic viscosity of fluid [Pa.s],</td></tr>
<tr><td><b> h                       </b></td><td> as height of cross sectional area in gap [m],</td></tr>
<tr><td><b> kc                      </b></td><td> as mean convective heat transfer coefficient [W/(m2.K)],</td></tr>
<tr><td><b> lambda                  </b></td><td> as heat conductivity of fluid [W/(m.K)],</td></tr>
<tr><td><b> L                       </b></td><td> as overflowed length of gap (normal to cross sectional area) [m] ,</td></tr>
<tr><td><b> Nu_turb                 </b></td><td> as mean Nusselt number for turbulent regime [-], </td></tr>
<tr><td><b> Pr = eta*cp/lambda      </b></td><td> as Prandtl number [-],</td></tr>
<tr><td><b> rho                     </b></td><td> as fluid density [kg/m3],</td></tr>
<tr><td><b> s                       </b></td><td> as distance between parallel plates of cross sectional area [m],</td></tr>
<tr><td><b> Re = rho*v*d_hyd/eta    </b></td><td> as Reynolds number [-],</td></tr>
<tr><td><b> v                       </b></td><td> as mean velocity in gap [m/s],</td></tr>
<tr><td><b> zeta                    </b></td><td> as pressure loss coefficient [-].</td></tr>
</table>

<p>
Note that the fluid flow properties shall be calculated with an arithmetic mean temperature out of the fluid flow temperatures at the entrance and the exit of the gap.
</p>

<h4>Verification</h4>
<p>
The mean Nusselt number <b> Nu_turb </b> representing the mean convective heat transfer coefficient <b> kc </b> in dependence of
the chosen fluid flow and heat transfer situations (targets) is shown in the figure below.
</p>
<ul>
   <li> Target 2: Developed fluid flow and heat transfer from both sides of the gap</li>
</ul>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/channel/fig_channel_kc_evenGapTurbulent.png\" alt=\"fig_channel_kc_evenGapTurbulent\"/>
</p>

<h4>References</h4>
<dl>
<dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 9th edition, 2002.</dd>
</dl>

</html>"));
          end kc_evenGapTurbulent;

          end Channel;

          package General
          extends Modelica_Icons.Information;

          class kc_approxForcedConvection
            extends Modelica_Icons.Information;
              annotation (Documentation(info="<html>
<p>
Approximate calculation of the mean convective heat transfer coefficient <b> kc </b> for forced convection with a fully developed fluid flow in a turbulent regime.
</p>

<h4>Functions <b>kc_approxForcedConvection</b> and <b>kc_approxForcedConvection_KC</b></h4>
<p>
There are basically three differences:
</p>
<ul>
<li>
The function <b>kc_approxForcedConvection</b> is using <b>kc_approxForcedConvection_KC</b> but offers additional output variables like e.g. Reynolds number or Nusselt number and failure status (an output of <b>1</b> means that the function is not valid for the inputs).</li>
<li>
Generally the  function <b>kc_approxForcedConvection_KC</b> is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known mass flow rate.</li>
<li>
You can perform an inverse calculation from <b>kc_approxForcedConvection_KC</b>, where an unknown mass flow rate is calculated out of a given mean convective heat transfer coefficient <b> kc </b>
</li>
</ul>

<h4>Restriction</h4>

<ul>
<li> Constant wall temperature <b> or </b> constant heat flux
<li> Turbulent regime (Reynolds number 2500 &lt; Re &lt; 1e6)
<li> Prandtl number 0.5 &le; Pr &le; 500
</ul>

<h4>Calculation</h4>
<p>
The mean convective heat transfer coefficient <b> kc </b> is approximated through different Nusselt number <b> Nu </b> correlations out of <i>[Bejan 2003, p. 424 ff]</i>. <br>
Roughest approximation according to Dittus/Boelter (1930):
</p>
<pre>
    Nu_1 = 0.023 * Re^(4/5) * Pr^(exp_Pr)
</pre>

<p>
Middle approximation according to Sieder/Tate (1936) considering the temperature dependence of the fluid properties:
</p>
<pre>
    Nu_2 = 0.023 * Re^(4/5) * Pr^(1/3) * (eta/eta_wall)^(0.14)
</pre>

<p>
Finest approximation according to Gnielinski (1976):
</p>
<pre>
    Nu_3 = 0.0214 * [Re^(0.8) - 100] * Pr^(0.4) for Pr &le; 1.5
         = 0.012 * [Re^(0.87) - 280] * Pr^(0.4) for Pr &gt; 1.5
</pre>

<p>
The mean convective heat transfer coefficient <b> kc </b> is calculated by:
</p>

<pre>
    kc =  Nu * lambda / d_hyd
</pre>

<p>
with
</p>

<table>
<tr><td><b> eta                          </b></td><td> as dynamic viscosity of fluid [Pa.s],</td></tr>
<tr><td><b> eta_wall                     </b></td><td> as dynamic viscosity of fluid at wall temperature [Pa.s],</td></tr>
<tr><td><b> exp_Pr                       </b></td><td> as exponent for Prandtl number w.r.t. Dittus/Boelter (0.4 for heating or 0.3 for cooling) [-],</td></tr>
<tr><td><b> kc                           </b></td><td> as mean convective heat transfer coefficient [W/(m2.K)],</td></tr>
<tr><td><b> lambda                       </b></td><td> as heat conductivity of fluid [W/(m.K)],</td></tr>
<tr><td><b> d_hyd                        </b></td><td> as hydraulic diameter [m],</td></tr>
<tr><td><b> Nu_1/2/3                     </b></td><td> as mean Nusselt number [-], </td></tr>
<tr><td><b> Pr                           </b></td><td> as Prandtl number [-],</td></tr>
<tr><td><b> Re                           </b></td><td> as Reynolds number [-].</td></tr>
</table>

<h4>Verification</h4>
<p>
The mean Nusselt number <b> Nu </b> representing the mean convective heat transfer coefficient <b> kc </b> for Prandtl numbers of different fluids is shown in the figure below. </p>
<p><b>Dittus/Boelter</b> (target = Modelica_Fluid.Dissipation.Utilities.Types.kc_general.Rough)
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/general/fig_kc_approxForcedConvection_T1.png\" alt=\"fig_kc_approxForcedConvection_T1\"/>
</p>

<p>
<b>Sieder/Tate</b> (Target = Modelica_Fluid.Dissipation.Utilities.Types.kc_general.Middle)
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/general/fig_kc_approxForcedConvection_T2.png\" alt=\"fig_kc_approxForcedConvection_T2\"/>
</p>

<p>
<b>Gnielinski</b> (Target = Modelica_Fluid.Dissipation.Utilities.Types.kc_general.Finest)
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/general/fig_kc_approxForcedConvection_T3.png\" alt=\"fig_kc_approxForcedConvection_T3\"/>
</p>

<p>
Note that all fluid properties shall be calculated with the mean temperature of the fluid between the entrance and the outlet of the generic device.
</p>

<h4>References</h4>
<dl>
<dt>Bejan,A.:</dt>
    <dd><b>Heat transfer handbook</b>.
    Wiley, 2003.</dd>
</dl>

</html>"));
          end kc_approxForcedConvection;
          end General;

          package HeatExchanger
          extends Modelica_Icons.Information;

          class kc_flatTube
            extends Modelica_Icons.Information;
              annotation (Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for the air-side heat transfer of heat exchangers with flat tubes and several fin geometries.
</p>
<h4>Functions <b>kc_flatTube</b> and <b>kc_flatTube_KC</b></h4>
<p>
There are basically three differences:
</p>
<ul>
<li>
The function <b>kc_flatTube</b> is using <b>kc_flatTube_KC</b> but offers additional output variables like e.g. Reynolds number or Nusselt number and failure status (an output of <b>1</b> means that the function is not valid for the inputs).</li>
<li>
Generally the  function <b>kc_flatTube_KC</b> is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known mass flow rate.</li>
<li>
You can perform an inverse calculation from <b>kc_flatTube_KC</b>, where an unknown mass flow rate is calculated out of a given mean convective heat transfer coefficient <b> kc </b>
</li>
</ul>

<h4>Restriction</h4>
<ul>
<li> According to the kind of fin geometry the calculation is valid in a range of <b> Re</b> from 100 to 5000. </li>
<li> medium = air </li>
</ul>

<h4>Geometry </h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/heatExchanger/pic_flatTube.png\" width=\"850\" alt=\"pic_flatTube\"/>
</p>

<h4>Calculation</h4>
<p>
The mean convective heat transfer coefficient <b> kc </b> for heat exchanger is calculated through the corresponding Coulburn factor <b> j </b>:
</p>
<pre>
    j = f(geometry, Re)
</pre>

<p>
with the resulting mean convective heat transfer coefficient <b> kc </b>
</p>

<pre>
    kc =  j * Re_L_p * Pr^(1/3) * lambda / L_p (Louver fin)
</pre>

 <p>
or
</p>

<pre>
    kc =  j * Re_D_h * Pr^(1/3) * lambda / D_h (Rectangular offset strip fin)
</pre>

<p>
with
</p>

<table>
<tr><td><b> D_h                        </b></td><td> as hydraulic diameter [m],</td></tr>
<tr><td><b> kc                         </b></td><td> as mean convective heat transfer coefficient [W/(m2K)],</td></tr>
<tr><td><b> lambda                     </b></td><td> as heat conductivity of fluid [W/(mK)],</td></tr>
<tr><td><b> L_p                        </b></td><td> as louver pitch [m],</td></tr>
<tr><td><b> Nu_D_h = kc*D_h/lambda     </b></td><td> as mean Nusselt number based on hydraulic diameter [-], </td></tr>
<tr><td><b> Nu_L_p = kc*L_p/lambda     </b></td><td> as mean Nusselt number based on louver pitch [-], </td></tr>
<tr><td><b> Pr = eta*cp/lambda         </b></td><td> as Prandtl number [-],</td></tr>
<tr><td><b> Re_D_h = rho*v*D_h/eta     </b></td><td> as Reynolds number based on hydraulic diameter [-],</td></tr>
<tr><td><b> Re_L_p = rho*v*L_p/eta     </b></td><td> as Reynolds number based on louver pitch [-],</td></tr>
</table>

<h4>Verification</h4>
<p>
The mean Nusselt number <b> Nu </b> representing the mean convective heat transfer coefficient <b> kc </b> is shown below for different fin geometries at similar dimensions.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/heatExchanger/fig_flatTube_kc.png\" alt=\"fig_flatTube_kc\"/>
</p>

<h4>References</h4>
<dl>
 <dt>Y.-J. CHANG and C.-C. WANG:</dt>
    <dd><b>A generalized heat transfer correlation for louver fin geometry</b>.
    In International Journal of Heat and Mass Transfer, volume 40, No. 3,  pages 533-544, 1997.</dd>
 <dt>Y.-J. CHANG and C.-C. WANG:</dt>
    <dd><b>Air Side Performance of Brazed Aluminium Heat Exchangers</b>.
    In Journal of Enhanced Heat Transfer, volume 3, No. 1,  pages 15-28, 1996.</dd>
 <dt>R.-M. Manglik, A.-E. Bergles:</dt>
    <dd><b>Heat Transfer and Pressure Drop Correlations for the Rectangular Offset Strip Fin Compact Heat Exchanger</b>.
    In Experimental Thermal and Fluid Science, volume 10, pages 171-180, 1995.</dd>
</dl>

</html>"));
          end kc_flatTube;

          class kc_roundTube
            extends Modelica_Icons.Information;
              annotation (Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for the air-side heat transfer of heat exchangers with round tubes and several fin geometries.
</p>
<h4>Functions <b>kc_roundTube</b> and <b>kc_roundTube_KC</b></h4>
<p>
There are basically three differences:
</p>
<ul>
<li>
The function <b>kc_roundTube</b> is using <b>kc_roundTube_KC</b> but offers additional output variables like e.g. Reynolds number or Nusselt number and failure status (an output of <b>1</b> means that the function is not valid for the inputs).</li>
<li>
Generally the  function <b>kc_roundTube_KC</b> is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known mass flow rate.</li>
<li>
You can perform an inverse calculation from <b>kc_roundTube_KC</b>, where an unknown mass flow rate is calculated out of a given mean convective heat transfer coefficient <b> kc </b>
</li>
</ul>

<h4>Restriction</h4>
<ul>
<li> According to the kind of fin geometry the calculation is valid in a range of <b> Re</b> from 300 to 8000. </li>
<li> medium = air </li>
</ul>

<h4>Geometry </h4>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/heatExchanger/pic_roundTube.png\" width=\"850\" alt=\"pic_roundTube\"/>
</p>

<h4>Calculation</h4>
<p>
The mean convective heat transfer coefficient <b> kc </b> for heat exchanger is calculated through the corresponding Coulburn factor <b> j </b>:
</p>

<pre>
    j = f(geometry, Re)
</pre>

<p>
with the resulting mean convective heat transfer coefficient <b> kc </b>
</p>

<pre>
    kc =  j * Re * Pr^(1/3) * lambda / D_c
</pre>

<p>
with
</p>

<table>
<tr><td><b> D_c                        </b></td><td> as fin collar diameter [m],</td></tr>
<tr><td><b> kc                         </b></td><td> as mean convective heat transfer coefficient [W/(m2K)],</td></tr>
<tr><td><b> lambda                     </b></td><td> as heat conductivity of fluid [W/(mK)],</td></tr>
<tr><td><b> Nu = kc*D_c/lambda         </b></td><td> as mean Nusselt number [-], </td></tr>
<tr><td><b> Pr = eta*cp/lambda         </b></td><td> as Prandtl number [-],</td></tr>
<tr><td><b> Re = rho*v*D_c/eta         </b></td><td> as Reynolds number [-],</td></tr>
</table>

<h4>Verification</h4>
<p>
The mean Nusselt number <b> Nu </b> representing the mean convective heat transfer coefficient <b> kc </b> is shown below for different fin geometries at similar dimensions.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/heatExchanger/fig_roundTube_kc.png\" alt=\"fig_roundTube_kc\"/>
</p>

<h4>References</h4>
<dl>
 <dt>C.-C. Wang, C.-T. Chang:</dt>
    <dd><b>Heat and mass transfer for plate fin-and-tube heat exchangers, with and without hydrophilic coating</b>.
    In International Journal of Heat and Mass Transfer, volume 41, pages 3109-3120, 1998.</dd>
 <dt>C.-C. Wang, C.-J. Lee, C.-T. Chang, S.-P. Lina:</dt>
    <dd><b>Heat transfer and friction correlation for compact louvered fin-and-tube heat exchangers</b>.
    In International Journal of Heat and Mass Transfer, volume 42, pages 1945-1956, 1999.</dd>
 <dt>C.-C. Wang, W.-H. Tao, C.-J. Chang:</dt>
    <dd><b>An investigation of the airside performance of the slit fin-and-tube heat exchangers</b>.
    In International Journal of Refrigeration, volume 22, pages 595-603, 1999.</dd>
 <dt>C.-C. Wang, W.-L. Fu, C.-T. Chang:</dt>
    <dd><b>Heat Transfer and Friction Characteristics of Typical Wavy Fin-and-Tube Heat Exchangers</b>.
    In Experimental Thermal and Fluid Science, volume 14, pages 174-186, 1997.</dd>
</dl>
</html>"));
          end kc_roundTube;

          end HeatExchanger;

          package HelicalPipe
          extends Modelica_Icons.Information;

          class kc_laminar
            extends Modelica_Icons.Information;

              annotation (Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a helical pipe in the laminar flow regime.
</p>
<h4>Functions <b>kc_laminar</b> and <b>kc_laminar_KC</b></h4>
<p>
There are basically three differences:
</p>
<ul>
<li>
The function <b>kc_laminar</b> is using <b>kc_laminar_KC</b> but offers additional output variables like e.g. Reynolds number or Nusselt number and failure status (an output of <b>1</b> means that the function is not valid for the inputs).</li>
<li>
Generally the  function <b>kc_laminar_KC</b> is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known mass flow rate.</li>
<li>
You can perform an inverse calculation from <b>kc_laminar_KC</b>, where an unknown mass flow rate is calculated out of a given mean convective heat transfer coefficient <b> kc </b>
</li>
</ul>

<h4>Restriction</h4>

<ul>
  <li> laminar regime (Reynolds number &le; critical Reynolds number <b> Re_crit</b>) </li>
  <li> neglect influence of heat transfer direction (heating/cooling) according to <i>Sieder and Tate </i> </li>
</ul>

<p>
The critical Reynolds number <b> Re_crit </b> in a helical pipe depends on its mean curvature diameter <b> d_coil </b>.
The smaller the mean curvature diameter of the helical pipe, the
earlier the turbulent regime will start due to vortexes out of higher
centrifugal forces.
</p>

<h4>Geometry </h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/helicalPipe/pic_helicalPipe.png\" alt=\"pic_helicalPipe\"/>
</p>

<h4>Calculation</h4>
<p>
The mean convective heat transfer coefficient <b> kc </b> for helical pipes is calculated through the corresponding Nusselt number <b> Nu </b> according to <i>[VDI 2002, p. Gc 2, eq. 5]</i> :
</p>

<pre>    Nu = 3.66 + 0.08*[1 + 0.8*(d_hyd/d_coil)^0.9]*Re^m*Pr^(1/3)<br></pre>

<p>
with the exponent <b> m </b> for the Reynolds number
</p>

<pre>    m = 0.5 + 0.2903*(d_hyd/d_coil)^0.194</pre>

<p>
and the resulting mean convective heat transfer coefficient <b> kc </b>
</p>

<pre>    kc =  Nu * lambda / d_hyd</pre>

<p>
with
</p>

<table>

  <tbody>
    <tr>
      <td><b> d_mean                     </b></td>
      <td> as mean diameter of helical pipe [m],</td>
    </tr>

    <tr>
      <td><b> d_coil = f(geometry)       </b></td>
      <td> as mean curvature diameter of helical pipe [m],</td>
    </tr>

    <tr>
      <td><b> d_hyd                      </b></td>
      <td> as hydraulic diameter of the helical pipe [m],</td>
    </tr>

    <tr>
      <td><b> h                          </b></td>
      <td> as slope of helical pipe [m],</td>
    </tr>

    <tr>
      <td><b> kc                         </b></td>
      <td> as mean convective heat transfer coefficient [W/(m2K)],</td>
    </tr>

    <tr>
      <td><b> lambda                     </b></td>
      <td> as heat conductivity of fluid [W/(mK)],</td>
    </tr>

    <tr>
      <td><b> L                          </b></td>
      <td> as total length of helical pipe [m],</td>
    </tr>

    <tr>
      <td><b> Nu = kc*d_hyd/lambda       </b></td>
      <td> as mean Nusselt number [-], </td>
    </tr>

    <tr>
      <td><b> Pr = eta*cp/lambda         </b></td>
      <td> as Prandtl number [-],</td>
    </tr>

    <tr>
      <td><b> Re = rho*v*d_hyd/eta       </b></td>
      <td> as Reynolds number [-],</td>
    </tr>

    <tr>
      <td><b> Re_crit = f(geometry)      </b></td>
      <td> as critical Reynolds number [-].</td>
    </tr>

  </tbody>
</table>

<h4>Verification</h4>
<p>
The mean Nusselt number <b> Nu </b> representing the mean convective heat transfer coefficient <b> kc </b> is shown below for different numbers of turns <b> n_nt </b> at constant total length of the helical pipe.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/helicalPipe/fig_helicalPipe_kc_laminar.png\" alt=\"fig_helicalPipe_kc_laminar\"/>
</p>

<p>The convective heat transfer of a helical pipe is enhanced compared
to a straight pipe due to occurring turbulences resulting out of
centrifugal forces. The higher the number of turns, the better is the
convective heat transfer for the same length of a pipe.
</p>
<p>
Note that the ratio of hydraulic diameter to total length of helical pipe <b> d_hyd/L </b> has no remarkable influence on the coefficient of heat transfer <b> kc </b>.
</p>
<h4>References</h4>
<dl>
 <dt>GNIELINSKI, V.:</dt>
    <dd><b>Heat transfer and pressure drop in helically coiled tubes.</b>.
    In 8th International Heat Transfer Conference, volume 6, pages 2847-2854, Washington,1986. Hemisphere.</dd>
</dl>
</html>"));
          end kc_laminar;

          class kc_overall
            extends Modelica_Icons.Information;

              annotation (Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> of a helical pipe in a hydrodynamically developed laminar and turbulent flow regime.
</p>
<h4>Functions <b>kc_overall</b> and <b>kc_overall_KC</b></h4>
<p>
There are basically three differences:
</p>
<ul>
<li>
The function <b>kc_overall</b> is using <b>kc_overall_KC</b> but offers additional output variables like e.g. Reynolds number or Nusselt number and failure status (an output of <b>1</b> means that the function is not valid for the inputs).</li>
<li>
Generally the  function <b>kc_overall_KC</b> is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known mass flow rate.</li>
<li>
You can perform an inverse calculation from <b>kc_overall_KC</b>, where an unknown mass flow rate is calculated out of a given mean convective heat transfer coefficient <b> kc </b>
</li>
</ul>

<h4>Geometry and Calculation </h4>

<p>This heat transfer function enables a calculation of heat transfer coefficient for laminar and turbulent flow regime. The geometry, constant and fluid parameters of the function are the same as for
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_laminar\">kc_laminar</a>  and <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_turbulent\">kc_turbulent</a>.
</p>
<p>
The calculation conditions for laminar and turbulent flow is equal to the calculation in <b>kc_laminar</b>
and <b>kc_turbulent</b>. A smooth transition between both functions is carried out between 2200 &le; Re &le; 30000 (see figure below). </p>

<h4>Verification</h4>
<p>
The mean Nusselt number <b> Nu </b> representing the mean convective heat transfer coefficient <b> kc </b> is shown below for different numbers of turns <b> n_nt </b> at constant total length of the helical pipe.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/helicalPipe/fig_helicalPipe_kc_overall.png\" alt=\"fig_helicalPipe_kc_overall\"/>
</p>

<p>
The convective heat transfer of a helical pipe is enhanced compared to a straight pipe due to occurring turbulences resulting out of centrifugal forces. The higher the number of turns, the better is the convective heat transfer for the same length of a pipe.
</p>

<p>
Note that the ratio of hydraulic diameter to total length of helical pipe <b> d_hyd/L </b> has no remarkable influence on the coefficient of heat transfer <b> kc </b>.
</p>

<h4>References</h4>
<dl>
 <dt>GNIELINSKI, V.:</dt>
    <dd><b>Heat transfer and pressure drop in helically coiled tubes.</b>.
    In 8th International Heat Transfer Conference, volume 6, pages 2847?2854, Washington,1986. Hemisphere.</dd>
</dl>
</html>"));
          end kc_overall;

          class kc_turbulent
            extends Modelica_Icons.Information;

              annotation (Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> of a helical pipe for turbulent flow regime.
</p>
<h4>Functions <b>kc_turbulent</b> and <b>kc_turbulent_KC</b></h4>

<p>
There are basically three differences:
</p>
<ul>
<li>
The function <b>kc_turbulent</b> is using <b>kc_turbulent_KC</b> but offers additional output variables like e.g. Reynolds number or Nusselt number and failure status (an output of <b>1</b> means that the function is not valid for the inputs).
</li>
<li>
Generally the  function <b>kc_turbulent_KC</b> is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known mass flow rate.</li>
<li>
You can perform an inverse calculation from <b>kc_turbulent_KC</b>, where an unknown mass flow rate is calculated out of a given mean convective heat transfer coefficient <b> kc </b>
</li>
</ul>

<p>
The critical Reynolds number <b> Re_crit </b> in a helical pipe depends on its mean curvature diameter. The smaller the mean curvature diameter of the helical pipe <b> d_mean </b>, the earlier the turbulent regime will start due to vortexes out of higher centrifugal forces.
</p>
<h4>Geometry </h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/helicalPipe/pic_helicalPipe.png\" alt=\"pic_helicalPipe\"/>
</p>

<h4>Calculation</h4>
<p>
The mean convective heat transfer coefficient <b> kc </b> for helical pipes is calculated through the corresponding Nusselt number <b> Nu </b> according to <i>[VDI 2002, p. Ga 2, eq. 6]</i>:
</p>
<pre>
    Nu = (zeta_TOT/8)*Re*Pr/{1 + 12.7*(zeta_TOT/8)^0.5*[Pr^(2/3)-1]},
</pre>

<p>
where the influence of the pressure loss on the heat transfer calculation is considered through
</p>
<pre>
    zeta_TOT = 0.3164*Re^(-0.25) + 0.03*(d_hyd/d_coil)^(0.5) and
</pre>

<p>
and the resulting mean convective heat transfer coefficient <b> kc </b>
</p>

<pre>
    kc =  Nu * lambda / d_hyd
</pre>

<p>
with
</p>

<table>
<tr><td><b> d_mean                     </b></td><td> as mean diameter of helical pipe [m],</td></tr>
<tr><td><b> d_coil = f(geometry)       </b></td><td> as mean curvature diameter of helical pipe [m],</td></tr>
<tr><td><b> d_hyd                      </b></td><td> as hydraulic diameter of the helical pipe [m],</td></tr>
<tr><td><b> h                          </b></td><td> as slope of helical pipe [m],</td></tr>
<tr><td><b> kc                         </b></td><td> as mean convective heat transfer coefficient [W/(m2K)],</td></tr>
<tr><td><b> lambda                     </b></td><td> as heat conductivity of fluid [W/(mK)],</td></tr>
<tr><td><b> L                          </b></td><td> as total length of helical pipe [m],</td></tr>
<tr><td><b> Nu = kc*d_hyd/lambda       </b></td><td> as mean Nusselt number [-], </td></tr>
<tr><td><b> Pr = eta*cp/lambda         </b></td><td> as Prandtl number [-],</td></tr>
<tr><td><b> Re = rho*v*d_hyd/eta       </b></td><td> as Reynolds number [-],</td></tr>
<tr><td><b> Re_crit = f(geometry)      </b></td><td> as critical Reynolds number [-].</td></tr>
</table>

<h4>Verification</h4>
<p>
The mean Nusselt number <b> Nu </b> representing the mean convective heat transfer coefficient <b> kc </b> is shown below for different numbers of turns <b> n_nt </b> at constant total length of the helical pipe.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/helicalPipe/fig_helicalPipe_kc_turbulent.png\" alt=\"fig_helicalPipe_kc_turbulent\"/>
</p>

<p>
The convective heat transfer of a helical pipe is enhanced compared to a straight pipe due to occurring turbulences resulting out of centrifugal forces. The higher the number of turns, the better is the convective heat transfer for the same length of a pipe.
</p>

<p>
Note that the ratio of hydraulic diameter to total length of helical pipe <b> d_hyd/L </b> has no remarkable influence on the coefficient of heat transfer <b> kc </b>.
</p>

<h4>References</h4>
<dl>
 <dt>GNIELINSKI, V.:</dt>
    <dd><b>Heat transfer and pressure drop in helically coiled tubes.</b>.
    In 8th International Heat Transfer Conference, volume 6, pages 2847?2854, Washington,1986. Hemisphere.</dd>
</dl>
</html>"));
          end kc_turbulent;

          end HelicalPipe;

          package Plate
          extends Modelica_Icons.Information;

          class kc_laminar
            extends Modelica_Icons.Information;

              annotation (Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a laminar fluid flow over an even surface.
</p>

<h4>Functions <b>kc_laminar</b> and <b>kc_laminar_KC</b></h4>
<p>
There are basically three differences:
</p>

<ul>
<li>
The function <b>kc_laminar</b> is using <b>kc_laminar_KC</b> but offers additional output variables like e.g. Reynolds number or Nusselt number and failure status (an output of <b>1</b> means that the function is not valid for the inputs).</li>
<li>
Generally the  function <b>kc_laminar_KC</b> is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known mass flow rate.</li>
<li>
You can perform an inverse calculation from <b>kc_laminar_KC</b>, where an unknown mass flow rate is calculated out of a given mean convective heat transfer coefficient <b> kc </b>
</li>
</ul>

<h4>Restriction</h4>

<ul>
<li> laminar regime (Reynolds number &le; 1e5)</li>
<li> Prandtl number 0.6 &le; Pr &le; 2000</li>
</ul>

<h4>Geometry </h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/plate/pic_plate.png\" alt=\"pic_plate\"/>
</p>

<h4>Calculation</h4>
<p>
The mean convective heat transfer coefficient <b> kc</b> for flat plate is calculated through the corresponding Nusselt number <b> Nu_lam</b> according to <i>[VDI 2002, p. Gd 1, eq. 1]</i> :
</p>
<pre>
    Nu_lam = 0.664 * Re^(0.5) * (Pr)^(1/3)
</pre>

<p>
and the corresponding mean convective heat transfer coefficient <b> kc </b>:
</p>
<pre>
    kc =  Nu_lam * lambda / L
</pre>

<p>
with
</p>

<table>
<tr><td><b> cp                 </b></td><td> as specific heat capacity at constant pressure [J/(kg.K)],</td></tr>
<tr><td><b> eta                </b></td><td> as dynamic viscosity of fluid [Pa.s],</td></tr>
<tr><td><b> kc                 </b></td><td> as mean convective heat transfer coefficient [W/(m2.K)],</td></tr>
<tr><td><b> lambda         </b></td><td> as heat conductivity of fluid [W/(m.K)],</td></tr>
<tr><td><b> L              </b></td><td> as length of plate [m],</td></tr>
<tr><td><b> Nu_lam                  </b></td><td> as mean Nusselt number for laminar regime [-], </td></tr>
<tr><td><b> Pr = eta*cp/lambda           </b></td><td> as Prandtl number [-],</td></tr>
<tr><td><b> rho          </b></td><td> as fluid density [kg/m3],</td></tr>
<tr><td><b> Re = rho*v*L/eta    </b></td><td> as Reynolds number [-].</td></tr>
</table>

<h4>Verification</h4>
<p>
The mean Nusselt number <b> Nu </b> in the laminar regime representing the mean convective heat transfer coefficient <b> kc </b> for Prandtl numbers of different fluids is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/plate/fig_plate_kc_laminar.png\" width=\"600\" alt=\"fig_plate_kc_laminar\"/>
</p>

<p>
Note that this function is best used in the laminar regime up to a Reynolds number <b> Re </b> smaller than 2300. There is a deviation w.r.t. literature due to the neglect of the turbulence influence in the transition regime even though this function is used inside its cited restrictions for a higher Reynolds number. The function
<a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.HeatTransfer.Plate.kc_overall\">kc_overall</a> is recommended for the simulation of a Reynolds number higher than 2300.
</p>
<h4>References</h4>
<dl>
<dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 9th edition, 2002.</dd>
</dl>

</html>"));
          end kc_laminar;

          class kc_overall
            extends Modelica_Icons.Information;

              annotation (Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a laminar or turbulent fluid flow over an even surface.
</p>
<h4>Functions <b>kc_overall</b> and <b>kc_overall_KC</b></h4>
<p>
There are basically three differences:
</p>
<ul>
<li>
The function <b>kc_overall</b> is using <b>kc_overall_KC</b> but offers additional output variables like e.g. Reynolds number or Nusselt number and failure status (an output of <b>1</b> means that the function is not valid for the inputs).</li>
<li>
Generally the  function <b>kc_overall_KC</b> is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known mass flow rate.</li>
<li>
You can perform an inverse calculation from <b>kc_overall_KC</b>, where an unknown mass flow rate is calculated out of a given mean convective heat transfer coefficient <b> kc </b>
</li>
</ul>

<h4>Restriction</h4>
<ul>
<li> constant wall temperature</li>
<li> overall regime (Reynolds number 1e1 &lt; Re &lt; 1e7)</li>
<li> Prandtl number 0.6 &le; Pr &le; 2000</li>
</ul>

<h4>Geometry and Calculation </h4>
<p>This heat transfer function enables a calculation of heat transfer coefficient for laminar and turbulent flow regime. The geometry, constant and fluid parameters of the function are the same as for
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Plate.kc_laminar\">kc_laminar</a>  and <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.Plate.kc_turbulent\">kc_turbulent</a>.
</p>
<p>
The calculation conditions for laminar and turbulent flow is equal to the calculation in <b>kc_laminar</b>
and <b>kc_turbulent</b>. A smooth transition between both functions is carried out between 1e5 &le; Re &le; 5e5 (see figure below).
</p>
<h4>Verification</h4>
<p>
The mean Nusselt number <b> Nu = sqrt(Nu_lam^2 + Nu_turb^2) </b> representing the mean convective heat transfer coefficient <b> kc </b> for Prandtl numbers of different fluids is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/plate/fig_plate_kc_overall.png\" alt=\"fig_plate_kc_overall\"/>
</p>

<h4>References</h4>
<dl>
<dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 9th edition, 2002.</dd>
</dl>

</html>"));
          end kc_overall;

          class kc_turbulent
            extends Modelica_Icons.Information;

              annotation (Documentation(info="<html>
<p>
Calculation of the mean convective heat transfer coefficient <b> kc </b> for a hydrodynamically developed turbulent fluid flow over an even surface.
</p>
<h4>Functions <b>kc_turbulent</b> and <b>kc_turbulent_KC</b></h4>
<p>
There are basically three differences:
</p>
<ul>
<li>
The function <b>kc_turbulent</b> is using <b>kc_turbulent_KC</b> but offers additional output variables like e.g. Reynolds number or Nusselt number and failure status (an output of <b>1</b> means that the function is not valid for the inputs).</li>
<li>
Generally the  function <b>kc_turbulent_KC</b> is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known mass flow rate.</li>
<li>
You can perform an inverse calculation from <b>kc_turbulent_KC</b>, where an unknown mass flow rate is calculated out of a given mean convective heat transfer coefficient <b> kc </b>
</li>
</ul>

<h4>Restriction</h4>
<ul>
<li> constant wall temperature</li>
<li> turbulent regime (Reynolds number 5e5 &lt; Re &lt; 1e7)</li>
<li> Prandtl number 0.6 &le; Pr &le; 2000</li>
</ul>

<h4>Geometry </h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/plate/pic_plate.png\" alt=\"pic_plate\"/>
</p>

<h4>Calculation</h4>
<p>
The mean convective heat transfer coefficient <b> kc</b> for flat plate is calculated through the corresponding Nusselt number <b> Nu_turb</b> according to <i>[VDI 2002, p. Gd 1, eq. 2]</i>:
</p>

<pre>
    Nu_turb = (0.037 * Re^0.8 * Pr) / (1 + 2.443/Re^0.1 * (Pr^(2/3)-1))
</pre>

<p>
and the corresponding mean convective heat transfer coefficient <b> kc </b>:
</p>

<pre>
    kc =  Nu_turb * lambda / L
</pre>

<p>
with
</p>

<table>
<tr><td><b> cp          </b></td><td> as specific heat capacity at constant pressure [J/(kg.K)],</td></tr>
<tr><td><b> eta          </b></td><td> as dynamic viscosity of fluid [Pa.s],</td></tr>
<tr><td><b> kc          </b></td><td> as mean convective heat transfer coefficient [W/(m2.K)],</td></tr>
<tr><td><b> lambda         </b></td><td> as heat conductivity of fluid [W/(m.K)],</td></tr>
<tr><td><b> L              </b></td><td> as length of plate [m],</td></tr>
<tr><td><b> Nu_turb                 </b></td><td> as mean Nusselt number for turbulent regime [-], </td></tr>
<tr><td><b> Pr = eta*cp/lambda           </b></td><td> as Prandtl number [-],</td></tr>
<tr><td><b> rho          </b></td><td> as fluid density [kg/m3],</td></tr>
<tr><td><b> Re = v*rho*L/eta    </b></td><td> as Reynolds number [-].</td></tr>
</table>

<h4>Verification</h4>
<p>
The mean Nusselt number in turbulent regime <b> Nu </b> representing the mean convective heat transfer coefficient <b> kc </b> for Prandtl numbers of different fluids is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/plate/fig_plate_kc_turbulent.png\" alt=\"fig_plate_kc_turbulent\"/>
</p>


<h4>References</h4>
<dl>

<dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 9th edition, 2002.</dd>
</dl>

</html>"));
          end kc_turbulent;
          end Plate;

          package StraightPipe
          extends Modelica_Icons.Information;

          class kc_laminar
            extends Modelica_Icons.Information;

              annotation (Documentation(info="<html>
<p>
Calculation of mean convective heat transfer coefficient <b> kc </b> of a straight pipe at an uniform wall temperature <b> or </b> uniform heat flux <b>and</b> for a hydrodynamically developed <b>or</b> undeveloped laminar fluid flow.
</p>
<h4>Functions <b>kc_laminar</b> and <b>kc_laminar_KC</b></h4>
<p>
There are basically three differences:
</p>
<ul>
<li>
The function <b>kc_laminar</b> is using <b>kc_laminar_KC</b> but offers additional output variables like e.g. Reynolds number or Nusselt number and failure status (an output of <b>1</b> means that the function is not valid for the inputs).</li>
<li>
Generally the  function <b>kc_laminar_KC</b> is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known mass flow rate.</li>
<li>
You can perform an inverse calculation from <b>kc_laminar_KC</b>, where an unknown mass flow rate is calculated out of a given mean convective heat transfer coefficient <b> kc </b>
</li>
</ul>

<h4>Restriction</h4>
<ul>
<li> circular cross sectional area</li>
<li> uniform wall temperature (UWT) <b> or </b> uniform heat flux (UHF)</li>
<li> hydrodynamically developed fluid flow (DFF) <b> or </b> hydrodynamically undeveloped fluid flow (UFF)</li>
<li> 0.6 &le; Prandtl number &le; 1000</li>
<li> laminar regime (Reynolds number &le; 2000)</li>
</ul>

<h4>Geometry </h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/pic_straightPipe.png\" alt=\"pic_straightPipe\"/>
</p>

<h4>Calculation</h4>
<p>
The mean convective heat transfer coefficient <b> kc </b> of a straight pipe in the laminar regime can be calculated for the following four heat transfer boundary conditions through its corresponding Nusselt number <b> Nu </b>:
</p>
<p>
<b> Uniform wall temperature in developed fluid flow (heatTransferBoundary == Modelica_Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UWTuDFF)</b> according to <i>[VDI 2002, p. Ga 2, eq. 6]</i> :
</p>

<pre>
    Nu_TD = [3.66^3 + 0.7^3 + {1.615*(Re*Pr*d_hyd/L)^1/3 - 0.7}^3]^1/3
</pre>

<p>
<b> Uniform heat flux in developed fluid flow (heatTransferBoundary == Modelica_Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuDFF)</b> according to <i>[VDI 2002, p. Ga 4, eq. 19]</i> :
</p>
<pre>
    Nu_qD = [4.364^3 + 0.6^3 + {1.953*(Re*Pr*d_hyd/L)^1/3 - 0.6}^3]^1/3
</pre>

<p>
<b> Uniform wall temperature in undeveloped fluid flow (heatTransferBoundary == Modelica_Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UWTuUFF)</b> according to <i>[VDI 2002, p. Ga 2, eq. 12]</i> :
</p>
<pre>
    Nu_TU = [3.66^3 + 0.7^3 + {1.615*(Re*Pr*d_hyd/L)^1/3 - 0.7}^3 + {(2/[1+22*Pr])^1/6*(Re*Pr*d_hyd/L)^0.5}^3]^1/3
</pre>

<p>
<b> Uniform heat flux in developed fluid flow (heatTransferBoundary == Modelica_Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF)</b> according to <i>[VDI 2002, p. Ga 5, eq. 25]</i> :
</p>

<pre>
    Nu_qU = [4.364^3 + 0.6^3 + {1.953*(Re*Pr*d_hyd/L)^1/3 - 0.6}^3 + {0.924*Pr^1/3*[Re*d_hyd/L]^0.5}^3]^1/3.
</pre>

<p>
The corresponding mean convective heat transfer coefficient <b> kc </b> is determined w.r.t. the chosen heat transfer boundary by:
</p>

<pre>
    kc =  Nu * lambda / d_hyd
</pre>

<p>
with
</p>

<table>
<tr><td><b> d_hyd                    </b></td><td> as hydraulic diameter of straight pipe [m],</td></tr>
<tr><td><b> kc                       </b></td><td> as mean convective heat transfer coefficient [W/(m2K)],</td></tr>
<tr><td><b> lambda                   </b></td><td> as heat conductivity of fluid [W/(mK)],</td></tr>
<tr><td><b> L                        </b></td><td> as length of straight pipe [m],</td></tr>
<tr><td><b> Nu = kc*d_hyd/lambda     </b></td><td> as mean Nusselt number [-], </td></tr>
<tr><td><b> Pr = eta*cp/lambda       </b></td><td> as Prandtl number [-],</td></tr>
<tr><td><b> Re = rho*v*d_hyd/eta     </b></td><td> as Reynolds number [-],</td></tr>
<tr><td><b> v                        </b></td><td> as mean velocity [m/s].</td></tr>
</table>

<h4>Verification</h4>
<p>The mean Nusselt number <b> Nu </b> representing the mean convective heat transfer coefficient <b> kc </b> depending on four different heat transfer boundary conditions is shown in the figures below.
</p>
<p>
This verification has been done with the fluid properties of Water (Prandtl number Pr = 7) and a diameter to pipe length fraction of 0.1.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/straightPipe/fig_straightPipe_kc_laminar.png\" alt=\"fig_straightPipe_kc_laminar\"/>
</p>

<h4>References</h4>
<dl>
 <dt>Bejan,A.:</dt>
    <dd><b>Heat transfer handbook</b>.
    Wiley, 2003.</dd>
 <dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 9th edition, 2002.</dd>
</dl>

</html>"));
          end kc_laminar;

          class kc_overall
            extends Modelica_Icons.Information;

              annotation (Documentation(info="<html>
<p>
Calculation of mean convective heat transfer coefficient <b> kc </b> of a straight pipe at an uniform wall temperature <b> or </b> uniform heat flux <b> and </b> for a hydrodynamically developed <b>or</b> undeveloped laminar or turbulent fluid flow with neglect <b> or </b> consideration of pressure loss influence.
</p>
<h4>Functions <b>kc_overall</b> and <b>kc_overall_KC</b></h4>
<p>
There are basically three differences:
</p>
<ul>
<li>
The function <b>kc_overall</b> is using <b>kc_overall_KC</b> but offers additional output variables like e.g. Reynolds number or Nusselt number and failure status (an output of <b>1</b> means that the function is not valid for the inputs).</li>
<li>
Generally the  function <b>kc_overall_KC</b> is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known mass flow rate.</li>
<li>
You can perform an inverse calculation from <b>kc_overall_KC</b>, where an unknown mass flow rate is calculated out of a given mean convective heat transfer coefficient <b> kc </b>
</li>
</ul>

<h4>Restriction</h4>
<ul>
<li> circular cross sectional area </li>
<li> uniform wall temperature (UWT) <b> or </b> uniform heat flux (UHF) </li>
<li> hydrodynamically developed fluid flow </li>
<li> hydraulic diameter / length &le; 1 </li>
<li> 0.6 &le; Prandtl number &le; 1000 </li>
</ul>

<h4>Geometry and Calculation </h4>

<p>This heat transfer function enables a calculation of heat transfer coefficient for laminar and turbulent flow regime. The geometry, constant and fluid parameters of the function are the same as for
<a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_laminar\">kc_laminar</a>  and <a href=\"modelica://Modelica_Fluid.Dissipation.HeatTransfer.HelicalPipe.kc_turbulent\">kc_turbulent</a>.
</p>
<p>
The calculation conditions for laminar and turbulent flow is equal to the calculation in <b>kc_laminar</b>
and <b>kc_turbulent</b>. A smooth transition between both functions is carried out between 2200 &le; Re &le; 10000 (see figure below). </p>

<h4>Verification</h4>
<p>
The mean Nusselt number <b> Nu </b> representing the mean convective heat transfer coefficient <b> kc </b> is shown for the fluid properties of Water (Prandtl number Pr = 7) and a diameter to pipe length fraction of 0.1 in the figure below.
</p>

<p>
The following verification considers pressure loss influence (roughness =2).
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/straightPipe/fig_straightPipe_kc_overall.png\" alt=\"fig_straightPipe_kc_overall\"/>
</p>

<h4>References</h4>
<dl>
 <dt>Bejan,A.:</dt>
    <dd><b>Heat transfer handbook</b>.
    Wiley, 2003.</dd>
 <dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 9th edition, 2002.</dd>
</dl>

</html>"));
          end kc_overall;

          class kc_turbulent
            extends Modelica_Icons.Information;

              annotation (Documentation(info="<html>
<p>
Calculation of mean convective heat transfer coefficient <b> kc </b> of a straight pipe for a hydrodynamically developed turbulent fluid flow at uniform wall temperature <b> or </b> uniform heat flux with neglecting <b> or </b> considering of pressure loss influence.
</p>
<h4>Functions <b>kc_turbulent</b> and <b>kc_turbulent_KC</b></h4>
<p>
There are basically three differences:
</p>
<ul>
<li>
The function <b>kc_turbulent</b> is using <b>kc_turbulent_KC</b> but offers additional output variables like e.g. Reynolds number or Nusselt number and failure status (an output of <b>1</b> means that the function is not valid for the inputs).</li>
<li>
Generally the  function <b>kc_turbulent_KC</b> is numerically best used for the calculation of the mean convective heat transfer coefficient <b> kc </b> at known mass flow rate.</li>
<li>
You can perform an inverse calculation from <b>kc_turbulent_KC</b>, where an unknown mass flow rate is calculated out of a given mean convective heat transfer coefficient <b> kc </b>
</li>
</ul>

<h4>Restriction</h4>

<ul>
<li> circular cross sectional area </li>
<li> hydrodynamically developed fluid flow </li>
<li> hydraulic diameter / length &le; 1 </li>
<li> 0.6 &le; Prandtl number &le; 1000 </li>
<li> turbulent flow regime (1e4 &le; Reynolds number &le; 1e6) </li>
</ul>

<h4>Geometry </h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/pic_straightPipe.png\" alt=\"pic_straightPipe\"/>
</p>

<h4>Calculation</h4>
<p>
<b>Neglect pressure loss influence (roughness == 1):</b>
</p>
<p>
The mean convective heat transfer coefficient <b> kc </b> for smooth straight pipes is calculated through its corresponding Nusselt number <b> Nu </b> according to <i> [Dittus and Boelter in Bejan 2003, p. 424, eq. 5.76]</i>
</p>

<pre>
    Nu = 0.023 * Re^(4/5) * Pr^(1/3).
</pre>

<p>
<b>Consider pressure loss influence (roughness == 2):</b>
</p>

<p>
The mean convective heat transfer coefficient <b> kc </b> for rough straight pipes is calculated through its corresponding Nusselt number <b> Nu </b> according to <i>[Gnielinski in VDI 2002, p. Ga 5, eq. 26]</i>
</p>

<pre>
    Nu = (zeta/8)*Re*Pr/(1 + 12.7*(zeta/8)^0.5*(Pr^(2/3)-1))*(1+(d_hyd/L)^(2/3)),
</pre>

<p>
where the influence of the pressure loss on the heat transfer calculation is considered through
</p>

<pre>
    zeta =  (1.8*log10(Re)-1.5)^-2.
</pre>

<p>
The mean convective heat transfer coefficient <b> kc </b> in dependence of the chosen calculation (neglecting or considering of pressure loss influence) results into:
</p>

<pre>
    kc =  Nu * lambda / d_hyd
</pre>

<p>
with
</p>

<table>
<tr><td><b> d_hyd                      </b></td><td> as hydraulic diameter of straight pipe [m],</td></tr>
<tr><td><b> kc                         </b></td><td> as mean convective heat transfer coefficient [W/(m2K)],</td></tr>
<tr><td><b> lambda                     </b></td><td> as heat conductivity of fluid [W/(mK)],</td></tr>
<tr><td><b> L                          </b></td><td> as length of straight pipe [m],</td></tr>
<tr><td><b> Nu = kc*d_hyd/lambda       </b></td><td> as mean Nusselt number [-], </td></tr>
<tr><td><b> Pr = eta*cp/lambda         </b></td><td> as Prandtl number [-],</td></tr>
<tr><td><b> Re = rho*v*d_hyd/eta       </b></td><td> as Reynolds number [-],</td></tr>
<tr><td><b> v                          </b></td><td> as mean velocity [m/s],</td></tr>
<tr><td><b> zeta                       </b></td><td> as pressure loss coefficient [-]. </td></tr>
</table>

<p>
Note that there is no significant difference for the calculation of the mean Nusselt number <b> Nu </b> at a uniform wall temperature (UWT) or a uniform heat flux (UHF) as heat transfer boundary in the turbulent regime (Bejan 2003, p.303).
</p>

<h4>Verification</h4>
<p>
The mean Nusselt number <b> Nu </b> representing the mean convective heat transfer coefficient <b> kc </b> for Prandtl numbers of different fluids is shown in the figures below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/straightPipe/fig_straightPipe_kc_turbulent.png\" alt=\"fig_straightPipe_kc_turbulent\"/>
</p>

<p>
Note that the higher the Prandtl number <b> Pr </b> there is a higher difference in Nusselt numbers <b> Nu </b> comparing the neglect and consideration of pressure loss.
</p>

<h4>References</h4>
<dl>
  <dt>Bejan,A.:</dt>
    <dd><b>Heat transfer handbook</b>.
    Wiley, 2003.</dd>
 <dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 9th edition, 2002.</dd>
</dl>

</html>"));
          end kc_turbulent;

          class kc_twoPhaseOverall
            extends Modelica_Icons.Information;

              annotation (Documentation(info="<html>
<p>
Calculation of local <b>two phase</b> heat transfer coefficient <b>kc_2ph </b>for (horizontal/vertical) <b>boiling</b> or (horizontal) <b>condensation</b> for an overall flow regime.
</p>

<h4>Restriction</h4>
<ul>
  <li>circular cross sectional area </li>
  <li>no subcooled boiling </li>
  <li>film condensation </li>
</ul>

<h4>Geometry </h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/pic_straightPipe.png\" alt=\"pic_straightPipe\"/>
</p>

<h4>Calculation</h4>
<p><b>Boiling in a horizontal pipe (target = Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.BoilHor):</b></p>
<p>
The local two phase heat transfer coefficient <b> kc_2ph </b> during boiling in a <b>horizontal</b> straight pipe for an overall regime is calculated according to <i>[Gungor/Winterton 1986, p.354, eq. 2]</i> :
</p>

<pre>
    kc_2ph = E_fc*E_fc_hor*kc_fc+S_nb+S_nb_hor*kc_nb
</pre>

<p>
with
</p>

<table>
<tr><td><b> Bo</b>=qdot_A/(mdot_A*dh_lv)  </td><td> as boiling number [-],</td></tr>
<tr><td><b> dh_lv                         </b></td><td> as evaporation enthalpy [J/kg],</td></tr>
<tr><td><b> E_fc</b>=f(Bo,Fr_l,X_tt)      </td><td> as forced convection enhancement factor [-],</td></tr>
<tr><td><b> E_fc_hor</b> =f(Fr_l)         </td><td> as forced convection enhancement factor for horizontal straight pipes [-],</td></tr>
<tr><td><b> Fr_l                          </b></td><td> as Froude number assuming total mass flow rate flowing as liquid [-],</td></tr>
<tr><td><b> kc_2ph                        </b></td><td> as local two phase heat transfer coefficient [W/(m2K)],</td></tr>
<tr><td><b> kc_fc                         </b></td><td> as heat transfer coefficient considering forced convection [W/(m2K)],</td></tr>
<tr><td><b> kc_nb                         </b></td><td> as heat transfer coefficient considering nucleate boiling [W/(m2K)],</td></tr>
<tr><td><b> mdot_A                        </b></td><td> as total mass flow rate density [kg/(m2s)],</td></tr>
<tr><td><b> qdot_A                        </b></td><td> as heat flow rate density [W/m2],</td></tr>
<tr><td><b> Re_l                          </b></td><td> as Reynolds number assuming liquid mass flow rate flowing alone [-],</td></tr>
<tr><td><b> S_nb</b> =f(E_fc,Re_l)        </td><td> as suppression factor of nucleate boiling [-],</td></tr>
<tr><td><b> S_nb_hor</b> =f(Fr_l)         </td><td> as suppression factor of nucleate boiling for horizontal straight pipes [-],</td></tr>
<tr><td><b> x_flow                        </b></td><td> as mass flow rate quality [-],</td></tr>
<tr><td><b> X_tt</b> = f(x_flow)          </td><td> as Martinelli parameter [-].</td></tr>
</table>

<p><b>Boiling in a vertical pipe (target = Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.BoilVer):</b></p>
<p>
The local two phase heat transfer coefficient <b> kc_2ph </b> during boiling in a <b>vertical</b> straight pipe for an overall regime is calculated out of the correlations for boiling in a horizontal straight pipe, where the horizontal correction factors <b> E_fc_hor,S_nb_hor</b> are unity.
</p>
<p>
Please note that the correlations named above are not valid for subcooled boiling due to a different driving temperature for nucleate boiling and forced convection. At subcooled boiling there is no enhancement factor (no vapour generation) but the suppression factor remains effective.
</p>

<p><b>Condensation in a horizontal pipe (target = Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.CondHor):</b></p>
<p>
The local two phase heat transfer coefficient <b> kc_2ph </b> during condensation in a <b>horizontal</b> straight pipe for an overall regime is calculated according to <i>[Shah 1979, p.548, eq. 8]</i> :
</p>

<pre>
  kc_2ph = kc_1ph*[(1 - x_flow)^0.8 + 3.8*x_flow^0.76*(1 - x_flow)^0.04/p_red^0.38]
</pre>

<p>
where the convective heat transfer coefficient <b> kc_1ph </b> assuming the total mass flow rate is flowing as liquid according to <i>[Shah 1979, p.548, eq. 5]</i> :
</p>

<pre>
  kc_1ph = 0.023*Re_l^0.8*Pr_l^0.4*lambda_l/d_hyd
 </pre>

<p>
with
</p>

<table>
<tr><td><b> d_hyd                        </b></td><td> as hydraulic diameter [m],</td></tr>
<tr><td><b> kc_2ph                       </b></td><td> as local two phase heat transfer coefficient [W/(m2K)],</td></tr>
<tr><td><b> kc_1ph                       </b></td><td> as convective heat transfer coefficient assuming total mass flow rate is flowing as liquid [W/(m2K)],</td></tr>
<tr><td><b> lambda_l                     </b></td><td> as thermal conductivity of fluid  [W/(mK)],</td></tr>
<tr><td><b> pressure                     </b></td><td> as thermodynamic pressure of fluid [Pa],</td></tr>
<tr><td><b> p_crit                       </b></td><td> as critical pressure of fluid [Pa],</td></tr>
<tr><td><b> p_red</b> = pressure/p_crit  </td><td> as reduced pressure [-],</td></tr>
<tr><td><b> Pr_l                         </b></td><td> as Prandtl number assuming [-],</td></tr>
<tr><td><b> Re_l                         </b></td><td> as Reynolds number assuming <b>total</b> mass flow rate is flowing as liquid [-],</td></tr>
<tr><td><b> x_flow                       </b></td><td> as mass flow rate quality [-],</td></tr>
</table>

<h4>Verification</h4>
<p>The local two phase heat transfer coefficient <b>kc_2ph </b> during for horizontal and vertical boiling as well as for horizontal condensation is shown for a straight pipe in the figures below.</p>

<p><b>Boiling in a horizontal pipe (target = Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.BoilVer):</b></p>
<p>
Here the validation of the two phase heat transfer coefficient is shown for boiling in a horizontal straight pipe.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/straightPipe/fig_kc_twoPhaseOverall_KC_4.png\" alt=\"fig_kc_twoPhaseOverall\"/>
</p>

<p>The two phase heat transfer coefficient (<b>kc_2ph </b>) w.r.t. <i>Gungor/Winterton</i> is shown in dependence of the mass flow rate quality (<b>x_flow </b>) for different mass flow rate densities (<b>mdot_A </b>). The validation has been done with measurement results from <i>Kattan/Thome</i> for R134a as medium.</p>
<p>
The two phase heat transfer coefficient increases with increasing mass flow rate quality up to a maximum value. After that there is a rapid decrease of (<b>kc_2ph </b>) with increasing (<b>x_flow </b>). This can be explained with a partial dryout of the pipe wall for a high mass flow rate quality.
</p>

<p><b>Condensation in a horizontal pipe (target = Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.CondHor):</b></p>
<p>
Here the validation of the two phase heat transfer coefficient is shown for condensation in a horizontal straight pipe.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/straightPipe/fig_kc_twoPhaseOverall_KC_2.png\" alt=\"fig_kc_twoPhaseOverall\"/>
</p>

<p>The two phase heat transfer coefficient (<b>kc_2ph </b>) w.r.t. <i>Shah</i> is shown in dependence of the mass flow rate quality (<b>x_flow </b>) for different mass flow rate densities (<b>mdot_A </b>). The validation has been done with measurement results from <i>Dobson/Chato</i> for R134a as medium.</p>

<h4>References</h4>
<dl><dt>Bejan,A.: </dt>
<dd><b>Heat transfer handbook</b>. Wiley, 2003. </dd>
<dt>M.K. Dobson and J.C. Chato: </dt>
<dd><b>Condensation in smooth horizontal tubes</b>. Journal of HeatTransfer, Vol.120, p.193-213, 1998. </dd>
<dt>Gungor, K.E. and R.H.S. Winterton: </dt>
<dd><b>A general correlation for flow boiling in tubes and annuli</b>, Int.J. Heat Mass Transfer, Vol.29, p.351-358, 1986. </dd>
<dt>N. Kattan and J.R. Thome: </dt>
<dd><b>Flow boiling in horizontal pipes: Part 2 - new heat transfer data for five refrigerants.</b>. Journal of Heat Transfer, Vol.120. p.148-155, 1998. </dd>
<dt>Shah, M.M.: </dt>
<dd><b>A general correlation for heat transfer during film condensation inside pipes</b>. Int. J. Heat Mass Transfer, Vol.22, p.547-556, 1979.</dd>
</dl></html>"));
          end kc_twoPhaseOverall;

          end StraightPipe;

        end HeatTransfer;

      package PressureLoss
        extends Modelica_Icons.Information;

      package Bend
        extends Modelica_Icons.Information;

      class dp_curvedOverall
       extends Modelica_Icons.Information;
      annotation(Documentation(info="<html>
<p>
Calculation of pressure loss in curved bends at overall flow regime for incompressible and single-phase fluid flow through circular cross sectional area considering surface roughness.
</p>
<h4>Restriction</h4>
<p>
This function shall be used inside of the restricted limits according to the referenced literature.
</p>

<ul>
<li><b>circular cross sectional area </b></li>
<li><b>0.5 &le; curvature radius / diameter &le; 3 </b><i>[Idelchik 2006, p. 357, diag. 6-1] </i></li>
<li><b>length of bend along curved axis / diameter &ge; 10 </b><i>[Idelchik 2006, p. 357, diag. 6-1] </i></li>
<li><b>angle of curvature smaller than 180&deg; (delta &le; 180) </b><i>[Idelchik 2006, p. 357, diag. 6-1] </i></li>
</ul>

<h4>Geometry</h4>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/bend/pic_circularBend.png\" alt=\"pic_circularBend\"/>
</p>

<h4>Calculation</h4>
<p>
The pressure loss <b>dp </b>for curved bends is determined by:
</p>
<pre>
    dp = zeta_TOT * (rho/2) * velocity^2
</pre>
<p>
with
</p>
<table cellspacing=\"2\" cellpadding=\"0\" border=\"0\"><tr>
<td><p><b>rho </b></p></td>
<td><p>as density of fluid [kg/m3],</p></td>
</tr>
<tr>
<td><p><b>velocity </b></p></td>
<td><p>as mean velocity [m/s],</p></td>
</tr>
<tr>
<td><p><b>zeta_TOT </b></p></td>
<td><p>as pressure loss coefficient [-].</p></td>
</tr>
</table>
<p>
<b>Curved bends with relative curvature radius R_0/d_hyd &le; 3 </b>according to <i>[Idelchik 2006, p. 357, diag. 6-1]</i>
</p>
<p>
The pressure loss of curved bends is similar to its calculation in straight pipes. There are three different flow regimes observed (laminar,transition,turbulent). The turbulent regime is further separated into sections with a dependence or independence of the local resistance coefficient (<b>zeta_LOC </b>) on Reynolds number. The local resistance coefficient (<b>zeta_LOC</b>) of a curved bend is calculated in dependence of the flow regime as follows:
</p>
<ul>
<li><p><b>Laminar regime (Re &le; Re_lam_leave)</b>: </p>
<pre>      zeta_LOC = A2/Re + A1*B1*C1</pre></li>
<li><p><b>Transition regime (Re_lam_leave &le; 4e4)</b></p>
<p> This calculation is done using a smoothing function interpolating between the laminar and the first turbulent flow regime.</p></li>
<li><p><b>Turbulent regime (4e4 &le; 3e5) with dependence </b> of local resistance coefficient on Reynolds number: </p>
<pre>      zeta_LOC = k_Re * (A1*B1*C1)</pre>
<p>where <b>k_Re</b> depends on the relative curvature radius <b>R_0/d_hyd </b></p>
<pre>
      k_Re = 1 + 4400/Re              for 0.50 &lt; r/d_hyd &lt; 0.55
      k_Re = 5.45/Re^(0.118)          for 0.55 &le; r/d_hyd &lt; 0.70
      k_Re = 11.5/Re^(0.19)           for 0.70 &le; r/d_hyd &lt; 3.00</pre></li>
<li><p><b>Turbulent regime (Re &ge; 3e5) with independence </b>of local resistance coefficient on Reynolds number </p>
<pre>      zeta_LOC = A1*B1*C1</pre></li>
</ul>

<p>with </p>
<table cellspacing=\"2\" cellpadding=\"0\" border=\"0\"><tr>
<td><p><b>A1 </b></p></td>
<td><p>as coefficient considering effect of angle of turning (delta) [-],</p></td>
</tr>
<tr>
<td><p><b>A2 </b></p></td>
<td><p>as coefficient considering effect for laminar regime [-],</p></td>
</tr>
<tr>
<td><p><b>B1 </b></p></td>
<td><p>as coefficient considering effect of relative curvature radius (R_0/d_hyd) [-],</p></td>
</tr>
<tr>
<td><p><b>C1=1 </b></p></td>
<td><p>as coefficient considering relative elongation of cross sectional area (here: circular cross sectional area) [-],</p></td>
</tr>
<tr>
<td><p><b>k_Re </b></p></td>
<td><p>as coefficient considering influence of laminar regime in transition regime [-],</p></td>
</tr>
<tr>
<td><p><b>Re </b></p></td>
<td><p>as Reynolds number [-].</p></td>
</tr>
</table>
<p><br/><br/>The pressure loss coefficient <b>zeta_TOT </b>of a curved bend including pressure loss due to friction is determined by its local resistance coefficient <b>zeta_LOC </b>multiplied with a correction factor <b>CF </b>for surface roughness according to <i>[Miller, p. 209, eq. 9.4]:</i> </p>
<pre>    zeta_TOT = CF*zeta_LOC </pre>
<p>where the correction factor <b>CF </b>is determined from the Darcy friction factor of a straight pipe having the bend flow path length </p>
<pre>    CF = 1 + (lambda_FRI_rough * pi * delta/d_hyd) / zeta_LOC</pre>
<p>and the Darcy friction factors <b>lambda_FRI_rough </b>is calculated with an approximated Colebrook-White law according to <i>[Miller, p. 191, eq. 8.4]:</i> </p>
<pre>    lambda_FRI_rough = 0.25*(lg(K/(3.7*d_hyd) + 5.74/Re^0.9))^-2</pre>
<p>with </p>
<table cellspacing=\"2\" cellpadding=\"0\" border=\"0\"><tr>
<td><p><b>delta </b></p></td>
<td><p>as curvature radiant [rad],</p></td>
</tr>
<tr>
<td><p><b>d_hyd </b></p></td>
<td><p>as hydraulic diameter [m],</p></td>
</tr>
<tr>
<td><p><b>K</b> </p></td>
<td><p>as absolute roughness (average height of surface asperities) [m],</p></td>
</tr>
<tr>
<td><p><b>lambda_FRI_rough </b></p></td>
<td><p>as Darcy friction factor[-],</p></td>
</tr>
<tr>
<td><p><b>Re </b></p></td>
<td><p>as Reynolds number [m],</p></td>
</tr>
<tr>
<td><p><b>zeta_LOC </b></p></td>
<td><p>as local resistance coefficient [-],</p></td>
</tr>
<tr>
<td><p><b>zeta_TOT </b></p></td>
<td><p>as pressure loss coefficient [-].</p></td>
</tr>
</table>
<p><br/>The correction for surface roughness through <b>CF </b>is used only in the turbulent regime, where the fluid flow is influenced by surface asperities not covered by a laminar boundary layer. The turbulent regime starts at <b>Re &ge; 4e4 </b>according to <i>[Idelchik 2006, p. 336, sec. 15]</i>. There is no correction due to roughness in the laminar regime up to <b>Re &le; 6.5e3 </b>according to <i>[Idelchik 2006, p. 336, sec. 15]</i>. </p>
<p>Nevertheless the transition point from the laminar to the transition regime is shifted to smaller Reynolds numbers for an increasing absolute roughness. This effect is considered according to <i>[Samoilenko in Idelchik 2006, p. 81, sec. 2-1-21]</i> as: </p>
<pre>    Re_lam_leave = 754*exp(if k &le; 0.007 then 0.0065/0.007 else 0.0065/k)</pre>
<p>with </p>
<table cellspacing=\"2\" cellpadding=\"0\" border=\"0\"><tr>
<td><p><b>k = K /d_hyd </b></p></td>
<td><p>as relative roughness [-],</p></td>
</tr>
<tr>
<td><p><b>Re_lam_leave </b></p></td>
<td><p>as Reynolds number for leaving laminar regime [-].</p></td>
</tr>
</table>
<p>Note that the beginning of the laminar regime cannot be beneath <b>Re &le; 1e2 </b>. </p>
<h4>Verification</h4>
<p>The pressure loss coefficient <b>zeta_TOT </b>of a curved bend in dependence of the Reynolds number <b>Re </b>for different relative curvature radii <b>R_0/d_hyd </b>and different angles of turning <b>delta </b>is shown in the figures below. </p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/bend/fig_bend_dp_curvedOverall_DPvsMFLOW.png\" alt=\"fig_bend_dp_curvedOverall_DPvsMFLOW\"/>
</p>

<p>There are deviations of the pressure loss coefficient <b>zeta_TOT</b> comparing different references. Usually these deviations in the transition regime have to be accepted due to an uncertainty for the determination of comparable boundary conditions in the different references. Nevertheless these calculations cover the usual range of pressure loss coefficients for a curved bend. The pressure loss coefficient <b>zeta_TOT </b>for the same geometry can be adjusted via varying the average height of surface asperities <b>K</b> for calibration. </p>
<p>The pressure loss in dependence of the mass flow rate of water is shown for different relative curvature radii: </p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/bend/fig_bend_dp_curvedOverall_DPvsMFLOWwrtRD.png\" alt=\"fig_bend_dp_curvedOverall_DPvsMFLOWwrtRD\"/>
</p>

<p>The pressure loss in dependence of the mass flow rate of water is shown for different angles of turning: </p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/bend/fig_bend_dp_curvedOverall_DPvsMFLOWwrtDelta.png\" alt=\"fig_bend_dp_curvedOverall_DPvsMFLOWwrtRD\"/>
</p>

<p>Note that there is a small deviation between the compressible and incompressible calculation due to the lack of a direct analytical invertibility.</p>

<h4>References</h4>
<dl><dt>Elmquist,H., M.Otter and S.E. Cellier: </dt>
<dd><b>Inline integration: A new mixed symbolic / numeric approach for solving differential-algebraic equation systems.</b>. In Proceedings of European Simulation MultiConference, Praque, 1995.</dd>
<dt>Idelchik,I.E.: </dt>
<dd><b>Handbook of hydraulic resistance</b>. Jaico Publishing House, Mumbai, 3rd edition, 2006.</dd>
<dt>Miller,D.S.: </dt>
<dd><b>Internal flow systems</b>. volume 5th of BHRA Fluid Engineering Series.BHRA Fluid Engineering, 1984. </dd>
<dt>Samoilenko,L.A.: </dt>
<dd><b>Investigation of the hydraulic resistance of pipelines in the zone of transition from laminar into turbulent motion</b>. PhD thesis, Leningrad State University, 1968.</dd>
<dt>VDI: </dt>
<dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>. Springer Verlag, 9th edition, 2002. </dd>
</dl></html>"));
      end dp_curvedOverall;

      class dp_edgedOverall
       extends Modelica_Icons.Information;
      annotation(Documentation(info="<html>
<p>
Calculation of pressure loss in edged bends with sharp corners at overall flow regime for incompressible and single-phase fluid flow through circular cross sectional area considering surface roughness.
</p>
<h4>Restriction</h4>
<p>
This function shall be used inside of the restricted limits according to the referenced literature.
</p>
<ul>
 <li>
      <b> circular cross sectional area </b> <i>[Idelchik 2006, p. 366, diag. 6-7] </i>
 </li>
 <li>
      <b> edged bend with sharp corners at turning </b> <i>[Idelchik 2006, p. 366, diag. 6-7] </i>
 </li>
 <li>
      <b> 0&deg; &le; angle of turning &le; 180&deg; </b> <i>[Idelchik 2006, p. 338, sec. 19] </i>
 </li>
 <li>
      <b> length of edged bend along edged axis / diameter &ge; 10 </b> <i>[Idelchik 2006, p. 366, diag. 6-7] </i>
 </li>
</ul>

<h4>Geometry</h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/bend/pic_edgedBend.png\" alt=\"pic_edgedBend\"/>
</p>

<h4>Calculation</h4>
<p>The pressure loss <b>dp</b> for edged bends is determined by:
</p>

<pre>
    dp = zeta_TOT * (rho/2) * velocity^2
</pre>

<p>
with
</p>

<table>
<tr><td><b> rho            </b></td><td> as density of fluid [kg/m3],</td></tr>
<tr><td><b> velocity       </b></td><td> as mean velocity [m/s],</td></tr>
<tr><td><b> zeta_TOT       </b></td><td> as pressure loss coefficient [-].</td></tr>
</table>

<p>
The pressure loss coefficient <b> zeta_TOT </b> of an edged bend can be calculated for different angles of turning <b> delta </b> by:
</p>

<pre>
    zeta_TOT = A * C1 * zeta_LOC * CF_Fri* CF_Re <i>[Idelchik 2006, p. 366, diag. 6-7] </i> and <i>[Miller 1984, p. 149, sec. 9.4]</i>
</pre>

<p>
with
</p>

<table>
<tr><td><b> A              </b></td><td> as coefficient considering effect for angle of turning [-],</td></tr>
<tr><td><b> C1             </b></td><td> as coefficient considering relative elongation of cross sectional area (here: circular cross sectional area) [-],</td></tr>
<tr><td><b> CF_Fri         </b></td><td> as correction factor considering surface roughness [-],</td></tr>
<tr><td><b> CF_Re          </b></td><td> as correction factor considering Reynolds number [-],</td></tr>
<tr><td><b> delta          </b></td><td> as angle of turning [deg].</td></tr>
</table>

<p>
The correction factor <b> CF_Fri </b> regarding the influence of surface roughness is determined as ratio of the Darcy friction factor for rough surfaces to smooth surfaces according to <i>[Miller, p. 207, eq. 9.3]:</i>
</p>
<pre>
    CF_Fri = lambda_FRI_rough / lambda_FRI_smooth
</pre>

<p>
and the Darcy friction factors <b>lambda_FRI</b> are calculated with an approximated Colebrook-White law according to <i>[Miller, p. 191, eq. 8.4]:</i>
</p>
<pre>
    lambda_FRI = 0.25*(lg(K/(3.7*d_hyd) + 5.74/Re^0.9))^-2
</pre>

<p>
with
</p>

<table>
<tr><td><b> d_hyd              </b></td><td> as hydraulic diameter [m],</td></tr>
<tr><td><b> K                  </b></td><td> as absolute roughness (average height of surface asperities) [m],</td></tr>
<tr><td><b> lambda_FRI         </b></td><td> as Darcy friction factor[-],</td></tr>
<tr><td><b> Re                 </b></td><td> as Reynolds number [m],</td></tr>
<tr><td><b> zeta_TOT           </b></td><td> as pressure loss coefficient [-].</td></tr>
</table>

<p>
Note that the Darcy friction factor for a smooth surface <b> lambda_FRI_smooth </b> is calculated with the previous equation and an absolute roughness of <b> K = 0 </b>.
</p>

<p>
The correction for surface roughness through <b> CF_Fri </b> is used only in the turbulent regime, where the fluid flow is influenced by surface asperities not covered by a laminar boundary layer. Here the correction according to friction starts at <b> Re &ge; Re_lam_leave </b> according to <i>[Idelchik 2006, p. 336, sec. 15]</i>. Here the end of the laminar regime is restricted to a Reynolds number smaller than 2e3 w.r.t <i>[VDI, p. Lac 6, fig. 16]</i>.
</p>

<p>
Nevertheless the transition point from the laminar to the transition regime is shifted to smaller Reynolds numbers for an increasing absolute roughness. This effect is considered according to <i>[Samoilenko in Idelchik 2006, p. 81, sec. 2-1-21]</i> as:
</p>

<pre>
    Re_lam_leave = 754*exp(if k &le; 0.007 then 0.0065/0.007 else 0.0065/k)
</pre>

<p>
with
</p>

<table>
<tr><td><b> k = K /d_hyd       </b></td><td> as relative roughness [-],</td></tr>
<tr><td><b> Re_lam_leave       </b></td><td> as Reynolds number for leaving laminar regime [-].</td></tr>
</table>

<p>
Note that the beginning of the laminar regime cannot be beneath <b> Re &le; 5e2 </b>.
</p>

<p>
In addition the influence or decreasing Reynolds numbers <b> Re </b> on the pressure loss coefficient <b> zeta_TOT </b> in the laminar and turbulent regime is considered through a second correction factor <b> CF_Re </b> according to <i>[Miller 1984, p. 149, sec. 9.4]</i> by:
</p>

<pre>
   CF_Re = B/Re^exp for Re &le; 2e5
</pre>

<p>
with
</p>

<table>
<tr><td><b> B = f(Geometry)  </b></td><td> as coefficient considering effect of Reynolds number in laminar regime [-],</td></tr>
<tr><td><b> exp              </b></td><td> as exponent for Reynolds number in laminar regime [-],</td></tr>
<tr><td><b> Re               </b></td><td> as Reynolds number [-], </td></tr>
</table>


<p>
Note that the coefficient <b> B </b> considers the influence of the angle of turning <b> delta </b> on the pressure loss coefficient <b> zeta_TOT </b> in the laminar regime according to <i>[Idelchik 2006, p. 340, sec. 28]</i>.
</p>

<p>
Note that the correction of the pressure loss coefficient <b> zeta_TOT </b> is influenced by the correction factor <b> CF_Re </b> only for decreasing Reynolds numbers <b> Re </b> out of the turbulent fluid flow regime at <b> Re &le; 2e5 </b> into transition and laminar fluid flow regime.
</p>

<h4>Verification</h4>
<p>
The pressure loss coefficient <b> zeta_TOT </b> of a edged bend in dependence of the Reynolds number <b> Re </b> for different angles of turning <b> delta </b> is shown in the figures below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/bend/fig_bend_dp_edgedOverall_ZETAvsRE.png\" alt=\"fig_bend_dp_edgedOverall_ZETAvsRE\"/>
</p>

<p>
Pressure loss calculation of edged bends is complex and there are large differences in literature data. Nevertheless these calculations cover the usual range of pressure loss coefficients for an edged bend.
</p>

<p>
The validation of the pressure loss coefficient for an edged bends shows four possible flow regimes:
</p>
<ul>
 <li>
      <b> laminar regime </b> for Re &le; 5e2</li>
 <li>
      <b> transition regime </b> for 5e2 &le; Re &le; 1e3 ... 1e4</li>
 <li>
      <b> turbulent regime dependent on Reynolds number </b> for 2e3 ... 1e4 &le; Re &le; 1e5</li>
 <li>
      <b> turbulent regime independent of Reynolds number</b> for Re &ge; 2e5</li>
</ul>

<p>
<b> Incompressible case </b> [Pressure loss = f(m_flow)]:
</p>
<p>
The pressure loss in dependence of the mass flow rate of water is shown for different angles of turning:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/bend/fig_bend_dp_edgedOverall_DPvsMFLOWwrtDelta.png\" alt=\"fig_bend_dp_edgedOverall_DPvsMFLOWwrtDelta\"/>
</p>

<p>
<b> Compressible case </b> [Mass flow rate = f(dp)]:
</p>
<p>
The mass flow rate in dependence of the pressure loss of water is shown for different angles of turning:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/bend/fig_bend_dp_edgedOverall_MFLOWvsDPwrtDelta.png\" alt=\"fig_bend_dp_edgedOverall_MFLOWvsDPwrtDelta\"/>
</p>

<h4>References</h4>
<dl>
<dt>Idelchik,I.E.:</dt>
    <dd><b>Handbook of hydraulic resistance</b>.
    Jaico Publishing House,Mumbai,3rd edition, 2006.</dd>
<dt>Miller,D.S.:</dt>
    <dd><b>Internal flow systems</b>.
    volume 5th of BHRA Fluid Engineering Series.BHRA Fluid Engineering, 1984.</dd>
 <dt>Samoilenko,L.A.:</dt>
    <dd><b>Investigation of the hydraulic resistance of pipelines in the
        zone of transition from laminar into turbulent motion</b>.
        PhD thesis, Leningrad State University, 1968.</dd>
<dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 9th edition, 2002.</dd>
</dl>
</html>"));
      end dp_edgedOverall;

        annotation (DocumentationClass=true);
      end Bend;

      package Channel
        extends Modelica_Icons.Information;

      class dp_internalFlowOverall
       extends Modelica_Icons.Information;
      annotation(Documentation(info="<html>
<p>
Calculation of pressure loss for an internal flow through different geometries at overall flow regime for single-phase fluid flow considering surface roughness.
</p>
<h4>Restriction</h4>
<p>
This function shall be used inside of the restricted limits according to the referenced literature.
</p>
<ul>
 <li>
      <b> developed fluid flow </b>
 </li>
</ul>

<h4>Geometry</h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/channel/pic-pLchannel.png\" alt=\"pic-pLchannel\"/>
</p>

<h4>Calculation</h4>
<p>
The pressure loss <b>dp</b> for channels is determined by:
</p>

<pre>
    dp = zeta_TOT * (rho/2) * velocity^2
</pre>

<p>
with
</p>

<table>
<tr><td><b> rho            </b></td><td> as density of fluid [kg/m3],</td></tr>
<tr><td><b> velocity       </b></td><td> as mean velocity [m/s],</td></tr>
<tr><td><b> zeta_TOT       </b></td><td> as pressure loss coefficient [-].</td></tr>
</table>

<p>
<b>Channels with different shape of its cross sectional area are calculated </b> according to <i>[Miller 1978, p. 138, fig. 8.5-8-6]</i>
</p>
<p>
The pressure loss of these channels is similar to its calculation in straight pipes. There are three different flow regimes observed (laminar,transition,turbulent). The pressure loss coefficient (<b>zeta_TOT</b>) of a channel is calculated in dependence of the flow regime as follows:
</p>

<ul>
  <li><b>Laminar regime (Re &le; Re_lam_leave)</b>:
     <pre>
      zeta_TOT = CF_lam/Re * (L/d_hyd)
     </pre></li>
  <li><p><b>Transition regime (Re_lam_leave &le; 4e4)</b></p>
        <p>This calculation is done using a smoothing function interpolating between the laminar and the turbulent flow regime.</p></li>
  <li> <p><b>Turbulent regime (Re &ge; 4e3)</b>:</p>
        <p>The turbulent regime can be calculated with the pressure loss correlations for a straight pipe with the hydraulic diameter of
           the chosen geometry instead of the internal diameter of a straight pipe according to <i>[VDI 2002, p. Lab 4, sec. 2.1]</i> .
           The documentation of turbulent fluid flow for a straight pipe is shown in
           <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.StraightPipe.dp_turbulent\">dp_turbulent</a>.</p></li>
</ul>

<p>
with
</p>

<table>
<tr><td><b> CF_lam        </b></td><td> as correction factor considering the geometry for laminar regime [-],</td></tr>
<tr><td><b> L             </b></td><td> as length of geometry perpendicular to cross sectional area [m],</td></tr>
<tr><td><b> d_hyd         </b></td><td> as hydraulic diameter of geometry [m],</td></tr>
<tr><td><b> Re            </b></td><td> as Reynolds number [-],</td></tr>
<tr><td><b> zeta_TOT      </b></td><td> as pressure loss coefficient [-].</td></tr>
</table>

<p>
Note that the beginning of the laminar regime depends on the chosen surface roughness of the channel and cannot be beneath <b>Re &le; 1e3</b>.
</p>
<h4>Verification</h4>
<p>
The Darcy friction factor (<b>lambda_FRI</b>) of a channel with different shapes of its cross sectional area are shown in dependence of the Reynolds number (<b>Re</b>) in the figures below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/channel/fig_channel_dp_internalFlowOverall_lambdaVsRe.png\" alt=\"fig_channel_dp_internalFlowOverall_lambdaVsRe\"/>
</p>

<p>
The Darcy friction factor (<b>lambda_FRI</b>) for different geometries has been obtained at the same hydraulic diameter and the same mean velocity of the internal flow. Note that there is no difference of the Darcy friction factor in the turbulent regime if using the same hydraulic diameter for all geometries. Roughness can be considered but it is not used for this validation.
</p>
<h4>References</h4>
<dl>
<dt>Miller,D.S.:</dt>
    <dd><b>Internal flow systems</b>.
    Volume 5th of BHRA Fluid Engineering Series.BHRA Fluid Engineering, 1978.</dd>
<dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 9th edition, 2002.</dd>
</dl>
</html>"));
      end dp_internalFlowOverall;

        annotation (DocumentationClass=true);
      end Channel;

      package General
        extends Modelica_Icons.Information;

      class dp_idealGas
       extends Modelica_Icons.Information;
      annotation(Documentation(info="<html>
<p>
Calculation of a generic pressure loss for an <b> ideal gas </b> using mean density.
</p>
<h4>Restriction</h4>
<p>
This function shall be used inside of the restricted limits according to the referenced literature.
</p>
<ul>
 <li>
    <b> ideal gas </b>
 </li>
 <li>
    mean density of ideal gas
 </li>
</ul>

<h4>Calculation</h4>
<p>
The geometry parameters of energy devices necessary for the pressure loss calculations are often not exactly known.
Therefore the modelling of the detailed pressure loss calculation has to be simplified.
</p>
<p>
The pressure loss <b>dp</b> for the compressible case [Mass flow rate = f(dp)] is determined by (Eq.1):
</p>

<pre>
    m_flow = (R_s/Km)^(1/exp)*(rho_m)^(1/exp)*dp^(1/exp)
</pre>

<p>
for the underlying base equation using ideal gas law as follows:
</p>

<pre>
    dp^2 = p_2^2 - p_1^2 = Km*m_flow^exp*(T_2 + T_1)
    dp   = p_2 - p_1     = Km*m_flow^exp*T_m/p_m, Eq.2 with [dp] = Pa, [m_flow] = kg/s
</pre>

<p>
so that the coefficient <b> Km </b> is calculated out of Eq.2:
</p>

<pre>
    Km = dp*R_s*rho_m / m_flow^exp , [Km] = [Pa^2/{(kg/s)^exp*K}]
</pre>

<p>
where the mean density <b> rho_m </b> is calculated according to the ideal gas law out of an arithmetic mean pressure and temperature:
</p>

<pre>
   rho_m = p_m / (R_s*T_m) , p_m = (p_1 + p_2)/2 and T_m = (T_1 + T_2)/2.
</pre>

<p>
with
</p>

<table>
<tr><td><b> exp                    </b></td><td> as exponent of pressure loss law [-],</td></tr>
<tr><td><b> dp                     </b></td><td> as pressure loss [Pa],</td></tr>
<tr><td><b> Km                     </b></td><td> as coefficient w.r.t. mass flow rate! [Km] = [Pa^2/{(kg/s)^exp*K}],</td></tr>
<tr><td><b> m_flow                 </b></td><td> as mass flow rate [kg/s],</td></tr>
<tr><td><b> p_m = (p_2 + p_1)/2    </b></td><td> as mean pressure of ideal gas [Pa],</td></tr>
<tr><td><b> T_m = (T_2 + T_1)/2    </b></td><td> as mean temperature of ideal gas [K],</td></tr>
<tr><td><b> rho_m = p_m/(R_s*T_m)  </b></td><td> as mean density of ideal gas [kg/m3],</td></tr>
<tr><td><b> R_s                    </b></td><td> as specific gas constant of ideal gas [J/(kgK)],</td></tr>
<tr><td><b> V_flow                 </b></td><td> as volume flow rate of ideal gas [m^3/s].</td></tr>
</table>

<p>
Furthermore the coefficient <b> Km </b> can be defined more detailed w.r.t. the definition of pressure loss if <b> Km </b> is not given as (e.g., measured) value. Generally pressure loss can be calculated due to local losses <b> Km,LOC </b> or frictional losses <b> Km,FRI </b>.
</p>
<p>
Pressure loss due to local losses gives the following definition of <b> Km </b>:
</p>

<pre>
    dp        = zeta_LOC * (rho_m/2)*velocity^2 is leading to
      Km,LOC  = (8/&pi;^2)*R_s*zeta_LOC/(d_hyd)^4, considering the cross sectional area of pipes.
</pre>

<p>
and pressure loss due to friction is leading to
</p>

<pre>
    dp        = lambda_FRI*L/d_hyd * (rho_m/2)*velocity^2
      Km,FRI  = (8/&pi;^2)*R_s*lambda_FRI*L/(d_hyd)^5, considering the cross sectional area of pipes.
</pre>

<p>
with
</p>

<table>
<tr><td><b> dp                    </b></td><td> as pressure loss [Pa],</td></tr>
<tr><td><b> d_hyd                 </b></td><td> as hydraulic diameter of pipe [m],</td></tr>
<tr><td><b> Km,i                  </b></td><td> as coefficients w.r.t. mass flow rate! [Km] = [Pa^2/{(kg/s)^exp*K}],</td></tr>
<tr><td><b> lambda_FRI            </b></td><td> as Darcy friction factor [-],</td></tr>
<tr><td><b> L                     </b></td><td> as length of pipe [m],</td></tr>
<tr><td><b> rho_m = p_m/(R_s*T_m) </b></td><td> as mean density of ideal gas [kg/m3],</td></tr>
<tr><td><b> velocity              </b></td><td> as mean velocity [m/s],</td></tr>
<tr><td><b> zeta_LOC              </b></td><td> as local resistance coefficient [-].</td></tr>
</table>

<p>
Note that the variables of this function are delivered in SI units so that the coefficient Km shall be given in SI units too.
</p>
<h4>Verification</h4>
<p>
<b> Compressible case </b> [Mass flow rate = f(dp)]:
</p>
<p>
The mass flow rate <b>m_flow</b> for different coefficients <b> Km </b> as parameter is shown in dependence of its pressure loss <b>dp</b> in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/general/fig_general_dp_idealGas_MFLOWvsDP.png\" alt=\"fig_general_dp_idealGas_MFLOWvsDP\"/>
</p>

<p>
Note that the verification for <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_idealGas\">dp_idealGas</a> is also valid for this inverse calculation due to using the same functions.
</p>
<h4>References</h4>
<dl>
<dt>Elmquist, H., M.Otter and S.E. Cellier:</dt>
    <dd><b>Inline integration: A new mixed
    symbolic / numeric approach for solving differential-algebraic equation systems.</b>.
    In Proceedings of European Simulation MultiConference, Praque, 1995.</dd>
</dl>
</html>"));
      end dp_idealGas;

      class dp_nominalDensityViscosity
       extends Modelica_Icons.Information;
      annotation(Documentation(info="<html>
<p>
Calculation of a generic pressure loss in dependence of nominal fluid variables (e.g., nominal density, nominal dynamic viscosity) at an operation point via interpolation.
This generic function considers the pressure loss law via a pressure loss exponent and the influence of density and dynamic viscosity on pressure loss.
</p>
<h4>Calculation</h4>
<p>
The geometry parameters of energy devices necessary for the pressure loss calculations are often not exactly known.
Therefore the modelling of the detailed pressure loss calculation has to be simplified.
This function uses nominal variables (e.g., nominal pressure loss) at a known operation point of the energy device to interpolate the actual pressure loss according to a pressure loss law (exponent).
</p>
<p>
The generic pressure loss <b>dp</b> is determined for:
</p>
<ul>
 <li>
 compressible case [Mass flow rate = f(dp)]:
  <pre>
   m_flow = m_flow_nom*[(dp/dp_nom)*(rho/rho_nom)]^(1/exp)*(eta_nom/eta)^(exp_eta/exp)
   </pre>
 </li>
 <li>
 incompressible case [Pressure loss = f(m_flow)]:
  <pre>
   dp = dp_nom*(m_flow/m_flow_nom)^exp*(rho_nom/rho)*(eta/eta_nom)^exp_eta
   </pre>
  </li>
</ul>

<p>
with
</p>

<table>
<tr><td><b> dp             </b></td><td> as pressure loss [Pa],</td></tr>
<tr><td><b> dp_nom         </b></td><td> as nominal pressure loss [Pa],</td></tr>
<tr><td><b> eta            </b></td><td> as dynamic viscosity of fluid [kg/(ms)].</td></tr>
<tr><td><b> eta_nom        </b></td><td> as nominal dynamic viscosity of fluid [kg/(ms)].</td></tr>
<tr><td><b> m_flow         </b></td><td> as mass flow rate [kg/s],</td></tr>
<tr><td><b> m_flow_nom     </b></td><td> as nominal mass flow rate [kg/s],</td></tr>
<tr><td><b> exp            </b></td><td> as exponent of pressure loss calculation [-],</td></tr>
<tr><td><b> exp_eta        </b></td><td> as exponent of dynamic viscosity dependence [-],</td></tr>
<tr><td><b> rho            </b></td><td> as fluid density [kg/m3],</td></tr>
<tr><td><b> rho_nom        </b></td><td> as nominal fluid density [kg/m3].</td></tr>
</table>

<p>
To avoid numerical difficulties this pressure loss function is linear smoothed for
</p>
<ul>
 <li>
 small mass flow rates, where
 <pre>
    m_flow &le; (0.01*rho/rho_nom*(1/eta*eta_nom)^(exp_eta))^(1/exp) and
  </pre>
 </li>
 <li> small pressure losses, where
 <pre>
    dp &le; 0.01*dp_nom)
 </pre>
 </li>
</ul>
<p>
Note that the density (rho) and dynamic viscosity (eta) of the fluid are defined through the definition of the kinematic viscosity (nue).
</p>

<pre>
    nue = eta / rho
</pre>

<p>
Therefore if you set both the exponent of dynamic viscosity (exp_eta == 1) and additionally a relation of density and dynamic viscosity there will be no difference for varying densities because the dynamic viscosities will vary in the same manner.
</p>
<h4>Verification</h4>
<p>
<b> Incompressible case </b> [Pressure loss = f(m_flow)]:
</p>
<p>
The generic pressure loss <b> DP </b> in dependence of the mass flow rate <b>m_flow</b> with different fluid densities and dynamic viscosity dependence as parameters is shown for a turbulent pressure loss regime (exp == 2) in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/general/fig_general_dp_nominalDensityViscosity_DPvsMFLOW.png\" alt=\"fig_general_dp_nominalDensityViscosity_DPvsMFLOW\"/>
</p>

<p>
<b> Compressible case </b> [Mass flow rate = f(dp)]:
</p>
<p>
The generic mass flow rate <b> M_FLOW </b> in dependence of the pressure loss <b>dp</b> at different fluid densities and dynamic viscosity as parameters is shown for a turbulent pressure loss regime (exp == 2) in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/general/fig_general_dp_nominalDensityViscosity_MFLOWvsDP.png\" alt=\"fig_general_dp_nominalDensityViscosity_MFLOWvsDP\"/>
</p>

<h4>References</h4>
<dl>
<dt>Elmquist, H., M.Otter and S.E. Cellier:</dt>
    <dd><b>Inline integration: A new mixed
    symbolic / numeric approach for solving differential-algebraic equation systems.</b>.
    In Proceedings of European Simulation MultiConference, Praque, 1995.</dd>
<dt>Wischhusen, S.:</dt>
    <dd><b>Dynamische Simulation zur wirtschaftlichen Bewertung von komplexen Energiesystemen.</b>.
    PhD thesis, Technische Universit&auml;t Hamburg-Harburg, 2005.</dd>
</dl>

</html>"));
      end dp_nominalDensityViscosity;

      class dp_nominalPressureLossLawDensity
       extends Modelica_Icons.Information;
      annotation(Documentation(info="<html>
<p>
Calculation of a generic pressure loss in dependence of nominal fluid variables (e.g., nominal density) via interpolation from an operation point.
This generic function considers the pressure loss law via a nominal pressure loss (dp_nom), a pressure loss coefficient (zeta_TOT) and a pressure loss law exponent (exp) as well as the influence of density on pressure loss.
</p>
<h4>Calculation</h4>
<p>
The geometry parameters of energy devices necessary for the pressure loss calculations are often not exactly known.
Therefore the modelling of the detailed pressure loss calculation have to be simplified.
This function uses nominal variables (e.g., nominal pressure loss) at a known operation point of the energy device to interpolate the actual pressure loss according to a pressure loss law (exponent).
</p>
<p>
In the following the pressure loss <b>dp</b> is generally determined from a known operation point via a law of similarity:
</p>

<pre>
   dp/dp_nom = (zeta_TOT/zeta_TOT_nom)*(rho/rho_nom)*(v/v_nom)^exp
</pre>

<p>
with
</p>

<table>
<tr><td><b> dp             </b></td><td> as pressure loss [Pa],</td></tr>
<tr><td><b> dp_nom         </b></td><td> as nominal pressure loss [Pa],</td></tr>
<tr><td><b> m_flow         </b></td><td> as mass flow rate [kg/s],</td></tr>
<tr><td><b> m_flow_nom     </b></td><td> as nominal mass flow rate [kg/s],</td></tr>
<tr><td><b> exp            </b></td><td> as exponent of pressure loss calculation [-],</td></tr>
<tr><td><b> rho            </b></td><td> as fluid density [kg/m3],</td></tr>
<tr><td><b> rho_nom        </b></td><td> as nominal fluid density [kg/m3],</td></tr>
<tr><td><b> v              </b></td><td> as mean flow velocity [m/s],</td></tr>
<tr><td><b> v_nom          </b></td><td> as nominal mean flow velocity [m/s],</td></tr>
<tr><td><b> zeta_TOT       </b></td><td> as pressure loss coefficient [-],</td></tr>
<tr><td><b> zeta_TOT_nom   </b></td><td> as nominal pressure loss coefficient [-].</td></tr>
</table>

<p>
The fraction of mean flow velocities (v/v_nom) can be calculated through its corresponding <b> mass flow rates </b>, densities and cross sectional areas:
</p>

<pre>
   v/v_nom = (m_flow/m_flow_nom)*(A_cross_nom/A_cross)*(rho_nom/rho)
</pre>

<p>
<b> or </b> through its corresponding <b> volume flow rates </b>, densities and cross sectional areas:
</p>

<pre>
    v/v_nom = (V_flow/V_flow_nom)*(A_cross_nom/A_cross).
</pre>

<p>
with
</p>

<table>
<tr><td><b> A_cross        </b></td><td> as cross sectional area [m2],</td></tr>
<tr><td><b> A_cross_nom    </b></td><td> as nominal cross sectional area [m2],</td></tr>
<tr><td><b> rho            </b></td><td> as fluid density [kg/m3],</td></tr>
<tr><td><b> rho_nom        </b></td><td> as nominal fluid density [kg/m3],</td></tr>
<tr><td><b> v              </b></td><td> as mean flow velocity [m/s],</td></tr>
<tr><td><b> v_nom          </b></td><td> as nominal mean flow velocity [m/s],</td></tr>
<tr><td><b> V_flow         </b></td><td> as volume flow rate [m3/s],</td></tr>
<tr><td><b> V_flow_nom     </b></td><td> as nominal volume flow rate [m3/s].</td></tr>
</table>

<p>
Here the <b> compressible case </b> [Mass flow rate = f(dp)] determines the unknown mass flow rate out of a given pressure loss:
</p>

<pre>
   m_flow = m_flow_nom*(A_cross/A_cross_nom)*(rho_nom/rho)^(exp_density/exp)*[(dp/dp_nom)*(zeta_TOT_nom/zeta_TOT)]^(1/exp);
</pre>

<p>
where the exponent for the fraction of densities is determined w.r.t. the chosen nominal mass flow rate or nominal volume flow rate to:
</p>

<pre>
  exp_density = if NominalMassFlowRate == Modelica_Fluid.Dissipation.Utilities.Types.MassOrVolumeFlowRate.MassFlowRate then 1-exp else 1
</pre>

<p>
with
</p>

<table>
<tr><td><b> NominalMassFlowRate    </b></td><td> as reference for pressure loss law (mass flow rate of volume flow rate),</td></tr>
<tr><td><b> exp                    </b></td><td> as exponent of pressure loss calculation [-],</td></tr>
<tr><td><b> exp_density            </b></td><td> as exponent for density [-].</td></tr>
</table>

<p>
To avoid numerical difficulties this pressure loss function is linear smoothed for small pressure losses, with
</p>

<pre>
   dp &le; 0.01*dp_nom
</pre>

<p>
Note that the input and output arguments for functions throughout this library always use mass flow rates. Here you can choose <b> NominalMassFlowRate == Modelica_Fluid.Dissipation.Utilities.Types.MassOrVolumeFlowRate.MassFlowRate </b> for using a nominal mass flow rate or <b> NominalMassFlowRate == Modelica_Fluid.Dissipation.Utilities.Types.MassOrVolumeFlowRate.VolumeFlowRate </b> for using a nominal volume flow rate. The output argument will always be a mass flow rate for further use as flow model in a thermo-hydraulic framework.
</p>

<p>
Note that the pressure loss coefficients (zeta_TOT,zeta_TOT_nom) refer to its mean flow velocities (v,v_nom) in the pressure loss law to obtain its corresponding pressure loss.
</p>

<h4>Verification</h4>
<p>
<b> Compressible case </b> [Mass flow rate = f(dp)]:
</p>
<p>
The generic mass flow rate <b> M_FLOW </b> in dependence of the pressure loss <b>dp</b> is shown for a turbulent pressure loss regime (exp == 2) in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/general/fig_general_dp_nominalPressureLossLawDensity_MFLOWvsDP.png\" alt=\"fig_general_dp_nominalPressureLossLawDensity_MFLOWvsDP\"/>
</p>

<p>
Note that the verification for <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_nominalPressureLossLawDensity\">dp_nominalPressureLossLawDensity</a> is also valid for this inverse calculation due to using the same functions.
</p>

<h4>References</h4>
<dl>
<dt>Elmquist, H., M.Otter and S.E. Cellier:</dt>
    <dd><b>Inline integration: A new mixed
    symbolic / numeric approach for solving differential-algebraic equation systems.</b>.
    In Proceedings of European Simulation MultiConference, Praque, 1995.</dd>
<dt>Wischhusen, S.:</dt>
    <dd><b>Dynamische Simulation zur wirtschaftlichen Bewertung von komplexen Energiesystemen.</b>.
    PhD thesis, Technische Universit&auml;t Hamburg-Harburg, 2005.</dd>
</dl>

</html>"));
      end dp_nominalPressureLossLawDensity;

      class dp_pressureLossCoefficient
       extends Modelica_Icons.Information;
      annotation(Documentation(info="<html>
<p>
Calculation of a generic pressure loss in dependence of a pressure loss coefficient.
</p>
<h4>Calculation</h4>
<p>
The mass flow rate <b>m_flow</b> is determined by:
</p>

<pre>
    m_flow = rho*A_cross*(dp/(zeta_TOT *(rho/2))^0.5
</pre>

<p>
with
</p>

<table>
<tr><td><b> A_cross        </b></td><td> as cross sectional area [m2],</td></tr>
<tr><td><b> dp             </b></td><td> as pressure loss [Pa],</td></tr>
<tr><td><b> rho            </b></td><td> as density of fluid [kg/m3],</td></tr>
<tr><td><b> m_flow         </b></td><td> as mass flow rate [kg/s],</td></tr>
<tr><td><b> zeta_TOT       </b></td><td> as pressure loss coefficient [-].</td></tr>
</table>

<h4>Verification</h4>
<p>
<b> Compressible case </b> [Mass flow rate = f(dp)]:
</p>
<p>
The mass flow rate <b> M_FLOW </b> in dependence of the pressure loss <b>dp</b> for a constant pressure loss coefficient <b> zeta_TOT </b> is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/general/fig_general_dp_pressureLossCoefficient_MFLOWvsDP.png\" alt=\"fig_general_dp_pressureLossCoefficient_MFLOWvsDP\"/>
</p>

<p>
Note that the verification for <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_pressureLossCoefficient\">dp_pressureLossCoefficient</a> is also valid for this inverse calculation due to using the same functions.
</p>

<h4>References</h4>
<dl>
 <dt>Elmquist, H., M.Otter and S.E. Cellier:</dt>
    <dd><b>Inline integration: A new mixed
    symbolic / numeric approach for solving differential-algebraic equation systems.</b>.
    In Proceedings of European Simulation MultiConference, Praque, 1995.</dd>
 <dt>Wischhusen, S.:</dt>
    <dd><b>Dynamische Simulation zur wirtschaftlichen Bewertung von komplexen Energiesystemen.</b>.
    PhD thesis, Technische Universit&auml;t Hamburg-Harburg, 2005.</dd>
</dl>
</html>"));
      end dp_pressureLossCoefficient;

      class dp_volumeFlowRate
       extends Modelica_Icons.Information;
      annotation(Documentation(info="<html>
<p>
Calculation of a generic pressure loss with linear or quadratic dependence on volume flow rate.
</p>
<h4>Calculation</h4>
<p>
The geometry parameters of energy devices necessary for the pressure loss calculations are often not exactly known.
Therefore the modelling of the detailed pressure loss calculation has to be simplified. This function uses as
quadratic dependence of the pressure loss on the volume flow rate.
</p>
<p>
The mass flow rate <b>m_flow</b> for the compressible case [Mass flow rate = f(dp)] is determined to <i> [see Wischhusen] </i>:
</p>
<pre>
 m_flow = rho*[-b/(2a) + {[b/(2a)]^2 + dp/a}^0.5]
</pre>
<p>
with
</p>

<table>
<tr><td><b> a              </b></td><td> as quadratic coefficient [Pa*s^2/m^6],</td></tr>
<tr><td><b> b              </b></td><td> as linear coefficient [Pa*s/m3],</td></tr>
<tr><td><b> dp             </b></td><td> as pressure loss [Pa],</td></tr>
<tr><td><b> m_flow         </b></td><td> as mass flow rate [kg/s],</td></tr>
<tr><td><b> rho            </b></td><td> as density of fluid [kg/m3].</td></tr>
</table>

<p>
Note that the coefficients <b> a,b </b> have to be positive values so that there will be a positive (linear or quadratic) pressure loss at positive volume flow rate and vice versa.
</p>
<h4>Verification</h4>
<p><b> Compressible case </b> [Mass flow rate = f(dp)]:</p>
<p>
The generic pressure loss <b>dp</b> for different coefficients <b> a </b> as parameter is shown in dependence of the volume flow rate <b> V_flow </b> in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/general/fig_general_dp_volumeFlowRate_MFLOWvsDP.png\" alt=\"fig_general_dp_volumeFlowRate_MFLOWvsDP\"/>
</p>

<p>
Note that the verification for <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_volumeFlowRate\">dp_volumeFlowRate</a> is also valid for this inverse calculation due to using the same functions.
</p>

<h4>References</h4>
<dl>
<dt>Elmquist, H., M.Otter and S.E. Cellier:</dt>
    <dd><b>Inline integration: A new mixed
    symbolic / numeric approach for solving differential-algebraic equation systems.</b>.
    In Proceedings of European Simulation MultiConference, Praque, 1995.</dd>
<dt>Wischhusen, S.:</dt>
    <dd><b>Dynamische Simulation zur wirtschaftlichen Bewertung von komplexen Energiesystemen.</b>.
    PhD thesis, Technische Universit&auml;t Hamburg-Harburg, 2005.</dd>
</dl>
</html>"));
      end dp_volumeFlowRate;

        annotation (DocumentationClass=true);
      end General;

      package Orifice
        extends Modelica_Icons.Information;

      class dp_suddenChange
       extends Modelica_Icons.Information;
      annotation(Documentation(info="<html>
<h4>Restriction</h4>
<p>
This function shall be used within the restricted limits according to the referenced literature.
</p>
<ul>
 <li>
      <b>Smooth surface</b></li>
 <li>
      <b>Turbulent flow regime</b></li>
 <li>
      <b>Reynolds number for sudden expansion Re &gt; 3.3e3 </b> <i>[Idelchik 2006, p. 208, diag. 4-1] </i></li>
 <li>
      <b>Reynolds number for sudden contraction Re &gt; 1e4 </b> <i>[Idelchik 2006, p. 216-217, diag. 4-9] </i></li>
</ul>

<h4>Geometry </h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/orifice/pic_suddenChangeSection.png\" alt=\"pic_suddenChangeSection\"/>
</p>

<h4>Calculation</h4>
<p>
The local pressure loss <b>dp</b> is generally determined by:
</p>

<pre>
    dp = 0.5 * zeta_LOC * rho * |v_1|*v_1
</pre>

<p>
with
</p>

<table>
<tr><td><b> rho              </b></td><td> as density of fluid [kg/m3],</td></tr>
<tr><td><b> v_1             </b></td><td> as average flow velocity in small cross sectional area [m/s].</td></tr>
<tr><td><b> zeta_LOC         </b></td><td> as local resistance coefficient [-],</td></tr>
</table>

<p>
The local resistance coefficient <b> zeta_LOC </b> of a sudden expansion can be calculated for different ratios of cross sectional areas by:
</p>

<pre>
    zeta_LOC = (1 - A_1/A_2)^2  <i>[Idelchik 2006, p. 208, diag. 4-1] </i>
</pre>

<p>
and for sudden contraction:
</p>

<pre>
    zeta_LOC = 0.5*(1 - A_1/A_2)^0.75  <i>[Idelchik 2006, p. 216-217, diag. 4-9] </i>
</pre>

<p>
with
</p>

<table>
<tr><td><b> A_1       </b></td><td> small cross sectional area [m^2],</td></tr>
<tr><td><b> A_2       </b></td><td> large cross sectional area [m^2].</td></tr>
</table>

<h4>Verification</h4>
<p>
The local resistance coefficient <b> zeta_LOC </b> of a sudden expansion in dependence of the cross sectional area ratio <b> A_1/A_2 </b> is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/orifice/fig_orifice_suddenChangeExpansion.png\" alt=\"fig_orifice_suddenChangeExpansion\"/>
</p>

<p>
The local resistance coefficient <b> zeta_LOC </b> of a sudden contraction in dependence of the cross sectional area ratio <b> A_1/A_2 </b> is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/orifice/fig_orifice_suddenChangeContraction.png\" alt=\"fig_orifice_suddenChangeContraction\"/>
</p>

<h4>References</h4>
<dl>
<dt>Elmquist, H., M.Otter and S.E. Cellier:</dt>
    <dd><b>Inline integration: A new mixed
    symbolic / numeric approach for solving differential-algebraic equation systems.</b>.
    In Proceedings of European Simulation MultiConference, Praque, 1995.</dd>
<dt>Idelchik,I.E.:</dt>
    <dd><b>Handbook of hydraulic resistance</b>.
    Jaico Publishing House, Mumbai, 3rd edition, 2006.</dd>
</dl>
</html>"));
      end dp_suddenChange;

      class dp_thickEdgedOverall
       extends Modelica_Icons.Information;
      annotation(Documentation(info="<html>
<h4>Restriction</h4>
<p>
This function shall be used within the restricted limits according to the referenced literature.
</p>
<ul>
 <li>
      <b> Reynolds number (for vena contraction) Re &gt; 1e3 </b> <i>[Idelchik 2006, p. 222, diag. 4-15] </i>
 <li>
      <b> Relative length of vena contraction (L/d_hyd_0) &gt; 0.015 </b> <i>[Idelchik 2006, p. 222, diag. 4-15] </i>
 <li>
      <b> Darcy friction factor lambda_FRI = 0.02 </b> <i>[Idelchik 2006, p. 222, sec. 4-15] </i>
</ul>

<h4>Geometry</h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/orifice/pic_thickEdged.png\" alt=\"pic_thickEdged\"/>
</p>

<h4>Calculation</h4>
<p>
The pressure loss <b>dp</b> for a thick edged orifice is determined by:
</p>

<pre>
    dp = zeta_TOT * (rho/2) * (velocity_1)^2
</pre>

<p>
with
</p>

<table>
<tr><td><b> rho            </b></td><td> as density of fluid [kg/m3],</td></tr>
<tr><td><b> velocity_1     </b></td><td> as mean velocity in large cross sectional area [m/s],</td></tr>
<tr><td><b> zeta_TOT       </b></td><td> as pressure loss coefficient [-].</td></tr>
</table>

<p>
The pressure loss coefficient <b> zeta_TOT </b> of a thick edged orifice can be calculated for different cross sectional areas <b> A_0 </b> and relative length of orifice <b> l_bar </b>=L/d_hyd_0 by:
</p>

<pre>
    zeta_TOT = (0.5*(1 - A_0/A_1)^0.75 + tau*(1 - A_0/A_1)^1.375 + (1 - A_0/A_1)^2 + lambda_FRI*l_bar)*(A_1/A_0)^2 <i>[Idelchik 2006, p. 222, diag. 4-15] </i>
</pre>

<p>
with
</p>

<table>
<tr><td><b> A_0       </b></td><td> cross sectional area of vena contraction [m2],</td></tr>
<tr><td><b> A_1       </b></td><td> large cross sectional area of orifice [m2],</td></tr>
<tr><td><b> d_hyd_0   </b></td><td> hydraulic diameter of vena contraction [m],</td></tr>
<tr><td><b> lambda_FRI</b></td><td> as constant Darcy friction factor [-],</td></tr>
<tr><td><b> l_bar     </b></td><td> relative length of orifice [-],</td></tr>
<tr><td><b> L         </b></td><td> length of vena contraction [m],</td></tr>
<tr><td><b> tau       </b></td><td> geometry parameter [-].</td></tr>
</table>

<p>
The geometry factor <b> tau </b> is determined by <i>[Idelchik 2006, p. 219, diag. 4-12]</i>:
</p>

<pre>
    tau = (2.4 - l_bar)*10^(-phi)
    phi = 0.25 + 0.535*l_bar^8 / (0.05 + l_bar^8) .
</pre>

<h4>Verification</h4>
<p>
The pressure loss coefficient <b> zeta_TOT </b> of a thick edged orifice in dependence of a relative length <b>(l_bar = L /d_hyd)</b> with different ratios of cross sectional areas <b> A_0/A_1 </b> is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/orifice/fig_orifice_thickEdgedOverall_ZETAvsLENGHT.png\" alt=\"fig_orifice_thickEdgedOverall_ZETAvsLENGHT\"/>
</p>

<p>
<b> Incompressible case </b> [Pressure loss = f(m_flow)]:
</p>
<p>
The pressure loss <b> DP </b> of an thick edged orifice in dependence of the mass flow rate <b>m_flow</b> of water for different ratios <b>A_0/A_1</b> (where <b> A_0 </b> = 0.001 m^2) is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/orifice/fig_orifice_thickEdgedOverall_DPvsMFLOW.png\" alt=\"fig_orifice_thickEdgedOverall_DPvsMFLOW\"/>
</p>

<p>
<b>And for the compressible case </b> [Mass flow rate = f(dp)]:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/orifice/fig_orifice_thickEdgedOverall_MFLOWvsDP.png\" alt=\"fig_orifice_thickEdgedOverall_MFLOWvsDP\"/>
</p>

<h4>References</h4>
<dl>
 <dt>Elmquist,H., M.Otter and S.E. Cellier:</dt>
    <dd><b>Inline integration: A new mixed
symbolic / numeric approach for solving differential-algebraic equation systems.</b>.
    In Proceedings of European Simulation MultiConference, Praque, 1995.</dd>
<dt>Idelchik,I.E.:</dt>
    <dd><b>Handbook of hydraulic resistance</b>.
    Jaico Publishing House,Mumbai, 3rd edition, 2006.</dd>
</dl>
</html>"));
      end dp_thickEdgedOverall;

        annotation (DocumentationClass=true);
      end Orifice;

      package StraightPipe
        extends Modelica_Icons.Information;

      class dp_laminar
       extends Modelica_Icons.Information;
      annotation(Documentation(info="<html>
<p>
Calculation of pressure loss in a straight pipe for <b> laminar </b> flow regime of single-phase fluid flow only.
</p>
<h4>Restriction</h4>
<p>
This function shall be used inside of the restricted limits according to the referenced literature.
</p>
<ul>
 <li><b> circular cross sectional area </b></li>
 <li><b> laminar flow regime (Reynolds number Re &le; 2000) <i>[VDI-W&auml;rmeatlas 2002, p. Lab, eq. 3] </i> </b></li>
</ul>

<h4>Geometry </h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/pic_straightPipe.png\" alt=\"pic_straightPipe\"/>
</p>

<h4>Calculation</h4>
<p>
The pressure loss <b>dp</b> for straight pipes is determined by:
</p>

<pre>
    dp = lambda_FRI * (L/d_hyd) * (rho/2) * velocity^2
</pre>

<p>
with
</p>

<table>
<tr><td><b> lambda_FRI     </b></td><td> as Darcy friction factor [-].</td></tr>
<tr><td><b> L              </b></td><td> as length of straight pipe [m],</td></tr>
<tr><td><b> d_hyd          </b></td><td> as hydraulic diameter of straight pipe [m],</td></tr>
<tr><td><b> rho            </b></td><td> as density of fluid [kg/m3],</td></tr>
<tr><td><b> velocity       </b></td><td> as mean velocity [m/s].</td></tr>
</table>

<p>
The Darcy friction factor <b>lambda_FRI</b> of straight pipes for the laminar flow regime is calculated by <b>Hagen-Poiseuilles</b> law according to <i>[Idelchik 2006, p. 77, eq. 2-3]</i> as follows:
</p>
<ul>
 <li><b> Laminar flow regime </b> is restricted to a Reynolds number <b> Re </b> &le; 2000</li>
 <li>and calculated through:
     <pre>
     lambda_FRI = 64/Re
     </pre>
     <p>
     with
     </p>
     <table>
     <tr><td><b> lambda_FRI     </b></td><td> as Darcy friction factor [-],</td></tr>
     <tr><td><b> Re             </b></td><td> as Reynolds number [-].</td></tr>
     </table>
      </li>
</ul>

<p>
The Darcy friction factor <b>lambda_FRI</b> in the laminar regime is independent
of the surface roughness <b> K </b> as long as the relative roughness <b>k = surface roughness/hydraulic diameter</b> is smaller than 0.007.
A higher relative roughness <b> k </b> than 0.007 leads to an earlier leaving of the laminar regime to the transition regime at some value of Reynolds number <b> Re_lam_leave </b>. This earlier leaving is not modelled here because only laminar fluid flow is considered.
</p>

<h4>Verification</h4>
<p>
The Darcy friction factor <b>lambda_FRI</b> in dependence of Reynolds number is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/fig_straightPipe_laminar_lambdavsRe_ver.png\" alt=\"fig_straightPipe_laminar_lambdavsRe_ver\"/>
</p>

<p>
The pressure loss <b>dp</b> for the laminar regime in dependence of the mass flow rate of water is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/fig_straightPipe_dp_laminar_DPvsMFLOW.png\" alt=\"fig_straightPipe_dp_laminar_DPvsMFLOW\"/>
</p>

<p>
Note that this pressure loss function shall not be used for the modelling outside of the laminar flow regime at <i><b> Re </b> &gt; 2000</i> even though it could be used for that.
</p>
<p>
If the whole flow
regime shall be modelled, the pressure loss function <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.StraightPipe.dp_overall\">dp_overall</a> can be used.
</p>

<h4>References</h4>
<dl>
 <dt>Elmquist,H., M.Otter and S.E. Cellier:</dt>
    <dd><b>Inline integration: A new mixed
    symbolic / numeric approach for solving differential-algebraic equation systems.</b>.
    In Proceedings of European Simulation MultiConference, Praque, 1995.</dd>
<dt>Idelchik,I.E.:</dt>
    <dd><b>Handbook of hydraulic resistance</b>.
    Jaico Publishing House, Mumbai, 3rd edition, 2006.</dd>
 <dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 9th edition, 2002.</dd>
</dl>
</html>"));
      end dp_laminar;

      class dp_overall
       extends Modelica_Icons.Information;
      annotation(Documentation(info="<html>
<p>
Calculation of pressure loss in a straight pipe for <b> laminar or turbulent </b> flow regime of single-phase fluid flow only considering surface roughness.
</p>
<h4>Restriction</h4>
<p>
This function shall be used within the restricted limits according to the referenced literature.
</p>
<ul>
 <li>
      <b> circular cross sectional area </b></li>
</ul>

<h4>Geometry </h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/pic_straightPipe.png\" alt=\"pic_straightPipe\"/>
</p>

<h4>Calculation</h4>
The pressure loss <b>dp</b> for straight pipes is determined by:

<pre>
    dp = lambda_FRI * (L/d_hyd) * (rho/2) * velocity^2
</pre>

<p>
with
</p>

<table>
<tr><td><b> lambda_FRI     </b></td><td> as Darcy friction factor [-],</td></tr>
<tr><td><b> L              </b></td><td> as length of straight pipe [m],</td></tr>
<tr><td><b> d_hyd          </b></td><td> as hydraulic diameter of straight pipe [m],</td></tr>
<tr><td><b> rho            </b></td><td> as density of fluid [kg/m3],</td></tr>
<tr><td><b> velocity       </b></td><td> as mean velocity [m/s].</td></tr>
</table>

<p>
The Darcy friction factor <b>lambda_FRI</b> for straight pipes is calculated depending on the fluid flow regime (with corresponding Reynolds number <b>Re</b>) and the absolute surface roughness <b> K </b>.
</p>
<p>

<b> The Laminar regime </b> is calculated for <b> Re </b> &le; 2000 by the Hagen-Poiseuille law according to <i>[Idelchik 2006, p. 77, eq. 2-3]</i>
</p>

<pre>
    lambda_FRI = 64/Re
</pre>

<p>
The Darcy friction factor <b>lambda_FRI</b> in the laminar regime is independent of the surface roughness <b> k </b> as long as the relative roughness <b> k </b> is smaller than 0.007. A greater relative roughness <b> k </b> than 0.007 is leading to an earlier leaving of the Hagen-Poiseuille law at some value of Reynolds number <b> Re_lam_leave </b>. The leaving of the laminar regime in dependence of the relative roughness <b> k </b> is calculated according to <i>[Samoilenko in Idelchik 2006, p. 81, sect. 2-1-21]</i> as:
</p>
<pre>
    Re_lam_leave = 754*exp(if k &le; 0.007 then 0.93 else 0.0065/k)
</pre>

<p>
<b>The Transition regime</b> is calculated for 2000 &lt; <b>Re</b> &le; 4000  by a cubic interpolation between the equations of the laminar and turbulent flow regime. Different cubic
interpolation equations for the calculation of either pressure loss <b>dp</b> or mass flow rate <b>m_flow</b> results in a deviation of the Darcy friction factor <b>lambda_FRI</b> through the
transition regime. This deviation can be neglected due to the uncertainty in determination of the fluid flow in the transition regime.
</p>

<p>
<b> Turbulent regime </b> can be calculated for a smooth surface (Blasius law) <b> or </b> a rough surface (Colebrook-White law):
</p>

<p>
<b> Smooth surface (roughness = Modelica_Fluid.Dissipation.Utilities.Types.Roughness.Neglected) </b> w.r.t. <b> Blasius </b> law in the turbulent regime according to <i>[Idelchik 2006, p. 77, sec. 15]</i>:
</p>
<pre>
    lambda_FRI = 0.3164*Re^(-0.25)
</pre>

<p>
with
</p>

<table>
<tr><td><b> lambda_FRI     </b></td><td> as Darcy friction factor [-].</td></tr>
<tr><td><b> Re             </b></td><td> as Reynolds number [-].</td></tr>
</table>

<p>
Note that the Darcy friction factor <b>lambda_FRI</b> for smooth straight pipes in the turbulent regime is independent
of the surface roughness <b> K </b> .
</p>

<p>
<b> Rough surface (roughness = Modelica_Fluid.Dissipation.Utilities.Types.Roughness.Considered) </b> w.r.t. <b> Colebrook-White </b> law in the turbulent regime according to <i>[Miller 1984, p. 191, eq. 8.4]</i>:
</p>
<pre>
    lambda_FRI = 0.25/{lg[k/(3.7*d_hyd) + 5.74/(Re)^0.9]}^2
</pre>

<p>
with
</p>

<table>
<tr><td><b> d_hyd          </b></td><td> as hydraulic diameter [-],</td></tr>
<tr><td><b> k= K/d_hyd     </b></td><td> as relative roughness [-],</td></tr>
<tr><td><b> K              </b></td><td> as roughness (average height of surface asperities [m],</td></tr>
<tr><td><b> lambda_FRI     </b></td><td> as Darcy friction factor [-],</td></tr>
<tr><td><b> Re             </b></td><td> as Reynolds number [-].</td></tr>
</table>

<h4>Verification</h4>
<p>
The Darcy friction factor <b>lambda_FRI</b> in dependence of Reynolds number for different values of relative roughness <b> k </b> is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/fig_straightPipe_dp_overall_lambdavsRe_ver.png\" alt=\"fig_straightPipe_dp_overall_lambdavsRe_ver\"/>
</p>

<p>
The pressure loss <b>dp</b> for the turbulent regime in dependence of the mass flow rate of water is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/fig_straightPipe_dp_overall_DPvsMFLOW.png\" alt=\"fig_straightPipe_dp_overall_DPvsMFLOW\"/>
</p>

<p>
And the mass flow rate <b>m_flow</b> for the turbulent regime in dependence of the pressure loss of water is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/fig_straightPipe_dp_overall_MFLOWvsDP.png\" alt=\"fig_straightPipe_dp_overall_MFLOWvsDP\"/>
</p>

<h4>References</h4>
<dl>
 <dt>Idelchik,I.E.:</dt>
    <dd><b>Handbook of hydraulic resistance</b>.
    Jaico Publishing House, Mumbai, 3rd edition, 2006.</dd>
 <dt>Miller,D.S.:</dt>
    <dd><b>Internal flow systems</b>.
    volume 5th of BHRA Fluid Engineering Series.BHRA Fluid Engineering, 1984.
 <dt>Samoilenko,L.A.:</dt>
    <dd><b>Investigation of the hydraulic resistance of pipelines in the
        zone of transition from laminar into turbulent motion</b>.
        PhD thesis, Leningrad State University, 1968.</dd>
 <dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 9th edition, 2002.</dd>
</dl>
</html>"));
      end dp_overall;

      class dp_turbulent
       extends Modelica_Icons.Information;
      annotation(Documentation(info="<html>
<p>
Calculation of pressure loss in a straight pipe for <b> turbulent </b> flow regime of single-phase fluid flow only considering surface roughness.
</p>
<h4>Restriction</h4>
<p>
This function shall be used within the restricted limits according to the referenced literature.
</p>
<ul>
 <li>
      <b> circular cross sectional area </b></li>
 <li>
      <b> turbulent flow regime (Reynolds number Re &ge; 4e3) <i>[VDI-W&auml;rmeatlas 2002, p. Lab 3, fig. 1] </i> </b></li>
</ul>


<h4>Geometry </h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/pic_straightPipe.png\" alt=\"pic_straightPipe\"/>
</p>

<h4>Calculation</h4>
<p>
The pressure loss <b>dp</b> for straight pipes is determined by:
</p>

<pre>
    dp = lambda_FRI * (L/d_hyd) * (rho/2) * velocity^2
</pre>

<p>
with
</p>

<table>
<tr><td><b> lambda_FRI     </b></td><td> as Darcy friction factor [-].</td></tr>
<tr><td><b> L              </b></td><td> as length of straight pipe [m],</td></tr>
<tr><td><b> d_hyd          </b></td><td> as hydraulic diameter of straight pipe [m],</td></tr>
<tr><td><b> rho            </b></td><td> as density of fluid [kg/m3],</td></tr>
<tr><td><b> velocity       </b></td><td> as mean velocity [m/s].</td></tr>
</table>

<p>
The Darcy friction factor <b>lambda_FRI</b> for a straight pipe in the turbulent regime can be calculated for a smooth surface (Blasius law) <b> or </b> a rough surface (Colebrook-White law).
</p>
<p>
<b> Smooth surface (roughness = Modelica_Fluid.Dissipation.Utilities.Types.Roughness.Neglected) </b> w.r.t. <b> Blasius </b> law in the turbulent regime according to <i>[Idelchik 2006, p. 77, sec. 15]</i>:
</p>

<pre>
    lambda_FRI = 0.3164*Re^(-0.25)
</pre>

<p>
with
</p>

<table>
<tr><td><b> lambda_FRI     </b></td><td> as Darcy friction factor [-].</td></tr>
<tr><td><b> Re             </b></td><td> as Reynolds number [-].</td></tr>
</table>

<p>
Note that the Darcy friction factor <b>lambda_FRI</b> for smooth straight pipes in the turbulent regime is independent
of the surface roughness <b> K </b> .
</p>

<p>
<b> Rough surface (roughness = Modelica_Fluid.Dissipation.Utilities.Types.Roughness.Considered) </b> w.r.t. <b> Colebrook-White </b> law in the turbulent regime according to <i>[Miller 1984, p. 191, eq. 8.4]</i>:
</p>

<pre>
    lambda_FRI = 0.25/{lg[k/(3.7*d_hyd) + 5.74/(Re)^0.9]}^2
</pre>

<p>
with
</p>

<table>
<tr><td><b> d_hyd          </b></td><td> as hydraulic diameter [-],</td></tr>
<tr><td><b> k= K/d_hyd     </b></td><td> as relative roughness [-],</td></tr>
<tr><td><b> K              </b></td><td> as roughness (average height of surface asperities [m].</td></tr>
<tr><td><b> lambda_FRI     </b></td><td> as Darcy friction factor [-],</td></tr>
<tr><td><b> Re             </b></td><td> as Reynolds number [-].</td></tr>
</table>

<h4>Verification</h4>
<p>
The Darcy friction factor <b>lambda_FRI</b> in dependence of Reynolds number for different values of relative roughness <b> k </b> is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/fig_straightPipe_turbulent.png\" alt=\"fig_straightPipe_turbulent\"/>
</p>

<p>
Note that this pressure loss function shall not be used for the modelling outside of the turbulent flow regime at <b> Re </b> &lt; 4e3 even though it could be used for that.
</p>

<p>
If the overall flow regime shall be modelled, the pressure loss function <a href=\"modelica://Modelica_Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.StraightPipe.dp_overall\">dp_overall</a> can be used.
</p>

<h4>References</h4>
<dl>
 <dt>Idelchik,I.E.:</dt>
    <dd><b>Handbook of hydraulic resistance</b>.
    Jaico Publishing House, Mumbai, 3rd edition, 2006.</dd>
 <dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 9th edition, 2002.</dd>
</dl>
</html>"));
      end dp_turbulent;

      class dp_twoPhaseOverall
       extends Modelica_Icons.Information;
      annotation(Documentation(info="<html>
<p>
Calculation of pressure loss for <b>two phase flow</b> in a horizontal <b>or</b> vertical straight pipe for an overall flow regime considering frictional, momentum and geodetic pressure loss.
</p>
<h4>Restriction</h4>
<p>
This function shall be used within the restricted limits according to the referenced literature.
</p>
<ul>
 <li> <b> circular cross sectional area </b> </li>
 <li> <b> neglecting of surface roughness </b> </li>
 <li> <b> horizontal flow or vertical upflow </b> </li>
 <li> <b> usage of mass flow rate quality (see Calculation) </b> </li>
 <li> <b> two phase pressure loss for mean constant mass flow rate quality (x_flow) over (increment) length </b></li>
 <li> <b> usage of two phase pressure loss function for discretization at boiling or condensation considering variable mass flow rate quality</b> </li>
</ul>

<h4>Geometry </h4>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/pic_straightPipe.png\" alt=\"pic_straightPipe\"/>
</p>

<h4>Calculation</h4>
<p>
The two phase pressure loss <b> dp_2ph </b> of straight pipes is determined by:
</p>

<pre>
    dp_2ph = dp_fri + dp_mom + dp_geo
</pre>

<p>
with
</p>

<table>
<tr><td><b> dp_fri        </b></td><td> as frictional pressure loss [Pa],</td></tr>
<tr><td><b> dp_mom        </b></td><td> as momentum pressure loss [Pa],</td></tr>
<tr><td><b> dp_geo        </b></td><td> as geodetic pressure loss [Pa].</td></tr>
</table>

<p>
<b>Definition of quality for two phase flow</b>:
</p>
<p>
Different definitions of the quality exist for two phase flow. Static quality, mass flow rate quality and thermodynamic quality can be used to describe the fraction of gas and liquid in two phase flow.
Here the mass flow rate quality <b>(x_flow)</b> is used to describe two phase flow as follows:
</p>

<pre>
    x_flow = mdot_g/(mdot_g+mdot_l)
</pre>

<p>
with
</p>

<table>
<tr><td><b> x_flow        </b></td><td> as mass flow rate quality [-],</td></tr>
<tr><td><b> mdot_g        </b></td><td> as gaseous mass flow rate [kg/s],</td></tr>
<tr><td><b> mdot_l        </b></td><td> as liquid mass flow rate [kg/s].</td></tr>
</table>

<p>
Note that mass flow rate quality <b>(x_flow)</b> is only equal to the static quality, if a difference between the velocity of gas and liquid phase is neglected (homogeneous approach).
Additionally the thermodynamic quality is only equal to the mass flow rate quality <b>(x_flow)</b> in the two phase regime for thermodynamic equilibrium of the phases.
</p>
<p>
<b>Frictional pressure loss</b>:
</p>
<p>
The frictional pressure loss <b>dp_fri</b> of a straight pipe is calculated either by the correlation of <b>Friedel</b> (frictionalPressureLoss==Friedel) or by the correlation of <b>Chisholm</b> (frictionalPressureLoss==Chisholm).
Both correlations can be used for the above named two phase flow regimes.
The two phase frictional pressure loss results from a frictional pressure loss assuming one phase liquid fluid flow and a two phase multiplier taking into account the effects of two phase flow:
</p>

<pre>
    dp_fri = dp_1ph*phi_i
</pre>

<p>
with
</p>

<table>
<tr><td><b> dp_1ph  </b></td><td> as frictional pressure loss assuming one phase liquid fluid flow [Pa],</td></tr>
<tr><td><b> phi_i   </b></td><td> as two phase multiplier [-].</td></tr>
</table>

<p>
The liquid frictional pressure loss is calculated with the <b>total mass flow rate</b> assumed to flow as liquid.
</p>
<p>
The correlations of Friedel and Chisholm differ in their calculation of the two phase multiplier:
</p>
<pre>
    phi_friedel = (1 - x_flow)^2 + x_flow^2*(rho_l/rho_g)*(lambda_g/lambda_l)
                + 3.43*x_flow^0.685*(1 - x_flow)^0.24*(rho_l/rho_g)^0.8*(eta_g/eta_l)^0.22*(1 - eta_g/eta_l)^0.89*(1/Fr_l^(0.048))*(1/We_l^(0.0334))
</pre>
<pre>
    phi_chisholm = 1 + (gamma^2 - 1)*(B*x_flow^((2 - n_exp)/2)*(1 - x_flow)^((2 -n_exp)/2) + x_flow^(2 - n_exp))
</pre>

<p>
with
</p>

<table>
<tr><td><b> B              </b></td><td> as Lockhart-Martinelli coefficient [-],</td></tr>
<tr><td><b> eta_l          </b></td><td> as dynamic viscosity of the liquid phase [Pas],</td></tr>
<tr><td><b> eta_g          </b></td><td> as dynamic viscosity of the gaseous phase [Pas],</td></tr>
<tr><td><b> gamma          </b></td><td> as physical property coefficient [-],</td></tr>
<tr><td><b> n_exp</b> =0.2     </td><td> as exponent in Chisholm correlation [-],</td></tr>
<tr><td><b> phi_i          </b></td><td> as two phase multiplier [-],</td></tr>
<tr><td><b> rho_l          </b></td><td> as density of the liquid phase [kg/m3],</td></tr>
<tr><td><b> rho_g          </b></td><td> as density of the gaseous phase [kg/m3],</td></tr>
<tr><td><b> Re_l           </b></td><td> as Reynolds number of the liquid phase [-],</td></tr>
<tr><td><b> Re_g           </b></td><td> as Reynolds number of the gaseous phase [-],</td></tr>
<tr><td><b> Fr_l           </b></td><td> as Froude number of the liquid phase [-],</td></tr>
<tr><td><b> We_l           </b></td><td> as Weber number of the liquid phase [-],</td></tr>
<tr><td><b> x_flow         </b></td><td> as mass flow rate quality [-].</td></tr>
</table>

<p>
Note that the (mean constant) mass flow rate quality <b>(x_flow)</b> used for frictional pressure loss is calculated as arithmetic mean value out of the mass flow rate quality at the end and at the start of the straight pipe length.
</p>
<p>
<b>Momentum pressure loss</b>:
</p>
<p>
The momentum pressure loss <b> dp_mom </b> can be considered (momentumPressureLoss = true) for a homogeneous or heterogeneous two phase flow depending on the approach used for the void fraction <b>(epsilon)</b>.
At evaporation the liquid phase having a slow velocity has to be accelerated to the higher velocity of the gas. The difference in static pressure at the outlet and the inlet causes a positive momentum pressure loss at evaporation (assumed vice versa for condensation).
The momentum pressure loss occurs for a changing mass flow rate quality due to condensation or evaporation according to <i>[VDI 2006, p.Lba 4, eq. 22]</i> :
</p>

<pre>
    dp_mom = mdot_A^2*[[((1-x_flow)^2/(rho_l*(1-epsilon)) + x_flow^2/(rho_g*epsilon))]_out - [((1-x_flow)^2/(rho_l*(1-epsilon)) + x_flow^2/(rho_g*epsilon))]_in]
</pre>

<p>
with
</p>

<table>
<tr><td><b> mdot_A         </b></td><td> as total mass flow rate density [kg/(m2s)],</td></tr>
<tr><td><b> epsilon        </b></td><td> as void fraction [-],</td></tr>
<tr><td><b> rho_l          </b></td><td> as density of the liquid phase [kg/m3],</td></tr>
<tr><td><b> rho_g          </b></td><td> as density of the gaseous phase [kg/m3],</td></tr>
<tr><td><b> x_flow         </b></td><td> as mass flow rate quality [-].</td></tr>
</table>

<p>
Note that a momentum pressure loss is only considered for a variable mass flow rate quality <b>(x_flow)</b> during evaporation or condensation. Momentum pressure loss does not occur under adiabatic conditions for a corresponding constant mass flow rate quality (evaporation due to pressure loss is not considered).
</p>

<p>
<b>Void fraction approach</b>:
</p>
<p>
The void fraction is one of the most important parameter used to characterize two phase flow. There are several analytical and empirical approaches according to <i>[Thome, J.R]</i> :
</p>

<ul>
 <li>    <b> homogeneous approach </b> </li>
 <li>     <b> momentum flux approach (heterogeneous model) </b></li>
 <li>     <b> Kinetic energy flow approach by Zivi (heterogeneous model) </b></li>
 <li>     <b> Empirical momentum flux approach by Chisholm (heterogeneous model) </b></li>
</ul>

<p>
These approaches for the void fraction <b>epsilon</b> imply a correlation for the slip ratio. The slip ratio is defined as ratio of the velocity from the gaseous phase to the liquid phase at two phase flow.
The effects of different fluid flow velocities of the phases on two phase pressure loss can be considered with the slip ratio in the heterogeneous approaches. The slip ratio for the homogeneous approach is unity, so that there is no difference in the velocities of the two phases (e.g., usable for bubble flow).
</p>
<p>
<b>Geodetic pressure loss</b>:
</p>
<p>
The geodetic pressure loss <b>dp_geo</b> can be considered (geodeticPressureLoss=true) for two phase flow according to <i>[VDI 2006, p.Lbb 1, eq. 4]</i> :
</p>

<pre>
    dp_geo = (epsilon*rho_g +(1-epsilon)*rho_l)*g*L*sin(phi)
</pre>

<p>
with
</p>

<table>
<tr><td><b> epsilon        </b></td><td> as void fraction [-],</td></tr>
<tr><td><b> rho_l          </b></td><td> as density of the liquid phase [kg/m3],</td></tr>
<tr><td><b> rho_g          </b></td><td> as density of the gaseous phase [kg/m3],</td></tr>
<tr><td><b> g              </b></td><td> as acceleration of gravity [m/s2],</td></tr>
<tr><td><b> L              </b></td><td> as length of straight pipe [m],</td></tr>
<tr><td><b> phi            </b></td><td> as angle to horizontal [rad].</td></tr>
</table>

<h4>Verification</h4>
<p>
The two phase pressure loss for a horizontal pipe calculated by the correlation of <i> Friedel </i> neglecting momentum and geodetic pressure loss is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/fig_dp_twoPhaseOverall_1.png\" alt=\"fig_dp_twoPhaseOverall_1\"/>
</p>

<p>
The two phase pressure loss for a horizontal pipe calculated by the correlation of <i> Chisholm </i> neglecting momentum and geodetic pressure loss is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/fig_dp_twoPhaseOverall_4.png\" alt=\"fig_dp_twoPhaseOverall_4\"/>
</p>

<h4>References</h4>
<dl>
<dt>Chisholm,D.:</dt>
    <dd><b>Pressure gradients due to friction during the flow of evaporating two-phase mixtures in smooth tubes and channels</b>.
    Volume 16th of International Journal of Heat and Mass Transfer, 1973.</dd>
 <dt>Friedel,L.:</dt>
    <dd><b>IMPROVED FRICTION PRESSURE DROP CORRELATIONS FOR HORIZONTAL AND VERTICAL TWO PHASE PIPE FLOW</b>.3R International, Vol. 18, Issue 7, pp. 485-491, 1979.</dd>
 <dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 10th edition, 2006.</dd>
<dt>J.M. Jensen and H. Tummescheit:</dt>
    <dd><b>Moving boundary models for dynamic simulations of two-phase flows</b>.
    In Proceedings of the 2nd International Modelica Conference, pages 235-244, Oberpfaffenhofen, Germany, 2002. The Modelica Association.</dd>
<dt>Thome, J.R.:</dt>
    <dd><b>Engineering Data Book 3</b>.Swiss Federal Institute of Technology Lausanne (EPFL), 2009.</dd>
</dl>
</html>"));
      end dp_twoPhaseOverall;

        annotation (DocumentationClass=true);
      end StraightPipe;

      package Valve
        extends Modelica_Icons.Information;

      class dp_severalGeometryOverall
       extends Modelica_Icons.Information;
      annotation(Documentation(info="<html>
<p>
Calculation of pressure loss for a valve with different geometries at overall flow regime for incompressible and single-phase fluid flow in dependence of its opening.
</p>
<h4>Restriction</h4>
<p>
This function shall be used inside of the restricted limits according to the referenced literature.
</p>
<ul>
 <li>
      <b> developed fluid flow </b>
 </li>
 <li>
      <b> ball valve </b>
 </li>
 <li>
      <b> diaphragm valve </b>
 </li>
 <li>
      <b> butterfly valve </b>
 </li>
 <li>
      <b> gate valve </b>
 </li>
 <li>
      <b> sluice valve </b>
 </li>
</ul>

<h4>Geometry</h4>
<p>
Wide variations in valve geometry are possible and a manufacturer will not necessarily maintain geometric similarity between valves of the same type but of different size. Here pressure loss can be estimated for the following types of a valve:
</p>
<ul>
 <li>
      <b> ball valve </b>
 </li>
 <li>
      <b> diaphragm valve </b>
 </li>
 <li>
      <b> butterfly valve </b>
 </li>
 <li>
      <b> gate valve </b>
 </li>
 <li>
      <b> sluice valve </b>
 </li>
</ul>

<h4>Calculation</h4>
<p>
The mass flow rate <b>m_flow</b> for valves out of pressure loss is determined by:
</p>

<pre>
    m_flow = [rho * dp * Av^2 / (zeta_TOT/2]^0.5
    m_flow = (2/zeta_TOT)^0.5 * Av * (rho * dp)^0.5
    m_flow = valveCharacteristic * Av * (rho * dp)^0.5
</pre>

<p>
with
</p>

<table>
<tr><td><b> rho                        </b></td><td> as density of fluid [kg/m3],</td></tr>
<tr><td><b> Av                         </b></td><td> as (metric) flow coefficient (cross sectional area) [m^2],</td></tr>
<tr><td><b> m_flow                     </b></td><td> as mass flow rate [kg/s],</td></tr>
<tr><td><b> valveCharacteristic        </b></td><td> as coefficient of a valve in dependence of its opening [-],</td></tr>
<tr><td><b> velocity                   </b></td><td> as mean velocity [m/s],</td></tr>
<tr><td><b> zeta_TOT                   </b></td><td> as pressure loss coefficient [-].</td></tr>
</table>

<p>
The <b>valveCharacteristic</b> is determined out of a correlation for the pressure loss coefficient (<b>zeta_TOT</b>) in dependence of its opening. The reason for introducing an additional variable
<b>valveCharacteristic</b> is a different definition of the following pressure loss correlations of valves.
</p>

<h4>Verification</h4>
<p>
The pressure loss coefficient (<b>zeta_TOT</b>) of a valve with different geometries are shown in dependence of the <b>opening</b> in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/valve/fig_valve_dp_severalGeometryOverall_zetaVsOpening.png\" alt=\"fig_valve_dp_severalGeometryOverall_zetaVsOpening\">
</p>

<p>
Note that the pressure loss coefficients (<b>zeta_TOT</b>) are numerically optimized for very small openings (opening &le; 5%). At openings smaller than 5% the pressure loss coefficient is smoothly set
to a maximum value (<b>zeta_TOT_max</b>) to be adjusted as parameter. Therefore a very small leakage mass flow rate can be adjusted for a given pressure difference at almost closed valves. A very small
leakage mass flow rate can often be neglected in system simulation with valves, whereas the numerical behaviour of the simulation is improved.
</p>
<p>
The mass flow rate of different valves at a constant opening of 50% in dependence of pressure loss is shown in the figure below.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/valve/fig_valve_dp_severalGeometryOverall_MFLOWvsDP.png\" alt=\"fig_valve_dp_severalGeometryOverall_MFLOWvsDP\"/>
</p>

<h4>References</h4>
<dl>
<dt>Miller,D.S.:</dt>
    <dd><b>Internal flow systems</b>.
    Volume 5th of BHRA Fluid Engineering Series. BHRA Fluid Engineering, 1978.</dd>
</dl>
</html>"));
      end dp_severalGeometryOverall;

        annotation (DocumentationClass=true);
      end Valve;

        annotation (DocumentationClass=true);
      end PressureLoss;

        annotation (DocumentationClass=true, Documentation(info="<html>
<p>
This package contains documentation that is used multiple times
in several functions. To avoid duplication of the documentation, links
are used in the respective functions to link to the corresponding shared
documentation available in this package.
</p>

</html>"));
      end SharedDocumentation;

      package Functions "Package for utility functions"
      extends Modelica_Icons.Package;

        package PressureLoss "Package for utility pressure loss functions"
          extends Modelica_Icons.Package;

          package TwoPhase
            "Package with utility functions to compute two phase pressure loss characteristics"
            extends Modelica_Icons.Package;

            function dp_twoPhaseChisholm_DP
              "Frictional pressure loss of straight pipe for two phase flow according to Chisholm correlation | calculate pressure loss | overall flow regime"
              import Modelica_Fluid;
              extends Modelica_Icons.Function;
              //SOURCE_1: Chisholm,D.:PRESSURE GRADIENTS DUE TO FRICTION DURING THE FLOW OF EVAPORATING TWO-PHASE MIXTURES IN SMOOTH TUBES AND CHANNELS, Int. J. Heat Mass Transfer, Vol. 16, pp. 347-358, Pergamon Press 1973

              //records
              input Records.General.TwoPhaseFlow_con IN_con
                annotation (Dialog(group="Constant inputs"));
              input Records.General.TwoPhaseFlow_var IN_var
                annotation (Dialog(group="Variable inputs"));
              input SI.MassFlowRate m_flow "Mass flow rate"
                annotation (Dialog(group="Input"));

              output SI.Pressure DP
                "Output for function dp_twoPhaseChisholm_DP";

            protected
              Real MIN=Modelica_Constants.eps;

              Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_IN_con
                IN_con_1ph(
                final roughness=Dissipation.Utilities.Types.Roughness.Neglected,

                final d_hyd=4*abs(IN_con.A_cross)/max(MIN, abs(IN_con.perimeter)),

                final K=0,
                final L=abs(IN_con.length));

              Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_IN_var
                IN_var_1ph(final eta=IN_var.eta_l, final rho=IN_var.rho_l);

            algorithm
              DP :=
                Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_DP(
                            IN_con_1ph,
                            IN_var_1ph,
                            m_flow)*(
                Modelica_Fluid.Dissipation.Utilities.Functions.PressureLoss.TwoPhase.TwoPhaseMultiplierChisholm(
                            IN_con,
                            IN_var,
                            m_flow));

              annotation (Inline=false);
            end dp_twoPhaseChisholm_DP;

            function dp_twoPhaseFriedel_DP
              "Frictional pressure loss of straight pipe for two phase flow according to Friedel correlation | calculate pressure loss| overall flow regime"
              extends Modelica_Icons.Function;
              //SOURCE_1: Friedel,L.:IMPROVED FRICTION PRESSURE DROP CORRELATIONS FOR HORIZONTAL AND VERTICAL TWO PHASE PIPE FLOW, 3R International, Vol. 18, Issue 7, pp. 485-491, 1979
              //SOURCE_2: VDI-Waermeatlas, 10th edition, Springer-Verlag, 2006.

              import SMOOTH =
                Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;
              import SMOOTH2 =
                Modelica_Fluid.Dissipation.Utilities.Functions.General.SmoothPower;

              //records
              input Records.General.TwoPhaseFlow_con IN_con
                annotation (Dialog(group="Constant inputs"));
              input Records.General.TwoPhaseFlow_var IN_var
                annotation (Dialog(group="Variable inputs"));
              input SI.MassFlowRate m_flow "Mass flow rate"
                annotation (Dialog(group="Input"));

              output SI.Pressure DP "Output for function dp_twoPhaseFriedel_DP";

            protected
              Real MIN=Modelica_Constants.eps;

              SI.Area A_cross=max(MIN, IN_con.A_cross) "Cross sectional area";
              SI.Diameter d_hyd=max(MIN, 4*A_cross/max(MIN, IN_con.perimeter))
                "Hydraulic diameter";

              Real mdot_A=abs(m_flow)/A_cross "Mass flux";
              SI.ReynoldsNumber Re_liq=max(1, mdot_A*d_hyd/max(MIN, IN_var.eta_l))
                "Reynolds number assuming (total) mass flux flowing as liquid";
              SI.ReynoldsNumber Re_lam_leave=1055
                "Maximum Reynolds number for laminar regime (1055)";
              SI.ReynoldsNumber Re_turb=1100
                "Minimum Reynolds number for turbulent regime (1100)";
              SI.ReynoldsNumber Re_smooth=m_flow/A_cross*d_hyd/max(MIN, abs(
                  IN_var.eta_l)) "Reynolds number for smoothing";
              Types.DarcyFrictionFactor lambda_FRI_lam=64/Re_liq
                "Darcy friction factor for laminar regime";
              Types.DarcyFrictionFactor lambda_FRI_turb=(0.86859*
                  Modelica_Math.log(max(1, (Re_liq/max(MIN, (1.964*
                  Modelica_Math.log(Re_liq) - 3.8215))))))^(-2)
                "Darcy friction factor for turbulent regime";
              Types.DarcyFrictionFactor lambda_FRI=lambda_FRI_lam*SMOOTH(
                              Re_lam_leave,
                              Re_turb,
                              Re_liq) + lambda_FRI_turb*SMOOTH(
                              Re_turb,
                              Re_lam_leave,
                              Re_liq);
              Types.PressureLossCoefficient zeta_FRI=lambda_FRI*IN_con.length/
                  d_hyd "Pressure loss coefficient";
              SI.Pressure DP_liq=zeta_FRI*mdot_A^2/(2*max(MIN, IN_var.rho_l))
                "Frictional pressure loss assuming (total) mass flux flowing as liquid";

            algorithm
              DP := SMOOTH2(Re_smooth,
                            1,
                            0)*DP_liq*(TwoPhaseMultiplierFriedel(
                            IN_con,
                            IN_var,
                            m_flow));

                annotation (Inline=false);
            end dp_twoPhaseFriedel_DP;

            function dp_twoPhaseGeodetic_DP
              "Geodetic pressure loss of straight pipe for two phase flow | calculate pressure loss"
              extends Modelica_Icons.Function;
              //SOURCE_1: VDI-Waermeatlas, 10th edition, Springer-Verlag, 2006.

              import PI = Modelica_Constants.pi;

              input Types.VoidFractionApproach voidFractionApproach=Dissipation.Utilities.Types.VoidFractionApproach.Homogeneous
                "Choice of void fraction approach";

              input Boolean crossSectionalAveraged=true
                "true == cross sectional averaged void fraction | false == volumetric"
                annotation (Dialog);

              //geometry
              input SI.Length length=1 "Length in fluid flow direction"
                annotation (Dialog(group="Geometry"));
              input SI.Angle phi=0 "Tilt angle to horizontal"
                annotation (Dialog(group="Geometry"));

              //fluid properties
              input SI.Density rho_g(min=Modelica_Constants.eps)
                "Density of gaseous phase"
                annotation (Dialog(group="Fluid properties"));
              input SI.Density rho_l(min=Modelica_Constants.eps)
                "Density of liquid phase"
                annotation (Dialog(group="Fluid properties"));
              input Real x_flow(
                min=0,
                max=1) = 0 "Mass flow rate quality"
                annotation (Dialog(group="Fluid properties"));

              output SI.Pressure DP_geo "Geodetic pressure loss";

            protected
              Real xflow=min(1, max(0, abs(x_flow))) "Mass flow rate quality";
              Real eps=
                  VoidFraction(
                  voidFractionApproach,
                  crossSectionalAveraged,
                  rho_g,
                  rho_l,
                  xflow) "Void fraction";

            algorithm
              //SOURCE_1: p.Lbb 1, eq. 4: Considering geodetic pressure loss assuming constant void fraction for flow length
              DP_geo := (eps*rho_g + (1 - eps)*rho_l)*9.81*length*sin(phi);

                annotation (Inline=false);
            end dp_twoPhaseGeodetic_DP;

            function dp_twoPhaseMomentum_DP
              "Momentum pressure loss of straight pipe for two phase flow | calculate pressure loss"
              extends Modelica_Icons.Function;
              //SOURCE_1: VDI-Waermeatlas, 10th edition, Springer-Verlag, 2006.
              //SOURCE_2: Thome, J.R., Engineering Data Book 3, Swiss Federal Institute of Technology Lausanne (EPFL), 2009.
              //SOURCE 3: J.M. Jensen and H. Tummescheit. Moving boundary models for dynamic simulations of two-phase flows. In Proceedings of the 2nd International Modelica Conference, pp. 235-244, Oberpfaffenhofen, Germany, 2002. The Modelica Association.

              import PI = Modelica_Constants.pi;
              import MIN = Modelica_Constants.eps;
              import SMOOTH =
                Modelica_Fluid.Dissipation.Utilities.Functions.General.SmoothPower;

              //choices
              input Types.VoidFractionApproach voidFractionApproach=Types.VoidFractionApproach.Homogeneous
                "Choice of void fraction approach"
                annotation (Dialog(group="Choices"));

              //SOURCE_3: p.52, eq. 4.6: heterogenous effects on momentum pressure loss considered through corrected mass flow rate
              input Boolean massFlowRateCorrection=false
                "Consider heterogeneous mass flow rate correction"
                annotation (Dialog(group="Choices"));

              //geometry
              input SI.Area A_cross(min=Modelica_Constants.eps)=PI*0.1^2/4
                "Cross sectional area" annotation (Dialog(group="Geometry"));
              input SI.Length perimeter(min=Modelica_Constants.eps)=PI*0.1
                "Perimeter" annotation (Dialog(group="Geometry"));

              //fluid properties
              input SI.Density rho_g(min=Modelica_Constants.eps)
                "Density of gas" annotation (Dialog(group="Fluid properties"));
              input SI.Density rho_l(min=Modelica_Constants.eps)
                "Density of liquid"
                annotation (Dialog(group="Fluid properties"));
              input Real x_flow_end(
                min=0,
                max=1) = 0 "Mass flow rate quality at end of length"
                annotation (Dialog(group="Fluid properties"));
              input Real x_flow_sta(
                min=0,
                max=1) = 0 "Mass flow rate quality at start of length"
                annotation (Dialog(group="Fluid properties"));

              input SI.MassFlowRate m_flow "Mass flow rate"
                annotation (Dialog(group="Input"));

              output SI.Pressure DP_mom "Momentum pressure loss";

            protected
              Real MIN=Modelica_Constants.eps;

              SI.Area Across=max(MIN, A_cross) "Cross sectional area";
              SI.Diameter d_hyd=max(MIN, 4*A_cross/max(MIN, perimeter))
                "Hydraulic diameter";

              Real mdot_A=abs(m_flow)/Across "Mass flux";
              Real xflowEnd=min(1, max(0, abs(x_flow_end)))
                "Mass flow rate quality at end of length";
              Real xflowSta=min(1, max(0, abs(x_flow_sta)))
                "Mass flow rate quality at start of length";
              Real xflowMean=(xflowEnd + xflowSta)/2
                "Mean mass flow rate quality over length";

              Real delta_xflow=xflowEnd - xflowSta
                "Difference of mass flow rate quality between end and start of length (pos >> evaporation, neg >> condensation";

              //SOURCE_2: Considering void fraction approaches
              Real eps_end=
                  VoidFraction(
                  voidFractionApproach,
                  true,
                  rho_g,
                  rho_l,
                  xflowEnd) "Void fraction at end of length";
              Real eps_sta=
                  VoidFraction(
                  voidFractionApproach,
                  true,
                  rho_g,
                  rho_l,
                  xflowSta) "Void fraction at start of length";

              //SOURCE_2: p.17-6, eq. 17.3.3: Considering mean two phase density at end and start of length
              SI.Density rho_end=TwoPhaseDensity(
                              voidFractionApproach,
                              massFlowRateCorrection,
                              rho_g,
                              rho_l,
                              eps_end,
                              xflowEnd)
                "Mean two phase density at end of lenght";
              SI.Density rho_sta=TwoPhaseDensity(
                              voidFractionApproach,
                              massFlowRateCorrection,
                              rho_g,
                              rho_l,
                              eps_sta,
                              xflowSta)
                "Mean two phase density at start of lenght";

              SI.Velocity meanVelEnd=abs(m_flow)/max(MIN, rho_end*A_cross)
                "Mean velocity of two phase flow at end of length";
              SI.Velocity meanVelSta=abs(m_flow)/max(MIN, rho_sta*A_cross)
                "Mean velocity of two phase flow at start of length";

              //SOURCE 3: p.15, eq. 2.26: Considering velocity difference for heterogeneous approach using slip ratio
              Real SR=Dissipation.Utilities.Functions.PressureLoss.TwoPhase.SlipRatio(
                  voidFractionApproach,
                  rho_g,
                  rho_l,
                  xflowMean) "Slip ratio for velocity void fraction approach";
              SI.Velocity deltaVelEnd=meanVelEnd*(SR - 1)/(xflowEnd*(SR - 1) +
                  1) "Velocity difference of two phases at end of length";
              SI.Velocity deltaVelSta=meanVelSta*(SR - 1)/(xflowSta*(SR - 1) +
                  1) "Velocity difference of two phases at start of length";

              //SOURCE 3: p.52, eq. 4.6: Considering of corrected mass flow rate for heterogenous approach
              SI.MassFlowRate mdotCorEnd=xflowEnd*(1 - xflowEnd)*rho_end*
                  deltaVelEnd*Across
                "Correction mass flow rate at end of length";
              SI.MassFlowRate mdotCorSta=xflowSta*(1 - xflowSta)*rho_sta*
                  deltaVelSta*Across
                "Correction mass flow rate at start of length";

              //SOURCE 3: p.53, eq. 4.13: Calculation of heterogeneous approach with correction of mass flow rate for considering velocity difference between fluid phases
              SI.Pressure dp_mom_cor=SMOOTH(
                              delta_xflow,
                              0.05,
                              0)*abs(mdot_A*meanVelEnd + mdotCorEnd*deltaVelEnd
                  /Across) - abs(mdot_A*meanVelSta + mdotCorEnd*deltaVelSta/
                  Across)
                "Momentum pressure loss using mass flow rate correction";

            algorithm
              //SOURCE_1: p.Lba 4, eq. 22: Considering momentum pressure loss assuming heterogeneous approach for two phase flow
              //Momentum pressure loss occurs for a changing mass flow rate quality due to condensation or evaporation
              //At evaporation the liquid phase with a slow velocity has to be accelerated to the higher velocity of the gas
              //The difference in static pressure at the outlet and the inlet causes a positive momentum pressure loss at evaporation (assumed vice versa for condensation)
              DP_mom := if massFlowRateCorrection then dp_mom_cor else mdot_A^2
                *SMOOTH(    delta_xflow,
                            0.05,
                            0)*abs(1/max(MIN, rho_end) - 1/max(MIN, rho_sta));

              annotation (Inline=false, Documentation(revisions="<html>
2012-11-28 Corrected an error in momentum pressure loss calculation. Stefan Wischhusen.
</html>"));
            end dp_twoPhaseMomentum_DP;

            function TwoPhaseMultiplierFriedel
              "Calculation of two phase multiplier according to Friedel | constant mass flow rate quality | horizontal flow | vertical upflow and downflow"
              extends Modelica_Icons.Function;
              //SOURCE_1: Friedel,L.:IMPROVED FRICTION PRESSURE DROP CORRELATIONS FOR HORIZONTAL AND VERTICAL TWO PHASE PIPE FLOW, 3R International, Vol. 18, Issue 7, pp. 485-491, 1979
              //SOURCE_2: VDI-Waermeatlas, 10th edition, Springer-Verlag, 2006.

              import Modelica_Math.log;
              import SMOOTH =
                Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

              input Records.General.TwoPhaseFlow_con IN_con
                annotation (Dialog(group="Constant inputs"));
              input Records.General.TwoPhaseFlow_var IN_var(final sigma=0)
                annotation (Dialog(group="Variable inputs"));
              input SI.MassFlowRate m_flow "Mass flow rate"
                annotation (Dialog(group="Input"));

              output Real phi "Two phase multiplier w.r.t. Friedel";

            protected
              Real MIN=Modelica_Constants.eps;

              SI.Area A_cross=max(MIN, IN_con.A_cross) "Cross sectional area";
              SI.Diameter d_hyd=max(MIN, 4*A_cross/max(MIN, IN_con.perimeter))
                "Hydraulic diameter";

              //SOURCE_2: p.Lba 4, sec. 3.3: Correlation based on constant mass flow rate quality (x_flow) for increment (dx)
              //Pressure loss for total length (e.g., L=n*dx) can be achieved by discretization
              Real mdot_A=abs(m_flow)/A_cross "Mass flux";
              Real x_flow=max(0, min(1, abs(IN_var.x_flow)))
                "Mass flow rate quality";

              //SOURCE_1: p.490 (Appendix): Characteristic numbers based on total mass flow rate flowing as liquid
              SI.FroudeNumber Fr_l=max(MIN, mdot_A^2/max(MIN, 9.81*IN_var.rho_l
                  ^2*d_hyd)) "Froude number based on liquid flow";
              SI.ReynoldsNumber Re_g=max(1, mdot_A*d_hyd/max(MIN, IN_var.eta_g))
                "Reynolds number based on gas flow";
              SI.ReynoldsNumber Re_l=max(1, mdot_A*d_hyd/max(MIN, IN_var.eta_l))
                "Reynolds number based on liquid flow";
              SI.WeberNumber We_l=max(MIN, mdot_A^2*d_hyd/max(MIN, IN_var.sigma
                  *IN_var.rho_l)) "Weber number based on liquid flow";

              //SOURCE_1: p.490 (Appendix): Smoothing for sudden change from assumed laminar to assumed turbulent regime (numerical improvement at Re=1055)
              SI.ReynoldsNumber Re_lam_max=1025
                "Maximum Reynolds number assuming laminar regime";
              SI.ReynoldsNumber Re_turb_min=1075
                "Minimum Reynolds number assuming turbulent regime";

              //SOURCE_2: p.Lbb 2, eq. 9-10: Considering influence of Reynolds number on Darcy friction factor for smooth straight pipes
              //Correlation based on neglection of surface roughness
              //Correlation based on assumption that total mass flow rate is flowing as gas
              Types.DarcyFrictionFactor lambda_lam_g=64/Re_g
                "Darcy friction factor of gas for assumed laminar regime";
              Types.DarcyFrictionFactor lambda_turb_g=1/max(MIN, 0.86859*log(
                  max(1, Re_g/max(MIN, 1.964*log(Re_g) - 3.8215))))^(2)
                "Darcy friction factor of gas for assumed turbulent regime";
              Types.DarcyFrictionFactor lambda_g=lambda_lam_g*SMOOTH(
                              Re_lam_max,
                              Re_turb_min,
                              Re_g) + lambda_turb_g*SMOOTH(
                              Re_turb_min,
                              Re_lam_max,
                              Re_g)
                "Darcy friction factor of gas for overall regime";
              //Correlation based on assumption that total mass flow rate is flowing as liquid
              Types.DarcyFrictionFactor lambda_lam_l=64/Re_l
                "Darcy friction factor of liquid for assumed laminar regime";
              Types.DarcyFrictionFactor lambda_turb_l=1/max(MIN, 0.86859*log(
                  max(1, Re_l/max(MIN, 1.964*log(Re_l) - 3.8215))))^(2)
                "Darcy friction factor of liquid for assumed turbulent regime";
              Types.DarcyFrictionFactor lambda_l=lambda_lam_l*SMOOTH(
                              Re_lam_max,
                              Re_turb_min,
                              Re_l) + lambda_turb_l*SMOOTH(
                              Re_turb_min,
                              Re_lam_max,
                              Re_l)
                "Darcy friction factor of liquid for overall regime";

              Real A=(1 - x_flow)^2 + x_flow^2*(IN_var.rho_l/max(MIN, IN_var.rho_g))*(
                  lambda_g/max(MIN, lambda_l))
                "Summand for two phase multiplier";

              //SOURCE_1: p.490 (Appendix): Two phase multiplier for vertical downflow for future usage
              Real phi_vdo=A + 38.5*x_flow^0.76*(1 - x_flow)^0.314*(IN_var.rho_l/max(MIN,
                  IN_var.rho_g))^0.86*(IN_var.eta_g/max(MIN, IN_var.eta_l))^0.73*(1 -
                  IN_var.eta_g/max(MIN, IN_var.eta_l))^6.84*(1/Fr_l^(0.0001))*(1/We_l^(
                  0.087));

              //SOURCE_1: p.490 (Appendix): Two phase multiplier for horizontal and vertical upflow (failure in SOURCE_2)
              Real phi_vup=A + 3.43*x_flow^0.685*(1 - x_flow)^0.24*(IN_var.rho_l/max(MIN,
                  IN_var.rho_g))^0.8*(IN_var.eta_g/max(MIN, IN_var.eta_l))^0.22*(1 - IN_var.eta_g
                  /max(MIN, IN_var.eta_l))^0.89*(1/Fr_l^(0.048))*(1/We_l^(0.0334));

            algorithm
              phi := phi_vup;

                annotation (Inline=false);
            end TwoPhaseMultiplierFriedel;

            function TwoPhaseMultiplierChisholm
              "Calculation of two phase multiplier according to Chisholm | constant mass flow rate quality"
              extends Modelica_Icons.Function;
              //SOURCE_1: Chisholm,D.:PRESSURE GRADIENTS DUE TO FRICTION DURING THE FLOW OF EVAPORATING TWO-PHASE MIXTURES IN SMOOTH TUBES AND CHANNELS, Int. J. Heat Mass Transfer, Vol. 16, pp. 347-358, Pergamon Press 1973
              //SOURCE_2: VDI-Waermeatlas, 10th edition, Springer-Verlag, 2006.

              import SMOOTH =
                Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

              input Records.General.TwoPhaseFlow_con IN_con
                annotation (Dialog(group="Constant inputs"));
              input Records.General.TwoPhaseFlow_var IN_var
                annotation (Dialog(group="Variable inputs"));
              input SI.MassFlowRate m_flow "Mass flow rate"
                annotation (Dialog(group="Input"));

              output Real phi "Two phase multiplier w.r.t. Chisholm";

            protected
              Real MIN=Modelica_Constants.eps;

              SI.Area A_cross=max(MIN, IN_con.A_cross) "Cross sectional area";
              SI.Diameter d_hyd=max(MIN, 4*A_cross/max(MIN, IN_con.perimeter))
                "Hydraulic diameter";

              Real mdot_A=abs(m_flow)/A_cross "Mass flux";
              Real x_flow=max(0, min(1, abs(IN_var.x_flow)))
                "Mass flow rate quality";

              //SOURCE_1: p.357, Appendix 1: Considering Darcy friction factor (lambda_FRI) of smooth pipes for overall flow regime
              Real n_exp=0.2
                "Exponent for Reynolds number (lambda_FRI= A/Re^n)";

              //SOURCE_1: p.349, eq. 21: Considering effect of physical properties (failure in SOURCE_2)
              Real gamma=max(1, abs(IN_var.rho_l/max(MIN, IN_var.rho_g))^0.5*(IN_var.eta_g/
                  max(MIN, IN_var.eta_l))^(n_exp/2));

              //SOURCE: p. 353, tab. 2: Considering effect of mass flux on two phase multiplier
              Real B_gamma_1=SMOOTH(
                  450,
                  550,
                  mdot_A)*4.8 + SMOOTH(
                  550,
                  450,
                  mdot_A)*2400/max(MIN, mdot_A) - SMOOTH(
                  1950,
                  1850,
                  mdot_A)*2400/max(MIN, mdot_A) + SMOOTH(
                  1950,
                  1850,
                  mdot_A)*55/max(MIN, mdot_A^0.5)
                "Coefficient B for gamma <= 9.5";
              Real B_gamma_2=SMOOTH(
                  550,
                  650,
                  mdot_A)*520/max(1, max(9.5, gamma)*mdot_A^0.5) + SMOOTH(
                  650,
                  550,
                  mdot_A)*21/max(9.5, gamma)
                "Coefficient B for 9.5 <= gamma <= 28";
              Real B_gamma=SMOOTH(
                  9.0,
                  10,
                  gamma)*B_gamma_1 + SMOOTH(
                  10,
                  9.0,
                  gamma)*B_gamma_2 - SMOOTH(
                  28.5,
                  27.7,
                  gamma)*B_gamma_2 + SMOOTH(
                  28.5,
                  27.5,
                  gamma)*15000/max(MIN, gamma^2*mdot_A^0.5)
                "Coefficient B for gamma";

              //SOURCE_1: p. 350, eq. 24/26: Considering two phase multiplier w.r.t. Chisholm
            algorithm
              phi := 1 + (gamma^2 - 1)*(B_gamma*x_flow^((2 - n_exp)/2)*(1 - x_flow)^((2 -
                n_exp)/2) + x_flow^(2 - n_exp));

               annotation (Inline=false);
            end TwoPhaseMultiplierChisholm;

            function TwoPhaseDensity
              "Calculation of mean density for two phase flow"
              extends Modelica_Icons.Function;
              //SOURCE_1: VDI-Waermeatlas, 10th edition, Springer-Verlag, 2006.
              input Types.VoidFractionApproach voidFractionApproach=Types.VoidFractionApproach.Homogeneous
                "Choice of void fraction approach"
                annotation (Dialog(group="Choices"));

              //SOURCE_3: p.52, eq. 4.6: heterogenous effects on momentum pressure loss considered through corrected mass flow rate
              input Boolean massFlowRateCorrection=false
                "Consider heterogeneous mass flow rate correction"
                annotation (Dialog(group="Choices"));

              input SI.Density rho_g(min=Modelica_Constants.eps)
                "Density of gaseous phase" annotation (Dialog);
              input SI.Density rho_l(min=Modelica_Constants.eps)
                "Density of liquid phase" annotation (Dialog);
              input Real epsilon_A(min=0,max=1)
                "Void fraction (cross sectional averaged)"
                annotation (Dialog(enable=not (twoPhaseDensityApproach == Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseDensityApproach.Homogeneous)));
              input Real x_flow(min=0,max=1) "Mass flow rate quality" annotation (Dialog);

              output SI.Density rho_2ph "Mean density of two phase flow";
            protected
              Real MIN=Modelica_Constants.eps;

              Real epsilonA=min(1, max(0, abs(epsilon_A)))
                "Void fraction (cross sectional averaged)";
              Real xflow=min(1, max(0, abs(x_flow))) "Mass flow rate quality";

              //SOURCE_1: p.Lba 3, eq. 17: Mean two phase density assuming homogeneous approach
              SI.Density rho_hom=1/max(MIN, x_flow/max(MIN, rho_g) + (1 -
                  x_flow)/max(MIN, rho_l));
              //SOURCE_1: p.Lbb 7, tab. 2: Mean two phase density assuming momentum flux approach
              SI.Density rho_mom=1/max(MIN, (x_flow)^2/max(MIN, rho_g*epsilonA)
                   + (1 - x_flow)^2/max(MIN, rho_l*(1 - epsilonA)));
              //SOURCE_1: p.Lbb 7, tab. 2: Mean two phase density assuming kinetic energy flow approach from Zivi (corrected formula!)
              SI.Density rho_kin=1/max(MIN, rho_hom*(x_flow^3/max(MIN, rho_g^2*
                  epsilonA^2) + (1 - x_flow)^3/max(MIN, rho_l^2*(1 - epsilonA)^
                  2)));

            algorithm
              rho_2ph := if not massFlowRateCorrection then rho_hom else if
                voidFractionApproach == Modelica_Fluid.Dissipation.Utilities.Types.VoidFractionApproach.Homogeneous
                 then rho_hom else if voidFractionApproach == Modelica_Fluid.Dissipation.Utilities.Types.VoidFractionApproach.Momentum
                 then rho_mom else if voidFractionApproach == Modelica_Fluid.Dissipation.Utilities.Types.VoidFractionApproach.Energy
                 then rho_kin else MIN;

              annotation (Inline=false, Documentation(info="<html>
<p>
The gaseous and the liquid part of a fluid in a two phase flow are often discontinuously distributed. This complex behaviour is simplified for engineering calculations. The two phase flow of different fluid flow situations (e.g., bubble or stratified flow) is modelled as if the gaseous and the liquid phase are continuously distributed.
</p>

<p>
A <b> mean density </b> assuming a continuous distribution out of a discontinuous two phase fluid flow situation can be calculated with a <b> homogeneous or a heterogeneous approach </b> (see <a href=\"modelica://Modelica_Fluid.Dissipation.PressureLoss.StraightPipe.dp_twoPhaseOverall_DP\">dp_twoPhaseOverall_DP</a>).</p>
<p>
The following <b> modelling approaches </b> can be used to calculate the mean density of two phase flow:
</p>
<ul>
<li>        <b> homogeneous density </b> (homogeneous approach) </li>
<li>         <b> momentum flux density </b> (heterogeneous approach) </li>
<li>         <b> kinetic energy flow density </b> (heterogeneous approach) </li>
</ul>


<p>
The heterogeneous approaches are analytically derived by minimising the momentum flux or the kinetic energy flow assuming implicitly that the two-phase flow will tend towards the minimum of this quantity.
</p>

<h4>References</h4>
<dl>
 <dt>VDI:</dt>
    <dd><b>VDI - W&auml;rmeatlas: Berechnungsbl&auml;tter f&uuml;r den W&auml;rme&uuml;bergang</b>.
    Springer Verlag, 10th edition, 2006.</dd>
</dl>
</html>",             revisions="<html>
<ul>
<li><i>2 May 2011</i>
    by Stefan Wischhusen:<br>
       Corrected a logical error in use of input <code>massFlowRateCorrection</code>.</li>
</ul>
</html>"));
            end TwoPhaseDensity;

            function VoidFraction
              "Calculation of (cross sectional) void fraction for two phase flow"
              extends Modelica_Icons.Function;
              //SOURCE_1: VDI-Waermeatlas, 10th edition, Springer-Verlag, 2006.
              //SOURCE_2: Thome, J.R., Engineering Data Book 3, Swiss Federal Institute of Technology Lausanne (EPFL), 2009.

              input Types.VoidFractionApproach voidFractionApproach=Dissipation.Utilities.Types.VoidFractionApproach.Homogeneous
                "Choice of void fraction approach"
                annotation (Dialog(group="Choices"));

              input Boolean crossSectionalAveraged=true
                "true == cross sectional averaged void fraction | false == volumetric"
                annotation (Dialog);

              input SI.Density rho_g(min=Modelica_Constants.eps)
                "Density of gaseous phase" annotation (Dialog);
              input SI.Density rho_l(min=Modelica_Constants.eps)
                "Density of liquid phase" annotation (Dialog);
              input Real x_flow(
                min=0,
                max=1) = 0 "Mass flow rate quality" annotation (Dialog);

              output Real epsilon "Void fraction";
              output Real slipRatio "Slip ratio";

            protected
              Real MIN=Modelica_Constants.eps;

              Real xflow=min(1, max(0, abs(x_flow))) "Mass flow rate quality";

              Real SR=Dissipation.Utilities.Functions.PressureLoss.TwoPhase.SlipRatio(
                  voidFractionApproach,
                  rho_g,
                  rho_l,
                  xflow) "Slip ratio for void fraction approach";

              //SOURCE_2: p.17-5, eq. 17.2.5: (Heterogeneous) cross sectional void fraction [epsilon_A=A_g/(A_g+A_l)]
              Real epsilon_A=rho_l*x_flow/max(MIN, rho_l*x_flow + rho_g*(1 - x_flow)*SR);

            algorithm
              epsilon := if crossSectionalAveraged then epsilon_A else epsilon_A/((1/max(
                MIN, SR))*(1 - epsilon_A) + epsilon_A);
              slipRatio := SR;

                annotation (Inline=false);
            end VoidFraction;

            function SlipRatio
              "Calculation of (analytical/empirical) slip ratio"
              extends Modelica_Icons.Function;
              //SOURCE_1: VDI-Waermeatlas, 10th edition, Springer-Verlag, 2006.
              //SOURCE_2: Thome, J.R., Engineering Data Book 3, Swiss Federal Institute of Technology Lausanne (EPFL), 2009.
              //SOURCE 3: J.M. Jensen and H. Tummescheit. Moving boundary models for dynamic simulations of two-phase flows. In Proceedings of the 2nd International Modelica Conference, pp. 235-244, Oberpfaffenhofen, Germany, 2002. The Modelica Association.

              input Types.VoidFractionApproach voidFractionApproach=Dissipation.Utilities.Types.VoidFractionApproach.Homogeneous
                "Choice of void fraction approach"
                annotation (Dialog(group="Choices"));

              input SI.Density rho_g(min=Modelica_Constants.eps)
                "Density of gaseous phase" annotation (Dialog);
              input SI.Density rho_l(min=Modelica_Constants.eps)
                "Density of liquid phase" annotation (Dialog);
              input Real x_flow=0 "Mass flow rate quality" annotation (Dialog);

              output Real SR "Slip ratio";

            protected
              Real MIN=Modelica_Constants.eps;

              //SOURCE_1: p.Lba 3, sec. 3.2
              Real SR_hom=1 "Slip ratio w.r.t. homogeneous approach";
              //SOURCE_2: p.17-6, eq. 17.3.4
              Real SR_mom=abs(rho_l/max(MIN, rho_g))^0.5
                "Slip ratio w.r.t. momentum flux approach (heterogeneous)";
              //SOURCE_2: p.17-7, eq. 17.3.13
              Real SR_kin=abs(rho_l/max(MIN, rho_g))^(1/3)
                "Slip ratio w.r.t. kinetic energy flow approach from Zivi (heterogeneous)";
              //SOURCE_2: p.17-10, eq. 17.4.3
              Real SR_chi=(1 - x_flow*(1 - abs(rho_l)/max(MIN, abs(rho_g))))^0.5
                "Empirical slip ratio w.r.t. momentum flux approach from Chisholm (heterogeneous)";

            algorithm
              SR := if voidFractionApproach == Modelica_Fluid.Dissipation.Utilities.Types.VoidFractionApproach.Homogeneous
                 then SR_hom else if voidFractionApproach == Modelica_Fluid.Dissipation.Utilities.Types.VoidFractionApproach.Momentum
                 then SR_mom else if voidFractionApproach == Modelica_Fluid.Dissipation.Utilities.Types.VoidFractionApproach.Energy
                 then SR_kin else if voidFractionApproach == Modelica_Fluid.Dissipation.Utilities.Types.VoidFractionApproach.Chisholm
                 then SR_chi else 1;

              annotation (Inline=false);
            end SlipRatio;
          end TwoPhase;
        end PressureLoss;

        package HeatTransfer "Package for utility heat transfer functions"
          extends Modelica_Icons.Package;

          package TwoPhase
            "Package with utility functions to compute two phase heat transfer characteristics"
            extends Modelica_Icons.Package;

            function kc_twoPhase_condensationHorizontal_KC
              "Local two phase heat transfer coefficient of straight pipe | horizontal condensation"
              extends Modelica_Icons.Function;
              //SOURCE_1: M.M. Shah. A general correlation for heat transfer during film condensation inside pipes.Int. J. Heat Mass Transfer, Vol.22, p.547-556, 1979.

              //records
              input Records.HeatTransfer.TwoPhaseFlowHT_IN_con IN_con
                annotation (Dialog(group="Constant inputs"));
              input Records.HeatTransfer.TwoPhaseFlowHT_IN_var IN_var
                annotation (Dialog(group="Variable inputs"));

              output SI.CoefficientOfHeatTransfer kc
                "Local two phase heat transfer coefficient";

            protected
              Real MIN=Modelica_Constants.eps;

              SI.Area A_cross=max(MIN, IN_con.A_cross) "Cross sectional area";
              SI.Diameter d_hyd=max(MIN, 4*A_cross/max(MIN, IN_con.perimeter))
                "Hydraulic diameter";

              Real x_flow=max(0, min(1, abs(IN_var.x_flow)))
                "Mass flow rate quality";
              Real p_red=max(MIN, abs(IN_var.pressure)/max(MIN, abs(IN_con.p_crit)))
                "Reduced pressure";

              SI.Velocity velocity=abs(IN_var.m_flow)/max(MIN, IN_var.rho_l*
                  A_cross) "Mean velocity";
              SI.ReynoldsNumber Re_l=max(1, IN_var.rho_l*velocity*d_hyd/max(MIN,
                  IN_var.eta_l))
                "Reynolds number assuming (total) mass flux flowing as liquid";
              SI.PrandtlNumber Pr_l=abs(IN_var.eta_l*IN_var.cp_l/max(MIN,
                  IN_var.lambda_l))
                "Prandtl number assuming (total) mass flux flowing as liquid";

              //SOURCE_1: p.548, eq. 8: Considering two phase multiplier for condensation w.r.t. Shah
              SI.CoefficientOfHeatTransfer kc_1ph=0.023*Re_l^0.8*Pr_l^0.4*
                  IN_var.lambda_l/d_hyd;

            algorithm
              kc := kc_1ph*((1 - x_flow)^0.8 + 3.8*x_flow^0.76*(1 - x_flow)^0.04/p_red^
                0.38);
              annotation (Inline=false, smoothOrder=5);
            end kc_twoPhase_condensationHorizontal_KC;

            function kc_twoPhase_boilingVertical_KC
              "Local two phase heat transfer coefficient of straight pipe | vertical boiling"
              extends Modelica_Icons.Function;
              //SOURCE_1: Bejan,A.: HEAT TRANSFER HANDBOOK, Wiley, 2003.
              //SOURCE_2: Gungor, K.E. and R.H.S. Winterton: A general correlation for flow boiling in tubes and annuli, Int.J. Heat Mass Transfer, Vol.29, p.351-358, 1986.

              //records
              input Records.HeatTransfer.TwoPhaseFlowHT_IN_con IN_con
                annotation (Dialog(group="Constant inputs"));
              input Records.HeatTransfer.TwoPhaseFlowHT_IN_var IN_var
                annotation (Dialog(group="Variable inputs"));

              output SI.CoefficientOfHeatTransfer kc
                "Local two phase heat transfer coefficient";

            protected
              Real MIN=Modelica_Constants.eps;

              SI.Area A_cross=max(MIN, IN_con.A_cross) "Cross sectional area";
              SI.Diameter d_hyd=max(MIN, 4*A_cross/max(MIN, IN_con.perimeter))
                "Hydraulic diameter";

              Real mdot_A=abs(IN_var.m_flow)/A_cross "Mass flux";
              Real x_flow=max(0, min(1, abs(IN_var.x_flow)))
                "Mass flow rate quality";
              Real p_red=max(MIN, abs(IN_var.pressure)/max(MIN, abs(IN_con.p_crit)))
                "Reduced pressure";

              //SOURCE_1: p.674, sec. 9.8.3: Considering nucleate and convective boiling w.r.t. equation of Gungor-Winterton
              SI.MassFlowRate mdot_l=abs(IN_var.m_flow)*(1 - x_flow)
                "Mass flow rate of liquid only";
              SI.Velocity velocity_l=mdot_l/max(MIN, IN_var.rho_l*A_cross)
                "Mean velocity assuming liquid mass flow rate flows alone";
              SI.ReynoldsNumber Re_l=max(1, IN_var.rho_l*velocity_l*d_hyd/max(
                  MIN, IN_var.eta_l))
                "Reynolds number assuming liquid mass flow rate flows alone";
              SI.PrandtlNumber Pr_l=abs(IN_var.eta_l*IN_var.cp_l/max(MIN,
                  IN_var.lambda_l))
                "Prandtl number assuming liquid mass flow rate flows alone";

              //SOURCE_1: p.674, eq. 9.98: Considering effect of heat flux on nucleate boiling with Boiling number
              //Boiling number (Bo) is defined as ratio of actual heat flux to maximum heat flux necessary for complete evaporation of liquid
              Real Bo=abs(IN_var.qdot_A)/(max(MIN, mdot_A*IN_var.dh_lg))
                "Boiling number";
              //SOURCE_1: p.673, eq. 9.94: Considering of Martinelli parameter w.r.t. equation of Chen
              Real X_tt=abs(((1 - x_flow)/max(MIN, x_flow))^0.9*(IN_var.rho_g/max(MIN,
                  IN_var.rho_l))^0.5*(IN_var.eta_l/max(MIN, IN_var.eta_g))^0.1)
                "Martinelli parameter";

              //SOURCE_1: p.675, eq. 9.105: Considering of convection enhancement factor w.r.t. equation of of Gungor-Winterton
              Real E_fc=1 + 24000*Bo^1.16 + 1.37*(1/max(MIN, X_tt))^0.86
                "Enhancement factor for forced convection";
              //SOURCE_1: p.675, eq. 9.105: Considering of boiling suppression factor w.r.t. equation of of Gungor-Winterton
              Real S_nb=1/max(MIN, 1 + 1.15e-6*E_fc^2*Re_l^1.17)
                "Suppression factor for nucleate boiling";

              //SOURCE_1: p.672, eq. 9.91: Considering effect of forced convective boiling ew.r.t. equation of Dittus-Boelter
              SI.CoefficientOfHeatTransfer kc_fc=0.023*Re_l^0.8*Pr_l^0.4*(
                  IN_var.lambda_l/d_hyd)
                "Convective heat transfer coefficient assuming liquid mass flow rate only";
              //SOURCE_1: p.675, eq. 9.107: Considering effect of nucleate boiling w.r.t. equation of Cooper
              SI.CoefficientOfHeatTransfer kc_nb=55*p_red^0.12*(1/max(MIN,
                  Modelica_Math.log10(1/p_red))^0.55)*(1/max(MIN, IN_con.MM)^
                  0.5)*IN_var.qdot_A^0.67
                "Nucleate boiling heat transfer coefficient";

              //SOURCE_2: p.354, sec. final equations: Calculation of two phase heat transfer coefficient for vertical pipes w.r.t. equation of Gungor-Winterton
            algorithm
              kc := E_fc*kc_fc + S_nb*kc_nb;
              annotation (Inline = false, smoothOrder=5);
            end kc_twoPhase_boilingVertical_KC;

            function kc_twoPhase_boilingHorizontal_KC
              "Local two phase heat transfer coefficient of straight pipe | horizontal boiling"
              extends Modelica_Icons.Function;
              //SOURCE_1: Bejan,A.: HEAT TRANSFER HANDBOOK, Wiley, 2003.
              //SOURCE_2: Gungor, K.E. and R.H.S. Winterton: A general correlation for flow boiling in tubes and annuli, Int.J. Heat Mass Transfer, Vol.29, p.351-358, 1986.

              import SMOOTH =
                Modelica_Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;

              //records
              input Records.HeatTransfer.TwoPhaseFlowHT_IN_con IN_con
                annotation (Dialog(group="Constant inputs"));
              input Records.HeatTransfer.TwoPhaseFlowHT_IN_var IN_var
                annotation (Dialog(group="Variable inputs"));

              output SI.CoefficientOfHeatTransfer kc
                "Local two phase heat transfer coefficient";

            protected
              Real MIN=Modelica_Constants.eps;

              SI.Area A_cross=max(MIN, IN_con.A_cross) "Cross sectional area";
              SI.Diameter d_hyd=max(MIN, 4*A_cross/max(MIN, IN_con.perimeter))
                "Hydraulic diameter";

              Real mdot_A=abs(IN_var.m_flow)/A_cross "Mass flux";
              Real x_flow=max(0, min(1, abs(IN_var.x_flow)))
                "Mass flow rate quality";
              Real p_red=max(MIN, abs(IN_var.pressure)/max(MIN, abs(IN_con.p_crit)))
                "Reduced pressure";

              //SOURCE_1: p.674, sec. 9.8.3: Considering nucleate and convective boiling w.r.t. equation of Gungor-Winterton
              SI.MassFlowRate mdot_l=abs(IN_var.m_flow)*(1 - x_flow)
                "Mass flow rate of liquid only";
              SI.Velocity velocity_l=mdot_l/max(MIN, IN_var.rho_l*A_cross)
                "Mean velocity assuming liquid mass flow rate flows alone";
              SI.ReynoldsNumber Re_l=max(1, IN_var.rho_l*velocity_l*d_hyd/max(
                  MIN, IN_var.eta_l))
                "Reynolds number assuming liquid mass flow rate flows alone";
              SI.PrandtlNumber Pr_l=abs(IN_var.eta_l*IN_var.cp_l/max(MIN,
                  IN_var.lambda_l))
                "Prandtl number assuming liquid mass flow rate flows alone";
              //SOURCE_1: p.352, sec. Nomenclature: Considering effect of stratification w.r.t. Froude number
              SI.FroudeNumber Fr_l=abs(mdot_A^2/max(MIN, IN_var.rho_l^2*9.81*
                  d_hyd))
                "Froude number assuming (total) mass flux flowing as liquid";

              //SOURCE_1: p.674, eq. 9.98: Considering effect of heat flux on nucleate boiling with Boiling number
              //Boiling number (Bo) is defined as ratio of actual heat flux to maximum heat flux necessary for complete evaporation of liquid
              Real Bo=abs(IN_var.qdot_A)/(max(MIN, mdot_A*IN_var.dh_lg))
                "Boiling number";
              //SOURCE_1: p.673, eq. 9.94: Considering of Martinelli parameter w.r.t. equation of Chen
              Real X_tt=abs(((1 - x_flow)/max(MIN, x_flow))^0.9*(IN_var.rho_g/max(MIN,
                  IN_var.rho_l))^0.5*(IN_var.eta_l/max(MIN, IN_var.eta_g))^0.1)
                "Martinelli parameter";

              //SOURCE_1: p.675, eq. 9.105: Considering of convection enhancement factor w.r.t. equation of Gungor-Winterton
              Real E_fc=1 + 24000*Bo^1.16 + 1.37*(1/max(MIN, X_tt))^0.86
                "Enhancement factor for forced convection";
              //SOURCE_1: p.675, eq. 9.105: Considering of boiling suppression factor w.r.t. equation of Gungor-Winterton
              Real S_nb=1/max(MIN, 1 + 1.15e-6*E_fc^2*Re_l^1.17)
                "Suppression factor for nucleate boiling";
              //SOURCE_1: p.680, eq. 9.123: Considering correction of convection enhancement factor for horizontal pipes
              Real E_fc_hor=SMOOTH(
                    0.049,
                    0.051,
                    Fr_l)*Fr_l^max(0, abs(0.1 - 2*Fr_l)) + SMOOTH(
                    0.051,
                    0.049,
                    Fr_l)
                "Correction of enhancement factor for forced convection in horizontal pipes";
              //SOURCE_1: p.680, eq. 9.124: Considering correction of boiling suppression factor for horizontal pipes
              Real S_nb_hor=SMOOTH(
                    0.049,
                    0.051,
                    Fr_l)*Fr_l^0.5 + SMOOTH(
                    0.051,
                    0.049,
                    Fr_l)
                "Correction of suppression factor for nucleate boiling in horizontal pipes";

              //SOURCE_1: p.672, eq. 9.91: Considering effect of forced convective boiling ew.r.t. equation of Dittus-Boelter
              SI.CoefficientOfHeatTransfer kc_fc=0.023*Re_l^0.8*Pr_l^0.4*(
                  IN_var.lambda_l/d_hyd)
                "Convective heat transfer coefficient assuming liquid mass flow rate only";
              //SOURCE_1: p.675, eq. 9.107: Considering effect of nucleate boiling w.r.t. equation of Cooper
              SI.CoefficientOfHeatTransfer kc_nb=55*p_red^0.12*(1/max(MIN,
                  Modelica_Math.log10(1/p_red))^0.55)*(1/max(MIN, IN_con.MM^0.5))
                  *abs(IN_var.qdot_A)^0.67
                "Nucleate boiling heat transfer coefficient";

              //SOURCE_2: p.354, sec. final equations: Calculation of two phase heat transfer coefficient for horizontal pipes w.r.t. equation of Gungor-Winterton
            algorithm
              kc := E_fc*E_fc_hor*kc_fc + S_nb*S_nb_hor*kc_nb;
              annotation (Inline=false, smoothOrder=5);
            end kc_twoPhase_boilingHorizontal_KC;

          end TwoPhase;
        end HeatTransfer;

        package General
          extends Modelica_Icons.Package;

          function CubicInterpolation_DP
            extends Modelica_Icons.Function;
            import Math = Modelica_Math;
            input Real Re_turbulent;
            input SI.ReynoldsNumber Re1;
            input SI.ReynoldsNumber Re2;
            input Real Delta;
            input Real lambda2;
            output SI.ReynoldsNumber Re;
            // point lg(lambda2(Re1)) with derivative at lg(Re1)
          protected
            Real x1=Math.log10(64*Re1);
            Real y1=Math.log10(Re1);
            Real yd1=1;

            // Point lg(lambda2(Re2)) with derivative at lg(Re2)
            Real aux1=(0.5/Math.log(10))*5.74*0.9;
            Real aux2=Delta/3.7 + 5.74/Re2^0.9;
            Real aux3=Math.log10(aux2);
            Real L2=0.25*(Re2/aux3)^2;
            Real aux4=2.51/sqrt(L2) + 0.27*Delta;
            Real aux5=-2*sqrt(L2)*Math.log10(aux4);
            Real x2=Math.log10(L2);
            Real y2=Math.log10(aux5);
            Real yd2=0.5 + (2.51/Math.log(10))/(aux5*aux4);

            // Constants: Cubic polynomial between lg(Re1) and lg(Re2)
            Real diff_x=x2 - x1;
            Real m=(y2 - y1)/diff_x;
            Real c2=(3*m - 2*yd1 - yd2)/diff_x;
            Real c3=(yd1 + yd2 - 2*m)/(diff_x*diff_x);
            Real lambda2_1=64*Re1;
            Real dx=Math.log10(lambda2/lambda2_1);

          algorithm
            Re := Re1*(lambda2/lambda2_1)^(1 + dx*(c2 + dx*c3));
            annotation (Inline=false, smoothOrder=5);
          end CubicInterpolation_DP;

          function CubicInterpolation_MFLOW
            extends Modelica_Icons.Function;
            import Math = Modelica_Math;
            input SI.ReynoldsNumber Re;
            input SI.ReynoldsNumber Re1;
            input SI.ReynoldsNumber Re2;
            input Real Delta;
            output Real lambda2;
            // point lg(lambda2(Re1)) with derivative at lg(Re1)
          protected
            Real x1=Math.log10(Re1);
            Real y1=Math.log10(64*Re1);
            Real yd1=1;

            // Point lg(lambda2(Re2)) with derivative at lg(Re2)
            Real aux1=(0.5/Math.log(10))*5.74*0.9;
            Real aux2=Delta/3.7 + 5.74/Re2^0.9;
            Real aux3=Math.log10(aux2);
            Real L2=0.25*(Re2/aux3)^2;
            Real aux4=2.51/sqrt(L2) + 0.27*Delta;
            Real aux5=-2*sqrt(L2)*Math.log10(aux4);
            Real x2=Math.log10(Re2);
            Real y2=Math.log10(L2);
            Real yd2=2 + 4*aux1/(aux2*aux3*(Re2)^0.9);

            // Constants: Cubic polynomial between lg(Re1) and lg(Re2)
            Real diff_x=x2 - x1;
            Real m=(y2 - y1)/diff_x;
            Real c2=(3*m - 2*yd1 - yd2)/diff_x;
            Real c3=(yd1 + yd2 - 2*m)/(diff_x*diff_x);
            Real dx=Math.log10(Re/Re1);

          algorithm
            lambda2 := 64*Re1*(Re/Re1)^(1 + dx*(c2 + dx*c3));
            annotation (Inline=false, smoothOrder=5);
          end CubicInterpolation_MFLOW;

          function LambertW
            "Closed approximation of Lambert's w function for solving f(x) = x exp(x) for x"
            extends Modelica_Icons.Function;
            input Real y "f(x)";
            output Real x "W(y)";
          protected
            Real xl;

          algorithm
            if (y <= 500.0) then
              xl := Modelica_Math.log(y + 1.0);
              x := 0.665*(1 + 0.0195*xl)*xl + 0.04;
            else
              xl := 0;
              x := Modelica_Math.log(y - 4.0) - (1.0 - 1.0/Modelica_Math.log(y))*
                Modelica_Math.log(Modelica_Math.log(y));
            end if;

            assert(y > -1/Modelica_Math.exp(1),
              "Lambert-w-function is only valid for inputs y > -1/Modelica_Math.exp(1)!");

            annotation (Inline=false, smoothOrder=5,
                        Documentation(info="<html>

<p>
This function calculates an approximation of the <b> inverse </b> for
</p>
<pre>
    f(x) = y = x * exp( x )
</pre>

<p>
within &infin; > y > -1/e.  The relative deviation of this approximation for Lambert's w function <b>x = W(y)</b> is displayed in the following graph.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/utilities/LambertW_deviation.png\" alt=\"LambertW_deviation\"/>
</p>

<p>
For y > 10 and higher values the relative deviation is smaller 2%.
</p>

</html>"));
          end LambertW;

          function LambertWIter
            "Iterative form of Lambert's w function for solving f(x) = x exp(x) for x"
            extends Modelica_Icons.Function;
            input Real y "f(x)";
            output Real x "W(y)";
            output Integer iter;
          protected
            Real w;
            Real prec=1e-12;
            Real c1;
            Real c2;
            Real dw;
            Real w1;
            /*Real wTimesExpW;
  Real wPlusOneTimesExpW;*/
            Real dev;
            Integer i;

          algorithm
            w := if y > 0.1 then LambertW(y) else sqrt(5.43656*max(y, -1/
              Modelica_Math.exp(1)) + 2) - 1;
            dev := 1;
            i := 0;
            while prec < dev and i < 100 loop
              /*wTimesExpW := w*Modelica_Math.exp(w);
                wPlusOneTimesExpW := (w+1)*Modelica_Math.exp(w);
                w := w-(wTimesExpW-y)/(wPlusOneTimesExpW-(w+2)*(wTimesExpW-y)/(2*w+2));
                dev := abs((y-wTimesExpW)/wPlusOneTimesExpW);
                i := i+1;*/

              c1 := Modelica_Math.exp(w);
              c2 := w*c1 - y;
              w1 := if w <> 1 then w + 1 else w;
              dw := c2/(c1*w1 - ((w + 2)*c2/(2*w1)));
              w := w - dw;
              //dev := abs(dw)/(2+abs(w));
              dev := abs((y - w*c1)/(w + 1)*c1);
              i := i + 1;
            end while;
            x := w;
            iter := i;

            annotation (Inline=false, smoothOrder=5,
                        Documentation(info="<html>

<p>
This function calculates an approximation of the <b> inverse </b> for
</p>
<pre>
    f(x) = y = x * exp( x )
</pre>

<p>
within &infin; > y > -1/e. Please note, that for negative inputs <b>two</b> solutions exists. The function currently delivers the result x = -1 ... 0 for that particular range.
</p>

</html>"));
          end LambertWIter;

          function PrandtlNumber "calculation of Prandtl number"
            extends Modelica_Icons.Function;
            import MIN = Modelica_Constants.eps;

            //fluid properties
            input SI.SpecificHeatCapacityAtConstantPressure cp
              "specific heat capacity of fluid at constant pressure";
            input SI.DynamicViscosity eta "dynamic viscosity of fluid";
            input SI.ThermalConductivity lambda "thermal conductivity of fluid";

            output SI.PrandtlNumber Pr "Prandtl number";

          algorithm
            Pr := eta*cp/max(MIN, lambda);
            annotation (Inline=true, smoothOrder=1);
          end PrandtlNumber;

          function ReynoldsNumber "calculation of Reynolds number"
            extends Modelica_Icons.Function;
            import MIN = Modelica_Constants.eps;

            //geometry
            input SI.Area A_cross "Cross sectional area";
            input SI.Length perimeter "Wetted perimeter";

            //fluid properties
            input SI.Density rho "Density of fluid";
            input SI.DynamicViscosity eta "Dynamic viscosity of fluid";

            input SI.MassFlowRate m_flow "Mass flow rate";

            output SI.ReynoldsNumber Re "Reynolds number";
            output SI.Velocity velocity "Mean velocity";

          protected
            SI.Diameter d_hyd=4*A_cross/max(MIN, perimeter)
              "Hydraulic diameter";

          algorithm
            Re := 4*abs(m_flow)/max(MIN, (perimeter*eta));
            velocity := m_flow/max(MIN, (rho*A_cross));
            annotation (Inline=true, smoothOrder=1);
          end ReynoldsNumber;

          function SmoothPower
            "Limiting the derivative of function y = if x>=0 then x^pow else -(-x)^pow"
            extends Modelica_Icons.Function;
            input Real x "input variable";
            input Real deltax "range for interpolation";
            input Real pow "exponent for x";
            output Real y "output variable";
          protected
            Real adeltax=abs(deltax);
            Real C3=(pow - 1)/2*adeltax^(pow - 3);
            Real C1=(3 - pow)/2*adeltax^(pow - 1);

          algorithm
            y := if x >= adeltax then x^pow else if x <= -adeltax then -(-x)^pow else (C1
               + C3*x*x)*x;
            annotation (derivative(zeroDerivative=deltax, zeroDerivative=pow)=SmoothPower_der,
              Inline=false,
              smoothOrder=1,
              Documentation(info="<html>
<p>
The function is used to limit the derivative of the following function at x=0:
</p>
<pre>
   y = <b>if</b> x &ge; 0 <b>then</b> x<sup><b>pow</b></sup> <b>else</b> -(-x)<sup><b>pow</b></sup>;  // pow &gt; 0
</pre>

<p>
by approximating the function in the range -<b>deltax</b>&lt; x &lt; <b>deltax</b>
with a third order polynomial that has the same derivative at <b>abs</b>(x)=deltax, as the
function above.
</p>

<h4>Example </h4>
<p>
In the picture below the input x is increased from -1 to 1. The range of interpolation is defined by the same range. Displayed is the output of the function SmoothPower compared to
</p>
<pre>
y=x*|x|
</pre>
<p>
For |x| &gt; 1 both functions return identical results.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/utilities/SmoothPower.png\" alt=\"SmoothPower\"/>
</p>

<h4>References</h4>
<dl>
<dt>ThermoFluid Library</dt>
    <dd><b><a href=\"http://sourceforge.net/projects/thermofluid/\">http://sourceforge.net/projects/thermofluid/</a></b></dd>
</dl>
</html>",   revisions="<html>
2014-04-29 Stefan Wischhusen: Introduced deltax and pow as zero derivatives.
</html>"));
          end SmoothPower;

          function SmoothPower_der "The derivative of function SmoothPower"
            extends Modelica_Icons.Function;
            input Real x "input variable";
            input Real deltax "range of interpolation";
            input Real pow "exponent for x";
            input Real dx "derivative of x";
            output Real dy "derivative of SmoothPower";
          protected
            Real C3;
            Real C1;
            Real adeltax;

          algorithm
            adeltax := abs(deltax);
            if noEvent(x >= adeltax) then
              dy := dx*pow*x^(pow - 1);
            elseif noEvent(x <= -adeltax) then
              dy := dx*pow*(-x)^(pow - 1);
            else
              C3 := (pow - 1)/2*adeltax^(pow - 3);
              C1 := (3 - pow)/2*adeltax^(pow - 1);
              dy := (C1 + 3*C3*x*x)*dx;
            end if;
           annotation (Documentation(revisions="<html>
2014-04-29 Stefan Wischhusen: Corrected branch for x<=-adeltax, removed dpow and ddeltax.
</html>"));
          end SmoothPower_der;

          function Stepsmoother "Continuous interpolation for x"

            extends Modelica_Icons.Function;
            input Real func "input value for that result = 100%";
            input Real nofunc "input value for that result = 0%";
            input Real x "input variable for continuous interpolation";
            output Real result "output value";

          protected
            Real m=Modelica_Constants.pi/(func - nofunc);
            Real b=-Modelica_Constants.pi/2 - m*nofunc;

          algorithm
            result := if x >= func and func > nofunc or x
               <= func and nofunc > func then 1 else if x
               <= nofunc and func > nofunc or x >= nofunc and nofunc > func then 0 else (1+Modelica_Math.tanh(Modelica_Math.tan(m*x + b)))/2;
            annotation (
              Inline=false,
              derivative=Stepsmoother_der,
              Documentation(info="<html>
<p>
The function is used for continuous fading of variable inputs within a defined range. It allows a differentiable and smooth transition between function outputs, e.g., laminar and turbulent pressure drop or correlations for certain ranges.
</p>
<h4>Function</h4>
<p>
The tanh-function is used, since it provides an existing derivative and the derivative is zero at the borders [<b>nofunc</b>, <b>func</b>] of the interpolation domain (smooth derivative for transitions).<br>
<br>
In order to work correctly, the internal interpolation range in terms of the external arbitrary input <b> x </b> needs to be scaled such that:
</p>
<pre>
f(func)   = 0.5 &pi;
f(nofunc) = -0.5 &pi;
</pre>

<h4>Example </h4>
<p>
In the picture below the input x is increased from 0 to 1. The range of interpolation is defined by:
</p>
<ul>
<li> func = 0.75</li>
<li> nofunc = 0.25</li>
</ul>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/utilities/Stepsmoother.png\" alt=\"Stepsmoother\"/>
</p>

<h4>References</h4>
<dl>
<dt>Wischhusen, St.</dt>
    <dd><b>Simulation von K&auml;ltemaschinen-Prozessen mit MODELICA / DYMOLA</b>.
    Diploma thesis, Hamburg University of Technology, Institute of Thermofluiddynamics, 2000.</dd>
</dl></html>"),    smoothOrder=5);
          end Stepsmoother;

          function Stepsmoother_der "Derivative of function Stepsmoother"

            extends Modelica_Icons.Function;
            input Real func "input for that result = 100%";
            input Real nofunc "input for that result = 0%";
            input Real x "input for interpolation";
            input Real dfunc "derivative of func";
            input Real dnofunc "derivative of nofunc";
            input Real dx "derivative of x";
            output Real dresult;

          protected
            Real m=Modelica_Constants.pi/(func - nofunc);
            Real b=-Modelica_Constants.pi/2 - m*nofunc;

          algorithm
          dresult := if x >= func and func > nofunc or x <= func and nofunc > func or x <= nofunc and func > nofunc or x >= nofunc
               and nofunc > func then 0 else (1 - Modelica_Math.tanh(Modelica_Math.tan(m*x + b))^2)*
               (1 + Modelica_Math.tan(m*x + b)^2)*(-m^2/Modelica_Constants.pi*(dfunc - dnofunc)*x
                + m*dx + m^2/Modelica_Constants.pi*(dfunc - dnofunc)*nofunc - m*dnofunc)/2;
          end Stepsmoother_der;
        end General;
      end Functions;

      package Icons "Icons for Fluid.Dissipation and Fluid.Fittings libraries"
        extends Modelica_Icons.IconsPackage;

        package HeatTransfer "Icons for heat transfer calculation"
        extends Modelica_Icons.Package;

          partial model Gap1_d "Geometry figure for gap"

            annotation ( Diagram(coordinateSystem(
                    preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
                  graphics={
                  Rectangle(
                    extent={{-100,-40},{60,-60}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.Forward,
                    fillColor={255,255,170},
                    lineThickness=1),
                  Polygon(
                    points={{60,-40},{60,-60},{100,-20},{100,0},{60,-40}},
                    lineColor={0,0,0},
                    lineThickness=1,
                    smooth=Smooth.None,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),
                  Rectangle(
                    extent={{-100,40},{60,20}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.Forward,
                    fillColor={255,255,170},
                    lineThickness=1),
                  Polygon(
                    points={{60,40},{60,20},{100,60},{100,80},{60,40}},
                    lineColor={0,0,0},
                    lineThickness=1,
                    smooth=Smooth.None,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),
                  Polygon(
                    points={{100,60},{100,0},{60,0},{60,20},{100,60}},
                    lineThickness=1,
                    smooth=Smooth.None,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-100,-40},{-100,20},{60,20},{60,0},{-60,0},{-100,-40}},
                    lineThickness=1,
                    smooth=Smooth.None,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-100,40},{-60,80},{100,80},{60,40},{-100,40}},
                    lineColor={0,0,0},
                    lineThickness=1,
                    smooth=Smooth.None,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),
                  Line(
                    points={{-100,20},{60,20},{100,60}},
                    thickness=1,
                    smooth=Smooth.None,
                    color={0,0,0}),
                  Line(
                    points={{-100,-40},{60,-40},{100,0}},
                    thickness=1,
                    smooth=Smooth.None),
                  Line(
                    points={{20,80},{-20,40}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    thickness=0.5),
                  Rectangle(
                    extent={{-4,66},{4,56}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineThickness=1,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-10,66},{10,54}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="h"),
                  Line(
                    points={{60,-66},{-100,-66}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    thickness=0.5),
                  Rectangle(
                    extent={{-22,-62},{-14,-72}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineThickness=1,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-28,-62},{-8,-74}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="L"),
                  Polygon(
                    points={{-100,-40},{-60,0},{100,0},{60,-40},{-100,-40}},
                    lineColor={0,0,0},
                    lineThickness=1,
                    smooth=Smooth.None,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),
                  Line(
                    points={{-80,20},{-80,-40}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    thickness=0.5),
                  Rectangle(
                    extent={{-84,-4},{-76,-14}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-90,-2},{-70,-14}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="s"),
                  Line(
                    points={{26,-10},{-24,-10}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.None},
                    thickness=1),
                  Rectangle(
                    extent={{-4,-4},{4,-14}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineThickness=1,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-10,-2},{10,-14}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="v"),
                  Ellipse(
                    extent={{78,52},{82,48}},
                    pattern=LinePattern.None,
                    lineThickness=0.5,
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{78,-28},{82,-32}},
                    pattern=LinePattern.None,
                    lineThickness=0.5,
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Line(
                    points={{80,-28},{80,48}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    thickness=0.5),
                  Rectangle(
                    extent={{76,16},{84,6}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineThickness=1,
                    pattern=LinePattern.None),
                  Text(
                    extent={{70,16},{90,4}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="T_wall"),
                  Text(
                    extent={{-30,36},{-10,24}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="wall 1"),
                  Text(
                    extent={{-30,-44},{-10,-56}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="wall 2")}));

          end Gap1_d;

          partial model HelicalPipe1_d "Geometry figure for helical pipe"

            annotation ( Diagram(coordinateSystem(
                    preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
                  graphics={
                  Line(
                    points={{-60,82},{-60,-84}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    pattern=LinePattern.Dash),
                  Line(
                    points={{-62,-26},{60,-36}},
                    pattern=LinePattern.None,
                    thickness=1,
                    smooth=Smooth.None),
                  Line(
                    points={{-62,24},{60,14}},
                    pattern=LinePattern.None,
                    thickness=1,
                    smooth=Smooth.None),
                  Line(
                    points={{-60,-16},{62,-26}},
                    pattern=LinePattern.None,
                    thickness=1,
                    smooth=Smooth.None),
                  Line(
                    points={{-60,34},{62,24}},
                    pattern=LinePattern.None,
                    thickness=1,
                    smooth=Smooth.None),
                  Ellipse(
                    extent={{38,64},{78,24}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{38,14},{78,-26}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-78,24},{-38,-16}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-78,-26},{-38,-66}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),
                  Polygon(
                    points={{-60,-26},{60,-36},{60,-76},{-60,-66},{-60,-26}},
                    lineThickness=0.5,
                    smooth=Smooth.None,
                    fillPattern=FillPattern.Forward,
                    fillColor={255,255,170},
                    pattern=LinePattern.None),
                  Line(
                    points={{-60,-46},{60,-56}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    pattern=LinePattern.Dash),
                  Polygon(
                    points={{-60,24},{60,14},{60,-26},{-60,-16},{-60,24}},
                    lineThickness=0.5,
                    smooth=Smooth.None,
                    fillPattern=FillPattern.Forward,
                    fillColor={255,255,170},
                    pattern=LinePattern.None),
                  Line(
                    points={{-60,4},{60,-6}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    pattern=LinePattern.Dash),
                  Ellipse(
                    extent={{40,-36},{80,-76}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),
                  Polygon(
                    points={{-62,74},{58,64},{58,24},{-62,34},{-62,74}},
                    lineThickness=0.5,
                    smooth=Smooth.None,
                    fillPattern=FillPattern.Forward,
                    fillColor={255,255,170},
                    pattern=LinePattern.None),
                  Line(
                    points={{-60,54},{60,44}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    pattern=LinePattern.Dash),
                  Ellipse(
                    extent={{-80,74},{-40,34}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),
                  Polygon(
                    points={{-60,24},{60,64},{60,24},{-60,-16},{-60,24}},
                    lineThickness=0.5,
                    smooth=Smooth.None,
                    fillPattern=FillPattern.Forward,
                    fillColor={255,255,170},
                    pattern=LinePattern.None),
                  Line(
                    points={{8,28},{-8,22}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.None,Arrow.Filled},
                    thickness=1),
                  Line(
                    points={{12,-24},{-4,-30}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.None,Arrow.Filled},
                    thickness=1),
                  Polygon(
                    points={{-60,-26},{60,14},{60,-26},{-60,-66},{-60,-26}},
                    lineThickness=0.5,
                    smooth=Smooth.None,
                    fillPattern=FillPattern.Forward,
                    fillColor={255,255,170},
                    pattern=LinePattern.None),
                  Line(
                    points={{60,24},{-60,-16}},
                    smooth=Smooth.None,
                    color={0,0,0},
                    thickness=0.5),
                  Line(
                    points={{60,14},{-60,-26}},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(
                    points={{60,-26},{-60,-66}},
                    thickness=0.5,
                    smooth=Smooth.None,
                    color={0,0,0}),
                  Line(
                    points={{-60,74},{60,64}},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(
                    points={{-60,24},{60,64}},
                    thickness=0.5,
                    smooth=Smooth.None,
                    color={0,0,0}),
                  Line(
                    points={{-60,-66},{60,-76}},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(
                    points={{10,-22},{-6,-28}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.None,Arrow.Filled},
                    thickness=1),
                  Ellipse(
                    extent={{46,-42},{74,-70}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-74,68},{-46,40}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-74,78},{-46,78}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Line(
                    points={{2,3},{-14,3}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.None,Arrow.Filled},
                    thickness=1,
                    origin={-38,55},
                    rotation=180),
                  Line(
                    points={{0,82},{0,-86}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    pattern=LinePattern.DashDot),
                  Line(
                    points={{60,-32},{60,-82}},
                    thickness=0.5,
                    smooth=Smooth.None,
                    color={0,0,0},
                    pattern=LinePattern.DashDot),
                  Line(
                    points={{-60,-82},{60,-82}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Rectangle(
                    extent={{-18,-76},{18,-88}},
                    fillPattern=FillPattern.Solid,
                    fillColor={255,255,255},
                    lineThickness=0.5,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-14,-76},{12,-86}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    textString="d_mean"),
                  Line(
                    points={{46,-56},{88,-56}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    pattern=LinePattern.DashDot),
                  Line(
                    points={{60,18},{60,-30}},
                    thickness=0.5,
                    smooth=Smooth.None,
                    color={0,0,0},
                    pattern=LinePattern.DashDot),
                  Line(
                    points={{46,-6},{88,-6}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    pattern=LinePattern.DashDot),
                  Line(
                    points={{84,-6},{84,-56}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Rectangle(
                    extent={{74,-24},{98,-36}},
                    fillPattern=FillPattern.Solid,
                    fillColor={255,255,255},
                    lineThickness=0.5,
                    pattern=LinePattern.None),
                  Line(
                    points={{-74,82},{-74,52}},
                    thickness=0.5,
                    smooth=Smooth.None,
                    color={0,0,0},
                    pattern=LinePattern.DashDot),
                  Line(
                    points={{-46,82},{-46,52}},
                    thickness=0.5,
                    smooth=Smooth.None,
                    color={0,0,0},
                    pattern=LinePattern.DashDot),
                  Text(
                    extent={{72,-26},{98,-36}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="h"),
                  Rectangle(
                    extent={{-68,84},{-50,76}},
                    fillPattern=FillPattern.Solid,
                    fillColor={255,255,255},
                    lineThickness=0.5,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-72,86},{-50,78}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="d_hyd"),
                  Rectangle(
                    extent={{-36,56},{-30,48}},
                    fillPattern=FillPattern.Solid,
                    fillColor={255,255,255},
                    lineThickness=0.5,
                    pattern=LinePattern.None),
                  Line(
                    points={{-40,54},{-40,50}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=1),
                  Text(
                    extent={{-44,56},{-22,48}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="L")}));
          end HelicalPipe1_d;

          partial model Plate1_d "Geometry figure 1 for plate"

            annotation ( Diagram(coordinateSystem(
                    preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
                  graphics={
                  Rectangle(
                    extent={{-100,10},{100,-10}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.Forward,
                    fillColor={255,255,170}),
                  Line(
                    points={{-100,-20},{100,-20}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Text(
                    extent={{-14,-20},{12,-30}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="L"),
                  Line(
                    points={{-20,16},{20,16}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.None,Arrow.Filled}),
                  Text(
                    extent={{-14,26},{12,16}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="velocity")}));
          end Plate1_d;

          partial model Plate2_d "Geometry figure 2 for plate"

            annotation ( Diagram(coordinateSystem(
                    preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
                    Rectangle(
                    extent={{-100,-20},{60,-40}},
                    fillPattern=FillPattern.Forward,
                    fillColor={255,255,170},
                    lineThickness=0.5,
                    lineColor={0,0,0}),Polygon(
                    points={{-100,-20},{-60,20},{100,20},{60,-20},{-100,-20}},
                    lineColor={0,0,0},
                    smooth=Smooth.None,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward,
                    lineThickness=0.5),Polygon(
                    points={{60,-20},{60,-40},{100,0},{100,20},{60,-20}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    smooth=Smooth.None,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),Line(
                    points={{-20,0},{20,0}},
                    thickness=1,
                    smooth=Smooth.None,
                    color={0,0,0},
                    arrow={Arrow.None,Arrow.Filled}),Text(
                    extent={{-14,10},{12,0}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="v"),Line(
                    points={{-100,-48},{60,-48}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled}),Rectangle(
                    extent={{-26,-44},{-18,-54}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineThickness=1,
                    pattern=LinePattern.None),Text(
                    extent={{-34,-44},{-8,-54}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="L")}));
          end Plate2_d;

          partial model Channel_i "Icon for heat transfer in a channel"

            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics={Bitmap(extent={{-100,100},{100,-100}},
                      fileName=
                        "modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/channel/icon_channel.png")}));
          end Channel_i;

          partial model General_i "Icon for general heat transfer component"

            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics={Bitmap(extent={{-100,100},{100,-100}},
                      fileName=
                        "modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/general/icon_general.png")}));
          end General_i;

          partial model HeatExchanger_i
            "Icon for heat transfer of a heat exchanger"

            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics={Bitmap(extent={{-100,100},{100,-100}},
                      fileName=
                        "modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/heatExchanger/icon_heatExchanger.png")}));
          end HeatExchanger_i;

          partial model HelicalPipe_i
            "Icon for heat transfer in a helical pipe"

            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics={Bitmap(extent={{-100,100},{100,-100}},
                      fileName=
                        "modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/helicalPipe/icon_helicalPipe.png")}));
          end HelicalPipe_i;

          partial model Plate_i "Icon for heat transfer of a plate"

            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics={Bitmap(extent={{-100,100},{100,-100}},
                      fileName="modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/plate/icon_plate.png")}));
          end Plate_i;

          partial model StraightPipe_i
            "Icon for heat transfer of a straight pipe"

            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics={Bitmap(extent={{-100,100},{100,-100}},
                      fileName=
                        "modelica://Modelica/Resources/Images/Fluid/Dissipation/heatTransfer/straightPipe/icon_straightPipe.png")}));

          end StraightPipe_i;
        end HeatTransfer;

        package PressureLoss "Icons for pressure loss calculation"
        extends Modelica_Icons.Package;

          partial model BendEdged_d "Geometry figure of edged bend"

            annotation ( Diagram(coordinateSystem(
                    preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
                  graphics={
                  Rectangle(
                    extent={{-100,10},{0,-20}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{0,10},{100,-48},{100,-80},{0,-20},{0,10}},
                    smooth=Smooth.None,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Ellipse(
                    extent={{-6,16},{8,2}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{0,40},{100,-20},{100,-48},{0,10},{0,40}},
                    smooth=Smooth.None,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{-100,40},{0,10}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{-100,-40},{-100,-20},{0,-20},{0,-40},{-100,-40}},
                    smooth=Smooth.None,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{0,-40},{0,-20},{100,-80},{100,-100},{0,-40}},
                    smooth=Smooth.None,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{0,40},{0,60},{100,0},{100,-20},{0,40}},
                    smooth=Smooth.None,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-100,40},{-100,60},{0,60},{0,40},{-100,40}},
                    smooth=Smooth.None,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward,
                    lineColor={0,0,0}),
                  Line(
                    points={{0,10},{100,-48}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.None,Arrow.Filled},
                    thickness=0.5),
                  Line(
                    points={{-100,10},{0,10}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    arrow={Arrow.Filled,Arrow.None}),
                  Line(
                    points={{-78,40},{-78,-20}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Rectangle(
                    extent={{-90,32},{-62,18}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-90,30},{-64,20}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="d_hyd"),
                  Text(
                    extent={{-10,20},{16,10}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="delta"),
                  Rectangle(
                    extent={{-54,18},{-44,2}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-58,14},{-40,4}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="L"),
                  Ellipse(
                    extent={{-2,6},{0,4}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-2,4},{2,10}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None)}));

          end BendEdged_d;

          partial model Channel_d "Geometry figure for channel"

            annotation ( Diagram(coordinateSystem(
                    preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
                  graphics={
                  Line(
                    points={{-92,80},{-60,80}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot),
                  Ellipse(
                    extent={{20,80},{-20,40}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{80,74},{40,46}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{14,74},{-14,46}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{0,74},{0,46}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Rectangle(
                    extent={{-10,66},{10,56}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-9,66},{9,56}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Solid,
                    textString="d_cir"),
                  Ellipse(
                    extent={{-40,80},{-80,40}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineThickness=0.5),
                  Ellipse(
                    extent={{-46,74},{-74,46}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),
                  Line(
                    points={{0,14},{0,-14}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    origin={-60,36},
                    rotation=90),
                  Line(
                    points={{-92,40},{-60,40}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot),
                  Line(
                    points={{-90,80},{-90,40}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Rectangle(
                    extent={{-98,64},{-82,54}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-99,65},{-81,55}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Solid,
                    textString="D_ann"),
                  Line(
                    points={{-16,0},{16,0}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot,
                    origin={-74,46},
                    rotation=270),
                  Line(
                    points={{-16,0},{16,0}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot,
                    origin={-46,46},
                    rotation=90),
                  Rectangle(
                    extent={{-68,38},{-52,28}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-69,39},{-51,29}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Solid,
                    textString="d_ann"),
                  Ellipse(
                    extent={{78,72},{42,48}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-22,0},{22,0}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot,
                    origin={60,60},
                    rotation=90),
                  Line(
                    points={{0,4},{0,-14}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    origin={46,42},
                    rotation=90),
                  Rectangle(
                    extent={{46,46},{55,39}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{46,46},{55,39}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Solid,
                    textString="a_ell"),
                  Line(
                    points={{0,0},{22,0}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot,
                    origin={42,38},
                    rotation=90),
                  Line(
                    points={{60,72},{92,72}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot),
                  Line(
                    points={{38,60},{92,60}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot),
                  Line(
                    points={{0,4},{0,-8}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    origin={88,68},
                    rotation=360),
                  Rectangle(
                    extent={{82,68},{94,65}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{83,69},{95,63}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Solid,
                    textString="b_ell"),
                  Rectangle(
                    extent={{-60,24},{-20,-6}},
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward,
                    lineColor={0,0,0},
                    lineThickness=0.5),
                  Rectangle(
                    extent={{-56,20},{-24,-2}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    lineThickness=0.5),
                  Line(
                    points={{-16,0},{16,0}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot,
                    origin={-56,-2},
                    rotation=270),
                  Line(
                    points={{-16,0},{16,0}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot,
                    origin={-24,-2},
                    rotation=270),
                  Line(
                    points={{0,14},{0,-18}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    origin={-42,-14},
                    rotation=90),
                  Rectangle(
                    extent={{-50,-10},{-30,-20}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-48,-9},{-31,-18}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Solid,
                    textString="a_rec"),
                  Line(
                    points={{-16,0},{16,0}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot,
                    origin={-31,20},
                    rotation=360),
                  Line(
                    points={{-16,0},{16,0}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot,
                    origin={-31,-2},
                    rotation=360),
                  Line(
                    points={{0,12},{0,-10}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    origin={-16,10},
                    rotation=180),
                  Rectangle(
                    extent={{-19,15},{0,3}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-18,13},{-1,4}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Solid,
                    textString="b_rec"),
                  Polygon(
                    points={{20,-10},{40,30},{60,-10},{20,-10}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    smooth=Smooth.None,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),
                  Polygon(
                    points={{26,-6},{40,22},{54,-6},{26,-6}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    smooth=Smooth.None,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-16,0},{-4,0}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot,
                    origin={26,-22},
                    rotation=270),
                  Line(
                    points={{0,20},{0,-8}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    origin={46,-16},
                    rotation=90),
                  Line(
                    points={{-16,0},{-4,0}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot,
                    origin={54,-22},
                    rotation=270),
                  Line(
                    points={{-16,0},{12,0}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot,
                    origin={56,22},
                    rotation=360),
                  Line(
                    points={{-16,0},{12,0}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dot,
                    origin={56,-6},
                    rotation=360),
                  Line(
                    points={{0,20},{0,-8}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    origin={64,14},
                    rotation=180),
                  Rectangle(
                    extent={{55,15},{74,3}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{56,13},{73,4}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Solid,
                    textString="h_tri"),
                  Rectangle(
                    extent={{31,-11},{50,-23}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{32,-11},{49,-20}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Solid,
                    textString="a_tri"),
                  Line(
                    points={{36,14},{38,12},{42,12},{44,14}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(
                    points={{-12,-2},{0,-8}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.None},
                    origin={40,24},
                    rotation=360),
                  Text(
                    extent={{12,27},{29,18}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Solid,
                    textString="beta")}));

          end Channel_d;

          partial model OrificeSuddenChangeSection_d
            "Geometry figure for orifice with sudden change of cross sectional area"

            annotation ( Diagram(coordinateSystem(
                    preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                  graphics={
                  Rectangle(
                    extent={{-100,60},{100,-60}},
                    lineColor={0,0,0},
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Backward),
                  Rectangle(
                    extent={{-100,20},{0,-20}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{0,40},{100,-42}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Text(
                    extent={{-80,88},{86,76}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="sudden expansion"),
                  Text(
                    extent={{-82,-76},{86,-88}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="sudden contraction"),
                  Line(
                    points={{-20,0},{20,0}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.None,Arrow.Filled},
                    origin={0,-72},
                    rotation=180),
                  Line(
                    points={{-20,0},{20,0}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    origin={-48,0},
                    rotation=90),
                  Line(
                    points={{-62,0},{20,0}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    origin={52,20},
                    rotation=90),
                  Rectangle(
                    extent={{42,6},{62,-8}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{38,4},{64,-6}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="A_2"),
                  Rectangle(
                    extent={{-58,6},{-38,-8}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-62,4},{-36,-6}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="A_1"),
                  Rectangle(
                    extent={{0,20},{0,-20}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-44,10},{40,2}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="design flow direction"),
                  Line(
                    points={{-24,-4},{16,-4}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.None,Arrow.Filled}),
                  Line(
                    points={{-20,70},{20,70}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.None,Arrow.Filled})}));

          end OrificeSuddenChangeSection_d;

          partial model OrificeThickEdged_d
            "Geometry figure for orifice with thick edged vena contraction"

            annotation ( Diagram(coordinateSystem(
                    preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                  graphics={
                  Rectangle(
                    extent={{-100,60},{100,-60}},
                    lineColor={0,0,0},
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Backward),
                  Rectangle(
                    extent={{-40,20},{40,-20}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{40,40},{100,-42}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Line(
                    points={{-20,0},{20,0}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    origin={-48,0},
                    rotation=90),
                  Line(
                    points={{-62,0},{20,0}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    origin={70,20},
                    rotation=90),
                  Rectangle(
                    extent={{60,6},{80,-8}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{56,4},{82,-6}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="A_1"),
                  Rectangle(
                    extent={{0,20},{0,-20}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Line(
                    points={{-40,-32},{40,-32}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Rectangle(
                    extent={{-100,40},{-40,-42}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Line(
                    points={{-62,0},{20,0}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    origin={-70,20},
                    rotation=90),
                  Rectangle(
                    extent={{-80,6},{-60,-8}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-84,4},{-58,-6}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="A_1"),
                  Line(
                    points={{-42,0},{-2,0}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled},
                    origin={0,22},
                    rotation=90),
                  Rectangle(
                    extent={{-2,6},{18,-8}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-14,4},{12,-6}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="A_0"),
                  Rectangle(
                    extent={{-44,20},{-40,-20}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{40,20},{44,-20}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{-4,-28},{4,-38}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-12,-28},{14,-38}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="L")}));
          end OrificeThickEdged_d;

          partial model StraightPipe_d "Geometry figure for straight pipe"

            annotation ( Diagram(coordinateSystem(
                    preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
                  graphics={
                  Ellipse(
                    extent={{98,46},{62,-54}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillPattern=FillPattern.Forward,
                    fillColor={255,255,170}),
                  Polygon(
                    points={{-80,-54},{-80,46},{80,46},{80,-54},{-80,-54}},
                    smooth=Smooth.None,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward,
                    lineThickness=0.5,
                    pattern=LinePattern.None),
                  Line(
                    points={{-80,52},{80,52}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5,
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Rectangle(
                    extent={{-4,58},{6,48}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-8,58},{10,48}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="L"),
                  Ellipse(
                    extent={{90,26},{70,-34}},
                    lineColor={0,0,0},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5),
                  Line(
                    points={{0,26},{0,-34}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Rectangle(
                    extent={{-6,-74},{10,-86}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Ellipse(
                    extent={{-62,46},{-98,-54}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-70,26},{-90,-34}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineThickness=0.5),
                  Line(
                    points={{-80,46},{80,46}},
                    pattern=LinePattern.None,
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(
                    points={{-80,-54},{80,-54}},
                    pattern=LinePattern.None,
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(
                    points={{-80,26},{80,26}},
                    pattern=LinePattern.Dash,
                    thickness=0.5,
                    smooth=Smooth.None,
                    color={0,0,0}),
                  Line(
                    points={{-80,-34},{80,-34}},
                    thickness=0.5,
                    smooth=Smooth.None,
                    color={0,0,0},
                    pattern=LinePattern.Dash),
                  Line(
                    points={{-62,-4},{98,-4}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Rectangle(
                    extent={{-12,2},{10,-8}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-14,2},{12,-8}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Solid,
                    textString="d_hyd")}));

          end StraightPipe_d;

          partial model Valve_d "Icon for valve"

            annotation ( Diagram(coordinateSystem(
                    preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
                  graphics={
                  Rectangle(
                    extent={{-6,-74},{10,-86}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Line(points={{-60,0},{-100,0}}, color={0,127,255}),
                  Polygon(
                    points={{-60,50},{-60,-50},{60,-50},{60,50},{-60,50}},
                    smooth=Smooth.None,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Line(points={{60,0},{100,0}}, color={0,127,255}),
                  Line(
                    points={{-60,50},{-60,-50},{60,50},{60,-50},{-60,50}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5)}));

          end Valve_d;

          model FlowModel "Icon for flow model in Modelica_Fluid applications"

            annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                      -100},{100,100}}), graphics={
                  Polygon(
                    points={{-60,50},{-60,-50},{60,-50},{60,50},{-60,50}},
                    smooth=Smooth.None,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Line(points={{-60,0},{-100,0}}, color={0,127,255}),
                  Line(
                    points={{-60,50},{-60,-50},{60,50},{60,-50},{-60,50}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(points={{60,0},{100,0}}, color={0,127,255})}));
          end FlowModel;

          partial model Bend_i "Icon for bend"

            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics={Bitmap(extent={{-100,100},{100,-100}},
                      fileName="modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/bend/icon_bend.png")}));
          end Bend_i;

          partial model Channel_i "Icon for channel"

            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics={Bitmap(extent={{-100,100},{100,-100}},
                      fileName=
                        "modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/channel/icon_channel.png")}));
          end Channel_i;

          partial model General_i "Icon for general pressure drop"

            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics={Bitmap(extent={{-100,100},{100,-100}},
                      fileName=
                        "modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/general/icon_general.png")}));
          end General_i;

          partial model HeatExchanger_i

            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                      {100,100}}), graphics={Bitmap(extent={{-100,100},{100,-100}},
                    fileName=
                    "modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/heatExchanger/icon_heatExchanger.png")}));
          end HeatExchanger_i;

          partial model Orifice_i "Icon for orifice"

            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics={Bitmap(extent={{-100,100},{100,-100}},
                      fileName=
                        "modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/orifice/icon_orifice.png")}));
          end Orifice_i;

          partial model StraightPipe_i "Icon for straight pipe"

            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics={Bitmap(extent={{-100,100},{100,-100}},
                      fileName=
                        "modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/straightPipe/icon_straightPipe.png")}));
          end StraightPipe_i;

          partial model Valve_i "Icon for valve"

            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics={Bitmap(extent={{-100,100},{100,-100}},
                      fileName="modelica://Modelica/Resources/Images/Fluid/Dissipation/pressureLoss/valve/icon_valve.png")}));
          end Valve_i;
        end PressureLoss;

      end Icons;

      package Records "Package for base records"
      extends Modelica_Icons.Package;
        package General
          extends Modelica_Icons.Package;
          record PressureLoss
            "Base record for fluid properties for pressure loss"
            extends Modelica_Icons.Record;

            SI.DynamicViscosity eta "Dynamic viscosity of fluid"
              annotation (Dialog(group="Fluid properties"));
            SI.Density rho "Density of fluid"
              annotation (Dialog(group="Fluid properties"));
          end PressureLoss;

          record FluidProperties "Base record for fluid properties"
            extends Modelica_Icons.Record;

            SI.SpecificHeatCapacityAtConstantPressure cp
              "Specific heat capacity of fluid at constant pressure"
              annotation (Dialog(group="Fluid properties"));

            SI.DynamicViscosity eta "Dynamic viscosity of fluid"
              annotation (Dialog(group="Fluid properties"));

            SI.ThermalConductivity lambda "Thermal conductivity of fluid"
              annotation (Dialog(group="Fluid properties"));

            SI.Density rho "Density of fluid"
              annotation (Dialog(group="Fluid properties"));
          end FluidProperties;

          record IdealGas_con
            "Base record for generic pressure loss function | ideal gas | mean density"
            extends Modelica_Icons.Record;

            Real exp=2 "Exponent of pressure loss law"
              annotation (Dialog(group="Generic variables"));
            SI.SpecificHeatCapacity R_s "Specific gas constant of ideal gas"
              annotation (Dialog(group="Fluid properties"));
            Real Km=6824.86
              "Coefficient for pressure loss law [(Pa)^2/{(kg/s)^exp*K}]"
              annotation (Dialog(group="Generic variables"));

          end IdealGas_con;

          record IdealGas_var
            "Base record for generic pressure loss function | ideal gas | mean density"
            extends Modelica_Icons.Record;

            SI.Density rho_m "Mean density of ideal gas" annotation (Dialog(
                  group="Fluid properties", enable=useMeanDensity));
            SI.Temp_K T_m "Mean temperature of ideal gas" annotation (Dialog(
                  group="Fluid properties", enable=not (useMeanDensity)));
            SI.Pressure p_m "Mean pressure of ideal gas" annotation (Dialog(
                  group="Fluid properties", enable=not (useMeanDensity)));

          end IdealGas_var;

          record NominalDensityViscosity
            "Base record for generic pressure loss function"

            extends Modelica_Icons.Record;

            SI.Pressure dp_nom=2
              "Nominal pressure loss (at nominal values of mass flow rate and density)"
              annotation (Dialog(group="Generic variables"));
            Real exp=2 "Exponent of pressure loss law"
              annotation (Dialog(group="Generic variables"));
            SI.MassFlowRate m_flow_nom=1
              "Nominal mass flow rate (at nominal values of pressure loss and density)"
              annotation (Dialog(group="Generic variables"));
            SI.Density rho_nom
              "Nominal density (at nominal values of mass flow rate and pressure loss)"
              annotation (Dialog(group="Generic variables"));
            Real exp_eta=1 "Exponent for dynamic viscosity dependence"
              annotation (Dialog(group="Generic variables"));
            SI.DynamicViscosity eta_nom
              "Dynamic viscosity at nominal pressure loss"
              annotation (Dialog(group="Generic variables"));

          end NominalDensityViscosity;

          record NominalPressureLossLawDensity_con
            "Base record for generic pressure loss function"

            extends Modelica_Icons.Record;

            //NominalMassFlowRate
            Types.MassOrVolumeFlowRate target=Dissipation.Utilities.Types.MassOrVolumeFlowRate.MassFlowRate
              "MassFlowRate == use nominal mass flow rate | VolumeFlowRate == use nominal volume flow rate"
              annotation (Dialog(group="Generic variables"));

            SI.Area A_cross=A_cross_nom "Cross sectional area"
              annotation (Dialog(group="Generic variables"));
            SI.Area A_cross_nom=Modelica_Constants.pi*0.1^2/4
              "Nominal cross sectional area"
              annotation (Dialog(group="Generic variables"));

            SI.Pressure dp_nom=2
              "Nominal pressure loss (at nominal values of mass flow rate and density)"
              annotation (Dialog(group="Generic variables"));
            SI.MassFlowRate m_flow_nom=1
              "Nominal mass flow rate (at nominal values of pressure loss and density)"
              annotation (Dialog(group="Generic variables", enable=target ==
                    Modelica_Fluid.Dissipation.Utilities.Types.MassOrVolumeFlowRate.MassFlowRate));
            Real exp=2 "Exponent of pressure loss law"
              annotation (Dialog(group="Generic variables"));

            SI.VolumeFlowRate V_flow_nom=m_flow_nom/rho_nom
              "Nominal volume flow rate (at nominal values of pressure loss and density)"
              annotation (Dialog(group="Generic variables", enable=target ==
                    Modelica_Fluid.Dissipation.Utilities.Types.MassOrVolumeFlowRate.VolumeFlowRate));
            SI.Density rho_nom
              "Nominal density (at nominal values of mass flow rate and pressure loss)"
              annotation (Dialog(group="Generic variables"));

            Types.PressureLossCoefficient zeta_TOT_nom=0.02*1/0.1
              "Nominal pressure loss coefficient (for nominal values)"
              annotation (Dialog(group="Generic variables"));

          end NominalPressureLossLawDensity_con;

          record NominalPressureLossLawDensity_var
            "Base record for generic pressure loss function"

            extends Modelica_Icons.Record;

            Types.PressureLossCoefficient zeta_TOT=0.2
              "Pressure loss coefficient"
              annotation (Dialog(group="Generic variables"));

          end NominalPressureLossLawDensity_var;

          record QuadraticVFLOW
            "Base record for generic pressure loss function | quadratic function (dp=a*Vdot^2 + b*Vdot)"

            extends Modelica_Icons.Record;

            Real a(unit="(Pa.s2)/m6") = 15 "Coefficient for quadratic term"
              annotation (Dialog(group="Generic variables"));
            Real b(unit="(Pa.s)/m3") = 0 "Coefficient for linear term"
              annotation (Dialog(group="Generic variables"));

          end QuadraticVFLOW;

          record TwoPhaseFlow_con "Base record for two phase Flow"
            extends Modelica_Icons.Record;

            SI.Area A_cross=PI*0.1^2/4 "Cross sectional area"
              annotation (Dialog(group="Geometry"));
            SI.Length perimeter=PI*0.1 "Wetted perimeter"
              annotation (Dialog(group="Geometry"));
            SI.Length length=1 "Length in fluid flow direction"
              annotation (Dialog(group="Geometry"));

          end TwoPhaseFlow_con;

          record TwoPhaseFlow_var "Base record for two phase flow"
            extends Modelica_Icons.Record;

            SI.Density rho_g "Density of gas"
              annotation (Dialog(group="Fluid properties"));
            SI.Density rho_l "Density of liquid"
              annotation (Dialog(group="Fluid properties"));
            SI.DynamicViscosity eta_g "Dynamic viscosity of gas"
              annotation (Dialog(group="Fluid properties"));
            SI.DynamicViscosity eta_l "Dynamic viscosity of liquid"
              annotation (Dialog(group="Fluid properties"));
            SI.SurfaceTension sigma "Surface tension"
              annotation (Dialog(group="Fluid properties"));

            //input variables
            Real x_flow=0 "Mean mass flow rate quality over length"
              annotation (Dialog(group="Input"));
          end TwoPhaseFlow_var;

          record IdealGas
            "Base record for generic pressure loss function | ideal gas | mean density"
            extends Modelica_Icons.Record;

            parameter Real exp(min=Modelica_Constants.eps) = 2
              "Exponent of pressure loss law"
              annotation (Dialog(group="Generic variables"));
            parameter SI.SpecificHeatCapacity R_s(min=1)
              "Specific gas constant of ideal gas"
              annotation (Dialog(group="Fluid properties"));

            Real Km(min=Modelica_Constants.eps) = R_s*(2e3)/((10)^exp/rho_m)
              "Coefficient for pressure loss law [(Pa)^2/{(kg/s)^exp*K}]"
              annotation (Dialog(group="Generic variables"));
            SI.Density rho_m=p_m/(R_s*T_m) "Mean density of ideal gas"
              annotation (Dialog(group="Fluid properties", enable=
                    useMeanDensity));
            SI.Temp_K T_m "Mean temperature of ideal gas" annotation (Dialog(
                  group="Fluid properties", enable=not (useMeanDensity)));
            SI.Pressure p_m "Mean pressure of ideal gas" annotation (Dialog(
                  group="Fluid properties", enable=not (useMeanDensity)));

          end IdealGas;

          record NominalPressureLossLawDensity
            "Base record for generic pressure loss function"

            extends Modelica_Icons.Record;

            //NominalMassFlowRate
            Types.MassOrVolumeFlowRate target=Dissipation.Utilities.Types.MassOrVolumeFlowRate.MassFlowRate
              "MassFlowRate == use nominal mass flow rate | VolumeFlowRate == use nominal volume flow rate"
              annotation (Dialog(group="Generic variables"));

            parameter SI.Area A_cross=A_cross_nom "Cross sectional area"
              annotation (Dialog(group="Generic variables"));
            parameter SI.Area A_cross_nom=Modelica_Constants.pi*0.1^2/4
              "Nominal cross sectional area"
              annotation (Dialog(group="Generic variables"));

            parameter SI.Pressure dp_nom(min=Modelica_Constants.eps)=2
              "Nominal pressure loss (at nominal values of mass flow rate and density)"
              annotation (Dialog(group="Generic variables"));
            parameter SI.MassFlowRate m_flow_nom(min=Modelica_Constants.eps)=1
              "Nominal mass flow rate (at nominal values of pressure loss and density)"
              annotation (Dialog(group="Generic variables", enable=target ==
                    Modelica_Fluid.Dissipation.Utilities.Types.MassOrVolumeFlowRate.MassFlowRate));
            parameter Real exp(min=Modelica_Constants.eps) = 2
              "Exponent of pressure loss law"
              annotation (Dialog(group="Generic variables"));

            SI.VolumeFlowRate V_flow_nom(min=Modelica_Constants.eps)=m_flow_nom
              /rho_nom
              "Nominal volume flow rate (at nominal values of pressure loss and density)"
              annotation (Dialog(group="Generic variables", enable=not (target
                     == Modelica_Fluid.Dissipation.Utilities.Types.MassOrVolumeFlowRate.MassFlowRate)));
            SI.Density rho_nom(min=Modelica_Constants.eps)
              "Nominal density (at nominal values of mass flow rate and pressure loss)"
              annotation (Dialog(group="Generic variables"));

            Types.PressureLossCoefficient zeta_TOT=zeta_TOT_nom
              "Pressure loss coefficient" annotation (Dialog(group="Generic variables"));
            parameter Types.PressureLossCoefficient zeta_TOT_nom=0.02*1/0.1
              "Nominal pressure loss coefficient (for nominal values)"
              annotation (Dialog(group="Generic variables"));

          end NominalPressureLossLawDensity;

          record TwoPhaseFlow "base record for two phase Flow"
            extends Modelica_Icons.Record;

            SI.Density rho_l "Density of liquid"
              annotation (Dialog(group="Fluid properties"));
            SI.Density rho_g "Density of gas" annotation (Dialog(group=
                    "Fluid properties", enable=if KC == 1 or KC == 2 then true
                     else false));
            SI.DynamicViscosity eta_l "Dynamic viscosity of liquid"
              annotation (Dialog(group="Fluid properties"));
            SI.DynamicViscosity eta_g "Dynamic viscosity of gas" annotation (
                Dialog(group="Fluid properties", enable=if KC == 1 or KC == 2
                     then true else false));
            SI.MassFraction x=0.5 "Vapour fraction"
              annotation (Dialog(group="Fluid properties"));
            SI.SurfaceTension sigma "Surface Tension" annotation (Dialog(group=
                    "Fluid properties", enable=if DP_fric == 1 then true else
                    false));
            Real n=0.25 "Exponent in Blasius equation (0.2-0.25)" annotation (Dialog(
                  group="others", enable=if DP_fric == 2 then true else false));
          end TwoPhaseFlow;
        end General;

        package HeatTransfer
          extends Modelica_Icons.Package;
          record EvenGap "Input for even gap"
            extends Modelica_Icons.Record;

            //choices
            Types.kc_evenGap target=Dissipation.Utilities.Types.kc_evenGap.DevBoth
              "Target variable of calculation"
              annotation (Dialog(group="Even gap"));

            SI.Length h=0.1 "Height of cross sectional area"
              annotation (Dialog(group="Even gap"));
            SI.Length s=0.05
              "Distance between parallel plates in cross sectional area"
              annotation (Dialog(group="Even gap"));
            SI.Length L=1 "Overflowed length of gap"
              annotation (Dialog(group="Even gap"));
          end EvenGap;

          record General "Input for generic correlation"
            extends Modelica_Icons.Record;

            //choices
            Types.kc_general target=Dissipation.Utilities.Types.kc_general.Finest
              "Target correlation"
              annotation (Dialog(group="Generic variables"));

            //geometry
            SI.Area A_cross=Modelica_Constants.pi*0.1^2/4
              "Cross sectional area"
              annotation (Dialog(group="Generic variables"));
            SI.Length perimeter=Modelica_Constants.pi*0.1 "Wetted perimeter"
              annotation (Dialog(group="Generic variables"));
          end General;

          record HelicalPipe "Input for helical pipe"
            extends Modelica_Icons.Record;

            Real n_nt=1 "Total number of turns" annotation (Dialog(group="HelicalPipe"));
            SI.Diameter d_hyd=0.1 "Hydraulic diameter"
              annotation (Dialog(group="HelicalPipe"));
            SI.Length h=0.01 "Distance between turns"
              annotation (Dialog(group="HelicalPipe"));
            SI.Length L=1 "Total length of helical pipe"
              annotation (Dialog(group="HelicalPipe"));

          end HelicalPipe;

          record Plate "Input for plate"
            extends Modelica_Icons.Record;

            SI.Length L=1 "Length of plate" annotation (Dialog(group="Plate"));

          end Plate;

          record StraightPipe "Input for straight pipe"
            extends Modelica_Icons.Record;

            SI.Diameter d_hyd=0.1 "Hydraulic diameter"
              annotation (Dialog(group="Straight pipe"));
            SI.Length L=1 "Length" annotation (Dialog(group="Straight pipe"));
          end StraightPipe;

          record TwoPhaseFlowHT_IN_con
            "Base record for two phase heat transfer coefficient"
            extends Modelica_Icons.Record;

            //choices
            Types.TwoPhaseHeatTransferTarget target=Types.TwoPhaseHeatTransferTarget.BoilHor
              "Choice of (horizontal/vertical) boiling or (horizontal) condensation in pipe"
              annotation (Dialog(group="Choices"));

            SI.Area A_cross=Modelica_Constants.pi*0.1^2/4
              "Cross sectional area" annotation (Dialog(group="Geometry"));
            SI.Length perimeter=Modelica_Constants.pi*0.1 "Wetted perimeter"
              annotation (Dialog(group="Geometry"));

            Types.MolarMass_gpmol MM=18.02 "Molar mass of fluid" annotation (
                Dialog(group="Fluid properties", enable=if target ==
                    Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.BoilHor
                     or target == Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.BoilVer
                     then true else false));
            SI.Pressure p_crit "Critical pressure of fluid"
              annotation (Dialog(group="Fluid properties"));

            annotation (Documentation(revisions="<html>
<ul>
<li><i>13 May 2011</i>
    by Stefan Wischhusen:<br>
       Corrected the required unit of parameter MM.</li>
</ul>
</html>"));
          end TwoPhaseFlowHT_IN_con;

          record TwoPhaseFlowHT_IN_var
            "Base record for two phase heat transfer coefficient"
            extends Modelica_Icons.Record;

            //choices
            Types.TwoPhaseHeatTransferTarget target=Types.TwoPhaseHeatTransferTarget.BoilHor
              "Choice of (horizontal/vertical) boiling or (horizontal) condensation in pipe"
              annotation (Dialog(group="Choices"));

            //fluid properties
            SI.SpecificHeatCapacityAtConstantPressure cp_l
              "Specific heat capacity of liquid"
              annotation (Dialog(group="Fluid properties"));
            SI.ThermalConductivity lambda_l "Thermal conductivity of liquid"
              annotation (Dialog(group="Fluid properties"));
            SI.Density rho_g "Density of gas" annotation (Dialog(group=
                    "Fluid properties", enable=if target == Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.BoilHor
                     or target == Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.BoilVer
                     then true else false));
            SI.Density rho_l "Density of liquid"
              annotation (Dialog(group="Fluid properties"));
            SI.DynamicViscosity eta_g "Dynamic viscosity of gas" annotation (
                Dialog(group="Fluid properties", enable=if target ==
                    Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.BoilHor
                     or target == Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.BoilVer
                     then true else false));
            SI.DynamicViscosity eta_l "Dynamic viscosity of liquid"
              annotation (Dialog(group="Fluid properties"));

            SI.Pressure pressure "Mean pressure of fluid"
              annotation (Dialog(group="Fluid properties"));
            SI.SpecificEnthalpy dh_lg "Evaporation enthalpy of fluid"
              annotation (Dialog(group="Fluid properties", enable=if target ==
                    Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.BoilHor
                     or target == Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.BoilVer
                     then true else false));

            //input variables
            SI.MassFlowRate m_flow "Mass flow rate"
              annotation (Dialog(group="Input"));
            SI.HeatFlux qdot_A=0 "Heat flux at boiling" annotation (Dialog(
                  group="Input", enable=if target == Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.BoilHor
                     or target == Modelica_Fluid.Dissipation.Utilities.Types.TwoPhaseHeatTransferTarget.BoilVer
                     then true else false));

            Real x_flow=0 "Mass flow rate quality" annotation (Dialog(group="Input"));
          end TwoPhaseFlowHT_IN_var;
        end HeatTransfer;

        package PressureLoss
          extends Modelica_Icons.Package;

          record Bend "Input for bend"
            extends EdgedBend;
            SI.Radius R_0=0.5*d_hyd "Curvature radius"
              annotation (Dialog(group="Bend"));

          end Bend;

          record Geometry "Input for several geometries of internal flow"
            extends Modelica_Icons.Record;

            Types.GeometryOfInternalFlow geometry=Types.GeometryOfInternalFlow.Circular
              "Choice of geometry for internal flow"
              annotation (Dialog(group="Channel"));

            SI.Length K=0 "Roughness (average height of surface asperities)"
              annotation (Dialog(group="Channel"));
            SI.Length L=1 "Length" annotation (Dialog(group="Channel"));

            //geometry variables
            //annular(1)
            SI.Diameter d_ann=d_cir "Small diameter" annotation (Dialog(group=
                    "Annular cross sectional area", enable=geometry ==
                    Modelica_Fluid.Dissipation.Utilities.Types.GeometryOfInternalFlow.Annular));
            SI.Diameter D_ann=2*d_ann "Large diameter" annotation (Dialog(group
                  ="Annular cross sectional area", enable=geometry ==
                    Modelica_Fluid.Dissipation.Utilities.Types.GeometryOfInternalFlow.Annular));
            //circular(2)
            SI.Diameter d_cir=0.1 "Internal diameter" annotation (Dialog(group=
                    "Circular cross sectional area", enable=geometry ==
                    Modelica_Fluid.Dissipation.Utilities.Types.GeometryOfInternalFlow.Circular));
            //elliptical(3)
            SI.Length a_ell=(3/4)*d_cir "Half length of long base line"
              annotation (Dialog(group="Elliptical cross sectional area",
                  enable=geometry == Modelica_Fluid.Dissipation.Utilities.Types.GeometryOfInternalFlow.Elliptical));
            SI.Length b_ell=0.5*a_ell "Half length of short base line"
              annotation (Dialog(group="Elliptical cross sectional area",
                  enable=geometry == Modelica_Fluid.Dissipation.Utilities.Types.GeometryOfInternalFlow.Elliptical));
            //rectangular(4)
            SI.Length a_rec=d_cir "Horizontal length" annotation (Dialog(group=
                    "Rectangular cross sectional area", enable=geometry ==
                    Modelica_Fluid.Dissipation.Utilities.Types.GeometryOfInternalFlow.Rectangular));
            SI.Length b_rec=a_rec "Vertical length" annotation (Dialog(group=
                    "Rectangular cross sectional area", enable=geometry ==
                    Modelica_Fluid.Dissipation.Utilities.Types.GeometryOfInternalFlow.Rectangular));
            //triangular(5)
            SI.Length a_tri=d_cir*(1 + 2^0.5) "Length of base line" annotation
              (Dialog(group="Rectangular cross sectional area", enable=geometry
                     == Modelica_Fluid.Dissipation.Utilities.Types.GeometryOfInternalFlow.Rectangular));
            SI.Length h_tri=0.5*a_tri
              "Height to top angle perpendicular to base line" annotation (
                Dialog(group="Triangle cross sectional area", enable=geometry
                     == Modelica_Fluid.Dissipation.Utilities.Types.GeometryOfInternalFlow.Isosceles));
            SI.Angle beta=90*PI/180 "Top angle" annotation (Dialog(group=
                    "Triangle cross sectional area", enable=geometry ==
                    Modelica_Fluid.Dissipation.Utilities.Types.GeometryOfInternalFlow.Isosceles));
          end Geometry;

          record Orifice "Input for orifice"

            extends Modelica_Icons.Record;

            SI.Area A_0=0.1*A_1 "Cross sectional area of vena contraction"
              annotation (Dialog(group="Orifice"));
            SI.Length C_0=0.1*C_1 "Perimeter of vena contraction"
              annotation (Dialog(group="Orifice"));
            SI.Area A_1=PI*0.01^2/4 "Large cross sectional area of orifice"
              annotation (Dialog(group="Orifice"));
            SI.Length C_1=PI*0.01 "Large perimeter of orifice"
              annotation (Dialog(group="Orifice"));
            SI.Length L=1e-3 "Length of vena contraction"
              annotation (Dialog(group="Orifice"));
          end Orifice;

          record PressureLossInput "Input for pressure loss calculation"
            extends Modelica_Icons.Record;

            //target variables
            Types.PressureLossTarget target=Dissipation.Utilities.Types.PressureLossTarget.PressureLoss
              "Target variable of calculation"
              annotation (Dialog(group="Input"));

            SI.Pressure dp=0 "Pressure loss" annotation (Dialog(group="Input",
                  enable=target == Modelica_Fluid.Dissipation.Utilities.Types.PressureLossTarget.pressureLoss));
            SI.MassFlowRate m_flow=0 "Mass flow rate" annotation (Dialog(group=
                    "Input", enable=target == Modelica_Fluid.Dissipation.Utilities.Types.PressureLossTarget.massFlowRate));

          end PressureLossInput;

          record StraightPipe "Input for straight pipe"

            extends Modelica_Icons.Record;

            SI.Diameter d_hyd=0.1 "Hydraulic diameter"
              annotation (Dialog(group="Straight pipe"));
            SI.Length L=1 "Length" annotation (Dialog(group="Straight pipe"));
          end StraightPipe;

          record Tjunction "Input for T-junction"
            extends Modelica_Icons.Record;

            //T-junction variables
            Boolean united_converging_crossection=true
              "true == A_cross_total = 2*A_cross_branch | false == A_cross_total > 2*A_cross_branch"
              annotation (Dialog(group="T-junction"));
            Boolean velocity_reference_branches=true
              "true == pressure loss coefficents w.r.t. velocity in each passage | false == w.r.t. velocity in total passage"
              annotation (Dialog(group="T-junction"));

            Integer alpha=90 "Angle of branching" annotation (Dialog(group="T-junction"));

            SI.Diameter d_hyd[3]=ones(3)*0.1
              "Hydraulic diameter of passages [side,straight,total]"
              annotation (Dialog(group="T-junction"));

            //restrictions
            SI.MassFlowRate m_flow_min=1e-3
              "Restriction for smoothing at reverse fluid flow"
              annotation (Dialog(group="Restrictions"));
            SI.Velocity v_max=2e2 "Restriction for maximum fluid flow velocity"
              annotation (Dialog(group="Restrictions"));
            Real zeta_TOT_max=1e3
              "Restriction for maximum value of pressure loss coefficient"
              annotation (Dialog(group="Restrictions"));
          end Tjunction;

          record Diffuser "Input for diffuser"
            extends Modelica_Icons.Record;

            SI.Angle alpha=PI*45/180 "Diffuser diverging angle"
              annotation (Dialog(group="Diffuser"));

            SI.Area A_1=PI*0.01^2/4
              "Small constant cross sectional area before diffuser section"
              annotation (Dialog(group="Diffuser"));
            SI.Area A_2=2*A_1
              "Large constant cross sectional area after diffuser section"
              annotation (Dialog(group="Diffuser"));
            SI.Length C_1=PI*0.01 "Small perimeter before diffuser section"
              annotation (Dialog(group="Diffuser"));
            SI.Length C_2=2*C_1 "Large perimeter after diffuser section"
              annotation (Dialog(group="Diffuser"));
            SI.Length L_1=0.1 "Length of straight pipe before diffuser section"
              annotation (Dialog(group="Diffuser"));
            SI.Length L_2=L_1 "Length of straight pipe after diffuser section"
              annotation (Dialog(group="Diffuser"));
            SI.Length L_d=L_1
              "Lenght of diffuser section (parallel to bulk fluid flow)"
              annotation (Dialog(group="Diffuser"));

            //numerical aspects
            SI.Pressure dp_small=1
              "Linearisation for a pressure loss smaller then dp_small"
              annotation (Dialog(group="Numerical aspects"));
            Real zeta_TOT_min=1e-3
              "Minimal pressure loss coefficient for infinite Reynolds number"
              annotation (Dialog(group="Numerical aspects"));
            Real zeta_TOT_max=1e8
              "Maximum pressure loss coefficient for Reynolds number approaching zero"
              annotation (Dialog(group="Numerical aspects"));
          end Diffuser;

          record EdgedBend "Input for bend"
            extends Modelica_Icons.Record;

            SI.Diameter d_hyd(min=Modelica_Constants.eps)=0.1
              "Hydraulic diameter" annotation (Dialog(group="Bend"));
            SI.Angle delta=90*PI/180 "Angle of turning"
              annotation (Dialog(group="Bend"));
            SI.Length K=0
              "Roughness (absolute average height of surface asperities)"
              annotation (Dialog(group="Bend"));

          end EdgedBend;

          record SuddenChange "Input for sudden change of diameter"

            extends Modelica_Icons.Record;

            SI.Area A_1=PI*0.01^2/4 "Small cross sectional area of orifice"
              annotation (Dialog(group="Orifice"));
            SI.Area A_2=A_1 "Large cross sectional area of orifice"
              annotation (Dialog(group="Orifice"));
            SI.Length C_1=PI*0.01 "Small perimeter of orifice"
              annotation (Dialog(group="Orifice"));
            SI.Length C_2=C_1 "Large perimeter of orifice"
              annotation (Dialog(group="Orifice"));
          end SuddenChange;
        end PressureLoss;
      end Records;

      package Types "Package for types"
      extends Modelica_Icons.TypesPackage;
        type DarcyFrictionFactor = Modelica_Icons.TypeReal (
            final quantity=
                "Darcy friction factor | lambda_fri = zeta_fri / (length/diameter)",
            final unit="1",
            min=0,
            max=1111);
        type FrictionalResistanceCoefficient = Modelica_Icons.TypeReal (
            final quantity="Frictional resistance coefficient | zeta_fri",
            final unit="1",
            min=0,
            max=1111);
        type LocalResistanceCoefficient = Modelica_Icons.TypeReal (
            final quantity="Local resistance coefficient | zeta_loc",
            final unit="1",
            min=0,
            max=1111);
        type PressureLossCoefficient = Modelica_Icons.TypeReal (
            final quantity="Pressure loss coefficient | zeta_tot = zeta_loc + zeta_fri",
            final unit="1",
            min=0,
            max=1111);
        type TwoPhaseFrictionalPressureLoss = enumeration(
            Friedel "Friedel correlation for frictional pressure loss",
            Chisholm "Chisholm correlation for frictional pressure loss");
        type Roughness = enumeration(
            Neglected "Neglect surface roughness",
            Considered "Consider surface roughness");
        type TwoPhaseHeatTransferTarget = enumeration(
            BoilHor "Boiling horizontal",
            BoilVer "Boiling vertical",
            CondHor "Condensation horizontal");
        type PressureLossTarget = enumeration(
            PressureLoss "Calculate pressure loss from mass flow rate",
            MassFlowRate "Calculate mass flow rate from pressure loss");
        type GeometryOfInternalFlow = enumeration(
            Annular "Annular geometry",
            Circular "Circular geometry",
            Elliptical "Elliptical geometry",
            Rectangular "Rectangular geometry",
            Isosceles "Isosceles triangular geometry");
        type kc_evenGap = enumeration(
            DevOne
              "Hydrodynamically DEVELOPED laminar flow regime AND heat transfer at ONE side",

            DevBoth
              "Hydrodynamically DEVELOPED laminar flow regime AND heat transfer at BOTH sides",

            UndevOne
              "Hydrodynamic and thermal START of laminar flow regime AND heat transfer at ONE side",

            UndevBoth
              "Hydrodynamic and thermal START of laminar flow regime AND heat transfer at BOTH side");

        type kc_general = enumeration(
            Rough "Roughest approximation w.r.t. Dittus/Boelter (1930)",
            Middle "Middle approximation w.r.t. Sieder/Tate (1936)",
            Finest "Finest approximation w.r.t. Gnielinski (1976)");
        type HeatTransferBoundary = enumeration(
            UWTuDFF
              "Uniform wall temperature in developed fluid flow (UWT+DFF)",
            UHFuDFF "Uniform heat flux in developed fluid flow (UHF+DFF)",
            UWTuUFF
              "Uniform wall temperature in undeveloped fluid flow (UWT+UFF)",
            UHFuUFF "Uniform heat flux in undeveloped fluid flow (UHF+UFF)");

        type MassOrVolumeFlowRate = enumeration(
            MassFlowRate "Mass flow rate",
            VolumeFlowRate "Volume flow rate");
        type VoidFractionApproach = enumeration(
            Homogeneous "Homogeneous approach",
            Momentum "Analytical momentum flux approach (heterogeneous)",
            Energy "Kinetic energy flow approach w.r.t. Zivi (heterogeneous)",
            Chisholm
              "Empirical momentum flux approach w.r.t. Chisholm (heterogeneous)");

        type OrificeGeometry = enumeration(
            SharpEdged "Sharp edged shape of orifice inlet",
            ThickEdged "Thick edged shape of orifice inlet",
            TiltedEdged "Tilted edged shape of orifice inlet",
            RoundedEdged "Rounded edged shape of orifice inlet");
        type ValveGeometry = enumeration(
            Ball "Ball valve",
            Diaphragm "Diaphragm valve",
            Butterfly "Butterfly valve",
            Gate "Gate valve",
            Sluice "Sluice valve");
        type ValveCoefficient = enumeration(
            AV "Av (metric) flow coefficient",
            KV "Kv (metric) flow coefficient",
            CV "Cv (US) flow coefficient",
            OP "Av defined by operating point");
        type FluidFlowRegime = enumeration(
            Laminar "Laminar fluid flow regime",
            Overall "Overall fluid flow regime",
            Turbulent "Turbulent fluid flow regime");
        type HTXGeometry_flatTubes = enumeration(
            LouverFin "Louver fin",
            RectangularFin "Rectangular offset strip fin");
        type HTXGeometry_roundTubes = enumeration(
            PlainFin "Plain fin",
            LouverFin "Louver fin",
            SlitFin "Slit fin",
            WavyFin "Wavy fin (Herringbone wavy fin)");

        type MolarMass_gpmol = Real (final quantity="Molar mass", final unit="g/mol");
      end Types;
    end Utilities;
  annotation (Documentation(info="<html>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Dissipation/FD2.png\" alt=\"FD2\"/>
</p>

<h4>  Library description </h4>

This library contains <b>convective heat transfer</b> and  <b>pressure loss</b> functions written in
Modelica&reg;. Generally the pressure loss calculations are based on incompressible fluids and total pressure difference. For devices with non changing cross sectional area, the calculated total pressure loss is equal to the static pressure difference. Geodetic pressure loss is not considered throughout the library. The functions supplied may be used separately.<br>
<br>
The library is a non-commercial product of XRG Simulation GmbH. It makes use of external,
non-commercial models supplied by Modelica Standard Library. In order to work correctly,
ensure that this library is always loaded with <b> Modelica Standard Library version
3.1</b> especially to be able to use Modelica_Fluid applications.<br>

<h4>  Acknowledgements </h4>
The following people contributed to the Fluid.Dissipation library (alphabetical list):
J&ouml;rg Eiden, Ole Engel, Nina Peci, Sven Rutkowski, Thorben Vahlenkamp, Stefan
Wischhusen.

<p>
The development of the Fluid.Dissipation library is founded within the ITEA research
project EuroSysLib-D by German Federal Ministry of Education and Research (promotional
reference 01IS07022B). The project is started in October 2007 and will end in March 2010.
</p>

<h4>  License condition </h4>
<p>
<b>Licensed by XRG-Simulation GmbH under the Modelica License 2</b><br>
Copyright &copy; 2007-2013, XRG Simulation GmbH.
</p>

<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica_UsersGuide.ModelicaLicense2\">Modelica_UsersGuide.ModelicaLicense2</a> or visit <a href=\"https://www.modelica.org/licenses/ModelicaLicense2\"> https://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>

<h4>  Contact </h4>

XRG Simulation GmbH<br>
Harburger Schlossstrasse 6-12<br>
21079 Hamburg<br>
Germany<br>
<br>
<a href=mailto:info@xrg-simulation.de>info@xrg-simulation.de</a> </html>"));

  end Dissipation;

  package Utilities
    "Utility models to construct fluid components (should not be used directly)"
    extends Modelica_Icons.UtilitiesPackage;

    function checkBoundary "Check whether boundary definition is correct"
      extends Modelica_Icons.Function;
      input String mediumName;
      input String substanceNames[:] "Names of substances";
      input Boolean singleState;
      input Boolean define_p;
      input Real X_boundary[:];
      input String modelName = "??? boundary ???";
    protected
      Integer nX = size(X_boundary,1);
      String X_str;
    algorithm
      assert(not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""   + modelName + "\":
The selected medium \""   + mediumName + "\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");

      for i in 1:nX loop
        assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""
    + mediumName + "\" in model \"" + modelName + "\":
The boundary value X_boundary(" + String(i) + ") = " + String(
          X_boundary[i]) + "
is negative. It must be positive.
");   end for;

      if nX > 0 and abs(sum(X_boundary) - 1.0) > 1.e-10 then
         X_str :="";
         for i in 1:nX loop
            X_str :=X_str + "   X_boundary[" + String(i) + "] = " + String(X_boundary[
            i]) + " \"" + substanceNames[i] + "\"\n";
         end for;
         Modelica_Utilities.Streams.error(
            "The boundary mass fractions in medium \"" + mediumName + "\" in model \"" + modelName + "\"\n" +
            "do not sum up to 1. Instead, sum(X_boundary) = " + String(sum(X_boundary)) + ":\n"
            + X_str);
      end if;
    end checkBoundary;

    function regRoot
      "Anti-symmetric square root approximation with finite derivative in the origin"
      extends Modelica_Icons.Function;
      input Real x;
      input Real delta=0.01
        "Range of significant deviation from sqrt(abs(x))*sgn(x)";
      output Real y;
    algorithm
      y := x/(x*x+delta*delta)^0.25;

      annotation(derivative(zeroDerivative=delta)=regRoot_der,
        Documentation(info="<html>
<p>
This function approximates sqrt(abs(x))*sgn(x), such that the derivative is finite and smooth in x=0.
</p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Function</th><th>Approximation</th><th>Range</th></tr>
<tr><td>y = regRoot(x)</td><td>y ~= sqrt(abs(x))*sgn(x)</td><td>abs(x) &gt;&gt;delta</td></tr>
<tr><td>y = regRoot(x)</td><td>y ~= x/sqrt(delta)</td><td>abs(x) &lt;&lt; delta</td></tr>
</table>
<p>
With the default value of delta=0.01, the difference between sqrt(x) and regRoot(x) is 16% around x=0.01, 0.25% around x=0.1 and 0.0025% around x=1.
</p>
</html>", revisions="<html>
<ul>
<li><i>15 Mar 2005</i>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br>
       Created. </li>
</ul>
</html>"));
    end regRoot;

    function regRoot_der "Derivative of regRoot"
      extends Modelica_Icons.Function;
      input Real x;
      input Real delta=0.01 "Range of significant deviation from sqrt(x)";
      input Real dx "Derivative of x";
      output Real dy;
    algorithm
      dy := dx*0.5*(x*x+2*delta*delta)/((x*x+delta*delta)^1.25);

    annotation (Documentation(info="<html>
</html>", revisions="<html>
<ul>
<li><i>15 Mar 2005</i>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br>
       Created. </li>
</ul>
</html>"));
    end regRoot_der;

    function regSquare
      "Anti-symmetric square approximation with non-zero derivative in the origin"
      extends Modelica_Icons.Function;
      input Real x;
      input Real delta=0.01 "Range of significant deviation from x^2*sgn(x)";
      output Real y;
    algorithm
      y := x*sqrt(x*x+delta*delta);

      annotation(Documentation(info="<html>
<p>
This function approximates x^2*sgn(x), such that the derivative is non-zero in x=0.
</p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Function</th><th>Approximation</th><th>Range</th></tr>
<tr><td>y = regSquare(x)</td><td>y ~= x^2*sgn(x)</td><td>abs(x) &gt;&gt;delta</td></tr>
<tr><td>y = regSquare(x)</td><td>y ~= x*delta</td><td>abs(x) &lt;&lt; delta</td></tr>
</table>
<p>
With the default value of delta=0.01, the difference between x^2 and regSquare(x) is 41% around x=0.01, 0.4% around x=0.1 and 0.005% around x=1.
</p>
</html>", revisions="<html>
<ul>
<li><i>15 Mar 2005</i>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br>
       Created. </li>
</ul>
</html>"));
    end regSquare;

    function regPow
      "Anti-symmetric power approximation with non-zero derivative in the origin"
      extends Modelica_Icons.Function;
      input Real x;
      input Real a;
      input Real delta=0.01 "Range of significant deviation from x^a*sgn(x)";
      output Real y;
    algorithm
      y := x*(x*x+delta*delta)^((a-1)/2);

      annotation(Documentation(info="<html>
<p>
This function approximates abs(x)^a*sign(x), such that the derivative is positive, finite and smooth in x=0.
</p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Function</th><th>Approximation</th><th>Range</th></tr>
<tr><td>y = regPow(x)</td><td>y ~= abs(x)^a*sgn(x)</td><td>abs(x) &gt;&gt;delta</td></tr>
<tr><td>y = regPow(x)</td><td>y ~= x*delta^(a-1)</td><td>abs(x) &lt;&lt; delta</td></tr>
</table>
</html>", revisions="<html>
<ul>
<li><i>15 Mar 2005</i>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br>
       Created. </li>
</ul>
</html>"));
    end regPow;

    function regRoot2
      "Anti-symmetric approximation of square root with discontinuous factor so that the first derivative is finite and continuous"

      extends Modelica_Icons.Function;
      input Real x "abscissa value";
      input Real x_small(min=0)=0.01
        "approximation of function for |x| <= x_small";
      input Real k1(min=0)=1 "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|)";
      input Real k2(min=0)=1 "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|)";
      input Boolean use_yd0 = false "= true, if yd0 shall be used";
      input Real yd0(min=0)=1 "Desired derivative at x=0: dy/dx = yd0";
      output Real y "ordinate value";
    protected
      encapsulated function regRoot2_utility
        "Interpolating with two 3-order polynomials with a prescribed derivative at x=0"
        import Modelica_Icons;
        extends Modelica_Icons.Function;
        import Modelica_Fluid.Utilities.evaluatePoly3_derivativeAtZero;
         input Real x;
         input Real x1 "approximation of function abs(x) < x1";
         input Real k1
          "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|); k1 >= k2";
         input Real k2 "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|))";
         input Boolean use_yd0 "= true, if yd0 shall be used";
         input Real yd0(min=0) "Desired derivative at x=0: dy/dx = yd0";
         output Real y;
      protected
         Real x2;
         Real xsqrt1;
         Real xsqrt2;
         Real y1;
         Real y2;
         Real y1d;
         Real y2d;
         Real w;
         Real y0d;
         Real w1;
         Real w2;
         Real sqrt_k1 = if k1 > 0 then sqrt(k1) else 0;
         Real sqrt_k2 = if k2 > 0 then sqrt(k2) else 0;
      algorithm
         if k2 > 0 then
            // Since k1 >= k2 required, k2 > 0 means that k1 > 0
            x2 :=-x1*(k2/k1);
         elseif k1 > 0 then
            x2 := -x1;
         else
            y := 0;
            return;
         end if;

         if x <= x2 then
            y := -sqrt_k2*sqrt(abs(x));
         else
            y1 :=sqrt_k1*sqrt(x1);
            y2 :=-sqrt_k2*sqrt(abs(x2));
            y1d :=sqrt_k1/sqrt(x1)/2;
            y2d :=sqrt_k2/sqrt(abs(x2))/2;

            if use_yd0 then
               y0d :=yd0;
            else
               /* Determine derivative, such that first and second derivative
              of left and right polynomial are identical at x=0:
           _
           Basic equations:
              y_right = a1*(x/x1) + a2*(x/x1)^2 + a3*(x/x1)^3
              y_left  = b1*(x/x2) + b2*(x/x2)^2 + b3*(x/x2)^3
              yd_right*x1 = a1 + 2*a2*(x/x1) + 3*a3*(x/x1)^2
              yd_left *x2 = b1 + 2*b2*(x/x2) + 3*b3*(x/x2)^2
              ydd_right*x1^2 = 2*a2 + 6*a3*(x/x1)
              ydd_left *x2^2 = 2*b2 + 6*b3*(x/x2)
           _
           Conditions (6 equations for 6 unknowns):
                     y1 = a1 + a2 + a3
                     y2 = b1 + b2 + b3
                 y1d*x1 = a1 + 2*a2 + 3*a3
                 y2d*x2 = b1 + 2*b2 + 3*b3
                    y0d = a1/x1 = b1/x2
                   y0dd = 2*a2/x1^2 = 2*b2/x2^2
           _
           Derived equations:
              b1 = a1*x2/x1
              b2 = a2*(x2/x1)^2
              b3 = y2 - b1 - b2
                 = y2 - a1*(x2/x1) - a2*(x2/x1)^2
              a3 = y1 - a1 - a2
           _
           Remaining equations
              y1d*x1 = a1 + 2*a2 + 3*(y1 - a1 - a2)
                     = 3*y1 - 2*a1 - a2
              y2d*x2 = a1*(x2/x1) + 2*a2*(x2/x1)^2 +
                       3*(y2 - a1*(x2/x1) - a2*(x2/x1)^2)
                     = 3*y2 - 2*a1*(x2/x1) - a2*(x2/x1)^2
              y0d    = a1/x1
           _
           Solving these equations results in y0d below
           (note, the denominator "(1-w)" is always non-zero, because w is negative)
           */
               w :=x2/x1;
               y0d := ( (3*y2 - x2*y2d)/w - (3*y1 - x1*y1d)*w) /(2*x1*(1 - w));
            end if;

            /* Modify derivative y0d, such that the polynomial is
           monotonically increasing. A sufficient condition is
             0 <= y0d <= sqrt(8.75*k_i/|x_i|)
        */
            w1 :=sqrt_k1*sqrt(8.75/x1);
            w2 :=sqrt_k2*sqrt(8.75/abs(x2));
            y0d :=smooth(2, min(y0d, 0.9*min(w1, w2)));

            /* Perform interpolation in scaled polynomial:
           y_new = y/y1
           x_new = x/x1
        */
            y := y1*(if x >= 0 then evaluatePoly3_derivativeAtZero(x/x1,1,1,y1d*x1/y1,y0d*x1/y1) else
                                    evaluatePoly3_derivativeAtZero(x/x1,x2/x1,y2/y1,y2d*x1/y1,y0d*x1/y1));
         end if;
         annotation(smoothOrder=2);
      end regRoot2_utility;
    algorithm
      y := smooth(2, if x >= x_small then sqrt(k1*x) else
                     if x <= -x_small then -sqrt(k2*abs(x)) else
                     if k1 >= k2 then regRoot2_utility(x,x_small,k1,k2,use_yd0,yd0) else
                                     -regRoot2_utility(-x,x_small,k2,k1,use_yd0,yd0));
      annotation(smoothOrder=2, Documentation(info="<html>
<p>
Approximates the function
</p>
<pre>
   y = <b>if</b> x &ge; 0 <b>then</b> <b>sqrt</b>(k1*x) <b>else</b> -<b>sqrt</b>(k2*<b>abs</b>(x)), with k1, k2 &ge; 0
</pre>
<p>
in such a way that within the region -x_small &le; x &le; x_small,
the function is described by two polynomials of third order
(one in the region -x_small .. 0 and one within the region 0 .. x_small)
such that
</p>
<ul>
<li> The derivative at x=0 is finite. </li>
<li> The overall function is continuous with a
     continuous first derivative everywhere.</li>
<li> If parameter use_yd0 = <b>false</b>, the two polynomials
     are constructed such that the second derivatives at x=0
     are identical. If use_yd0 = <b>true</b>, the derivative
     at x=0 is explicitly provided via the additional argument
     yd0. If necessary, the derivative yd0 is automatically
     reduced in order that the polynomials are strict monotonically
     increasing <i>[Fritsch and Carlson, 1980]</i>.</li>
</ul>
<p>
Typical screenshots for two different configurations
are shown below. The first one with k1=k2=1:
</p>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regRoot2_a.png\"
     alt=\"regRoot2_a.png\">
</p>
<p>
and the second one with k1=1 and k2=3:
</p>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regRoot2_b.png\"
      alt=\"regRoot2_b.png\">
</p>

<p>
The (smooth) derivative of the function with
k1=1, k2=3 is shown in the next figure:
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regRoot2_c.png\"
     alt=\"regRoot2_c.png\">
</p>

<p>
<b>Literature</b>
</p>

<dl>
<dt> Fritsch F.N. and Carlson R.E. (1980):</dt>
<dd> <b>Monotone piecewise cubic interpolation</b>.
     SIAM J. Numerc. Anal., Vol. 17, No. 2, April 1980, pp. 238-246</dd>
</dl>
</html>",   revisions="<html>
<ul>
<li><i>Sept., 2019</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Improved so that k1=0 and/or k2=0 is also possible.</li>
<li><i>Nov., 2005</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Designed and implemented.</li>
</ul>
</html>"));
    end regRoot2;

    function regSquare2
      "Anti-symmetric approximation of square with discontinuous factor so that the first derivative is non-zero and is continuous"
      extends Modelica_Icons.Function;
      input Real x "abscissa value";
      input Real x_small(min=0)=0.01
        "approximation of function for |x| <= x_small";
      input Real k1(min=0)=1 "y = (if x>=0 then k1 else k2)*x*|x|";
      input Real k2(min=0)=1 "y = (if x>=0 then k1 else k2)*x*|x|";
      input Boolean use_yd0 = false "= true, if yd0 shall be used";
      input Real yd0(min=0)=1 "Desired derivative at x=0: dy/dx = yd0";
      output Real y "ordinate value";
    protected
      encapsulated function regSquare2_utility
        "Interpolating with two 3-order polynomials with a prescribed derivative at x=0"
        import Modelica_Icons;
        extends Modelica_Icons.Function;
        import Modelica_Fluid.Utilities.evaluatePoly3_derivativeAtZero;
         input Real x;
         input Real x1 "approximation of function abs(x) < x1";
         input Real k1 "y = (if x>=0 then k1 else -k2)*x*|x|; k1 >= k2";
         input Real k2 "y = (if x>=0 then k1 else -k2)*x*|x|";
         input Boolean use_yd0 = false "= true, if yd0 shall be used";
         input Real yd0(min=0)=1 "Desired derivative at x=0: dy/dx = yd0";
         output Real y;
      protected
         Real x2;
         Real y1;
         Real y2;
         Real y1d;
         Real y2d;
         Real w;
         Real w1;
         Real w2;
         Real y0d;
         Real ww;
      algorithm
         // x2 :=-x1*(k2/k1)^2;
         x2 := -x1;
         if x <= x2 then
            y := -k2*x^2;
         else
             y1 := k1*x1^2;
             y2 :=-k2*x2^2;
            y1d := k1*2*x1;
            y2d :=-k2*2*x2;
            if use_yd0 then
               y0d :=yd0;
            else
               /* Determine derivative, such that first and second derivative
              of left and right polynomial are identical at x=0:
              see derivation in function regRoot2
           */
               w :=x2/x1;
               y0d := ( (3*y2 - x2*y2d)/w - (3*y1 - x1*y1d)*w) /(2*x1*(1 - w));
            end if;

            /* Modify derivative y0d, such that the polynomial is
           monotonically increasing. A sufficient condition is
             0 <= y0d <= sqrt(5)*k_i*|x_i|
        */
            w1 :=sqrt(5)*k1*x1;
            w2 :=sqrt(5)*k2*abs(x2);
            // y0d :=min(y0d, 0.9*min(w1, w2));
            ww :=0.9*(if w1 < w2 then w1 else w2);
            if ww < y0d then
               y0d :=ww;
            end if;
            y := if x >= 0 then evaluatePoly3_derivativeAtZero(x,x1,y1,y1d,y0d) else
                                evaluatePoly3_derivativeAtZero(x,x2,y2,y2d,y0d);
         end if;
         annotation(smoothOrder=2);
      end regSquare2_utility;
    algorithm
      y := smooth(2,if x >= x_small then k1*x^2 else
                    if x <= -x_small then -k2*x^2 else
                    if k1 >= k2 then regSquare2_utility(x,x_small,k1,k2,use_yd0,yd0) else
                                    -regSquare2_utility(-x,x_small,k2,k1,use_yd0,yd0));
      annotation(smoothOrder=2, Documentation(info="<html>
<p>
Approximates the function
</p>
<pre>
   y = <b>if</b> x &ge; 0 <b>then</b> k1*x*x <b>else</b> -k2*x*x, with k1, k2 > 0
</pre>
<p>
in such a way that within the region -x_small &le; x &le; x_small,
the function is described by two polynomials of third order
(one in the region -x_small .. 0 and one within the region 0 .. x_small)
such that
</p>

<ul>
<li> The derivative at x=0 is non-zero (in order that the
     inverse of the function does not have an infinite derivative). </li>
<li> The overall function is continuous with a
     continuous first derivative everywhere.</li>
<li> If parameter use_yd0 = <b>false</b>, the two polynomials
     are constructed such that the second derivatives at x=0
     are identical. If use_yd0 = <b>true</b>, the derivative
     at x=0 is explicitly provided via the additional argument
     yd0. If necessary, the derivative yd0 is automatically
     reduced in order that the polynomials are strict monotonically
     increasing <i>[Fritsch and Carlson, 1980]</i>.</li>
</ul>

<p>
A typical screenshot for k1=1, k2=3 is shown in the next figure:
</p>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regSquare2_b.png\"
     alt=\"regSquare2_b.png\">
</p>

<p>
The (smooth, non-zero) derivative of the function with
k1=1, k2=3 is shown in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regSquare2_c.png\"
     alt=\"regSquare2_b.png\">
</p>

<p>
<b>Literature</b>
</p>

<dl>
<dt> Fritsch F.N. and Carlson R.E. (1980):</dt>
<dd> <b>Monotone piecewise cubic interpolation</b>.
     SIAM J. Numerc. Anal., Vol. 17, No. 2, April 1980, pp. 238-246</dd>
</dl>
</html>",   revisions="<html>
<ul>
<li><i>Nov., 2005</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Designed and implemented.</li>
</ul>
</html>"));
    end regSquare2;

    function regStep
      "Approximation of a general step, such that the characteristic is continuous and differentiable"
      extends Modelica_Icons.Function;
      input Real x "Abscissa value";
      input Real y1 "Ordinate value for x > 0";
      input Real y2 "Ordinate value for x < 0";
      input Real x_small(min=0) = 1e-5
        "Approximation of step for -x_small <= x <= x_small; x_small >= 0 required";
      output Real y
        "Ordinate value to approximate y = if x > 0 then y1 else y2";
    algorithm
      y := smooth(1, if x >  x_small then y1 else
                     if x < -x_small then y2 else
                     if x_small > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2-y1)/4 + (y1+y2)/2 else (y1+y2)/2);
      annotation(Documentation(revisions="<html>
<ul>
<li><i>April 29, 2008</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Designed and implemented.</li>
<li><i>August 12, 2008</i>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
</ul>
</html>",     info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    y = <b>if</b> x &gt; 0 <b>then</b> y1 <b>else</b> y2;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   y = <b>smooth</b>(1, <b>if</b> x &gt;  x_small <b>then</b> y1 <b>else</b>
                 <b>if</b> x &lt; -x_small <b>then</b> y2 <b>else</b> f(y1, y2));
</pre>

<p>
In the region -x_small &lt; x &lt; x_small a 2nd order polynomial is used
for a smooth transition from y1 to y2.
</p>
</html>"));
    end regStep;

    function evaluatePoly3_derivativeAtZero
      "Evaluate polynomial of order 3 that passes the origin with a predefined derivative"
      extends Modelica_Icons.Function;
      input Real x "Value for which polynomial shall be evaluated";
      input Real x1 "Abscissa value";
      input Real y1 "y1=f(x1)";
      input Real y1d "First derivative at y1";
      input Real y0d "First derivative at f(x=0)";
      output Real y;
    protected
      Real a1;
      Real a2;
      Real a3;
      Real xx;
    algorithm
      a1 := x1*y0d;
      a2 := 3*y1 - x1*y1d - 2*a1;
      a3 := y1 - a2 - a1;
      xx := x/x1;
      y  := xx*(a1 + xx*(a2 + xx*a3));
      annotation(smoothOrder=3, Documentation(info="<html>

</html>"));
    end evaluatePoly3_derivativeAtZero;

    function regFun3 "Co-monotonic and C1 smooth regularization function"
      extends Modelica_Icons.Function;

      input Real x "Abscissa value";
      input Real x0 "Lower abscissa value";
      input Real x1 "Upper abscissa value";
      input Real y0 "Ordinate value at lower abscissa value";
      input Real y1 "Ordinate value at upper abscissa value";
      input Real y0d "Derivative at lower abscissa value";
      input Real y1d "Derivative at upper abscissa value";

      output Real y "Ordinate value";
      output Real c
        "Slope of linear section between two cubic polynomials or dummy linear section slope if single cubic is used";

    protected
      Real h0 "Width of interval i=0";
      Real Delta0 "Slope of secant on interval i=0";
      Real xstar "Inflection point of cubic polynomial S0";
      Real mu "Distance of inflection point and left limit x0";
      Real eta "Distance of right limit x1 and inflection point";
      Real omega "Slope of cubic polynomial S0 at inflection point";
      Real rho "Weighting factor of eta and eta_tilde, mu and mu_tilde";
      Real theta0 "Slope metric";
      Real mu_tilde "Distance of start of linear section and left limit x0";
      Real eta_tilde "Distance of right limit x1 and end of linear section";
      Real xi1 "Start of linear section";
      Real xi2 "End of linear section";
      Real a1 "Leading coefficient of cubic on the left";
      Real a2 "Leading coefficient of cubic on the right";
      Real const12 "Integration constant of left cubic, linear section";
      Real const3 "Integration constant of right cubic";
      Real aux01;
      Real aux02;
      Boolean useSingleCubicPolynomial=false
        "Indicate to override further logic and use single cubic";
    algorithm
      // Check arguments: Data point position
      assert(x0 < x1, "regFun3(): Data points not sorted appropriately (x0 = " +
        String(x0) + " > x1 = " + String(x1) + "). Please flip arguments.");
      // Check arguments: Data point derivatives
      if y0d*y1d >= 0 then
        // Derivatives at data points allow co-monotone interpolation, nothing to do
      else
        // Strictily speaking, derivatives at data points do not allow co-monotone interpolation, however, they may be numerically zero so assert this
        assert(abs(y0d)<Modelica_Constants.eps or abs(y1d)<Modelica_Constants.eps, "regFun3(): Derivatives at data points do not allow co-monotone interpolation, as both are non-zero, of opposite sign and have an absolute value larger than machine eps (y0d = " +
        String(y0d) + ", y1d = " + String(y1d) + "). Please correct arguments.");
      end if;

      h0 := x1 - x0;
      Delta0 := (y1 - y0)/h0;

      if abs(Delta0) <= 0 then
        // Points (x0,y0) and (x1,y1) on horizontal line
        // Degenerate case as we cannot fulfill the C1 goal an comonotone behaviour at the same time
        y := y0 + Delta0*(x-x0);     // y == y0 == y1 with additional term to assist automatic differentiation
        c := 0;
      elseif abs(y1d + y0d - 2*Delta0) < 100*Modelica_Constants.eps then
        // Inflection point at +/- infinity, thus S0 is co-monotone and can be returned directly
        y := y0 + (x-x0)*(y0d + (x-x0)/h0*( (-2*y0d-y1d+3*Delta0) + (x-x0)*(y0d+y1d-2*Delta0)/h0));
        // Provide a "dummy linear section slope" as the slope of the cubic at x:=(x0+x1)/2
        aux01 := (x0 + x1)/2;
        c := 3*(y0d + y1d - 2*Delta0)*(aux01 - x0)^2/h0^2 + 2*(-2*y0d - y1d + 3*Delta0)*(aux01 - x0)/h0
           + y0d;
      else
        // Points (x0,y0) and (x1,y1) not on horizontal line and inflection point of S0 not at +/- infinity
        // Do actual interpolation
        xstar := 1/3*(-3*x0*y0d - 3*x0*y1d + 6*x0*Delta0 - 2*h0*y0d - h0*y1d + 3*h0*
          Delta0)/(-y0d - y1d + 2*Delta0);
        mu := xstar - x0;
        eta := x1 - xstar;
        omega := 3*(y0d + y1d - 2*Delta0)*(xstar - x0)^2/h0^2 + 2*(-2*y0d - y1d + 3*
          Delta0)*(xstar - x0)/h0 + y0d;

        aux01 := 0.25*sign(Delta0)*min(abs(omega), abs(Delta0))
          "Slope c if not using plain cubic S0";
        if abs(y0d - y1d) <= 100*Modelica_Constants.eps then
          // y0 == y1 (value and sign equal) -> resolve indefinite 0/0
          aux02 := y0d;
          if y1 > y0 + y0d*(x1 - x0) then
            // If y1 is above the linear extension through (x0/y0)
            // with slope y0d (when slopes are identical)
            //  -> then always used single cubic polynomial
            useSingleCubicPolynomial := true;
          end if;
        elseif abs(y1d + y0d - 2*Delta0) < 100*Modelica_Constants.eps then
          // (y1d+y0d-2*Delta0) approximately 0 -> avoid division by 0
          aux02 := (6*Delta0*(y1d + y0d - 3/2*Delta0) - y1d*y0d - y1d^2 - y0d^2)*(
            if (y1d + y0d - 2*Delta0) >= 0 then 1 else -1)*Modelica_Constants.inf;
        else
          // Okay, no guarding necessary
          aux02 := (6*Delta0*(y1d + y0d - 3/2*Delta0) - y1d*y0d - y1d^2 - y0d^2)/(3*
            (y1d + y0d - 2*Delta0));
        end if;

        //aux02 := -1/3*(y0d^2+y0d*y1d-6*y0d*Delta0+y1d^2-6*y1d*Delta0+9*Delta0^2)/(y0d+y1d-2*Delta0);
        //aux02 := -1/3*(6*y1d*y0*x1+y0d*y1d*x1^2-6*y0d*x0*y0+y0d^2*x0^2+y0d^2*x1^2+y1d^2*x1^2+y1d^2*x0^2-2*y0d*x0*y1d*x1-2*x0*y0d^2*x1+y0d*y1d*x0^2+6*y0d*x0*y1-6*y0d*y1*x1+6*y0d*y0*x1-2*x0*y1d^2*x1-6*y1d*y1*x1+6*y1d*x0*y1-6*y1d*x0*y0-18*y1*y0+9*y1^2+9*y0^2)/(y0d*x1^2-2*x0*y0d*x1+y1d*x1^2-2*x0*y1d*x1-2*y1*x1+2*y0*x1+y0d*x0^2+y1d*x0^2+2*x0*y1-2*x0*y0);

        // Test criteria (also used to avoid saddle points that lead to integrator contraction):
        //
        //  1. Cubic is not monotonic (from Gasparo Morandi)
        //       ((mu > 0) and (eta < h0) and (Delta0*omega <= 0))
        //
        //  2. Cubic may be monotonic but the linear section slope c is either too close
        //     to zero or the end point of the linear section is left of the start point
        //     Note however, that the suggested slope has to have the same sign as Delta0.
        //       (abs(aux01)<abs(aux02) and aux02*Delta0>=0)
        //
        //  3. Cubic may be monotonic but the resulting slope in the linear section
        //     is too close to zero (less than 1/10 of Delta0).
        //       (c < Delta0 / 10)
        //
        if (((mu > 0) and (eta < h0) and (Delta0*omega <= 0)) or (abs(aux01) < abs(
            aux02) and aux02*Delta0 >= 0) or (abs(aux01) < abs(0.1*Delta0))) and
            not useSingleCubicPolynomial then
          // NOT monotonic using plain cubic S0, use piecewise function S0 tilde instead
          c := aux01;
          // Avoid saddle points that are co-monotonic but lead to integrator contraction
          if abs(c) < abs(aux02) and aux02*Delta0 >= 0 then
            c := aux02;
          end if;
          if abs(c) < abs(0.1*Delta0) then
            c := 0.1*Delta0;
          end if;
          theta0 := (y0d*mu + y1d*eta)/h0;
          if abs(theta0 - c) < 1e-6 then
            // Slightly reduce c in order to avoid ill-posed problem
            c := (1 - 1e-6)*theta0;
          end if;
          rho := 3*(Delta0 - c)/(theta0 - c);
          mu_tilde := rho*mu;
          eta_tilde := rho*eta;
          xi1 := x0 + mu_tilde;
          xi2 := x1 - eta_tilde;
          a1 := (y0d - c)/max(mu_tilde^2, 100*Modelica_Constants.eps);
          a2 := (y1d - c)/max(eta_tilde^2, 100*Modelica_Constants.eps);
          const12 := y0 - a1/3*(x0 - xi1)^3 - c*x0;
          const3 := y1 - a2/3*(x1 - xi2)^3 - c*x1;
          // Do actual interpolation
          if (x < xi1) then
            y := a1/3*(x - xi1)^3 + c*x + const12;
          elseif (x < xi2) then
            y := c*x + const12;
          else
            y := a2/3*(x - xi2)^3 + c*x + const3;
          end if;
        else
          // Cubic S0 is monotonic, use it as is
          y := y0 + (x-x0)*(y0d + (x-x0)/h0*( (-2*y0d-y1d+3*Delta0) + (x-x0)*(y0d+y1d-2*Delta0)/h0));
          // Provide a "dummy linear section slope" as the slope of the cubic at x:=(x0+x1)/2
          aux01 := (x0 + x1)/2;
          c := 3*(y0d + y1d - 2*Delta0)*(aux01 - x0)^2/h0^2 + 2*(-2*y0d - y1d + 3*Delta0)*(aux01 - x0)/h0
             + y0d;
        end if;
      end if;

      annotation (smoothOrder=1, Documentation(revisions="<html>
<ul>
<li><i>May 2008</i> by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br/>Designed and implemented.</li>
<li><i>February 2011</i> by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br/>If the inflection point of the cubic S0 was at +/- infinity, the test criteria of <i>[Gasparo and Morandi, 1991]</i> result in division by zero. This case is handled properly now.</li>
<li><i>March 2013</i> by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br/>If the arguments prescribed a degenerate case with points <code>(x0,y0)</code> and <code>(x1,y1)</code> on horizontal line, then return value <code>c</code> was undefined. This was corrected. Furthermore, an additional term was included for the computation of <code>y</code> in this case to assist automatic differentiation.</li>
</ul>
</html>",     info="<html>
<p>
Approximates a function in a region between <code>x0</code> and <code>x1</code>
such that
</p>
<ul>
<li> The overall function is continuous with a
     continuous first derivative everywhere.</li>
<li> The function is co-monotone with the given
     data points.</li>
</ul>
<p>
In this region, a continuation is constructed from the given points
<code>(x0, y0)</code>, <code>(x1, y1)</code> and the respective
derivatives. For this purpose, a single polynomial of third order or two
cubic polynomials with a linear section in between are used <i>[Gasparo
and Morandi, 1991]</i>. This algorithm was extended with two additional
conditions to avoid saddle points with zero/infinite derivative that lead to
integrator step size reduction to zero.
</p>
<p>
This function was developed for pressure loss correlations properly
addressing the static head on top of the established requirements
for monotonicity and smoothness. In this case, the present function
allows to implement the exact solution in the limit of
<code>x1-x0 -> 0</code> or <code>y1-y0 -> 0</code>.
</p>
<p>
Typical screenshots for two different configurations
are shown below. The first one illustrates five different settings of <code>xi</code> and <code>yid</code>:
</p>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regFun3_a.png\"
      alt=\"regFun3_a.png\">
</p>
<p>
The second graph shows the continuous derivative of this regularization function:
</p>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regFun3_b.png\"
     alt=\"regFun3_a.png\">
</p>

<p>
<b>Literature</b>
</p>

<dl>
<dt> Gasparo M. G. and Morandi R. (1991):</dt>
<dd> <b>Piecewise cubic monotone interpolation with assigned slopes</b>.
     Computing, Vol. 46, Issue 4, December 1991, pp. 355 - 365.</dd>
</dl>
</html>"));
    end regFun3;

    function cubicHermite "Evaluate a cubic Hermite spline"
      extends Modelica_Icons.Function;

      input Real x "Abscissa value";
      input Real x1 "Lower abscissa value";
      input Real x2 "Upper abscissa value";
      input Real y1 "Lower ordinate value";
      input Real y2 "Upper ordinate value";
      input Real y1d "Lower gradient";
      input Real y2d "Upper gradient";
      output Real y "Interpolated ordinate value";
    protected
      Real h "Distance between x1 and x2";
      Real t "abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
      Real h00 "Basis function 00 of cubic Hermite spline";
      Real h10 "Basis function 10 of cubic Hermite spline";
      Real h01 "Basis function 01 of cubic Hermite spline";
      Real h11 "Basis function 11 of cubic Hermite spline";
      Real aux3 "t cube";
      Real aux2 "t square";
    algorithm
      h := x2 - x1;
      if abs(h)>0 then
        // Regular case
        t := (x - x1)/h;

        aux3 :=t^3;
        aux2 :=t^2;

        h00 := 2*aux3 - 3*aux2 + 1;
        h10 := aux3 - 2*aux2 + t;
        h01 := -2*aux3 + 3*aux2;
        h11 := aux3 - aux2;
        y := y1*h00 + h*y1d*h10 + y2*h01 + h*y2d*h11;
      else
        // Degenerate case, x1 and x2 are identical, return step function
        y := (y1 + y2)/2;
      end if;
      annotation(smoothOrder=3, Documentation(revisions="<html>
<ul>
<li><i>May 2008</i>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Designed and implemented.</li>
</ul>
</html>"));
    end cubicHermite;

    function cubicHermite_withDerivative
      "Evaluate a cubic Hermite spline, return value and derivative"
      extends Modelica_Icons.Function;

      input Real x "Abscissa value";
      input Real x1 "Lower abscissa value";
      input Real x2 "Upper abscissa value";
      input Real y1 "Lower ordinate value";
      input Real y2 "Upper ordinate value";
      input Real y1d "Lower gradient";
      input Real y2d "Upper gradient";
      output Real y "Interpolated ordinate value";
      output Real dy_dx "Derivative dy/dx at abscissa value x";
    protected
      Real h "Distance between x1 and x2";
      Real t "abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
      Real h00 "Basis function 00 of cubic Hermite spline";
      Real h10 "Basis function 10 of cubic Hermite spline";
      Real h01 "Basis function 01 of cubic Hermite spline";
      Real h11 "Basis function 11 of cubic Hermite spline";

      Real h00d "d/dt h00";
      Real h10d "d/dt h10";
      Real h01d "d/dt h01";
      Real h11d "d/dt h11";

      Real aux3 "t cube";
      Real aux2 "t square";
    algorithm
      h := x2 - x1;
      if abs(h)>0 then
        // Regular case
        t := (x - x1)/h;

        aux3 :=t^3;
        aux2 :=t^2;

        h00 := 2*aux3 - 3*aux2 + 1;
        h10 := aux3 - 2*aux2 + t;
        h01 := -2*aux3 + 3*aux2;
        h11 := aux3 - aux2;

        h00d := 6*(aux2 - t);
        h10d := 3*aux2 - 4*t + 1;
        h01d := 6*(t - aux2);
        h11d := 3*aux2 - 2*t;

        y := y1*h00 + h*y1d*h10 + y2*h01 + h*y2d*h11;
        dy_dx := y1*h00d/h + y1d*h10d + y2*h01d/h + y2d*h11d;
      else
        // Degenerate case, x1 and x2 are identical, return step function
        y := (y1 + y2)/2;
        dy_dx := sign(y2 - y1)*Modelica_Constants.inf;
      end if;
      annotation(smoothOrder=3, Documentation(revisions="<html>
<ul>
<li><i>May 2008</i>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Designed and implemented.</li>
</ul>
</html>"));
    end cubicHermite_withDerivative;

    annotation (Documentation(info="<html>

</html>"));
  end Utilities;

  package Icons
    extends Modelica_Icons.IconsPackage;
    partial class VariantLibrary
      "This icon will be removed in future Modelica versions, use Modelica_Icons.VariantsPackage instead."
      // extends Modelica_Icons.VariantsPackage;
      // extends Modelica_Icons.ObsoleteModel;
      annotation (Documentation(info="<html>
<p>
This icon will be removed in future versions of the Modelica Standard Library.
Instead the icon <a href=\"modelica://Modelica_Icons.VariantsPackage\">Modelica_Icons.VariantsPackage</a> shall be used.
</p>
</html>"),   Icon(graphics={
            Rectangle(
              lineColor={200,200,200},
              fillColor={248,248,248},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-100,-100},{100,100}},
              radius=25.0),
            Rectangle(
              lineColor={128,128,128},
              fillPattern=FillPattern.None,
              extent={{-100,-100},{100,100}},
              radius=25.0),
            Ellipse(
              origin={10,10},
              fillColor={76,76,76},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-80.0,-80.0},{-20.0,-20.0}}),
            Ellipse(
              origin={10,10},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,-80.0},{60.0,-20.0}}),
            Ellipse(
              origin={10,10},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,0.0},{60.0,60.0}}),
            Ellipse(
              origin={10,10},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              extent={{-80.0,0.0},{-20.0,60.0}})}));
    end VariantLibrary;

    partial package BaseClassLibrary
      "This icon will be removed in future Modelica versions, use Modelica_Icons.BasePackage instead."
      extends Modelica_Icons.BasesPackage;
      // extends Modelica_Icons.ObsoleteModel;
      annotation(Documentation(info="<html>
<p>
This icon will be removed in future versions of the Modelica Standard Library.
Instead the icon <a href=\"modelica://Modelica_Icons.BasesPackage\">Modelica_Icons.BasesPackage</a> shall be used.
</p>
</html>"));

    end BaseClassLibrary;
  end Icons;
annotation (Icon(graphics={
        Polygon(points={{-70,26},{68,-44},{68,26},{2,-10},{-70,-42},{-70,26}},
            lineColor={0,0,0}),
        Line(points={{2,42},{2,-10}}, color={0,0,0}),
        Rectangle(
          extent={{-18,50},{22,42}},
          lineColor={0,0,0},
          fillColor={0,0,0},
          fillPattern=FillPattern.Solid)}), preferredView="info",
  Documentation(info="<html>
<p>
Library <b>Modelica_Fluid</b> is a <b>free</b> Modelica package providing components for
<b>1-dimensional thermo-fluid flow</b> in networks of vessels, pipes, fluid machines, valves and fittings.
A unique feature is that the component equations and the media models
as well as pressure loss and heat transfer correlations are decoupled from each other.
All components are implemented such that they can be used for
media from the Modelica_Media library. This means especially that an
incompressible or compressible medium, a single or a multiple
substance medium with one or more phases might be used.
</p>

<p>
In the next figure, several features of the library are demonstrated with
a simple heating system with a closed flow cycle. By just changing one configuration parameter in the system object the equations are changed between steady-state and dynamic simulation with fixed or steady-state initial conditions.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/UsersGuide/HeatingSystem.png\" border=\"1\"
     alt=\"HeatingSystem.png\">
</p>

<p>
With respect to previous versions, the design
of the connectors has been changed in a non-backward compatible way,
using the recently developed concept
of stream connectors that results in much more reliable simulations
(see also <a href=\"modelica://Modelica/Resources/Documentation/Fluid/Stream-Connectors-Overview-Rationale.pdf\">Stream-Connectors-Overview-Rationale.pdf</a>).
This extension was included in Modelica 3.1.
As of Jan. 2009, the stream concept is supported in Dymola 7.1.
It is recommended to use Dymola 7.2 (available since Feb. 2009), or a later Dymola version,
since this version supports a new annotation to connect very
conveniently to vectors of connectors.
Other tool vendors will support the stream concept as well.
</p>

<p>
The following parts are useful, when newly starting with this library:
</p>
<ul>
<li> <a href=\"modelica://Modelica_Fluid.UsersGuide\">Modelica_Fluid.UsersGuide</a>.</li>
<li> <a href=\"modelica://Modelica_Fluid.UsersGuide.ReleaseNotes\">Modelica_Fluid.UsersGuide.ReleaseNotes</a>
     summarizes the changes of the library releases.</li>
<li> <a href=\"modelica://Modelica_Fluid.Examples\">Modelica_Fluid.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
<b>Licensed by the Modelica Association under the Modelica License 2</b><br>
Copyright &copy; 2002-2013, ABB, DLR, Dassault Syst&egrave;mes AB, Modelon, TU Braunschweig, TU Hamburg-Harburg, Politecnico di Milano.
</p>
<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica_UsersGuide.ModelicaLicense2\">Modelica_UsersGuide.ModelicaLicense2</a> or visit <a href=\"https://www.modelica.org/licenses/ModelicaLicense2\"> https://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>
</html>"),
    uses(Modelica_Utilities(version="3.2.2"),
         Modelica_Blocks(version="3.2.2"),
         Modelica_Mechanics_Rotational_Interfaces(version="3.2.2"),
         Modelica_Mechanics_Translational_Interfaces(version="3.2.2"),
         Modelica_Media(version="3.2.2"),
         Modelica_Math(version="3.2.2"),
         Modelica_Blocks_Interfaces(version="3.2.2"),
         Modelica_Thermal_HeatTransfer_Interfaces(version="3.2.2"),
         Modelica_Fluid_Interfaces(version="3.2.2"),
         Modelica_Constants(version="3.2.2"),
         Modelica_Media_Interfaces(version="3.2.2"),
         Modelica_Icons(version="3.2.2")),
     version="3.2.2");
end Modelica_Fluid;
